function escapeInp(t) {
    t = t.replace(/&/g, '&amp;');
    t = t.replace(/</g, '&lt;');
    t = t.replace(/>/g, '&gt;');
    t = t.replace(/\n/g, '<br/>');
    return t;
}

var preRun = function() {
    FS.quit();
    FS.staticInit();
    FS.ignorePermissions = true;
    try
    {
	var inp = document.getElementById('inputTextarea').value;
	$('#inputModal').modal('hide');
	$('#inputPre').html(escapeInp(inp));
	FS.createDataFile('/', 'input.inp', inp, true, true);
    } catch (e) {
	console.log('/input.inp creation failed');
    }
},
	postRun = function() {
    var t = Module.intArrayToString(FS.findObject('/report.txt').contents),
	    s = $('#status'),
	    m = s.html(),
	    success = 0 > m.indexOf('error'), 
	    l = (success ? '<span class="label label-success">Success</span>'
	    : '<span class="label label-important">Error</span>');
    s.html(l + m.replace(/^[ \n]*\.\.\. */, ' '));    
    $('#output').html(escapeInp(t));
    epanetjs.setSuccess(success);
    $('#working').modal('hide');
    Module['calledRun'] = false;
},
	Module = {
    arguments: ['/input.inp', '/report.txt', '/report.bin'],
    preRun: preRun,
    postRun: postRun
};

runButton = function() {
    $('#working').modal('show');
    Module.run();
}

saveButton = function() {
    var inp = $('#inputTextarea').val(),
	    blob = new Blob([inp], {type: 'text/plain;charset=utf-8'});
    saveAs(blob, 'epanet.js.inp');
}

// Note: For maximum-speed code, see "Optimizing Code" on the Emscripten wiki, https://github.com/kripken/emscripten/wiki/Optimizing-Code
// Note: Some Emscripten settings may limit the speed of the generated code.
// The Module object: Our interface to the outside world. We import
// and export values on it, and do the work to get that through
// closure compiler if necessary. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to do an eval in order to handle the closure compiler
// case, where this code here is minified but Module was defined
// elsewhere (e.g. case 4 above). We also need to check if Module
// already exists (e.g. case 3 above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module;
if (!Module) Module = eval('(function() { try { return Module || {} } catch(e) { return {} } })()');

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
for (var key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function';
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  if (!Module['print']) Module['print'] = function print(x) {
    process['stdout'].write(x + '\n');
  };
  if (!Module['printErr']) Module['printErr'] = function printErr(x) {
    process['stderr'].write(x + '\n');
  };

  var nodeFS = require('fs');
  var nodePath = require('path');

  Module['read'] = function read(filename, binary) {
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename);
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename);
    }
    if (ret && !binary) ret = ret.toString();
    return ret;
  };

  Module['readBinary'] = function readBinary(filename) { return Module['read'](filename, true) };

  Module['load'] = function load(f) {
    globalEval(read(f));
  };

  Module['arguments'] = process['argv'].slice(2);

  module['exports'] = Module;
}
else if (ENVIRONMENT_IS_SHELL) {
  if (!Module['print']) Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function read() { throw 'no read() available (jsc?)' };
  }

  Module['readBinary'] = function readBinary(f) {
    return read(f, 'binary');
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  this['Module'] = Module;

  eval("if (typeof gc === 'function' && gc.toString().indexOf('[native code]') > 0) var gc = undefined"); // wipe out the SpiderMonkey shell 'gc' function, which can confuse closure (uses it as a minified name, and it is then initted to a non-falsey value unexpectedly)
}
else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function read(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof console !== 'undefined') {
    if (!Module['print']) Module['print'] = function print(x) {
      console.log(x);
    };
    if (!Module['printErr']) Module['printErr'] = function printErr(x) {
      console.log(x);
    };
  } else {
    // Probably a worker, and without console.log. We can do very little here...
    var TRY_USE_DUMP = false;
    if (!Module['print']) Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  if (ENVIRONMENT_IS_WEB) {
    this['Module'] = Module;
  } else {
    Module['load'] = importScripts;
  }
}
else {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] == 'undefined' && Module['read']) {
  Module['load'] = function load(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
Module['preRun'] = [];
Module['postRun'] = [];

// Merge back in the overrides
for (var key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}



// === Auto-generated preamble library stuff ===

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  forceAlign: function (target, quantum) {
    quantum = quantum || 4;
    if (quantum == 1) return target;
    if (isNumber(target) && isNumber(quantum)) {
      return Math.ceil(target/quantum)*quantum;
    } else if (isNumber(quantum) && isPowerOfTwo(quantum)) {
      return '(((' +target + ')+' + (quantum-1) + ')&' + -quantum + ')';
    }
    return 'Math.ceil((' + target + ')/' + quantum + ')*' + quantum;
  },
  isNumberType: function (type) {
    return type in Runtime.INT_TYPES || type in Runtime.FLOAT_TYPES;
  },
  isPointerType: function isPointerType(type) {
  return type[type.length-1] == '*';
},
  isStructType: function isStructType(type) {
  if (isPointerType(type)) return false;
  if (isArrayType(type)) return true;
  if (/<?{ ?[^}]* ?}>?/.test(type)) return true; // { i32, i8 } etc. - anonymous struct types
  // See comment in isStructPointerType()
  return type[0] == '%';
},
  INT_TYPES: {"i1":0,"i8":0,"i16":0,"i32":0,"i64":0},
  FLOAT_TYPES: {"float":0,"double":0},
  or64: function (x, y) {
    var l = (x | 0) | (y | 0);
    var h = (Math.round(x / 4294967296) | Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  and64: function (x, y) {
    var l = (x | 0) & (y | 0);
    var h = (Math.round(x / 4294967296) & Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  xor64: function (x, y) {
    var l = (x | 0) ^ (y | 0);
    var h = (Math.round(x / 4294967296) ^ Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  getNativeTypeSize: function (type) {
    switch (type) {
      case 'i1': case 'i8': return 1;
      case 'i16': return 2;
      case 'i32': return 4;
      case 'i64': return 8;
      case 'float': return 4;
      case 'double': return 8;
      default: {
        if (type[type.length-1] === '*') {
          return Runtime.QUANTUM_SIZE; // A pointer
        } else if (type[0] === 'i') {
          var bits = parseInt(type.substr(1));
          assert(bits % 8 === 0);
          return bits/8;
        } else {
          return 0;
        }
      }
    }
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  dedup: function dedup(items, ident) {
  var seen = {};
  if (ident) {
    return items.filter(function(item) {
      if (seen[item[ident]]) return false;
      seen[item[ident]] = true;
      return true;
    });
  } else {
    return items.filter(function(item) {
      if (seen[item]) return false;
      seen[item] = true;
      return true;
    });
  }
},
  set: function set() {
  var args = typeof arguments[0] === 'object' ? arguments[0] : arguments;
  var ret = {};
  for (var i = 0; i < args.length; i++) {
    ret[args[i]] = 0;
  }
  return ret;
},
  STACK_ALIGN: 8,
  getAlignSize: function (type, size, vararg) {
    // we align i64s and doubles on 64-bit boundaries, unlike x86
    if (vararg) return 8;
    if (!vararg && (type == 'i64' || type == 'double')) return 8;
    if (!type) return Math.min(size, 8); // align structures internally to 64 bits
    return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);
  },
  calculateStructAlignment: function calculateStructAlignment(type) {
    type.flatSize = 0;
    type.alignSize = 0;
    var diffs = [];
    var prev = -1;
    var index = 0;
    type.flatIndexes = type.fields.map(function(field) {
      index++;
      var size, alignSize;
      if (Runtime.isNumberType(field) || Runtime.isPointerType(field)) {
        size = Runtime.getNativeTypeSize(field); // pack char; char; in structs, also char[X]s.
        alignSize = Runtime.getAlignSize(field, size);
      } else if (Runtime.isStructType(field)) {
        if (field[1] === '0') {
          // this is [0 x something]. When inside another structure like here, it must be at the end,
          // and it adds no size
          // XXX this happens in java-nbody for example... assert(index === type.fields.length, 'zero-length in the middle!');
          size = 0;
          if (Types.types[field]) {
            alignSize = Runtime.getAlignSize(null, Types.types[field].alignSize);
          } else {
            alignSize = type.alignSize || QUANTUM_SIZE;
          }
        } else {
          size = Types.types[field].flatSize;
          alignSize = Runtime.getAlignSize(null, Types.types[field].alignSize);
        }
      } else if (field[0] == 'b') {
        // bN, large number field, like a [N x i8]
        size = field.substr(1)|0;
        alignSize = 1;
      } else if (field[0] === '<') {
        // vector type
        size = alignSize = Types.types[field].flatSize; // fully aligned
      } else if (field[0] === 'i') {
        // illegal integer field, that could not be legalized because it is an internal structure field
        // it is ok to have such fields, if we just use them as markers of field size and nothing more complex
        size = alignSize = parseInt(field.substr(1))/8;
        assert(size % 1 === 0, 'cannot handle non-byte-size field ' + field);
      } else {
        assert(false, 'invalid type for calculateStructAlignment');
      }
      if (type.packed) alignSize = 1;
      type.alignSize = Math.max(type.alignSize, alignSize);
      var curr = Runtime.alignMemory(type.flatSize, alignSize); // if necessary, place this on aligned memory
      type.flatSize = curr + size;
      if (prev >= 0) {
        diffs.push(curr-prev);
      }
      prev = curr;
      return curr;
    });
    if (type.name_ && type.name_[0] === '[') {
      // arrays have 2 elements, so we get the proper difference. then we scale here. that way we avoid
      // allocating a potentially huge array for [999999 x i8] etc.
      type.flatSize = parseInt(type.name_.substr(1))*type.flatSize/2;
    }
    type.flatSize = Runtime.alignMemory(type.flatSize, type.alignSize);
    if (diffs.length == 0) {
      type.flatFactor = type.flatSize;
    } else if (Runtime.dedup(diffs).length == 1) {
      type.flatFactor = diffs[0];
    }
    type.needsFlattening = (type.flatFactor != 1);
    return type.flatIndexes;
  },
  generateStructInfo: function (struct, typeName, offset) {
    var type, alignment;
    if (typeName) {
      offset = offset || 0;
      type = (typeof Types === 'undefined' ? Runtime.typeInfo : Types.types)[typeName];
      if (!type) return null;
      if (type.fields.length != struct.length) {
        printErr('Number of named fields must match the type for ' + typeName + ': possibly duplicate struct names. Cannot return structInfo');
        return null;
      }
      alignment = type.flatIndexes;
    } else {
      var type = { fields: struct.map(function(item) { return item[0] }) };
      alignment = Runtime.calculateStructAlignment(type);
    }
    var ret = {
      __size__: type.flatSize
    };
    if (typeName) {
      struct.forEach(function(item, i) {
        if (typeof item === 'string') {
          ret[item] = alignment[i] + offset;
        } else {
          // embedded struct
          var key;
          for (var k in item) key = k;
          ret[key] = Runtime.generateStructInfo(item[key], type.fields[i], alignment[i]);
        }
      });
    } else {
      struct.forEach(function(item, i) {
        ret[item[1]] = alignment[i];
      });
    }
    return ret;
  },
  dynCall: function (sig, ptr, args) {
    if (args && args.length) {
      if (!args.splice) args = Array.prototype.slice.call(args);
      args.splice(0, 0, ptr);
      return Module['dynCall_' + sig].apply(null, args);
    } else {
      return Module['dynCall_' + sig].call(null, ptr);
    }
  },
  functionPointers: [],
  addFunction: function (func) {
    for (var i = 0; i < Runtime.functionPointers.length; i++) {
      if (!Runtime.functionPointers[i]) {
        Runtime.functionPointers[i] = func;
        return 2*(1 + i);
      }
    }
    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
  },
  removeFunction: function (index) {
    Runtime.functionPointers[(index-2)/2] = null;
  },
  getAsmConst: function (code, numArgs) {
    // code is a constant string on the heap, so we can cache these
    if (!Runtime.asmConstCache) Runtime.asmConstCache = {};
    var func = Runtime.asmConstCache[code];
    if (func) return func;
    var args = [];
    for (var i = 0; i < numArgs; i++) {
      args.push(String.fromCharCode(36) + i); // $0, $1 etc
    }
    return Runtime.asmConstCache[code] = eval('(function(' + args.join(',') + '){ ' + Pointer_stringify(code) + ' })'); // new Function does not allow upvars in node
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func, sig) {
    assert(sig);
    if (!Runtime.funcWrappers[func]) {
      Runtime.funcWrappers[func] = function dynCall_wrapper() {
        return Runtime.dynCall(sig, func, arguments);
      };
    }
    return Runtime.funcWrappers[func];
  },
  UTF8Processor: function () {
    var buffer = [];
    var needed = 0;
    this.processCChar = function (code) {
      code = code & 0xFF;

      if (buffer.length == 0) {
        if ((code & 0x80) == 0x00) {        // 0xxxxxxx
          return String.fromCharCode(code);
        }
        buffer.push(code);
        if ((code & 0xE0) == 0xC0) {        // 110xxxxx
          needed = 1;
        } else if ((code & 0xF0) == 0xE0) { // 1110xxxx
          needed = 2;
        } else {                            // 11110xxx
          needed = 3;
        }
        return '';
      }

      if (needed) {
        buffer.push(code);
        needed--;
        if (needed > 0) return '';
      }

      var c1 = buffer[0];
      var c2 = buffer[1];
      var c3 = buffer[2];
      var c4 = buffer[3];
      var ret;
      if (buffer.length == 2) {
        ret = String.fromCharCode(((c1 & 0x1F) << 6)  | (c2 & 0x3F));
      } else if (buffer.length == 3) {
        ret = String.fromCharCode(((c1 & 0x0F) << 12) | ((c2 & 0x3F) << 6)  | (c3 & 0x3F));
      } else {
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        var codePoint = ((c1 & 0x07) << 18) | ((c2 & 0x3F) << 12) |
                        ((c3 & 0x3F) << 6)  | (c4 & 0x3F);
        ret = String.fromCharCode(
          Math.floor((codePoint - 0x10000) / 0x400) + 0xD800,
          (codePoint - 0x10000) % 0x400 + 0xDC00);
      }
      buffer.length = 0;
      return ret;
    }
    this.processJSString = function processJSString(string) {
      string = unescape(encodeURIComponent(string));
      var ret = [];
      for (var i = 0; i < string.length; i++) {
        ret.push(string.charCodeAt(i));
      }
      return ret;
    }
  },
  stackAlloc: function (size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = (((STACKTOP)+7)&-8); return ret; },
  staticAlloc: function (size) { var ret = STATICTOP;STATICTOP = (STATICTOP + size)|0;STATICTOP = (((STATICTOP)+7)&-8); return ret; },
  dynamicAlloc: function (size) { var ret = DYNAMICTOP;DYNAMICTOP = (DYNAMICTOP + size)|0;DYNAMICTOP = (((DYNAMICTOP)+7)&-8); if (DYNAMICTOP >= TOTAL_MEMORY) enlargeMemory();; return ret; },
  alignMemory: function (size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 8))*(quantum ? quantum : 8); return ret; },
  makeBigInt: function (low,high,unsigned) { var ret = (unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0))); return ret; },
  GLOBAL_BASE: 8,
  QUANTUM_SIZE: 4,
  __dummy__: 0
}










//========================================
// Runtime essentials
//========================================

var __THREW__ = 0; // Used in checking for thrown exceptions.

var ABORT = false; // whether we are quitting the application. no code should run after this. set in exit() and abort()
var EXITSTATUS = 0;

var undef = 0;
// tempInt is used for 32-bit signed values or smaller. tempBigInt is used
// for 32-bit unsigned values or more than 32 bits. TODO: audit all uses of tempInt
var tempValue, tempInt, tempBigInt, tempInt2, tempBigInt2, tempPair, tempBigIntI, tempBigIntR, tempBigIntS, tempBigIntP, tempBigIntD, tempDouble, tempFloat;
var tempI64, tempI64b;
var tempRet0, tempRet1, tempRet2, tempRet3, tempRet4, tempRet5, tempRet6, tempRet7, tempRet8, tempRet9;

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// C calling interface. A convenient way to call C functions (in C files, or
// defined with extern "C").
//
// Note: LLVM optimizations can inline and remove functions, after which you will not be
//       able to call them. Closure can also do so. To avoid that, add your function to
//       the exports using something like
//
//         -s EXPORTED_FUNCTIONS='["_main", "_myfunc"]'
//
// @param ident      The name of the C function (note that C++ functions will be name-mangled - use extern "C")
// @param returnType The return type of the function, one of the JS types 'number', 'string' or 'array' (use 'number' for any C pointer, and
//                   'array' for JavaScript arrays and typed arrays; note that arrays are 8-bit).
// @param argTypes   An array of the types of arguments for the function (if there are no arguments, this can be ommitted). Types are as in returnType,
//                   except that 'array' is not possible (there is no way for us to know the length of the array)
// @param args       An array of the arguments to the function, as native JS values (as in returnType)
//                   Note that string arguments will be stored on the stack (the JS string will become a C string on the stack).
// @return           The return value, as a native JS value (as in returnType)
function ccall(ident, returnType, argTypes, args) {
  return ccallFunc(getCFunc(ident), returnType, argTypes, args);
}
Module["ccall"] = ccall;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  try {
    var func = Module['_' + ident]; // closure exported function
    if (!func) func = eval('_' + ident); // explicit lookup
  } catch(e) {
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}

// Internal function that does a C call using a function, not an identifier
function ccallFunc(func, returnType, argTypes, args) {
  var stack = 0;
  function toC(value, type) {
    if (type == 'string') {
      if (value === null || value === undefined || value === 0) return 0; // null string
      value = intArrayFromString(value);
      type = 'array';
    }
    if (type == 'array') {
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length);
      writeArrayToMemory(value, ret);
      return ret;
    }
    return value;
  }
  function fromC(value, type) {
    if (type == 'string') {
      return Pointer_stringify(value);
    }
    assert(type != 'array');
    return value;
  }
  var i = 0;
  var cArgs = args ? args.map(function(arg) {
    return toC(arg, argTypes[i++]);
  }) : [];
  var ret = fromC(func.apply(null, cArgs), returnType);
  if (stack) Runtime.stackRestore(stack);
  return ret;
}

// Returns a native JS wrapper for a C function. This is similar to ccall, but
// returns a function you can call repeatedly in a normal way. For example:
//
//   var my_function = cwrap('my_c_function', 'number', ['number', 'number']);
//   alert(my_function(5, 22));
//   alert(my_function(99, 12));
//
function cwrap(ident, returnType, argTypes) {
  var func = getCFunc(ident);
  return function() {
    return ccallFunc(func, returnType, argTypes, Array.prototype.slice.call(arguments));
  }
}
Module["cwrap"] = cwrap;

// Sets a value in memory in a dynamic way at run-time. Uses the
// type data. This is the same as makeSetValue, except that
// makeSetValue is done at compile-time and generates the needed
// code then, whereas this function picks the right code at
// run-time.
// Note that setValue and getValue only do *aligned* writes and reads!
// Note that ccall uses JS types as for defining types, while setValue and
// getValue need LLVM types ('i8', 'i32') - this is a lower-level operation
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[(ptr)]=value; break;
      case 'i8': HEAP8[(ptr)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module['setValue'] = setValue;

// Parallel to setValue.
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[(ptr)];
      case 'i8': return HEAP8[(ptr)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module['getValue'] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk
var ALLOC_NONE = 4; // Do not allocate
Module['ALLOC_NORMAL'] = ALLOC_NORMAL;
Module['ALLOC_STACK'] = ALLOC_STACK;
Module['ALLOC_STATIC'] = ALLOC_STATIC;
Module['ALLOC_DYNAMIC'] = ALLOC_DYNAMIC;
Module['ALLOC_NONE'] = ALLOC_NONE;

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var ptr = ret, stop;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)|0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(slab, ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = Runtime.getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}
Module['allocate'] = allocate;

function Pointer_stringify(ptr, /* optional */ length) {
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = false;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))|0)];
    if (t >= 128) hasUtf = true;
    else if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = '';

  if (!hasUtf) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }

  var utf8 = new Runtime.UTF8Processor();
  for (i = 0; i < length; i++) {
    t = HEAPU8[(((ptr)+(i))|0)];
    ret += utf8.processCChar(t);
  }
  return ret;
}
Module['Pointer_stringify'] = Pointer_stringify;

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.
function UTF16ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
    if (codeUnit == 0)
      return str;
    ++i;
    // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
    str += String.fromCharCode(codeUnit);
  }
}
Module['UTF16ToString'] = UTF16ToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16LE form. The copy will require at most (str.length*2+1)*2 bytes of space in the HEAP.
function stringToUTF16(str, outPtr) {
  for(var i = 0; i < str.length; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[(((outPtr)+(i*2))>>1)]=codeUnit;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[(((outPtr)+(str.length*2))>>1)]=0;
}
Module['stringToUTF16'] = stringToUTF16;

// Given a pointer 'ptr' to a null-terminated UTF32LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.
function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}
Module['UTF32ToString'] = UTF32ToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32LE form. The copy will require at most (str.length+1)*4 bytes of space in the HEAP,
// but can use less, since str.length does not return the number of characters in the string, but the number of UTF-16 code units in the string.
function stringToUTF32(str, outPtr) {
  var iChar = 0;
  for(var iCodeUnit = 0; iCodeUnit < str.length; ++iCodeUnit) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    var codeUnit = str.charCodeAt(iCodeUnit); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++iCodeUnit);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[(((outPtr)+(iChar*4))>>2)]=codeUnit;
    ++iChar;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[(((outPtr)+(iChar*4))>>2)]=0;
}
Module['stringToUTF32'] = stringToUTF32;

function demangle(func) {
  try {
    // Special-case the entry point, since its name differs from other name mangling.
    if (func == 'Object._main' || func == '_main') {
      return 'main()';
    }
    if (typeof func === 'number') func = Pointer_stringify(func);
    if (func[0] !== '_') return func;
    if (func[1] !== '_') return func; // C function
    if (func[2] !== 'Z') return func;
    switch (func[3]) {
      case 'n': return 'operator new()';
      case 'd': return 'operator delete()';
    }
    var i = 3;
    // params, etc.
    var basicTypes = {
      'v': 'void',
      'b': 'bool',
      'c': 'char',
      's': 'short',
      'i': 'int',
      'l': 'long',
      'f': 'float',
      'd': 'double',
      'w': 'wchar_t',
      'a': 'signed char',
      'h': 'unsigned char',
      't': 'unsigned short',
      'j': 'unsigned int',
      'm': 'unsigned long',
      'x': 'long long',
      'y': 'unsigned long long',
      'z': '...'
    };
    function dump(x) {
      //return;
      if (x) Module.print(x);
      Module.print(func);
      var pre = '';
      for (var a = 0; a < i; a++) pre += ' ';
      Module.print (pre + '^');
    }
    var subs = [];
    function parseNested() {
      i++;
      if (func[i] === 'K') i++; // ignore const
      var parts = [];
      while (func[i] !== 'E') {
        if (func[i] === 'S') { // substitution
          i++;
          var next = func.indexOf('_', i);
          var num = func.substring(i, next) || 0;
          parts.push(subs[num] || '?');
          i = next+1;
          continue;
        }
        if (func[i] === 'C') { // constructor
          parts.push(parts[parts.length-1]);
          i += 2;
          continue;
        }
        var size = parseInt(func.substr(i));
        var pre = size.toString().length;
        if (!size || !pre) { i--; break; } // counter i++ below us
        var curr = func.substr(i + pre, size);
        parts.push(curr);
        subs.push(curr);
        i += pre + size;
      }
      i++; // skip E
      return parts;
    }
    var first = true;
    function parse(rawList, limit, allowVoid) { // main parser
      limit = limit || Infinity;
      var ret = '', list = [];
      function flushList() {
        return '(' + list.join(', ') + ')';
      }
      var name;
      if (func[i] === 'N') {
        // namespaced N-E
        name = parseNested().join('::');
        limit--;
        if (limit === 0) return rawList ? [name] : name;
      } else {
        // not namespaced
        if (func[i] === 'K' || (first && func[i] === 'L')) i++; // ignore const and first 'L'
        var size = parseInt(func.substr(i));
        if (size) {
          var pre = size.toString().length;
          name = func.substr(i + pre, size);
          i += pre + size;
        }
      }
      first = false;
      if (func[i] === 'I') {
        i++;
        var iList = parse(true);
        var iRet = parse(true, 1, true);
        ret += iRet[0] + ' ' + name + '<' + iList.join(', ') + '>';
      } else {
        ret = name;
      }
      paramLoop: while (i < func.length && limit-- > 0) {
        //dump('paramLoop');
        var c = func[i++];
        if (c in basicTypes) {
          list.push(basicTypes[c]);
        } else {
          switch (c) {
            case 'P': list.push(parse(true, 1, true)[0] + '*'); break; // pointer
            case 'R': list.push(parse(true, 1, true)[0] + '&'); break; // reference
            case 'L': { // literal
              i++; // skip basic type
              var end = func.indexOf('E', i);
              var size = end - i;
              list.push(func.substr(i, size));
              i += size + 2; // size + 'EE'
              break;
            }
            case 'A': { // array
              var size = parseInt(func.substr(i));
              i += size.toString().length;
              if (func[i] !== '_') throw '?';
              i++; // skip _
              list.push(parse(true, 1, true)[0] + ' [' + size + ']');
              break;
            }
            case 'E': break paramLoop;
            default: ret += '?' + c; break paramLoop;
          }
        }
      }
      if (!allowVoid && list.length === 1 && list[0] === 'void') list = []; // avoid (void)
      return rawList ? list : ret + flushList();
    }
    return parse();
  } catch(e) {
    return func;
  }
}

function demangleAll(text) {
  return text.replace(/__Z[\w\d_]+/g, function(x) { var y = demangle(x); return x === y ? x : (x + ' [' + y + ']') });
}

function stackTrace() {
  var stack = new Error().stack;
  return stack ? demangleAll(stack) : '(no stack trace available)'; // Stack trace is not available at least on IE10 and Safari 6.
}

// Memory management

var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
  return (x+4095)&-4096;
}

var HEAP;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

var STATIC_BASE = 0, STATICTOP = 0, staticSealed = false; // static area
var STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0; // stack area
var DYNAMIC_BASE = 0, DYNAMICTOP = 0; // dynamic area handled by sbrk

function enlargeMemory() {
  abort('Cannot enlarge memory arrays in asm.js. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value ' + TOTAL_MEMORY + ', or (2) set Module.TOTAL_MEMORY before the program runs.');
}

var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
var FAST_MEMORY = Module['FAST_MEMORY'] || 2097152;

var totalMemory = 4096;
while (totalMemory < TOTAL_MEMORY || totalMemory < 2*TOTAL_STACK) {
  if (totalMemory < 16*1024*1024) {
    totalMemory *= 2;
  } else {
    totalMemory += 16*1024*1024
  }
}
if (totalMemory !== TOTAL_MEMORY) {
  Module.printErr('increasing TOTAL_MEMORY to ' + totalMemory + ' to be more reasonable');
  TOTAL_MEMORY = totalMemory;
}

// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),
       'Cannot fallback to non-typed array case: Code is too specialized');

var buffer = new ArrayBuffer(TOTAL_MEMORY);
HEAP8 = new Int8Array(buffer);
HEAP16 = new Int16Array(buffer);
HEAP32 = new Int32Array(buffer);
HEAPU8 = new Uint8Array(buffer);
HEAPU16 = new Uint16Array(buffer);
HEAPU32 = new Uint32Array(buffer);
HEAPF32 = new Float32Array(buffer);
HEAPF64 = new Float64Array(buffer);

// Endianness check (note: assumes compiler arch was little-endian)
HEAP32[0] = 255;
assert(HEAPU8[0] === 255 && HEAPU8[3] === 0, 'Typed arrays 2 must be run on a little-endian system');

Module['HEAP'] = HEAP;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Runtime.dynCall('v', func);
      } else {
        Runtime.dynCall('vi', func, [callback.arg]);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the runtime has exited

var runtimeInitialized = false;

function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
}

function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}
Module['addOnPreRun'] = Module.addOnPreRun = addOnPreRun;

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}
Module['addOnInit'] = Module.addOnInit = addOnInit;

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}
Module['addOnPreMain'] = Module.addOnPreMain = addOnPreMain;

function addOnExit(cb) {
  __ATEXIT__.unshift(cb);
}
Module['addOnExit'] = Module.addOnExit = addOnExit;

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}
Module['addOnPostRun'] = Module.addOnPostRun = addOnPostRun;

// Tools

// This processes a JS string into a C-line array of numbers, 0-terminated.
// For LLVM-originating strings, see parser.js:parseLLVMString function
function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var ret = (new Runtime.UTF8Processor()).processJSString(stringy);
  if (length) {
    ret.length = length;
  }
  if (!dontAddNull) {
    ret.push(0);
  }
  return ret;
}
Module['intArrayFromString'] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module['intArrayToString'] = intArrayToString;

// Write a Javascript array to somewhere in the heap
function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[(((buffer)+(i))|0)]=chr;
    i = i + 1;
  }
}
Module['writeStringToMemory'] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[(((buffer)+(i))|0)]=array[i];
  }
}
Module['writeArrayToMemory'] = writeArrayToMemory;

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; i++) {
    HEAP8[(((buffer)+(i))|0)]=str.charCodeAt(i);
  }
  if (!dontAddNull) HEAP8[(((buffer)+(str.length))|0)]=0;
}
Module['writeAsciiToMemory'] = writeAsciiToMemory;

function unSign(value, bits, ignore, sig) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore, sig) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}

// check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 )
if (!Math['imul'] || Math['imul'](0xffffffff, 5) !== -5) Math['imul'] = function imul(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};
Math.imul = Math['imul'];


var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_min = Math.min;

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
}
Module['addRunDependency'] = addRunDependency;
function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}
Module['removeRunDependency'] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


var memoryInitializer = null;

// === Body ===



STATIC_BASE = 8;

STATICTOP = STATIC_BASE + 17784;


/* global initializers */ __ATINIT__.push({ func: function() { runPostSets() } });

var _stdout;
var _stdout=_stdout=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);;































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































/* memory initializer */ allocate([95,112,137,0,255,9,47,15,10,0,0,0,100,0,0,0,232,3,0,0,16,39,0,0,160,134,1,0,64,66,15,0,128,150,152,0,0,225,245,5,68,65,77,80,76,73,77,73,84,0,0,0,0,0,0,0,91,76,65,66,69,0,0,0,68,73,70,70,0,0,0,0,91,86,69,82,84,0,0,0,84,79,76,69,82,0,0,0,71,82,65,68,69,0,0,0,91,67,79,79,82,0,0,0,68,69,77,65,0,0,0,0,32,32,32,32,78,117,109,98,101,114,32,111,102,32,82,101,115,101,114,118,111,105,114,115,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,100,0,0,0,0,0,91,79,80,84,73,0,0,0,69,77,73,84,0,0,0,0,91,84,73,77,69,0,0,0,83,80,69,67,0,0,0,0,80,66,86,0,0,0,0,0,91,82,69,80,79,0,0,0,83,69,67,0,0,0,0,0,47,49,48,48,48,109,0,0,83,69,71,77,0,0,0,0,91,77,73,88,73,0,0,0,67,79,78,84,0,0,0,0,91,82,69,65,67,0,0,0,37,48,49,100,58,37,48,50,100,58,37,48,50,100,0,0,83,84,79,80,0,0,0,0,91,69,78,69,82,0,0,0,32,32,32,32,32,32,32,119,105,116,104,32,37,115,32,97,98,111,118,101,32,37,45,46,50,102,32,37,115,0,0,0,85,78,66,65,0,0,0,0,91,82,79,85,71,0,0,0,70,67,86,0,0,0,0,0,32,32,32,32,32,32,32,119,105,116,104,32,37,115,32,98,101,108,111,119,32,37,45,46,50,102,32,37,115,0,0,0,86,69,82,73,0,0,0,0,91,83,84,65,84,0,0,0,87,65,82,78,73,78,71,58,32,83,121,115,116,101,109,32,100,105,115,99,111,110,110,101,99,116,101,100,32,98,101,99,97,117,115,101,32,111,102,32,76,105,110,107,32,37,115,0,77,65,80,0,0,0,0,0,91,81,85,65,76,0,0,0,87,65,82,78,73,78,71,58,32,37,100,32,97,100,100,105,116,105,111,110,97,108,32,110,111,100,101,115,32,100,105,115,99,111,110,110,101,99,116,101,100,32,97,116,32,37,115,32,104,114,115,0,0,0,0,0,104,114,115,0,0,0,0,0,72,69,65,68,0,0,0,0,91,67,85,82,86,0,0,0,87,65,82,78,73,78,71,58,32,78,111,100,101,32,37,115,32,100,105,115,99,111,110,110,101,99,116,101,100,32,97,116,32,37,115,32,104,114,115,0,37,32,102,114,111,109,0,0,32,32,32,32,78,117,109,98,101,114,32,111,102,32,74,117,110,99,116,105,111,110,115,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,100,0,0,0,0,0,91,80,65,84,84,0,0,0,37,49,48,115,58,32,83,121,115,116,101,109,32,105,108,108,45,99,111,110,100,105,116,105,111,110,101,100,32,97,116,32,110,111,100,101,32,37,115,0,84,82,65,67,69,0,0,0,91,69,77,73,84,0,0,0,32,69,88,69,67,85,84,73,79,78,32,72,65,76,84,69,68,46,0,0,0,0,0,0,65,71,69,0,0,0,0,0,80,83,86,0,0,0,0,0,91,83,79,85,82,0,0,0,58,0,0,0,0,0,0,0,87,65,82,78,73,78,71,58,32,83,121,115,116,101,109,32,117,110,98,97,108,97,110,99,101,100,32,97,116,32,37,115,32,104,114,115,46,0,0,0,67,72,69,77,0,0,0,0,91,68,69,77,65,0,0,0,87,65,82,78,73,78,71,58,32,80,117,109,112,32,37,115,32,37,115,32,97,116,32,37,115,32,104,114,115,46,0,0,83,65,86,69,0,0,0,0,91,82,85,76,69,0,0,0,87,65,82,78,73,78,71,58,32,37,115,32,37,115,32,37,115,32,97,116,32,37,115,32,104,114,115,46,0,0,0,0,85,83,69,0,0,0,0,0,91,67,79,78,84,0,0,0,87,65,82,78,73,78,71,58,32,78,101,103,97,116,105,118,101,32,112,114,101,115,115,117,114,101,115,32,97,116,32,37,115,32,104,114,115,46,0,0,67,45,77,0,0,0,0,0,91,86,65,76,86,0,0,0,80,66,86,0,0,0,0,0,87,65,82,78,73,78,71,58,32,77,97,120,105,109,117,109,32,116,114,105,97,108,115,32,101,120,99,101,101,100,101,100,32,97,116,32,37,115,32,104,114,115,46,32,83,121,115,116,101,109,32,109,97,121,32,98,101,32,117,110,115,116,97,98,108,101,46,0,0,0,0,0,68,45,87,0,0,0,0,0,91,80,85,77,80,0,0,0,37,49,48,115,58,32,37,115,32,37,115,32,99,104,97,110,103,101,100,32,98,121,32,114,117,108,101,32,37,115,0,0,72,45,87,0,0,0,0,0,91,80,73,80,69,0,0,0,37,49,48,115,58,32,37,115,32,37,115,32,99,104,97,110,103,101,100,32,98,121,32,116,105,109,101,114,32,99,111,110,116,114,111,108,0,0,0,0,77,69,84,69,82,83,0,0,68,69,77,65,0,0,0,0,91,84,65,78,75,0,0,0,37,49,48,115,58,32,37,115,32,37,115,32,99,104,97,110,103,101,100,32,98,121,32,37,115,32,37,115,32,99,111,110,116,114,111,108,0,0,0,0,75,80,65,0,0,0,0,0,32,32,32,32,73,110,112,117,116,32,68,97,116,97,32,70,105,108,101,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,115,0,0,0,0,0,0,91,82,69,83,69,0,0,0,32,32,32,32,32,32,32,32,32,32,32,32,37,115,32,37,115,32,115,119,105,116,99,104,101,100,32,102,114,111,109,32,37,115,32,116,111,32,37,115,0,0,0,0,0,0,0,0,80,83,73,0,0,0,0,0,91,74,85,78,67,0,0,0,32,32,32,32,32,32,32,32,32,32,32,32,37,115,32,37,115,32,115,101,116,116,105,110,103,32,99,104,97,110,103,101,100,32,116,111,32,37,45,46,50,102,0,0,0,0,0,0,80,82,69,83,0,0,0,0,80,82,86,0,0,0,0,0,91,84,73,84,76,0,0,0,34,10,13,0,0,0,0,0,32,32,32,32,32,32,32,32,32,32,32,32,84,114,105,97,108,32,37,50,100,58,32,114,101,108,97,116,105,118,101,32,102,108,111,119,32,99,104,97,110,103,101,32,61,32,37,45,46,54,102,0,0,0,0,0,109,109,0,0,0,0,0,0,83,73,0,0,0,0,0,0,37,49,48,115,58,32,66,97,108,97,110,99,105,110,103,32,116,104,101,32,110,101,116,119,111,114,107,58,0,0,0,0,77,76,68,0,0,0,0,0,10,32,32,37,115,0,0,0,82,85,76,69,0,0,0,0,67,77,68,0,0,0,0,0,10,12,10,32,32,80,97,103,101,32,37,45,100,32,32,32,32,37,54,48,46,54,48,115,10,0,0,0,0,0,0,0,67,77,72,0,0,0,0,0,76,73,70,79,0,0,0,0,80,83,86,0,0,0,0,0,76,105,110,107,0,0,0,0,76,80,77,0,0,0,0,0,70,73,70,79,0,0,0,0,76,105,110,107,32,82,101,115,117,108,116,115,32,97,116,32,37,115,32,104,114,115,58,0,76,80,83,0,0,0,0,0,50,67,79,77,80,0,0,0,105,110,102,105,110,105,116,121,0,0,0,0,0,0,0,0,76,105,110,107,32,82,101,115,117,108,116,115,58,0,0,0,73,77,71,68,0,0,0,0,80,82,73,79,0,0,0,0,77,73,88,69,68,0,0,0,37,115,32,76,105,110,107,32,82,101,115,117,108,116,115,58,0,0,0,0,0,0,0,0,77,71,68,0,0,0,0,0,32,0,0,0,0,0,0,0,82,65,78,71,69,0,0,0,78,111,100,101,0,0,0,0,65,70,68,0,0,0,0,0,77,65,88,73,77,85,77,0,37,49,53,115,0,0,0,0,71,80,77,0,0,0,0,0,83,80,69,69,0,0,0,0,77,73,78,73,77,85,77,0,73,110,112,117,116,32,69,114,114,111,114,32,50,51,48,58,32,67,117,114,118,101,32,37,115,32,104,97,115,32,110,111,110,105,110,99,114,101,97,115,105,110,103,32,120,45,118,97,108,117,101,115,46,0,0,0,78,111,100,101,32,82,101,115,117,108,116,115,32,97,116,32,37,115,32,104,114,115,58,0,67,70,83,0,0,0,0,0,65,86,69,82,65,71,69,0,78,111,100,101,32,82,101,115,117,108,116,115,58,0,0,0,85,78,73,84,0,0,0,0,68,73,70,70,69,82,69,78,84,73,65,76,0,0,0,0,82,69,80,79,0,0,0,0,37,115,32,78,111,100,101,32,82,101,115,117,108,116,115,58,0,0,0,0,0,0,0,0,83,84,65,82,0,0,0,0,80,82,86,0,0,0,0,0,10,32,32,111,32,87,114,105,116,105,110,103,32,111,117,116,112,117,116,32,114,101,112,111,114,116,32,116,111,32,0,0,80,117,109,112,32,32,32,32,32,32,70,97,99,116,111,114,32,69,102,102,105,99,46,32,32,32,32,32,37,115,32,32,32,32,32,32,32,32,75,119,32,32,32,32,32,32,32,32,75,119,32,32,32,32,32,32,47,100,97,121,0,0,0,0,77,73,78,73,0,0,0,0,32,32,32,32,32,32,32,32,32,32,32,85,115,97,103,101,32,32,32,65,118,103,46,32,32,32,32,32,75,119,45,104,114,32,32,32,32,32,32,65,118,103,46,32,32,32,32,32,32,80,101,97,107,32,32,32,32,32,32,67,111,115,116,0,82,85,76,69,0,0,0,0,69,110,101,114,103,121,32,85,115,97,103,101,58,0,0,0,81,85,65,76,0,0,0,0,69,76,83,69,0,0,0,0,47,77,103,97,108,0,0,0,72,89,68,82,0,0,0,0,37,45,46,55,48,115,0,0,32,32,47,109,51,0,0,0,68,85,82,65,0,0,0,0,32,40,99,111,110,116,105,110,117,101,100,41,0,0,0,0,82,65,78,71,69,0,0,0,80,65,84,84,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,51,51,58,32,78,111,100,101,32,37,115,32,105,115,32,117,110,99,111,110,110,101,99,116,101,100,46,0,0,0,0,0,0,0,0,72,121,100,114,97,117,108,105,99,32,83,116,97,116,117,115,58,0,0,0,0,0,0,0,77,65,88,73,77,85,77,0,91,82,85,76,69,83,93,32,115,101,99,116,105,111,110,0,37,49,48,115,0,0,0,0,77,73,78,73,77,85,77,0,32,32,0,0,0,0,0,0,65,86,69,82,65,71,69,0,78,79,78,69,0,0,0,0,82,117,108,101,0,0,0,0,37,49,48,46,42,102,0,0,83,84,65,84,0,0,0,0,80,117,109,112,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,50,49,58,32,109,105,115,45,112,108,97,99,101,100,32,99,108,97,117,115,101,32,105,110,32,102,111,108,108,111,119,105,110,103,32,108,105,110,101,32,111,102,32,0,0,0,0,0,0,0,0,37,49,48,46,50,101,0,0,70,73,76,69,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,55,58,32,97,116,116,101,109,112,116,32,116,111,32,99,111,110,116,114,111,108,32,97,32,67,86,32,105,110,32,102,111,108,108,111,119,105,110,103,32,108,105,110,101,32,111,102,32,0,0,37,45,49,53,115,0,0,0,80,82,69,67,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,52,58,32,117,110,100,101,102,105,110,101,100,32,108,105,110,107,32,105,110,32,102,111,108,108,111,119,105,110,103,32,108,105,110,101,32,111,102,32,0,0,0,37,51,56,115,32,84,111,116,97,108,32,67,111,115,116,58,32,32,32,32,37,57,46,50,102,0,0,0,0,0,0,0,72,69,65,68,76,0,0,0,84,72,69,78,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,51,58,32,117,110,100,101,102,105,110,101,100,32,110,111,100,101,32,105,110,32,102,111,108,108,111,119,105,110,103,32,108,105,110,101,32,111,102,32,0,0,0,37,51,56,115,32,68,101,109,97,110,100,32,67,104,97,114,103,101,58,32,37,57,46,50,102,0,0,0,0,0,0,0,76,73,78,75,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,50,58,32,105,108,108,101,103,97,108,32,110,117,109,101,114,105,99,32,118,97,108,117,101,32,105,110,32,102,111,108,108,111,119,105,110,103,32,108,105,110,101,32,111,102,32,0,0,0,0,37,45,56,115,32,32,37,54,46,50,102,32,37,54,46,50,102,32,37,57,46,50,102,32,37,57,46,50,102,32,37,57,46,50,102,32,37,57,46,50,102,0,0,0,0,0,0,0,65,76,76,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,49,58,32,115,121,110,116,97,120,32,101,114,114,111,114,32,105,110,32,102,111,108,108,111,119,105,110,103,32,108,105,110,101,32,111,102,32,0,0,0,0,0,37,49,48,115,58,32,37,115,32,37,115,32,99,104,97,110,103,101,100,32,102,114,111,109,32,37,115,32,116,111,32,37,115,0,0,0,0,0,0,0,78,79,78,69,0,0,0,0,72,69,65,68,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,50,55,58,32,105,110,118,97,108,105,100,32,104,101,97,100,32,99,117,114,118,101,32,102,111,114,32,80,117,109,112,32,37,115,46,0,0,0,0,0,0,0,0,37,49,48,115,58,32,37,115,32,37,115,32,37,115,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,50,53,58,32,105,110,118,97,108,105,100,32,108,111,119,101,114,47,117,112,112,101,114,32,108,101,118,101,108,115,32,102,111,114,32,84,97,110,107,32,37,115,46,0,0,0,0,0,0,0,0,78,79,68,69,0,0,0,0,65,67,84,73,86,69,0,0,67,86,0,0,0,0,0,0,37,49,48,115,58,32,82,101,115,101,114,118,111,105,114,32,37,115,32,105,115,32,37,115,0,0,0,0,0,0,0,0,69,78,69,82,0,0,0,0,67,76,79,83,69,68,0,0,37,49,48,115,58,32,84,97,110,107,32,37,115,32,105,115,32,37,115,32,97,116,32,37,45,46,50,102,32,37,115,0,77,69,83,83,0,0,0,0,79,80,69,78,0,0,0,0,37,49,48,115,58,32,85,110,98,97,108,97,110,99,101,100,32,97,102,116,101,114,32,37,45,100,32,116,114,105,97,108,115,32,40,102,108,111,119,32,99,104,97,110,103,101,32,61,32,37,45,46,54,102,41,0,83,85,77,77,0,0,0,0,80,105,112,101,0,0,0,0,88,88,88,88,0,0,0,0,37,49,48,115,58,32,66,97,108,97,110,99,101,100,32,97,102,116,101,114,32,37,45,100,32,116,114,105,97,108,115,0,70,85,76,76,0,0,0,0,65,66,79,86,69,0,0,0,32,32,32,32,32,32,32,83,101,108,101,99,116,101,100,32,76,105,110,107,115,0,0,0,89,69,83,0,0,0,0,0,66,69,76,79,87,0,0,0,32,32,32,32,32,32,32,65,108,108,32,76,105,110,107,115,0,0,0,0,0,0,0,0,78,79,0,0,0,0,0,0,79,82,0,0,0,0,0,0,109,51,47,100,0,0,0,0,78,79,84,0,0,0,0,0,32,32,32,32,32,32,32,78,111,32,76,105,110,107,115,0,83,84,65,84,85,83,0,0,109,51,47,104,0,0,0,0,73,83,0,0,0,0,0,0,32,32,32,32,32,32,32,83,101,108,101,99,116,101,100,32,78,111,100,101,115,0,0,0,80,65,71,69,0,0,0,0,77,76,47,100,0,0,0,0,62,0,0,0,0,0,0,0,32,32,32,32,32,32,32,65,108,108,32,78,111,100,101,115,0,0,0,0,0,0,0,0,69,70,70,73,0,0,0,0,80,79,87,69,0,0,0,0,76,112,109,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,50,54,58,32,110,111,32,104,101,97,100,32,99,117,114,118,101,32,115,117,112,112,108,105,101,100,32,102,111,114,32,80,117,109,112,32,37,115,46,0,0,0,0,60,0,0,0,0,0,0,0,32,32,32,32,32,32,32,78,111,32,78,111,100,101,115,0,49,0,0,0,0,0,0,0,80,82,73,67,69,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,50,50,58,32,37,115,32,37,115,32,104,97,115,32,115,97,109,101,32,115,116,97,114,116,32,97,110,100,32,101,110,100,32,110,111,100,101,115,46,0,0,0,0,76,47,115,0,0,0,0,0,62,61,0,0,0,0,0,0,32,32,32,32,82,101,112,111,114,116,105,110,103,32,67,114,105,116,101,114,105,97,58,0,80,117,109,112,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,50,48,58,32,37,115,32,37,115,32,105,108,108,101,103,97,108,108,121,32,99,111,110,110,101,99,116,101,100,32,116,111,32,97,110,111,116,104,101,114,32,118,97,108,118,101,46,0,0,0,0,97,45,102,47,100,0,0,0,60,61,0,0,0,0,0,0,32,32,32,32,84,111,116,97,108,32,68,117,114,97,116,105,111,110,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,46,50,102,32,37,115,0,0,0,0,0,0,0,0,68,69,77,65,78,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,49,57,58,32,37,115,32,37,115,32,105,108,108,101,103,97,108,108,121,32,99,111,110,110,101,99,116,101,100,32,116,111,32,97,32,116,97,110,107,46,0,0,0,73,109,103,100,0,0,0,0,60,62,0,0,0,0,0,0,32,32,32,32,68,101,109,97,110,100,32,77,117,108,116,105,112,108,105,101,114,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,46,50,102,0,0,0,71,76,79,66,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,49,55,58,32,105,110,118,97,108,105,100,32,37,115,32,100,97,116,97,32,102,111,114,32,80,117,109,112,32,37,115,46,0,0,0,109,103,100,0,0,0,0,0,67,86,0,0,0,0,0,0,61,0,0,0,0,0,0,0,32,32,32,32,82,101,108,97,116,105,118,101,32,67,104,101,109,105,99,97,108,32,68,105,102,102,117,115,105,118,105,116,121,32,46,46,46,46,46,32,37,45,46,50,102,0,0,0,76,73,77,73,84,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,49,54,58,32,37,115,32,100,97,116,97,32,115,112,101,99,105,102,105,101,100,32,102,111,114,32,117,110,100,101,102,105,110,101,100,32,80,117,109,112,32,37,115,46,0,0,0,0,0,0,0,103,112,109,0,0,0,0,0,83,89,83,84,0,0,0,0,32,32,32,32,82,101,108,97,116,105,118,101,32,75,105,110,101,109,97,116,105,99,32,86,105,115,99,111,115,105,116,121,32,46,46,46,46,46,46,32,37,45,46,50,102,0,0,0,82,79,85,71,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,49,53,58,32,37,115,32,37,115,32,105,115,32,97,32,100,117,112,108,105,99,97,116,101,32,73,68,46,0,0,0,0,0,0,0,99,102,115,0,0,0,0,0,76,73,78,75,0,0,0,0,32,32,32,32,83,112,101,99,105,102,105,99,32,71,114,97,118,105,116,121,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,46,50,102,0,0,0,87,65,76,76,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,49,51,58,32,105,108,108,101,103,97,108,32,111,112,116,105,111,110,32,118,97,108,117,101,32,105,110,32,91,37,115,93,32,115,101,99,116,105,111,110,58,0,0,65,78,68,0,0,0,0,0,67,104,101,122,121,45,77,97,110,110,105,110,103,0,0,0,78,79,68,69,0,0,0,0,32,32,32,32,87,97,116,101,114,32,81,117,97,108,105,116,121,32,84,111,108,101,114,97,110,99,101,32,46,46,46,46,46,46,46,46,46,46,46,32,37,45,46,50,102,32,37,115,0,0,0,0,0,0,0,0,84,97,110,107,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,49,50,58,32,116,114,97,99,101,32,110,111,100,101,32,37,46,48,115,32,37,115,32,105,115,32,117,110,100,101,102,105,110,101,100,46,0,0,0,0,0,0,0,68,97,114,99,121,45,87,101,105,115,98,97,99,104,0,0,32,32,80,97,103,101,32,49,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,0,0,0,0,86,97,108,118,101,0,0,0,32,32,32,32,87,97,116,101,114,32,81,117,97,108,105,116,121,32,84,105,109,101,32,83,116,101,112,32,46,46,46,46,46,46,46,46,46,46,46,32,37,45,46,50,102,32,109,105,110,0,0,0,0,0,0,0,66,85,76,75,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,49,49,58,32,105,108,108,101,103,97,108,32,37,115,32,118,97,108,117,101,32,102,111,114,32,76,105,110,107,32,37,115,46,0,0,72,97,122,101,110,45,87,105,108,108,105,97,109,115,0,0,80,117,109,112,0,0,0,0,32,32,32,32,81,117,97,108,105,116,121,32,65,110,97,108,121,115,105,115,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,65,103,101,0,0,0,0,0,79,82,68,69,82,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,49,48,58,32,37,115,32,115,112,101,99,105,102,105,101,100,32,102,111,114,32,117,110,100,101,102,105,110,101,100,32,76,105,110,107,32,37,115,46,0,0,0,0,79,80,69,78,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,49,52,58,32,102,111,108,108,111,119,105,110,103,32,108,105,110,101,32,111,102,32,91,37,115,93,32,115,101,99,116,105,111,110,32,99,111,110,116,97,105,110,115,32,116,111,111,32,109,97,110,121,32,99,104,97,114,97,99,116,101,114,115,58,0,0,0,80,105,112,101,0,0,0,0,32,32,32,32,81,117,97,108,105,116,121,32,65,110,97,108,121,115,105,115,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,84,114,97,99,101,32,70,114,111,109,32,78,111,100,101,32,37,115,0,0,0,0,0,0,109,103,47,76,0,0,0,0,42,0,0,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,57,58,32,105,108,108,101,103,97,108,32,37,115,32,118,97,108,117,101,32,102,111,114,32,78,111,100,101,32,37,115,46,0,0,84,97,110,107,0,0,0,0,32,32,32,32,81,117,97,108,105,116,121,32,65,110,97,108,121,115,105,115,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,115,0,0,0,0,0,0,70,76,79,87,80,65,67,69,68,0,0,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,56,58,32,37,115,32,115,112,101,99,105,102,105,101,100,32,102,111,114,32,117,110,100,101,102,105,110,101,100,32,78,111,100,101,32,37,115,46,0,0,0,0,82,101,115,101,114,0,0,0,32,32,32,32,81,117,97,108,105,116,121,32,65,110,97,108,121,115,105,115,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,78,111,110,101,0,0,0,0,83,69,84,80,79,73,78,84,0,0,0,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,55,58,32,37,115,32,37,115,32,97,116,116,101,109,112,116,115,32,116,111,32,99,111,110,116,114,111,108,32,97,32,67,86,46,0,0,0,0,0,0,0,0,101,109,112,116,121,105,110,103,0,0,0,0,0,0,0,0,37,49,48,115,58,32,86,97,108,118,101,32,37,115,32,99,97,117,115,101,100,32,105,108,108,45,99,111,110,100,105,116,105,111,110,105,110,103,0,0,10,32,32,0,0,0,0,0,74,117,110,99,0,0,0,0,70,105,108,101,32,69,114,114,111,114,32,51,48,57,58,32,99,97,110,110,111,116,32,115,97,118,101,32,114,101,115,117,108,116,115,32,116,111,32,114,101,112,111,114,116,32,102,105,108,101,46,0,0,0,0,0,32,32,32,32,77,97,120,105,109,117,109,32,84,114,105,97,108,115,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,100,0,0,0,0,0,70,105,108,101,32,69,114,114,111,114,32,51,48,56,58,32,99,97,110,110,111,116,32,115,97,118,101,32,114,101,115,117,108,116,115,32,116,111,32,102,105,108,101,46,0,0,0,0,70,105,108,101,32,69,114,114,111,114,32,51,48,55,58,32,99,97,110,110,111,116,32,114,101,97,100,32,104,121,100,114,97,117,108,105,99,115,32,102,105,108,101,46,0,0,0,0,77,65,83,83,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,54,58,32,37,115,32,37,115,32,114,101,102,101,114,115,32,116,111,32,117,110,100,101,102,105,110,101,100,32,99,117,114,118,101,46,0,0,0,0,0,0,0,70,105,108,101,32,69,114,114,111,114,32,51,48,54,58,32,104,121,100,114,97,117,108,105,99,115,32,102,105,108,101,32,100,111,101,115,32,110,111,116,32,109,97,116,99,104,32,110,101,116,119,111,114,107,32,100,97,116,97,46,0,0,0,0,70,105,108,101,32,69,114,114,111,114,32,51,48,53,58,32,99,97,110,110,111,116,32,111,112,101,110,32,104,121,100,114,97,117,108,105,99,115,32,102,105,108,101,46,0,0,0,0,70,105,108,101,32,69,114,114,111,114,32,51,48,52,58,32,99,97,110,110,111,116,32,111,112,101,110,32,98,105,110,97,114,121,32,111,117,116,112,117,116,32,102,105,108,101,46,0,70,105,108,101,32,69,114,114,111,114,32,51,48,51,58,32,99,97,110,110,111,116,32,111,112,101,110,32,114,101,112,111,114,116,32,102,105,108,101,46,0,0,0,0,0,0,0,0,70,105,108,101,32,69,114,114,111,114,32,51,48,50,58,32,99,97,110,110,111,116,32,111,112,101,110,32,105,110,112,117,116,32,102,105,108,101,46,0,102,105,108,108,105,110,103,0,84,97,110,107,0,0,0,0,70,105,108,101,32,69,114,114,111,114,32,51,48,49,58,32,105,100,101,110,116,105,99,97,108,32,102,105,108,101,32,110,97,109,101,115,46,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,53,49,58,32,102,117,110,99,116,105,111,110,32,99,97,108,108,32,99,111,110,116,97,105,110,115,32,105,110,118,97,108,105,100,32,112,97,114,97,109,101,116,101,114,32,99,111,100,101,46,0,68,82,65,73,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,53,48,58,32,102,117,110,99,116,105,111,110,32,99,97,108,108,32,99,111,110,116,97,105,110,115,32,105,110,118,97,108,105,100,32,102,111,114,109,97,116,46,0,32,32,32,32,68,97,109,112,105,110,103,32,76,105,109,105,116,32,84,104,114,101,115,104,111,108,100,32,46,46,46,46,46,46,46,46,46,46,46,32,37,45,46,54,102,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,52,49,58,32,37,115,32,37,115,32,114,101,102,101,114,115,32,116,111,32,117,110,100,101,102,105,110,101,100,32,99,111,110,116,114,111,108,46,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,52,48,58,32,37,115,32,37,115,32,114,101,102,101,114,115,32,116,111,32,117,110,100,101,102,105,110,101,100,32,115,111,117,114,99,101,46,0,0,0,0,0,0,67,79,78,67,69,78,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,53,58,32,37,115,32,37,115,32,114,101,102,101,114,115,32,116,111,32,117,110,100,101,102,105,110,101,100,32,116,105,109,101,32,112,97,116,116,101,114,110,46,0,0,0,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,55,58,32,37,115,32,37,115,32,97,116,116,101,109,112,116,115,32,116,111,32,99,111,110,116,114,111,108,32,97,32,67,86,46,0,0,0,0,0,0,0,0,37,32,102,114,111,109,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,53,58,32,37,115,32,37,115,32,114,101,102,101,114,115,32,116,111,32,117,110,100,101,102,105,110,101,100,32,116,105,109,101,32,112,97,116,116,101,114,110,46,0,0,0,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,52,58,32,37,115,32,37,115,32,114,101,102,101,114,115,32,116,111,32,117,110,100,101,102,105,110,101,100,32,108,105,110,107,46,0,0,0,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,51,58,32,37,115,32,37,115,32,114,101,102,101,114,115,32,116,111,32,117,110,100,101,102,105,110,101,100,32,110,111,100,101,46,0,0,0,0,0,0,0,0,102,117,110,99,116,105,111,110,32,99,97,108,108,0,0,0,111,112,101,110,32,98,117,116,32,99,97,110,110,111,116,32,100,101,108,105,118,101,114,32,112,114,101,115,115,117,114,101,0,0,0,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,50,58,32,37,115,32,37,115,32,99,111,110,116,97,105,110,115,32,105,108,108,101,103,97,108,32,110,117,109,101,114,105,99,32,118,97,108,117,101,46,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,50,52,58,32,110,111,32,116,97,110,107,115,32,111,114,32,114,101,115,101,114,118,111,105,114,115,32,105,110,32,110,101,116,119,111,114,107,46,0,0,0,0,0,70,73,76,76,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,50,51,58,32,110,111,116,32,101,110,111,117,103,104,32,110,111,100,101,115,32,105,110,32,110,101,116,119,111,114,107,0,0,0,0,32,32,32,32,77,97,120,105,109,117,109,32,84,114,105,97,108,115,32,67,104,101,99,107,101,100,32,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,100,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,48,58,32,111,110,101,32,111,114,32,109,111,114,101,32,101,114,114,111,114,115,32,105,110,32,105,110,112,117,116,32,102,105,108,101,46,0,0,0,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,50,48,58,32,99,97,110,110,111,116,32,115,111,108,118,101,32,119,97,116,101,114,32,113,117,97,108,105,116,121,32,116,114,97,110,115,112,111,114,116,32,101,113,117,97,116,105,111,110,115,46,0,0,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,52,58,32,37,115,32,37,115,32,114,101,102,101,114,115,32,116,111,32,117,110,100,101,102,105,110,101,100,32,108,105,110,107,46,0,0,0,0,0,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,49,48,58,32,99,97,110,110,111,116,32,115,111,108,118,101,32,110,101,116,119,111,114,107,32,104,121,100,114,97,117,108,105,99,32,101,113,117,97,116,105,111,110,115,46,0,0,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,48,57,58,32,99,97,110,110,111,116,32,99,104,97,110,103,101,32,116,105,109,101,32,112,97,114,97,109,101,116,101,114,32,119,104,101,110,32,115,111,108,118,101,114,32,105,115,32,97,99,116,105,118,101,46,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,48,56,58,32,99,97,110,110,111,116,32,117,115,101,32,101,120,116,101,114,110,97,108,32,102,105,108,101,32,119,104,105,108,101,32,104,121,100,114,97,117,108,105,99,115,32,115,111,108,118,101,114,32,105,115,32,97,99,116,105,118,101,46,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,48,55,58,32,104,121,100,114,97,117,108,105,99,115,32,115,117,112,112,108,105,101,100,32,102,114,111,109,32,101,120,116,101,114,110,97,108,32,102,105,108,101,46,0,0,0,0,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,48,54,58,32,110,111,32,114,101,115,117,108,116,115,32,115,97,118,101,100,32,116,111,32,114,101,112,111,114,116,32,111,110,46,0,0,0,0,0,0,0,0,111,112,101,110,32,98,117,116,32,99,97,110,110,111,116,32,100,101,108,105,118,101,114,32,102,108,111,119,0,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,48,53,58,32,119,97,116,101,114,32,113,117,97,108,105,116,121,32,110,111,116,32,105,110,105,116,105,97,108,105,122,101,100,46,0,0,0,0,0,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,48,52,58,32,110,111,32,104,121,100,114,97,117,108,105,99,115,32,102,111,114,32,119,97,116,101,114,32,113,117,97,108,105,116,121,32,97,110,97,108,121,115,105,115,46,0,0,0,0,0,67,76,79,67,75,84,73,77,69,0,0,0,0,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,48,51,58,32,104,121,100,114,97,117,108,105,99,115,32,110,111,116,32,105,110,105,116,105,97,108,105,122,101,100,46,0,0,0,32,32,32,32,83,116,97,116,117,115,32,67,104,101,99,107,32,70,114,101,113,117,101,110,99,121,32,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,100,0,0,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,48,50,58,32,110,111,32,110,101,116,119,111,114,107,32,100,97,116,97,32,97,118,97,105,108,97,98,108,101,46,0,0,0,0,83,121,115,116,101,109,32,69,114,114,111,114,32,49,48,49,58,32,105,110,115,117,102,102,105,99,105,101,110,116,32,109,101,109,111,114,121,32,97,118,97,105,108,97,98,108,101,46,0,0,0,0,0,0,0,0,65,66,79,86,69,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,51,58,32,37,115,32,37,115,32,114,101,102,101,114,115,32,116,111,32,117,110,100,101,102,105,110,101,100,32,110,111,100,101,46,0,0,0,0,0,0,0,0,101,110,88,88,88,88,88,88,0,0,0,0,0,0,0,0,47,100,97,121,0,0,0,0,10,32,32,32,32,67,97,110,110,111,116,32,111,112,101,110,32,116,101,109,112,111,114,97,114,121,32,111,117,116,112,117,116,32,102,105,108,101,0,0,10,32,32,32,32,67,97,110,110,111,116,32,111,112,101,110,32,111,117,116,112,117,116,32,102,105,108,101,32,0,0,0,73,70,0,0,0,0,0,0,114,98,0,0,0,0,0,0,10,32,32,32,32,67,97,110,110,111,116,32,111,112,101,110,32,114,101,112,111,114,116,32,102,105,108,101,32,0,0,0,111,112,101,110,32,98,117,116,32,101,120,99,101,101,100,115,32,109,97,120,105,109,117,109,32,102,108,111,119,0,0,0,119,116,0,0,0,0,0,0,10,32,32,32,32,67,97,110,110,111,116,32,111,112,101,110,32,105,110,112,117,116,32,102,105,108,101,32,0,0,0,0,84,73,77,69,0,0,0,0,114,116,0,0,0,0,0,0,32,32,32,32,72,121,100,114,97,117,108,105,99,32,65,99,99,117,114,97,99,121,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,46,54,102,0,0,0,10,32,32,32,32,67,97,110,110,111,116,32,117,115,101,32,100,117,112,108,105,99,97,116,101,32,102,105,108,101,32,110,97,109,101,115,46,0,0,0,66,69,76,79,87,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,50,58,32,37,115,32,37,115,32,99,111,110,116,97,105,110,115,32,105,108,108,101,103,97,108,32,110,117,109,101,114,105,99,32,118,97,108,117,101,46,0,0,104,112,0,0,0,0,0,0,97,99,116,105,118,101,0,0,119,116,0,0,0,0,0,0,80,79,87,69,0,0,0,0,32,32,32,32,72,121,100,114,97,117,108,105,99,32,84,105,109,101,115,116,101,112,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,46,50,102,32,37,115,0,0,0,0,0,0,0,0,67,111,109,112,117,116,105,110,103,32,119,97,116,101,114,32,113,117,97,108,105,116,121,32,97,116,32,104,111,117,114,32,37,115,0,0,0,0,0,0,67,76,79,67,75,84,73,77,69,0,0,0,0,0,0,0,73,110,112,117,116,32,69,114,114,111,114,32,50,48,49,58,32,115,121,110,116,97,120,32,101,114,114,111,114,32,105,110,32,102,111,108,108,111,119,105,110,103,32,108,105,110,101,32,111,102,32,91,37,115,93,32,115,101,99,116,105,111,110,58,0,0,0,0,0,0,0,0,10,32,32,111,32,84,114,97,110,115,102,101,114,114,105,110,103,32,114,101,115,117,108,116,115,32,116,111,32,102,105,108,101,0,0,0,0,0,0,0,10,32,32,111,32,67,111,109,112,117,116,105,110,103,32,119,97,116,101,114,32,113,117,97,108,105,116,121,32,97,116,32,104,111,117,114,32,0,0,0,119,43,98,0,0,0,0,0,8,8,8,8,8,8,8,8,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,0,0,0,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,111,112,101,110,0,0,0,0,67,111,109,112,117,116,105,110,103,32,104,121,100,114,97,117,108,105,99,115,32,97,116,32,104,111,117,114,32,37,115,0,37,45,49,48,115,0,0,0,83,69,84,84,0,0,0,0,10,32,32,111,32,67,111,109,112,117,116,105,110,103,32,104,121,100,114,97,117,108,105,99,115,32,97,116,32,104,111,117,114,32,0,0,0,0,0,0,32,32,32,32,72,101,97,100,108,111,115,115,32,70,111,114,109,117,108,97,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,115,0,0,0,0,0,0,65,110,97,108,121,115,105,115,32,101,110,100,101,100,32,37,115,0,0,0,0,0,0,0,65,110,97,108,121,115,105,115,32,98,101,103,117,110,32,37,115,0,0,0,0,0,0,0,84,73,77,69,0,0,0,0,80,77,0,0,0,0,0,0,10,32,32,111,32,82,101,116,114,105,101,118,105,110,103,32,110,101,116,119,111,114,107,32,100,97,116,97,0,0,0,0,67,76,79,83,69,68,0,0,10,10,46,46,46,32,69,80,65,78,69,84,32,99,111,109,112,108,101,116,101,100,46,10,0,0,0,0,0,0,0,0,10,10,46,46,46,32,69,80,65,78,69,84,32,99,111,109,112,108,101,116,101,100,46,32,84,104,101,114,101,32,97,114,101,32,119,97,114,110,105,110,103,115,46,10,0,0,0,0,10,10,46,46,46,32,69,80,65,78,69,84,32,99,111,109,112,108,101,116,101,100,46,32,84,104,101,114,101,32,97,114,101,32,101,114,114,111,114,115,46,10,0,0,0,0,0,0,99,108,111,115,101,100,0,0,10,46,46,46,32,69,80,65,78,69,84,32,86,101,114,115,105,111,110,32,50,46,48,10,0,0,0,0,0,0,0,0,32,9,10,13,0,0,0,0,10,32,67,111,114,114,101,99,116,32,115,121,110,116,97,120,32,105,115,58,10,32,101,112,97,110,101,116,32,60,105,110,112,117,116,32,102,105,108,101,62,32,60,111,117,116,112,117,116,32,102,105,108,101,62,10,0,0,0,0,0,0,0,0,83,84,65,84,85,83,0,0,42,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,86,101,114,115,105,111,110,32,50,46,48,48,46,49,50,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,42,0,0,0,0,0,0,32,32,32,32,78,117,109,98,101,114,32,111,102,32,86,97,108,118,101,115,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,100,0,0,0,0,0,67,104,101,109,105,99,97,108,0,0,0,0,0,0,0,0,42,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,65,110,97,108,121,115,105,115,32,102,111,114,32,80,105,112,101,32,78,101,116,119,111,114,107,115,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,42,0,0,0,0,0,0,42,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,72,121,100,114,97,117,108,105,99,32,97,110,100,32,87,97,116,101,114,32,81,117,97,108,105,116,121,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,42,0,0,0,0,0,0,77,85,76,84,0,0,0,0,42,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,69,32,80,32,65,32,78,32,69,32,84,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,42,0,0,0,0,0,0,65,77,0,0,0,0,0,0,105,110,0,0,0,0,0,0,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,0,0,0,0,0,0,70,45,70,97,99,116,111,114,0,0,0,0,0,0,0,0,83,101,116,116,105,110,103,0,116,101,109,112,111,114,97,114,105,108,121,32,99,108,111,115,101,100,0,0,0,0,0,0,83,116,97,116,101,0,0,0,72,101,97,100,108,111,115,115,0,0,0,0,0,0,0,0,70,76,79,87,0,0,0,0,86,101,108,111,99,105,116,121,0,0,0,0,0,0,0,0,32,32,32,32,78,117,109,98,101,114,32,111,102,32,80,117,109,112,115,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,100,0,0,0,0,0,70,108,111,119,0,0,0,0,68,105,97,109,101,116,101,114,0,0,0,0,0,0,0,0,71,80,86,0,0,0,0,0,76,101,110,103,116,104,0,0,68,65,89,0,0,0,0,0,80,114,101,115,115,117,114,101,0,0,0,0,0,0,0,0,72,101,97,100,0,0,0,0,68,101,109,97,110,100,0,0,69,108,101,118,97,116,105,111,110,0,0,0,0,0,0,0,99,108,111,115,101,100,32,98,101,99,97,117,115,101,32,99,97,110,110,111,116,32,100,101,108,105,118,101,114,32,104,101,97,100,0,0,0,0,0,0,79,112,116,105,111,110,115,0,84,105,109,101,115,0,0,0,80,82,69,83,0,0,0,0,82,101,112,111,114,116,0,0,32,32,32,32,78,117,109,98,101,114,32,111,102,32,80,105,112,101,115,32,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,32,37,45,100,0,0,0,0,0,77,105,120,105,110,103,0,0,82,101,97,99,116,105,111,110,0,0,0,0,0,0,0,0,84,67,86,0,0,0,0,0,69,110,101,114,103,121,0,0,72,79,85,0,0,0,0,0,102,116,0,0,0,0,0,0,82,111,117,103,104,110,101,115,115,0,0,0,0,0,0,0,83,116,97,116,117,115,0,0,81,117,97,108,105,116,121,0,67,117,114,118,101,0,0,0,71,80,86,0,0,0,0,0,80,97,116,116,101,114,110,0,69,109,105,116,116,101,114,0,77,65,88,67,72,69,67,75,0,0,0,0,0,0,0,0,76,69,86,69,76,0,0,0,83,111,117,114,99,101,0,0,67,72,69,67,75,70,82,69,81,0,0,0,0,0,0,0,32,32,32,32,78,117,109,98,101,114,32,111,102,32,84,97,110,107,115,32,46,46,46,46,46,46,46,46,46,46,46,46], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE);
/* memory initializer */ allocate([46,46,46,46,46,46,46,32,37,45,100,0,0,0,0,0,68,101,109,97,110,100,32,102,111,114,32,78,111,100,101,0,82,81,84,79,76,0,0,0,82,117,108,101,0,0,0,0,81,84,79,76,0,0,0,0,70,67,86,0,0,0,0,0,67,111,110,116,114,111,108,0,77,73,78,0,0,0,0,0,107,119,0,0,0,0,0,0,72,84,79,76,0,0,0,0,86,97,108,118,101,0,0,0,65,67,67,85,0,0,0,0,91,69,78,68,0,0,0,0,84,82,73,65,76,0,0,0,91,84,65,71,83,0,0,0,86,73,83,67,0,0,0,0,91,66,65,67,75,0,0,0,84,67,86,0,0,0,0,0,82,101,115,101,114,118,111,105,114,0,0,0,0,0,0,0,74,117,110,99,116,105,111,110,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,136,4,0,0,16,2,0,0,96,0,0,0,200,39,0,0,0,39,0,0,32,38,0,0,16,36,0,0,88,34,0,0,224,32,0,0,32,32,0,0,48,30,0,0,40,27,0,0,104,24,0,0,0,0,0,0,64,13,0,0,240,12,0,0,192,12,0,0,136,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,136,7,0,0,40,7,0,0,8,7,0,0,240,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,200,38,0,0,240,37,0,0,160,35,0,0,40,34,0,0,208,32,0,0,216,31,0,0,152,29,0,0,144,26,0,0,240,23,0,0,168,21,0,0,0,0,0,0,0,0,0,0,128,5,0,0,56,5,0,0,248,4,0,0,144,4,0,0,80,4,0,0,32,4,0,0,192,3,0,0,136,3,0,0,88,3,0,0,40,3,0,0,232,2,0,0,184,2,0,0,128,2,0,0,24,2,0,0,200,1,0,0,136,1,0,0,80,1,0,0,32,1,0,0,0,1,0,0,240,0,0,0,208,0,0,0,184,0,0,0,168,0,0,0,104,0,0,0,80,0,0,0,64,0,0,0,152,40,0,0,136,40,0,0,120,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,6,0,0,168,31,0,0,240,17,0,0,192,13,0,0,168,10,0,0,176,8,0,0,184,6,0,0,0,0,0,0,0,0,0,0,184,40,0,0,168,40,0,0,248,23,0,0,56,13,0,0,160,9,0,0,104,40,0,0,72,40,0,0,48,40,0,0,24,40,0,0,208,39,0,0,176,39,0,0,168,39,0,0,152,39,0,0,144,39,0,0,136,39,0,0,120,39,0,0,96,39,0,0,72,39,0,0,64,39,0,0,8,39,0,0,248,38,0,0,240,38,0,0,0,0,0,0,64,19,0,0,136,18,0,0,248,17,0,0,0,0,0,0,112,17,0,0,248,16,0,0,104,16,0,0,240,15,0,0,104,15,0,0,248,14,0,0,88,14,0,0,32,14,0,0,240,13,0,0,200,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,120,16,0,0,248,15,0,0,112,15,0,0,0,15,0,0,152,14,0,0,40,14,0,0,248,13,0,0,208,13,0,0,152,13,0,0,112,13,0,0,0,0,0,0,0,0,0,0,232,21,0,0,40,21,0,0,168,20,0,0,32,20,0,0,80,19,0,0,200,18,0,0,8,18,0,0,120,17,0,0,0,17,0,0,0,0,0,0,184,40,0,0,168,40,0,0,248,23,0,0,0,0,0,0,192,6,0,0,136,6,0,0,96,6,0,0,64,6,0,0,0,0,0,0,0,0,0,0,144,37,0,0,56,37,0,0,232,36,0,0,160,36,0,0,24,36,0,0,144,37,0,0,0,0,0,0,0,0,0,0,112,16,0,0,56,13,0,0,160,9,0,0,224,7,0,0,72,6,0,0,200,3,0,0,88,1,0,0,160,40,0,0,160,39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,38,0,0,176,38,0,0,168,38,0,0,152,38,0,0,144,39,0,0,136,38,0,0,112,38,0,0,104,38,0,0,40,38,0,0,16,38,0,0,144,39,0,0,8,38,0,0,232,37,0,0,72,39,0,0,216,37,0,0,240,44,0,0,240,44,0,0,240,44,0,0,240,44,0,0,240,44,0,0,240,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE+10240);



var tempDoublePtr = Runtime.alignMemory(allocate(12, "i8", ALLOC_STATIC), 8);

assert(tempDoublePtr % 8 == 0);

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

}

function copyTempDouble(ptr) {

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];

  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];

  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];

  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];

}


  function _writecon(t) {
          document.getElementById('status').innerHTML = Module.Pointer_stringify(t);
      }

   
  Module["_strlen"] = _strlen;

  
  
  
  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};
  
  var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};
  
  
  var ___errno_state=0;function ___setErrNo(value) {
      // For convenient setting and returning of errno.
      HEAP32[((___errno_state)>>2)]=value;
      return value;
    }
  
  var PATH={splitPath:function (filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function (parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up--; up) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function (path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function (path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function (path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function (path) {
        return PATH.splitPath(path)[3];
      },join:function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function (l, r) {
        return PATH.normalize(l + '/' + r);
      },resolve:function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            continue;
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function (from, to) {
        from = PATH.resolve(from).substr(1);
        to = PATH.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY={ttys:[],init:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function (stream) {
          // flush any pending line data
          if (stream.tty.output.length) {
            stream.tty.ops.put_char(stream.tty, 10);
          }
        },read:function (stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          for (var i = 0; i < length; i++) {
            try {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              result = process['stdin']['read']();
              if (!result) {
                if (process['stdin']['_readableState'] && process['stdin']['_readableState']['ended']) {
                  return null;  // EOF
                }
                return undefined;  // no data available
              }
            } else if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['print'](tty.output.join(''));
            tty.output = [];
          } else {
            tty.output.push(TTY.utf8.processCChar(val));
          }
        }},default_tty1_ops:{put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['printErr'](tty.output.join(''));
            tty.output = [];
          } else {
            tty.output.push(TTY.utf8.processCChar(val));
          }
        }}};
  
  var MEMFS={ops_table:null,CONTENT_OWNING:1,CONTENT_FLEXIBLE:2,CONTENT_FIXED:3,mount:function (mount) {
        return MEMFS.createNode(null, '/', 16384 | 0777, 0);
      },createNode:function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            },
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.contents = [];
          node.contentMode = MEMFS.CONTENT_FLEXIBLE;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },ensureFlexible:function (node) {
        if (node.contentMode !== MEMFS.CONTENT_FLEXIBLE) {
          var contents = node.contents;
          node.contents = Array.prototype.slice.call(contents);
          node.contentMode = MEMFS.CONTENT_FLEXIBLE;
        }
      },node_ops:{getattr:function (node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.contents.length;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.ensureFlexible(node);
            var contents = node.contents;
            if (attr.size < contents.length) contents.length = attr.size;
            else while (attr.size > contents.length) contents.push(0);
          }
        },lookup:function (parent, name) {
          throw FS.genericErrors[ERRNO_CODES.ENOENT];
        },mknod:function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function (old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function (parent, name) {
          delete parent.contents[name];
        },rmdir:function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
          }
          delete parent.contents[name];
        },readdir:function (node) {
          var entries = ['.', '..']
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 0777 | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return node.link;
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else
          {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          }
          return size;
        },write:function (stream, buffer, offset, length, position, canOwn) {
          var node = stream.node;
          node.timestamp = Date.now();
          var contents = node.contents;
          if (length && contents.length === 0 && position === 0 && buffer.subarray) {
            // just replace it with the new data
            if (canOwn && offset === 0) {
              node.contents = buffer; // this could be a subarray of Emscripten HEAP, or allocated from some other source.
              node.contentMode = (buffer.buffer === HEAP8.buffer) ? MEMFS.CONTENT_OWNING : MEMFS.CONTENT_FIXED;
            } else {
              node.contents = new Uint8Array(buffer.subarray(offset, offset+length));
              node.contentMode = MEMFS.CONTENT_FIXED;
            }
            return length;
          }
          MEMFS.ensureFlexible(node);
          var contents = node.contents;
          while (contents.length < position) contents.push(0);
          for (var i = 0; i < length; i++) {
            contents[position + i] = buffer[offset + i];
          }
          return length;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.contents.length;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          stream.ungotten = [];
          stream.position = position;
          return position;
        },allocate:function (stream, offset, length) {
          MEMFS.ensureFlexible(stream.node);
          var contents = stream.node.contents;
          var limit = offset + length;
          while (limit > contents.length) contents.push(0);
        },mmap:function (stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);
            }
            buffer.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        }}};
  
  var IDBFS={dbs:{},indexedDB:function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",mount:function (mount) {
        return MEMFS.mount.apply(null, arguments);
      },syncfs:function (mount, populate, callback) {
        IDBFS.getLocalSet(mount, function(err, local) {
          if (err) return callback(err);
  
          IDBFS.getRemoteSet(mount, function(err, remote) {
            if (err) return callback(err);
  
            var src = populate ? remote : local;
            var dst = populate ? local : remote;
  
            IDBFS.reconcile(src, dst, callback);
          });
        });
      },reconcile:function (src, dst, callback) {
        var total = 0;
  
        var create = {};
        for (var key in src.files) {
          if (!src.files.hasOwnProperty(key)) continue;
          var e = src.files[key];
          var e2 = dst.files[key];
          if (!e2 || e.timestamp > e2.timestamp) {
            create[key] = e;
            total++;
          }
        }
  
        var remove = {};
        for (var key in dst.files) {
          if (!dst.files.hasOwnProperty(key)) continue;
          var e = dst.files[key];
          var e2 = src.files[key];
          if (!e2) {
            remove[key] = e;
            total++;
          }
        }
  
        if (!total) {
          // early out
          return callback(null);
        }
  
        var completed = 0;
        function done(err) {
          if (err) return callback(err);
          if (++completed >= total) {
            return callback(null);
          }
        };
  
        // create a single transaction to handle and IDB reads / writes we'll need to do
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');
        transaction.onerror = function transaction_onerror() { callback(this.error); };
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
  
        for (var path in create) {
          if (!create.hasOwnProperty(path)) continue;
          var entry = create[path];
  
          if (dst.type === 'local') {
            // save file to local
            try {
              if (FS.isDir(entry.mode)) {
                FS.mkdir(path, entry.mode);
              } else if (FS.isFile(entry.mode)) {
                var stream = FS.open(path, 'w+', 0666);
                FS.write(stream, entry.contents, 0, entry.contents.length, 0, true /* canOwn */);
                FS.close(stream);
              }
              done(null);
            } catch (e) {
              return done(e);
            }
          } else {
            // save file to IDB
            var req = store.put(entry, path);
            req.onsuccess = function req_onsuccess() { done(null); };
            req.onerror = function req_onerror() { done(this.error); };
          }
        }
  
        for (var path in remove) {
          if (!remove.hasOwnProperty(path)) continue;
          var entry = remove[path];
  
          if (dst.type === 'local') {
            // delete file from local
            try {
              if (FS.isDir(entry.mode)) {
                // TODO recursive delete?
                FS.rmdir(path);
              } else if (FS.isFile(entry.mode)) {
                FS.unlink(path);
              }
              done(null);
            } catch (e) {
              return done(e);
            }
          } else {
            // delete file from IDB
            var req = store.delete(path);
            req.onsuccess = function req_onsuccess() { done(null); };
            req.onerror = function req_onerror() { done(this.error); };
          }
        }
      },getLocalSet:function (mount, callback) {
        var files = {};
  
        function isRealDir(p) {
          return p !== '.' && p !== '..';
        };
        function toAbsolute(root) {
          return function(p) {
            return PATH.join2(root, p);
          }
        };
  
        var check = FS.readdir(mount.mountpoint)
          .filter(isRealDir)
          .map(toAbsolute(mount.mountpoint));
  
        while (check.length) {
          var path = check.pop();
          var stat, node;
  
          try {
            var lookup = FS.lookupPath(path);
            node = lookup.node;
            stat = FS.stat(path);
          } catch (e) {
            return callback(e);
          }
  
          if (FS.isDir(stat.mode)) {
            check.push.apply(check, FS.readdir(path)
              .filter(isRealDir)
              .map(toAbsolute(path)));
  
            files[path] = { mode: stat.mode, timestamp: stat.mtime };
          } else if (FS.isFile(stat.mode)) {
            files[path] = { contents: node.contents, mode: stat.mode, timestamp: stat.mtime };
          } else {
            return callback(new Error('node type not supported'));
          }
        }
  
        return callback(null, { type: 'local', files: files });
      },getDB:function (name, callback) {
        // look it up in the cache
        var db = IDBFS.dbs[name];
        if (db) {
          return callback(null, db);
        }
        var req;
        try {
          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        req.onupgradeneeded = function req_onupgradeneeded() {
          db = req.result;
          db.createObjectStore(IDBFS.DB_STORE_NAME);
        };
        req.onsuccess = function req_onsuccess() {
          db = req.result;
          // add to the cache
          IDBFS.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = function req_onerror() {
          callback(this.error);
        };
      },getRemoteSet:function (mount, callback) {
        var files = {};
  
        IDBFS.getDB(mount.mountpoint, function(err, db) {
          if (err) return callback(err);
  
          var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');
          transaction.onerror = function transaction_onerror() { callback(this.error); };
  
          var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
          store.openCursor().onsuccess = function store_openCursor_onsuccess(event) {
            var cursor = event.target.result;
            if (!cursor) {
              return callback(null, { type: 'remote', db: db, files: files });
            }
  
            files[cursor.key] = cursor.value;
            cursor.continue();
          };
        });
      }};
  
  var NODEFS={isWindows:false,staticInit:function () {
        NODEFS.isWindows = !!process.platform.match(/^win/);
      },mount:function (mount) {
        assert(ENVIRONMENT_IS_NODE);
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);
      },createNode:function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },getMode:function (path) {
        var stat;
        try {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            // On Windows, directories return permission bits 'rw-rw-rw-', even though they have 'rwxrwxrwx', so 
            // propagate write bits to execute bits.
            stat.mode = stat.mode | ((stat.mode & 146) >> 1);
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return stat.mode;
      },realPath:function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:function (flags) {
        if (flags in NODEFS.flagsToPermissionStringMap) {
          return NODEFS.flagsToPermissionStringMap[flags];
        } else {
          return flags;
        }
      },node_ops:{getattr:function (node) {
          var path = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.
          // See http://support.microsoft.com/kb/140365
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },setattr:function (node, attr) {
          var path = NODEFS.realPath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },lookup:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },mknod:function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return node;
        },rename:function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },unlink:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },rmdir:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readdir:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },symlink:function (parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readlink:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        }},stream_ops:{open:function (stream) {
          var path = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },close:function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },read:function (stream, buffer, offset, length, position) {
          // FIXME this is terrible.
          var nbuffer = new Buffer(length);
          var res;
          try {
            res = fs.readSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          if (res > 0) {
            for (var i = 0; i < res; i++) {
              buffer[offset + i] = nbuffer[i];
            }
          }
          return res;
        },write:function (stream, buffer, offset, length, position) {
          // FIXME this is terrible.
          var nbuffer = new Buffer(buffer.subarray(offset, offset + length));
          var res;
          try {
            res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return res;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES[e.code]);
              }
            }
          }
  
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
  
          stream.position = position;
          return position;
        }}};
  
  var _stdin=allocate(1, "i32*", ALLOC_STATIC);
  
  var _stdout=allocate(1, "i32*", ALLOC_STATIC);
  
  var _stderr=allocate(1, "i32*", ALLOC_STATIC);
  
  function _fflush(stream) {
      // int fflush(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fflush.html
      // we don't currently perform any user-space buffering of data
    }var FS={root:null,mounts:[],devices:[null],streams:[null],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},handleFSError:function (e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return ___setErrNo(e.errno);
      },lookupPath:function (path, opts) {
        path = PATH.resolve(FS.cwd(), path);
        opts = opts || { recurse_count: 0 };
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            current = current.mount.root;
          }
  
          // follow symlinks
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH.resolve(PATH.dirname(current_path), link);
              
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function (node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function (parentid, name) {
        var hash = 0;
  
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function (parent, name) {
        var err = FS.mayLookup(parent);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function (parent, name, mode, rdev) {
        if (!FS.FSNode) {
          FS.FSNode = function(parent, name, mode, rdev) {
            this.id = FS.nextInode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
            this.parent = null;
            this.mount = null;
            if (!parent) {
              parent = this;  // root node sets parent to itself
            }
            this.parent = parent;
            this.mount = parent.mount;
            FS.hashAddNode(this);
          };
  
          // compatibility
          var readMode = 292 | 73;
          var writeMode = 146;
  
          FS.FSNode.prototype = {};
  
          // NOTE we must use Object.defineProperties instead of individual calls to
          // Object.defineProperty in order to make closure compiler happy
          Object.defineProperties(FS.FSNode.prototype, {
            read: {
              get: function() { return (this.mode & readMode) === readMode; },
              set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }
            },
            write: {
              get: function() { return (this.mode & writeMode) === writeMode; },
              set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }
            },
            isFolder: {
              get: function() { return FS.isDir(this.mode); },
            },
            isDevice: {
              get: function() { return FS.isChrdev(this.mode); },
            },
          });
        }
        return new FS.FSNode(parent, name, mode, rdev);
      },destroyNode:function (node) {
        FS.hashRemoveNode(node);
      },isRoot:function (node) {
        return node === node.parent;
      },isMountpoint:function (node) {
        return node.mounted;
      },isFile:function (mode) {
        return (mode & 61440) === 32768;
      },isDir:function (mode) {
        return (mode & 61440) === 16384;
      },isLink:function (mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function (mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function (mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function (mode) {
        return (mode & 61440) === 4096;
      },isSocket:function (mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function (str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function (flag) {
        var accmode = flag & 2097155;
        var perms = ['r', 'w', 'rw'][accmode];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function (node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return ERRNO_CODES.EACCES;
        }
        return 0;
      },mayLookup:function (dir) {
        return FS.nodePermissions(dir, 'x');
      },mayCreate:function (dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return ERRNO_CODES.EEXIST;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function (dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var err = FS.nodePermissions(dir, 'wx');
        if (err) {
          return err;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return ERRNO_CODES.ENOTDIR;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return ERRNO_CODES.EBUSY;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return 0;
      },mayOpen:function (node, flags) {
        if (!node) {
          return ERRNO_CODES.ENOENT;
        }
        if (FS.isLink(node.mode)) {
          return ERRNO_CODES.ELOOP;
        } else if (FS.isDir(node.mode)) {
          if ((flags & 2097155) !== 0 ||  // opening for write
              (flags & 512)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {
        fd_start = fd_start || 1;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);
      },getStream:function (fd) {
        return FS.streams[fd];
      },createStream:function (stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function(){};
          FS.FSStream.prototype = {};
          // compatibility
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          });
        }
        if (stream.__proto__) {
          // reuse the object
          stream.__proto__ = FS.FSStream.prototype;
        } else {
          var newStream = new FS.FSStream();
          for (var p in stream) {
            newStream[p] = stream[p];
          }
          stream = newStream;
        }
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function (fd) {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:function (stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function () {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }},major:function (dev) {
        return ((dev) >> 8);
      },minor:function (dev) {
        return ((dev) & 0xff);
      },makedev:function (ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function (dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function (dev) {
        return FS.devices[dev];
      },syncfs:function (populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        var completed = 0;
        var total = FS.mounts.length;
        function done(err) {
          if (err) {
            return callback(err);
          }
          if (++completed >= total) {
            callback(null);
          }
        };
  
        // sync all mounts
        for (var i = 0; i < FS.mounts.length; i++) {
          var mount = FS.mounts[i];
          if (!mount.type.syncfs) {
            done(null);
            continue;
          }
          mount.type.syncfs(mount, populate, done);
        }
      },mount:function (type, opts, mountpoint) {
        var lookup;
        if (mountpoint) {
          lookup = FS.lookupPath(mountpoint, { follow: false });
          mountpoint = lookup.path;  // use the absolute path
        }
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          root: null
        };
        // create a root node for the fs
        var root = type.mount(mount);
        root.mount = mount;
        mount.root = root;
        // assign the mount info to the mountpoint's node
        if (lookup) {
          lookup.node.mount = mount;
          lookup.node.mounted = true;
          // compatibility update FS.root if we mount to /
          if (mountpoint === '/') {
            FS.root = mount.root;
          }
        }
        // add to our cached list of mounts
        FS.mounts.push(mount);
        return root;
      },lookup:function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function (path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var err = FS.mayCreate(parent, name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function (path, mode) {
        mode = mode !== undefined ? mode : 0666;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function (path, mode) {
        mode = mode !== undefined ? mode : 0777;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdev:function (path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 0666;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function (oldpath, newpath) {
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        // new path should not be an ancestor of the old path
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        err = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          err = FS.nodePermissions(old_dir, 'w');
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },rmdir:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, true);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        return node.node_ops.readdir(node);
      },unlink:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, false);
        if (err) {
          // POSIX says unlink should set EPERM, not EISDIR
          if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:function (path) {
        var lookup = FS.lookupPath(path, { follow: false });
        var link = lookup.node;
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return link.node_ops.readlink(link);
      },stat:function (path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return node.node_ops.getattr(node);
      },lstat:function (path) {
        return FS.stat(path, true);
      },chmod:function (path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function (path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function (fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chmod(stream.node, mode);
      },chown:function (path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function (fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.nodePermissions(node, 'w');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function (fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        FS.truncate(stream.node, len);
      },utime:function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function (path, flags, mode, fd_start, fd_end) {
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 0666 : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
          }
        }
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // check permissions
        var err = FS.mayOpen(node, flags);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            Module['printErr']('read file: ' + path);
          }
        }
        return stream;
      },close:function (stream) {
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
      },llseek:function (stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        return stream.stream_ops.llseek(stream, offset, whence);
      },read:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function (stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        if (stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:function (stream, offset, length) {
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function (stream, buffer, offset, length, position, prot, flags) {
        // TODO if PROT is PROT_WRITE, make sure we have write access
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EACCES);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },ioctl:function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = '';
          var utf8 = new Runtime.UTF8Processor();
          for (var i = 0; i < length; i++) {
            ret += utf8.processCChar(buf[i]);
          }
        } else if (opts.encoding === 'binary') {
          ret = buf;
        } else {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        FS.close(stream);
        return ret;
      },writeFile:function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        opts.encoding = opts.encoding || 'utf8';
        var stream = FS.open(path, opts.flags, opts.mode);
        if (opts.encoding === 'utf8') {
          var utf8 = new Runtime.UTF8Processor();
          var buf = new Uint8Array(utf8.processJSString(data));
          FS.write(stream, buf, 0, buf.length, 0);
        } else if (opts.encoding === 'binary') {
          FS.write(stream, data, 0, data.length, 0);
        } else {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        FS.close(stream);
      },cwd:function () {
        return FS.currentPath;
      },chdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        var err = FS.nodePermissions(lookup.node, 'x');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function () {
        FS.mkdir('/tmp');
      },createDefaultDevices:function () {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function() { return 0; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createStandardStreams:function () {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        HEAP32[((_stdin)>>2)]=stdin.fd;
        assert(stdin.fd === 1, 'invalid handle for stdin (' + stdin.fd + ')');
  
        var stdout = FS.open('/dev/stdout', 'w');
        HEAP32[((_stdout)>>2)]=stdout.fd;
        assert(stdout.fd === 2, 'invalid handle for stdout (' + stdout.fd + ')');
  
        var stderr = FS.open('/dev/stderr', 'w');
        HEAP32[((_stderr)>>2)]=stderr.fd;
        assert(stderr.fd === 3, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:function () {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno) {
          this.errno = errno;
          for (var key in ERRNO_CODES) {
            if (ERRNO_CODES[key] === errno) {
              this.code = key;
              break;
            }
          }
          this.message = ERRNO_MESSAGES[errno];
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [ERRNO_CODES.ENOENT].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function () {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.root = FS.createNode(null, '/', 16384 | 0777, 0);
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
      },init:function (input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function () {
        FS.init.initialized = false;
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function (relative, base) {
        return PATH.resolve(base, relative);
      },standardizePath:function (path) {
        return PATH.normalize(path);
      },findObject:function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },analyzePath:function (path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function (parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function (parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function (parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function (parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
          function LazyUint8Array() {
            this.lengthKnown = false;
            this.chunks = []; // Loaded chunks. Index is the chunk number
          }
          LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
            if (idx > this.length-1 || idx < 0) {
              return undefined;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = Math.floor(idx / this.chunkSize);
            return this.getter(chunkNum)[chunkOffset];
          }
          LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          }
          LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
              // Find length
              var xhr = new XMLHttpRequest();
              xhr.open('HEAD', url, false);
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              var datalength = Number(xhr.getResponseHeader("Content-length"));
              var header;
              var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
              var chunkSize = 1024*1024; // Chunk size in bytes
  
              if (!hasByteServing) chunkSize = datalength;
  
              // Function to get a range from the remote URL.
              var doXHR = (function(from, to) {
                if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
                // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, false);
                if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
                // Some hints to the browser that we want binary data.
                if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
                if (xhr.overrideMimeType) {
                  xhr.overrideMimeType('text/plain; charset=x-user-defined');
                }
  
                xhr.send(null);
                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
                if (xhr.response !== undefined) {
                  return new Uint8Array(xhr.response || []);
                } else {
                  return intArrayFromString(xhr.responseText || '', true);
                }
              });
              var lazyArray = this;
              lazyArray.setDataGetter(function(chunkNum) {
                var start = chunkNum * chunkSize;
                var end = (chunkNum+1) * chunkSize - 1; // including this byte
                end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
                if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
                  lazyArray.chunks[chunkNum] = doXHR(start, end);
                }
                if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
                return lazyArray.chunks[chunkNum];
              });
  
              this._length = datalength;
              this._chunkSize = chunkSize;
              this.lengthKnown = true;
          }
  
          var lazyArray = new LazyUint8Array();
          Object.defineProperty(lazyArray, "length", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._length;
              }
          });
          Object.defineProperty(lazyArray, "chunkSize", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._chunkSize;
              }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn) {
        Browser.init();
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
        function processData(byteArray) {
          function finish(byteArray) {
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency('cp ' + fullname);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency('cp ' + fullname);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency('cp ' + fullname);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function () {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          console.log('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};function _close(fildes) {
      // int close(int fildes);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/close.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        FS.close(stream);
        return 0;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }
  
  function _fsync(fildes) {
      // int fsync(int fildes);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fsync.html
      var stream = FS.getStream(fildes);
      if (stream) {
        // We write directly to the file system, so there's nothing to do here.
        return 0;
      } else {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
    }function _fclose(stream) {
      // int fclose(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fclose.html
      _fsync(stream);
      return _close(stream);
    }

  
  function _unlink(path) {
      // int unlink(const char *path);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/unlink.html
      path = Pointer_stringify(path);
      try {
        FS.unlink(path);
        return 0;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }
  
  function _rmdir(path) {
      // int rmdir(const char *path);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/rmdir.html
      path = Pointer_stringify(path);
      try {
        FS.rmdir(path);
        return 0;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _remove(path) {
      // int remove(const char *path);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/remove.html
      var ret = _unlink(path);
      if (ret == -1) ret = _rmdir(path);
      return ret;
    }

  
  
  
  function __reallyNegative(x) {
      return x < 0 || (x === 0 && (1/x) === -Infinity);
    }function __formatString(format, varargs) {
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        if (type === 'double') {
          ret = HEAPF64[(((varargs)+(argIndex))>>3)];
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+8))>>2)]];
          argIndex += 8; // each 32-bit chunk is in a 64-bit block
  
        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
        }
        argIndex += Math.max(Runtime.getNativeFieldSize(type), Runtime.getAlignSize(type, null, true));
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[(textIndex)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)|0)];
        if (curr == 37) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          var flagPadSign = false;
          flagsLoop: while (1) {
            switch (next) {
              case 43:
                flagAlwaysSigned = true;
                break;
              case 45:
                flagLeftAlign = true;
                break;
              case 35:
                flagAlternative = true;
                break;
              case 48:
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              case 32:
                flagPadSign = true;
                break;
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          }
  
          // Handle width.
          var width = 0;
          if (next == 42) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          } else {
            while (next >= 48 && next <= 57) {
              width = width * 10 + (next - 48);
              textIndex++;
              next = HEAP8[((textIndex+1)|0)];
            }
          }
  
          // Handle precision.
          var precisionSet = false, precision = -1;
          if (next == 46) {
            precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
            if (next == 42) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[((textIndex+1)|0)];
                if (precisionChr < 48 ||
                    precisionChr > 57) break;
                precision = precision * 10 + (precisionChr - 48);
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)|0)];
          }
          if (precision === -1) {
            precision = 6; // Standard default.
            precisionSet = false;
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 104) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 108) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)|0)];
  
          // Handle type specifier.
          switch (String.fromCharCode(next)) {
            case 'd': case 'i': case 'u': case 'o': case 'x': case 'X': case 'p': {
              // Integer.
              var signed = next == 100 || next == 105;
              argSize = argSize || 4;
              var currArg = getNextArg('i' + (argSize * 8));
              var origArg = currArg;
              var argText;
              // Flatten i64-1 [low, high] into a (slightly rounded) double
              if (argSize == 8) {
                currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 117);
              }
              // Truncate to requested size.
              if (argSize <= 4) {
                var limit = Math.pow(256, argSize) - 1;
                currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
              }
              // Format the number.
              var currAbsArg = Math.abs(currArg);
              var prefix = '';
              if (next == 100 || next == 105) {
                if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], null); else
                argText = reSign(currArg, 8 * argSize, 1).toString(10);
              } else if (next == 117) {
                if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], true); else
                argText = unSign(currArg, 8 * argSize, 1).toString(10);
                currArg = Math.abs(currArg);
              } else if (next == 111) {
                argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
              } else if (next == 120 || next == 88) {
                prefix = (flagAlternative && currArg != 0) ? '0x' : '';
                if (argSize == 8 && i64Math) {
                  if (origArg[1]) {
                    argText = (origArg[1]>>>0).toString(16);
                    var lower = (origArg[0]>>>0).toString(16);
                    while (lower.length < 8) lower = '0' + lower;
                    argText += lower;
                  } else {
                    argText = (origArg[0]>>>0).toString(16);
                  }
                } else
                if (currArg < 0) {
                  // Represent negative numbers in hex as 2's complement.
                  currArg = -currArg;
                  argText = (currAbsArg - 1).toString(16);
                  var buffer = [];
                  for (var i = 0; i < argText.length; i++) {
                    buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                  }
                  argText = buffer.join('');
                  while (argText.length < argSize * 2) argText = 'f' + argText;
                } else {
                  argText = currAbsArg.toString(16);
                }
                if (next == 88) {
                  prefix = prefix.toUpperCase();
                  argText = argText.toUpperCase();
                }
              } else if (next == 112) {
                if (currAbsArg === 0) {
                  argText = '(nil)';
                } else {
                  prefix = '0x';
                  argText = currAbsArg.toString(16);
                }
              }
              if (precisionSet) {
                while (argText.length < precision) {
                  argText = '0' + argText;
                }
              }
  
              // Add sign if needed
              if (currArg >= 0) {
                if (flagAlwaysSigned) {
                  prefix = '+' + prefix;
                } else if (flagPadSign) {
                  prefix = ' ' + prefix;
                }
              }
  
              // Move sign to prefix so we zero-pad after the sign
              if (argText.charAt(0) == '-') {
                prefix = '-' + prefix;
                argText = argText.substr(1);
              }
  
              // Add padding.
              while (prefix.length + argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad) {
                    argText = '0' + argText;
                  } else {
                    prefix = ' ' + prefix;
                  }
                }
              }
  
              // Insert the result into the buffer.
              argText = prefix + argText;
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 'f': case 'F': case 'e': case 'E': case 'g': case 'G': {
              // Float.
              var currArg = getNextArg('double');
              var argText;
              if (isNaN(currArg)) {
                argText = 'nan';
                flagZeroPad = false;
              } else if (!isFinite(currArg)) {
                argText = (currArg < 0 ? '-' : '') + 'inf';
                flagZeroPad = false;
              } else {
                var isGeneral = false;
                var effectivePrecision = Math.min(precision, 20);
  
                // Convert g/G to f/F or e/E, as per:
                // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
                if (next == 103 || next == 71) {
                  isGeneral = true;
                  precision = precision || 1;
                  var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                  if (precision > exponent && exponent >= -4) {
                    next = ((next == 103) ? 'f' : 'F').charCodeAt(0);
                    precision -= exponent + 1;
                  } else {
                    next = ((next == 103) ? 'e' : 'E').charCodeAt(0);
                    precision--;
                  }
                  effectivePrecision = Math.min(precision, 20);
                }
  
                if (next == 101 || next == 69) {
                  argText = currArg.toExponential(effectivePrecision);
                  // Make sure the exponent has at least 2 digits.
                  if (/[eE][-+]\d$/.test(argText)) {
                    argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                  }
                } else if (next == 102 || next == 70) {
                  argText = currArg.toFixed(effectivePrecision);
                  if (currArg === 0 && __reallyNegative(currArg)) {
                    argText = '-' + argText;
                  }
                }
  
                var parts = argText.split('e');
                if (isGeneral && !flagAlternative) {
                  // Discard trailing zeros and periods.
                  while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                         (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                    parts[0] = parts[0].slice(0, -1);
                  }
                } else {
                  // Make sure we have a period in alternative mode.
                  if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                  // Zero pad until required precision.
                  while (precision > effectivePrecision++) parts[0] += '0';
                }
                argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
                // Capitalize 'E' if needed.
                if (next == 69) argText = argText.toUpperCase();
  
                // Add sign.
                if (currArg >= 0) {
                  if (flagAlwaysSigned) {
                    argText = '+' + argText;
                  } else if (flagPadSign) {
                    argText = ' ' + argText;
                  }
                }
              }
  
              // Add padding.
              while (argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                    argText = argText[0] + '0' + argText.slice(1);
                  } else {
                    argText = (flagZeroPad ? '0' : ' ') + argText;
                  }
                }
              }
  
              // Adjust case.
              if (next < 97) argText = argText.toUpperCase();
  
              // Insert the result into the buffer.
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 's': {
              // String.
              var arg = getNextArg('i8*');
              var argLength = arg ? _strlen(arg) : '(null)'.length;
              if (precisionSet) argLength = Math.min(argLength, precision);
              if (!flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              if (arg) {
                for (var i = 0; i < argLength; i++) {
                  ret.push(HEAPU8[((arg++)|0)]);
                }
              } else {
                ret = ret.concat(intArrayFromString('(null)'.substr(0, argLength), true));
              }
              if (flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              break;
            }
            case 'c': {
              // Character.
              if (flagLeftAlign) ret.push(getNextArg('i8'));
              while (--width > 0) {
                ret.push(32);
              }
              if (!flagLeftAlign) ret.push(getNextArg('i8'));
              break;
            }
            case 'n': {
              // Write the length written so far to the next parameter.
              var ptr = getNextArg('i32*');
              HEAP32[((ptr)>>2)]=ret.length;
              break;
            }
            case '%': {
              // Literal percent sign.
              ret.push(curr);
              break;
            }
            default: {
              // Unknown specifiers remain untouched.
              for (var i = startTextIndex; i < textIndex + 2; i++) {
                ret.push(HEAP8[(i)]);
              }
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _snprintf(s, n, format, varargs) {
      // int snprintf(char *restrict s, size_t n, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var limit = (n === undefined) ? result.length
                                    : Math.min(result.length, Math.max(n - 1, 0));
      if (s < 0) {
        s = -s;
        var buf = _malloc(limit+1);
        HEAP32[((s)>>2)]=buf;
        s = buf;
      }
      for (var i = 0; i < limit; i++) {
        HEAP8[(((s)+(i))|0)]=result[i];
      }
      if (limit < n || (n === undefined)) HEAP8[(((s)+(i))|0)]=0;
      return result.length;
    }function _sprintf(s, format, varargs) {
      // int sprintf(char *restrict s, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      return _snprintf(s, undefined, format, varargs);
    }

  
  function _open(path, oflag, varargs) {
      // int open(const char *path, int oflag, ...);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/open.html
      var mode = HEAP32[((varargs)>>2)];
      path = Pointer_stringify(path);
      try {
        var stream = FS.open(path, oflag, mode);
        return stream.fd;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fopen(filename, mode) {
      // FILE *fopen(const char *restrict filename, const char *restrict mode);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fopen.html
      var flags;
      mode = Pointer_stringify(mode);
      if (mode[0] == 'r') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 0;
        }
      } else if (mode[0] == 'w') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 1;
        }
        flags |= 64;
        flags |= 512;
      } else if (mode[0] == 'a') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 1;
        }
        flags |= 64;
        flags |= 1024;
      } else {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return 0;
      }
      var ret = _open(filename, flags, allocate([0x1FF, 0, 0, 0], 'i32', ALLOC_STACK));  // All creation permissions.
      return (ret == -1) ? 0 : ret;
    }

  
  function _lseek(fildes, offset, whence) {
      // off_t lseek(int fildes, off_t offset, int whence);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/lseek.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        return FS.llseek(stream, offset, whence);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fseek(stream, offset, whence) {
      // int fseek(FILE *stream, long offset, int whence);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fseek.html
      var ret = _lseek(stream, offset, whence);
      if (ret == -1) {
        return -1;
      }
      stream = FS.getStream(stream);
      stream.eof = false;
      return 0;
    }

  
  
  
  
  var _mkport=undefined;var SOCKFS={mount:function (mount) {
        return FS.createNode(null, '/', 16384 | 0777, 0);
      },createSocket:function (family, type, protocol) {
        var streaming = type == 1;
        if (protocol) {
          assert(streaming == (protocol == 6)); // if SOCK_STREAM, must be tcp
        }
  
        // create our internal socket structure
        var sock = {
          family: family,
          type: type,
          protocol: protocol,
          server: null,
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };
  
        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;
  
        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node: node,
          flags: FS.modeStringToFlags('r+'),
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });
  
        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;
  
        return sock;
      },getSocket:function (fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },stream_ops:{poll:function (stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },ioctl:function (stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },read:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },write:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },close:function (stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        }},nextname:function () {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },websocket_sock_ops:{createPeer:function (sock, addr, port) {
          var ws;
  
          if (typeof addr === 'object') {
            ws = addr;
            addr = null;
            port = null;
          }
  
          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              var url = 'ws://' + addr + ':' + port;
              // the node ws library API is slightly different than the browser's
              var opts = ENVIRONMENT_IS_NODE ? {headers: {'websocket-protocol': ['binary']}} : ['binary'];
              // If node we use the ws library.
              var WebSocket = ENVIRONMENT_IS_NODE ? require('ws') : window['WebSocket'];
              ws = new WebSocket(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH);
            }
          }
  
  
          var peer = {
            addr: addr,
            port: port,
            socket: ws,
            dgram_send_queue: []
          };
  
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
  
          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport !== 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }
  
          return peer;
        },getPeer:function (sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },addPeer:function (sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },removePeer:function (sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },handlePeerEvents:function (sock, peer) {
          var first = true;
  
          var handleOpen = function () {
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };
  
          function handleMessage(data) {
            assert(typeof data !== 'string' && data.byteLength !== undefined);  // must receive an ArrayBuffer
            data = new Uint8Array(data);  // make a typed array view on the array buffer
  
  
            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }
  
            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
          };
  
          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, flags) {
              if (!flags.binary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('error', function() {
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
          }
        },poll:function (sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }
  
          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;
  
          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }
  
          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }
  
          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }
  
          return mask;
        },ioctl:function (sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)]=bytes;
              return 0;
            default:
              return ERRNO_CODES.EINVAL;
          }
        },close:function (sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },bind:function (sock, addr, port) {
          if (typeof sock.saddr !== 'undefined' || typeof sock.sport !== 'undefined') {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port || _mkport();
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e instanceof FS.ErrnoError)) throw e;
              if (e.errno !== ERRNO_CODES.EOPNOTSUPP) throw e;
            }
          }
        },connect:function (sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(ERRNO_CODS.EOPNOTSUPP);
          }
  
          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }
  
          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr !== 'undefined' && typeof sock.dport !== 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(ERRNO_CODES.EALREADY);
              } else {
                throw new FS.ErrnoError(ERRNO_CODES.EISCONN);
              }
            }
          }
  
          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;
  
          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS);
        },listen:function (sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
          if (sock.server) {
             throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already listening
          }
          var WebSocketServer = require('ws').Server;
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host: host,
            port: sock.sport
            // TODO support backlog
          });
  
          sock.server.on('connection', function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
  
              // create a peer on the new socket
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;
  
              // push to queue for accept to pick up
              sock.pending.push(newsock);
            } else {
              // create a peer on the listen socket so calling sendto
              // with the listen socket and an address will resolve
              // to the correct client
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            }
          });
          sock.server.on('closed', function() {
            sock.server = null;
          });
          sock.server.on('error', function() {
            // don't throw
          });
        },accept:function (listensock) {
          if (!listensock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },getname:function (sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr, port: port };
        },sendmsg:function (sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }
  
          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
  
          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }
  
          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          var data;
          if (buffer instanceof Array || buffer instanceof ArrayBuffer) {
            data = buffer.slice(offset, offset + length);
          } else {  // ArrayBufferView
            data = buffer.buffer.slice(buffer.byteOffset + offset, buffer.byteOffset + offset + length);
          }
  
          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }
  
          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
        },recvmsg:function (sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
          }
  
          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
  
              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
              }
              else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              else {
                // else, our socket is in a valid state but truly has nothing available
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
            } else {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }
  
          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };
  
  
          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }
  
          return res;
        }}};function _send(fd, buf, len, flags) {
      var sock = SOCKFS.getSocket(fd);
      if (!sock) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      // TODO honor flags
      return _write(fd, buf, len);
    }
  
  function _pwrite(fildes, buf, nbyte, offset) {
      // ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte, offset);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _write(fildes, buf, nbyte) {
      // ssize_t write(int fildes, const void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
  
  
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fputc(c, stream) {
      // int fputc(int c, FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputc.html
      var chr = unSign(c & 0xFF);
      HEAP8[((_fputc.ret)|0)]=chr;
      var ret = _write(stream, _fputc.ret, 1);
      if (ret == -1) {
        var streamObj = FS.getStream(stream);
        if (streamObj) streamObj.error = true;
        return -1;
      } else {
        return chr;
      }
    }

   
  Module["_strncpy"] = _strncpy;

   
  Module["_strcpy"] = _strcpy;

  
  function _strncmp(px, py, n) {
      var i = 0;
      while (i < n) {
        var x = HEAPU8[(((px)+(i))|0)];
        var y = HEAPU8[(((py)+(i))|0)];
        if (x == y && x == 0) return 0;
        if (x == 0) return -1;
        if (y == 0) return 1;
        if (x == y) {
          i ++;
          continue;
        } else {
          return x > y ? 1 : -1;
        }
      }
      return 0;
    }function _strcmp(px, py) {
      return _strncmp(px, py, TOTAL_MEMORY);
    }

  var _llvm_pow_f64=Math_pow;

  var _sqrt=Math_sqrt;

  function _fwrite(ptr, size, nitems, stream) {
      // size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fwrite.html
      var bytesToWrite = nitems * size;
      if (bytesToWrite == 0) return 0;
      var bytesWritten = _write(stream, ptr, bytesToWrite);
      if (bytesWritten == -1) {
        var streamObj = FS.getStream(stream);
        if (streamObj) streamObj.error = true;
        return 0;
      } else {
        return Math.floor(bytesWritten / size);
      }
    }

  
  
  function _recv(fd, buf, len, flags) {
      var sock = SOCKFS.getSocket(fd);
      if (!sock) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      // TODO honor flags
      return _read(fd, buf, len);
    }
  
  function _pread(fildes, buf, nbyte, offset) {
      // ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/read.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        var slab = HEAP8;
        return FS.read(stream, slab, buf, nbyte, offset);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _read(fildes, buf, nbyte) {
      // ssize_t read(int fildes, void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/read.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
  
  
      try {
        var slab = HEAP8;
        return FS.read(stream, slab, buf, nbyte);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fread(ptr, size, nitems, stream) {
      // size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fread.html
      var bytesToRead = nitems * size;
      if (bytesToRead == 0) {
        return 0;
      }
      var bytesRead = 0;
      var streamObj = FS.getStream(stream);
      if (!streamObj) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return 0;
      }
      while (streamObj.ungotten.length && bytesToRead > 0) {
        HEAP8[((ptr++)|0)]=streamObj.ungotten.pop();
        bytesToRead--;
        bytesRead++;
      }
      var err = _read(stream, ptr, bytesToRead);
      if (err == -1) {
        if (streamObj) streamObj.error = true;
        return 0;
      }
      bytesRead += err;
      if (bytesRead < bytesToRead) streamObj.eof = true;
      return Math.floor(bytesRead / size);
    }

  function _ftell(stream) {
      // long ftell(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/ftell.html
      stream = FS.getStream(stream);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      if (FS.isChrdev(stream.node.mode)) {
        ___setErrNo(ERRNO_CODES.ESPIPE);
        return -1;
      } else {
        return stream.position;
      }
    }

  
  function _creat(path, mode) {
      // int creat(const char *path, mode_t mode);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/creat.html
      return _open(path, 1 | 64 | 512, allocate([mode, 0, 0, 0], 'i32', ALLOC_STACK));
    }
  
  function _mktemp(template) {
      if (!_mktemp.counter) _mktemp.counter = 0;
      var c = (_mktemp.counter++).toString();
      var rep = 'XXXXXX';
      while (c.length < rep.length) c = '0' + c;
      writeArrayToMemory(intArrayFromString(c), template + Pointer_stringify(template).indexOf(rep));
      return template;
    }function _mkstemp(template) {
      return _creat(_mktemp(template), 0600);
    }

  
   
  Module["_memcpy"] = _memcpy;var _llvm_memcpy_p0i8_p0i8_i32=_memcpy;

  
   
  Module["_memset"] = _memset;var _llvm_memset_p0i8_i32=_memset;

  var _log=Math_log;

  var _fabs=Math_abs;

  function _rewind(stream) {
      // void rewind(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/rewind.html
      _fseek(stream, 0, 0);  // SEEK_SET.
      var streamObj = FS.getStream(stream);
      if (streamObj) streamObj.error = false;
    }

  
  function _fgetc(stream) {
      // int fgetc(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fgetc.html
      var streamObj = FS.getStream(stream);
      if (!streamObj) return -1;
      if (streamObj.eof || streamObj.error) return -1;
      var ret = _fread(_fgetc.ret, 1, 1, stream);
      if (ret == 0) {
        return -1;
      } else if (ret == -1) {
        streamObj.error = true;
        return -1;
      } else {
        return HEAPU8[((_fgetc.ret)|0)];
      }
    }function _fgets(s, n, stream) {
      // char *fgets(char *restrict s, int n, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fgets.html
      var streamObj = FS.getStream(stream);
      if (!streamObj) return 0;
      if (streamObj.error || streamObj.eof) return 0;
      var byte_;
      for (var i = 0; i < n - 1 && byte_ != 10; i++) {
        byte_ = _fgetc(stream);
        if (byte_ == -1) {
          if (streamObj.error || (streamObj.eof && i == 0)) return 0;
          else if (streamObj.eof) break;
        }
        HEAP8[(((s)+(i))|0)]=byte_;
      }
      HEAP8[(((s)+(i))|0)]=0;
      return s;
    }

  
  var ___strtok_state=0;
  
  function _strtok_r(s, delim, lasts) {
      var skip_leading_delim = 1;
      var spanp;
      var c, sc;
      var tok;
  
  
      if (s == 0 && (s = getValue(lasts, 'i8*')) == 0) {
        return 0;
      }
  
      cont: while (1) {
        c = getValue(s++, 'i8');
        for (spanp = delim; (sc = getValue(spanp++, 'i8')) != 0;) {
          if (c == sc) {
            if (skip_leading_delim) {
              continue cont;
            } else {
              setValue(lasts, s, 'i8*');
              setValue(s - 1, 0, 'i8');
              return s - 1;
            }
          }
        }
        break;
      }
  
      if (c == 0) {
        setValue(lasts, 0, 'i8*');
        return 0;
      }
      tok = s - 1;
  
      for (;;) {
        c = getValue(s++, 'i8');
        spanp = delim;
        do {
          if ((sc = getValue(spanp++, 'i8')) == c) {
            if (c == 0) {
              s = 0;
            } else {
              setValue(s - 1, 0, 'i8');
            }
            setValue(lasts, s, 'i8*');
            return tok;
          }
        } while (sc != 0);
      }
    }function _strtok(s, delim) {
      return _strtok_r(s, delim, ___strtok_state);
    }

  function _fprintf(stream, format, varargs) {
      // int fprintf(FILE *restrict stream, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var stack = Runtime.stackSave();
      var ret = _fwrite(allocate(result, 'i8', ALLOC_STACK), 1, result.length, stream);
      Runtime.stackRestore(stack);
      return ret;
    }

   
  Module["_strcat"] = _strcat;

  function _fputs(s, stream) {
      // int fputs(const char *restrict s, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputs.html
      return _write(stream, s, _strlen(s));
    }

  function _strchr(ptr, chr) {
      ptr--;
      do {
        ptr++;
        var val = HEAP8[(ptr)];
        if (val == chr) return ptr;
      } while (val);
      return 0;
    }

  function _strcspn(pstr, pset) {
      var str = pstr, set, strcurr, setcurr;
      while (1) {
        strcurr = HEAP8[(str)];
        if (!strcurr) return str - pstr;
        set = pset;
        while (1) {
          setcurr = HEAP8[(set)];
          if (!setcurr || setcurr == strcurr) break;
          set++;
        }
        if (setcurr) return str - pstr;
        str++;
      }
    }

  
  
  
  
  function _isspace(chr) {
      return (chr == 32) || (chr >= 9 && chr <= 13);
    }function __parseInt(str, endptr, base, min, max, bits, unsign) {
      // Skip space.
      while (_isspace(HEAP8[(str)])) str++;
  
      // Check for a plus/minus sign.
      var multiplier = 1;
      if (HEAP8[(str)] == 45) {
        multiplier = -1;
        str++;
      } else if (HEAP8[(str)] == 43) {
        str++;
      }
  
      // Find base.
      var finalBase = base;
      if (!finalBase) {
        if (HEAP8[(str)] == 48) {
          if (HEAP8[((str+1)|0)] == 120 ||
              HEAP8[((str+1)|0)] == 88) {
            finalBase = 16;
            str += 2;
          } else {
            finalBase = 8;
            str++;
          }
        }
      } else if (finalBase==16) {
        if (HEAP8[(str)] == 48) {
          if (HEAP8[((str+1)|0)] == 120 ||
              HEAP8[((str+1)|0)] == 88) {
            str += 2;
          }
        }
      }
      if (!finalBase) finalBase = 10;
  
      // Get digits.
      var chr;
      var ret = 0;
      while ((chr = HEAP8[(str)]) != 0) {
        var digit = parseInt(String.fromCharCode(chr), finalBase);
        if (isNaN(digit)) {
          break;
        } else {
          ret = ret * finalBase + digit;
          str++;
        }
      }
  
      // Apply sign.
      ret *= multiplier;
  
      // Set end pointer.
      if (endptr) {
        HEAP32[((endptr)>>2)]=str;
      }
  
      // Unsign if needed.
      if (unsign) {
        if (Math.abs(ret) > max) {
          ret = max;
          ___setErrNo(ERRNO_CODES.ERANGE);
        } else {
          ret = unSign(ret, bits);
        }
      }
  
      // Validate range.
      if (ret > max || ret < min) {
        ret = ret > max ? max : min;
        ___setErrNo(ERRNO_CODES.ERANGE);
      }
  
      if (bits == 64) {
        return ((asm["setTempRet0"]((tempDouble=ret,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)),ret>>>0)|0);
      }
  
      return ret;
    }function _strtol(str, endptr, base) {
      return __parseInt(str, endptr, base, -2147483648, 2147483647, 32);  // LONG_MIN, LONG_MAX.
    }function _atoi(ptr) {
      return _strtol(ptr, null, 10);
    }var _atol=_atoi;


  var _llvm_memset_p0i8_i64=_memset;

  function _time(ptr) {
      var ret = Math.floor(Date.now()/1000);
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret;
      }
      return ret;
    }

  
  
  var ___tm_current=allocate(44, "i8", ALLOC_STATIC);
  
  
  var ___tm_timezone=allocate(intArrayFromString("GMT"), "i8", ALLOC_STATIC);
  
  
  var _tzname=allocate(8, "i32*", ALLOC_STATIC);
  
  var _daylight=allocate(1, "i32*", ALLOC_STATIC);
  
  var _timezone=allocate(1, "i32*", ALLOC_STATIC);function _tzset() {
      // TODO: Use (malleable) environment variables instead of system settings.
      if (_tzset.called) return;
      _tzset.called = true;
  
      HEAP32[((_timezone)>>2)]=-(new Date()).getTimezoneOffset() * 60;
  
      var winter = new Date(2000, 0, 1);
      var summer = new Date(2000, 6, 1);
      HEAP32[((_daylight)>>2)]=Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());
  
      var winterName = 'GMT'; // XXX do not rely on browser timezone info, it is very unpredictable | winter.toString().match(/\(([A-Z]+)\)/)[1];
      var summerName = 'GMT'; // XXX do not rely on browser timezone info, it is very unpredictable | summer.toString().match(/\(([A-Z]+)\)/)[1];
      var winterNamePtr = allocate(intArrayFromString(winterName), 'i8', ALLOC_NORMAL);
      var summerNamePtr = allocate(intArrayFromString(summerName), 'i8', ALLOC_NORMAL);
      HEAP32[((_tzname)>>2)]=winterNamePtr;
      HEAP32[(((_tzname)+(4))>>2)]=summerNamePtr;
    }function _localtime_r(time, tmPtr) {
      _tzset();
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)]=date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)]=date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)]=date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)]=date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)]=date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)]=date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();
  
      var start = new Date(date.getFullYear(), 0, 1);
      var yday = Math.floor((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
      HEAP32[(((tmPtr)+(36))>>2)]=start.getTimezoneOffset() * 60;
  
      var dst = Number(start.getTimezoneOffset() != date.getTimezoneOffset());
      HEAP32[(((tmPtr)+(32))>>2)]=dst;
  
      HEAP32[(((tmPtr)+(40))>>2)]=___tm_timezone;
  
      return tmPtr;
    }function _localtime(time) {
      return _localtime_r(time, ___tm_current);
    }
  
  
  var ___tm_formatted=allocate(44, "i8", ALLOC_STATIC);
  
  
  function _mktime(tmPtr) {
      _tzset();
      var year = HEAP32[(((tmPtr)+(20))>>2)];
      var timestamp = new Date(year >= 1900 ? year : year + 1900,
                               HEAP32[(((tmPtr)+(16))>>2)],
                               HEAP32[(((tmPtr)+(12))>>2)],
                               HEAP32[(((tmPtr)+(8))>>2)],
                               HEAP32[(((tmPtr)+(4))>>2)],
                               HEAP32[((tmPtr)>>2)],
                               0).getTime() / 1000;
      HEAP32[(((tmPtr)+(24))>>2)]=new Date(timestamp).getDay();
      var yday = Math.round((timestamp - (new Date(year, 0, 1)).getTime()) / (1000 * 60 * 60 * 24));
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
      return timestamp;
    }function _asctime_r(tmPtr, buf) {
      var date = new Date(_mktime(tmPtr)*1000);
      var formatted = date.toString();
      var datePart = formatted.replace(/\d{4}.*/, '').replace(/ 0/, '  ');
      var timePart = formatted.match(/\d{2}:\d{2}:\d{2}/)[0];
      formatted = datePart + timePart + ' ' + date.getFullYear() + '\n';
      formatted.split('').forEach(function(chr, index) {
        HEAP8[(((buf)+(index))|0)]=chr.charCodeAt(0);
      });
      HEAP8[(((buf)+(25))|0)]=0;
      return buf;
    }function _asctime(tmPtr) {
      return _asctime_r(tmPtr, ___tm_formatted);
    }function _ctime(timer) {
      return _asctime(_localtime(timer));
    }

  function _abort() {
      Module['abort']();
    }

  function ___errno_location() {
      return ___errno_state;
    }

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
      // We control the "dynamic" memory - DYNAMIC_BASE to DYNAMICTOP
      var self = _sbrk;
      if (!self.called) {
        DYNAMICTOP = alignMemoryPage(DYNAMICTOP); // make sure we start out aligned
        self.called = true;
        assert(Runtime.dynamicAlloc);
        self.alloc = Runtime.dynamicAlloc;
        Runtime.dynamicAlloc = function() { abort('cannot dynamically allocate, sbrk now has control') };
      }
      var ret = DYNAMICTOP;
      if (bytes != 0) self.alloc(bytes);
      return ret;  // Previous break location.
    }

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 30: return PAGE_SIZE;
        case 132:
        case 133:
        case 12:
        case 137:
        case 138:
        case 15:
        case 235:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 149:
        case 13:
        case 10:
        case 236:
        case 153:
        case 9:
        case 21:
        case 22:
        case 159:
        case 154:
        case 14:
        case 77:
        case 78:
        case 139:
        case 80:
        case 81:
        case 79:
        case 82:
        case 68:
        case 67:
        case 164:
        case 11:
        case 29:
        case 47:
        case 48:
        case 95:
        case 52:
        case 51:
        case 46:
          return 200809;
        case 27:
        case 246:
        case 127:
        case 128:
        case 23:
        case 24:
        case 160:
        case 161:
        case 181:
        case 182:
        case 242:
        case 183:
        case 184:
        case 243:
        case 244:
        case 245:
        case 165:
        case 178:
        case 179:
        case 49:
        case 50:
        case 168:
        case 169:
        case 175:
        case 170:
        case 171:
        case 172:
        case 97:
        case 76:
        case 32:
        case 173:
        case 35:
          return -1;
        case 176:
        case 177:
        case 7:
        case 155:
        case 8:
        case 157:
        case 125:
        case 126:
        case 92:
        case 93:
        case 129:
        case 130:
        case 131:
        case 94:
        case 91:
          return 1;
        case 74:
        case 60:
        case 69:
        case 70:
        case 4:
          return 1024;
        case 31:
        case 42:
        case 72:
          return 32;
        case 87:
        case 26:
        case 33:
          return 2147483647;
        case 34:
        case 1:
          return 47839;
        case 38:
        case 36:
          return 99;
        case 43:
        case 37:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 28: return 32768;
        case 44: return 32767;
        case 75: return 16384;
        case 39: return 1000;
        case 89: return 700;
        case 71: return 256;
        case 40: return 255;
        case 2: return 100;
        case 180: return 64;
        case 25: return 20;
        case 5: return 16;
        case 6: return 6;
        case 73: return 4;
        case 84: return 1;
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }


  
  function _copysign(a, b) {
      return __reallyNegative(a) === __reallyNegative(b) ? a : -a;
    }var _copysignl=_copysign;

  
  function _fmod(x, y) {
      return x % y;
    }var _fmodl=_fmod;

  function _llvm_lifetime_start() {}

  function _llvm_lifetime_end() {}






  var Browser={mainLoop:{scheduler:null,shouldPause:false,paused:false,queue:[],pause:function () {
          Browser.mainLoop.shouldPause = true;
        },resume:function () {
          if (Browser.mainLoop.paused) {
            Browser.mainLoop.paused = false;
            Browser.mainLoop.scheduler();
          }
          Browser.mainLoop.shouldPause = false;
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        }},isFullScreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function () {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers
  
        if (Browser.initted || ENVIRONMENT_IS_WORKER) return;
        Browser.initted = true;
  
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            Browser.safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
  
        // Canvas event setup
  
        var canvas = Module['canvas'];
        canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                    canvas['mozRequestPointerLock'] ||
                                    canvas['webkitRequestPointerLock'];
        canvas.exitPointerLock = document['exitPointerLock'] ||
                                 document['mozExitPointerLock'] ||
                                 document['webkitExitPointerLock'] ||
                                 function(){}; // no-op if function does not exist
        canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas;
        }
  
        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
  
        if (Module['elementPointerLock']) {
          canvas.addEventListener("click", function(ev) {
            if (!Browser.pointerLock && canvas.requestPointerLock) {
              canvas.requestPointerLock();
              ev.preventDefault();
            }
          }, false);
        }
      },createContext:function (canvas, useWebGL, setInModule, webGLContextAttributes) {
        var ctx;
        try {
          if (useWebGL) {
            var contextAttributes = {
              antialias: false,
              alpha: false
            };
  
            if (webGLContextAttributes) {
              for (var attribute in webGLContextAttributes) {
                contextAttributes[attribute] = webGLContextAttributes[attribute];
              }
            }
  
  
            var errorInfo = '?';
            function onContextCreationError(event) {
              errorInfo = event.statusMessage || errorInfo;
            }
            canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);
            try {
              ['experimental-webgl', 'webgl'].some(function(webglId) {
                return ctx = canvas.getContext(webglId, contextAttributes);
              });
            } finally {
              canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, false);
            }
          } else {
            ctx = canvas.getContext('2d');
          }
          if (!ctx) throw ':(';
        } catch (e) {
          Module.print('Could not create canvas: ' + [errorInfo, e]);
          return null;
        }
        if (useWebGL) {
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";
  
          // Warn on context loss
          canvas.addEventListener('webglcontextlost', function(event) {
            alert('WebGL context lost. You will need to reload the page.');
          }, false);
        }
        if (setInModule) {
          GLctx = Module.ctx = ctx;
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function (canvas, useWebGL, setInModule) {},fullScreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullScreen:function (lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;
  
        var canvas = Module['canvas'];
        function fullScreenChange() {
          Browser.isFullScreen = false;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement']) === canvas) {
            canvas.cancelFullScreen = document['cancelFullScreen'] ||
                                      document['mozCancelFullScreen'] ||
                                      document['webkitCancelFullScreen'];
            canvas.cancelFullScreen = canvas.cancelFullScreen.bind(document);
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullScreen = true;
            if (Browser.resizeCanvas) Browser.setFullScreenCanvasSize();
          } else if (Browser.resizeCanvas){
            Browser.setWindowedCanvasSize();
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullScreen);
        }
  
        if (!Browser.fullScreenHandlersInstalled) {
          Browser.fullScreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullScreenChange, false);
          document.addEventListener('mozfullscreenchange', fullScreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
        }
  
        canvas.requestFullScreen = canvas['requestFullScreen'] ||
                                   canvas['mozRequestFullScreen'] ||
                                   (canvas['webkitRequestFullScreen'] ? function() { canvas['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
        canvas.requestFullScreen();
      },requestAnimationFrame:function requestAnimationFrame(func) {
        if (typeof window === 'undefined') { // Provide fallback to setTimeout if window is undefined (e.g. in Node.js)
          setTimeout(func, 1000/60);
        } else {
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                           window['mozRequestAnimationFrame'] ||
                                           window['webkitRequestAnimationFrame'] ||
                                           window['msRequestAnimationFrame'] ||
                                           window['oRequestAnimationFrame'] ||
                                           window['setTimeout'];
          }
          window.requestAnimationFrame(func);
        }
      },safeCallback:function (func) {
        return function() {
          if (!ABORT) return func.apply(null, arguments);
        };
      },safeRequestAnimationFrame:function (func) {
        return Browser.requestAnimationFrame(function() {
          if (!ABORT) func();
        });
      },safeSetTimeout:function (func, timeout) {
        return setTimeout(function() {
          if (!ABORT) func();
        }, timeout);
      },safeSetInterval:function (func, timeout) {
        return setInterval(function() {
          if (!ABORT) func();
        }, timeout);
      },getMimetype:function (name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function (func) {
        if(!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,calculateMouseEvent:function (event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
          
          // check if SDL is available
          if (typeof SDL != "undefined") {
          	Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
          	Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
          	// just add the mouse delta to the current absolut mouse position
          	// FIXME: ideally this should be clamped against the canvas size and zero
          	Browser.mouseX += Browser.mouseMovementX;
          	Browser.mouseY += Browser.mouseMovementY;
          }        
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var x, y;
          
          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);
          if (event.type == 'touchstart' ||
              event.type == 'touchend' ||
              event.type == 'touchmove') {
            var t = event.touches.item(0);
            if (t) {
              x = t.pageX - (scrollX + rect.left);
              y = t.pageY - (scrollY + rect.top);
            } else {
              return;
            }
          } else {
            x = event.pageX - (scrollX + rect.left);
            y = event.pageY - (scrollY + rect.top);
          }
  
          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
  
          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function xhr_onload() {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror, noRunDep) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (!noRunDep) removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (!noRunDep) addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        canvas.width = width;
        canvas.height = height;
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullScreenCanvasSize:function () {
        var canvas = Module['canvas'];
        this.windowedWidth = canvas.width;
        this.windowedHeight = canvas.height;
        canvas.width = screen.width;
        canvas.height = screen.height;
        // check if SDL is available   
        if (typeof SDL != "undefined") {
        	var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
        	flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
        	HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function () {
        var canvas = Module['canvas'];
        canvas.width = this.windowedWidth;
        canvas.height = this.windowedHeight;
        // check if SDL is available       
        if (typeof SDL != "undefined") {
        	var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
        	flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
        	HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      }};
FS.staticInit();__ATINIT__.unshift({ func: function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() } });__ATMAIN__.push({ func: function() { FS.ignorePermissions = false } });__ATEXIT__.push({ func: function() { FS.quit() } });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;
___errno_state = Runtime.staticAlloc(4); HEAP32[((___errno_state)>>2)]=0;
__ATINIT__.unshift({ func: function() { TTY.init() } });__ATEXIT__.push({ func: function() { TTY.shutdown() } });TTY.utf8 = new Runtime.UTF8Processor();
if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); NODEFS.staticInit(); }
_fputc.ret = allocate([0], "i8", ALLOC_STATIC);
__ATINIT__.push({ func: function() { SOCKFS.root = FS.mount(SOCKFS, {}, null); } });
_fgetc.ret = allocate([0], "i8", ALLOC_STATIC);
___strtok_state = Runtime.staticAlloc(4);
Module["requestFullScreen"] = function Module_requestFullScreen(lockPointer, resizeCanvas) { Browser.requestFullScreen(lockPointer, resizeCanvas) };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);

staticSealed = true; // seal the static portion of memory

STACK_MAX = STACK_BASE + 5242880;

DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);

assert(DYNAMIC_BASE < TOTAL_MEMORY, "TOTAL_MEMORY not big enough for stack");

 var ctlz_i8 = allocate([8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_DYNAMIC);
 var cttz_i8 = allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0], "i8", ALLOC_DYNAMIC);

var Math_min = Math.min;
function invoke_iiii(index,a1,a2,a3) {
  try {
    return Module["dynCall_iiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vi(index,a1) {
  try {
    Module["dynCall_vi"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_ii(index,a1) {
  try {
    return Module["dynCall_ii"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_v(index) {
  try {
    Module["dynCall_v"](index);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  try {
    return Module["dynCall_iii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function asmPrintInt(x, y) {
  Module.print('int ' + x + ',' + y);// + ' ' + new Error().stack);
}
function asmPrintFloat(x, y) {
  Module.print('float ' + x + ',' + y);// + ' ' + new Error().stack);
}
// EMSCRIPTEN_START_ASM
var asm = (function(global, env, buffer) {
  'use asm';
  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);

  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;
  var cttz_i8=env.cttz_i8|0;
  var ctlz_i8=env.ctlz_i8|0;
  var _stdout=env._stdout|0;
  var NaN=+env.NaN;
  var Infinity=+env.Infinity;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;

  var tempRet0 = 0;
  var tempRet1 = 0;
  var tempRet2 = 0;
  var tempRet3 = 0;
  var tempRet4 = 0;
  var tempRet5 = 0;
  var tempRet6 = 0;
  var tempRet7 = 0;
  var tempRet8 = 0;
  var tempRet9 = 0;
  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var abort=env.abort;
  var assert=env.assert;
  var asmPrintInt=env.asmPrintInt;
  var asmPrintFloat=env.asmPrintFloat;
  var Math_min=env.min;
  var invoke_iiii=env.invoke_iiii;
  var invoke_vi=env.invoke_vi;
  var invoke_ii=env.invoke_ii;
  var invoke_v=env.invoke_v;
  var invoke_iii=env.invoke_iii;
  var _strncmp=env._strncmp;
  var _lseek=env._lseek;
  var _tzset=env._tzset;
  var _snprintf=env._snprintf;
  var _fgetc=env._fgetc;
  var _fread=env._fread;
  var _fclose=env._fclose;
  var _strtok_r=env._strtok_r;
  var _ctime=env._ctime;
  var _sbrk=env._sbrk;
  var _abort=env._abort;
  var _fprintf=env._fprintf;
  var _sqrt=env._sqrt;
  var _pread=env._pread;
  var _fgets=env._fgets;
  var _close=env._close;
  var _fflush=env._fflush;
  var _fopen=env._fopen;
  var _open=env._open;
  var _mktemp=env._mktemp;
  var _fputc=env._fputc;
  var _strtol=env._strtol;
  var _creat=env._creat;
  var _fabs=env._fabs;
  var _strtok=env._strtok;
  var ___setErrNo=env.___setErrNo;
  var __reallyNegative=env.__reallyNegative;
  var _sysconf=env._sysconf;
  var _fseek=env._fseek;
  var _send=env._send;
  var _write=env._write;
  var _fputs=env._fputs;
  var _ftell=env._ftell;
  var _rmdir=env._rmdir;
  var _llvm_lifetime_end=env._llvm_lifetime_end;
  var _writecon=env._writecon;
  var _mkstemp=env._mkstemp;
  var _isspace=env._isspace;
  var _sprintf=env._sprintf;
  var _strchr=env._strchr;
  var _fmod=env._fmod;
  var _mktime=env._mktime;
  var _strcspn=env._strcspn;
  var _read=env._read;
  var _copysign=env._copysign;
  var _rewind=env._rewind;
  var __formatString=env.__formatString;
  var _localtime_r=env._localtime_r;
  var _atoi=env._atoi;
  var _asctime_r=env._asctime_r;
  var _unlink=env._unlink;
  var _recv=env._recv;
  var _log=env._log;
  var _pwrite=env._pwrite;
  var _llvm_pow_f64=env._llvm_pow_f64;
  var _fsync=env._fsync;
  var ___errno_location=env.___errno_location;
  var _asctime=env._asctime;
  var _remove=env._remove;
  var _llvm_lifetime_start=env._llvm_lifetime_start;
  var _time=env._time;
  var __parseInt=env.__parseInt;
  var _fwrite=env._fwrite;
  var _localtime=env._localtime;
  var _strcmp=env._strcmp;
  var tempFloat = 0.0;

// EMSCRIPTEN_START_FUNCS
function stackAlloc(size) {
  size = size|0;
  var ret = 0;
  ret = STACKTOP;
  STACKTOP = (STACKTOP + size)|0;
STACKTOP = (STACKTOP + 7)&-8;
  return ret|0;
}
function stackSave() {
  return STACKTOP|0;
}
function stackRestore(top) {
  top = top|0;
  STACKTOP = top;
}
function setThrew(threw, value) {
  threw = threw|0;
  value = value|0;
  if ((__THREW__|0) == 0) {
    __THREW__ = threw;
    threwValue = value;
  }
}
function copyTempFloat(ptr) {
  ptr = ptr|0;
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1|0] = HEAP8[ptr+1|0];
  HEAP8[tempDoublePtr+2|0] = HEAP8[ptr+2|0];
  HEAP8[tempDoublePtr+3|0] = HEAP8[ptr+3|0];
}
function copyTempDouble(ptr) {
  ptr = ptr|0;
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1|0] = HEAP8[ptr+1|0];
  HEAP8[tempDoublePtr+2|0] = HEAP8[ptr+2|0];
  HEAP8[tempDoublePtr+3|0] = HEAP8[ptr+3|0];
  HEAP8[tempDoublePtr+4|0] = HEAP8[ptr+4|0];
  HEAP8[tempDoublePtr+5|0] = HEAP8[ptr+5|0];
  HEAP8[tempDoublePtr+6|0] = HEAP8[ptr+6|0];
  HEAP8[tempDoublePtr+7|0] = HEAP8[ptr+7|0];
}

function setTempRet0(value) {
  value = value|0;
  tempRet0 = value;
}

function setTempRet1(value) {
  value = value|0;
  tempRet1 = value;
}

function setTempRet2(value) {
  value = value|0;
  tempRet2 = value;
}

function setTempRet3(value) {
  value = value|0;
  tempRet3 = value;
}

function setTempRet4(value) {
  value = value|0;
  tempRet4 = value;
}

function setTempRet5(value) {
  value = value|0;
  tempRet5 = value;
}

function setTempRet6(value) {
  value = value|0;
  tempRet6 = value;
}

function setTempRet7(value) {
  value = value|0;
  tempRet7 = value;
}

function setTempRet8(value) {
  value = value|0;
  tempRet8 = value;
}

function setTempRet9(value) {
  value = value|0;
  tempRet9 = value;
}
function runPostSets() {


}

function _main($argc,$argv){
 $argc=($argc)|0;
 $argv=($argv)|0;
 var $blank=0,$1=0,$2=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$f3_0=0,$14=0,$15=0,$18=0,$19=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $blank=((sp)|0);
 $1=(($blank)|0);
 HEAP8[($1)]=0;
 $2=($argc|0)<3;
 if ($2) {
  _writecon(((9168)|0));
  STACKTOP=sp;return ((0)|0);
 }
 $5=(($argv+4)|0);
 $6=((HEAP32[(($5)>>2)])|0);
 $7=(($argv+8)|0);
 $8=((HEAP32[(($7)>>2)])|0);
 $9=($argc|0)>3;
 if ($9) {
  $11=(($argv+12)|0);
  $12=((HEAP32[(($11)>>2)])|0);
  $f3_0=$12;
 } else {
  $f3_0=$1;
 }

 _writecon(((9128)|0));
 $14=((_ENepanet($6,$8,$f3_0,0))|0);
 $15=($14|0)>0;
 if ($15) {
  _writecon(((9072)|0));
  STACKTOP=sp;return ((0)|0);
 }
 $18=((HEAP8[(12008)])|0);
 $19=(($18<<24)>>24)>0;
 if ($19) {
  _writecon(((9024)|0));
  STACKTOP=sp;return ((0)|0);
 } else {
  _writecon(((8992)|0));
  STACKTOP=sp;return ((0)|0);
 }
}


function _ENepanet($f1,$f2,$f3,$pviewprog){
 $f1=($f1)|0;
 $f2=($f2)|0;
 $f3=($f3)|0;
 $pviewprog=($pviewprog)|0;
 var $1=0,$2=0,$3=0,$4=0,$or_cond=0,$6=0,$errcode_0=0,$8=0,$10=0,$11=0,$13=0,$14=0,$15=0,label=0;

 HEAP32[((11432)>>2)]=$pviewprog;
 $1=((_ENopen($f1,$f2,$f3))|0);
 $2=((HEAP8[(15288)])|0);
 $3=(($2<<24)>>24)==0;
 $4=($1|0)>100;
 $or_cond=$3|$4;
 if ($or_cond) {
  $errcode_0=$1;
 } else {
  $6=((_ENsolveH())|0);
  $errcode_0=$6;
 }

 $8=($errcode_0|0)>100;
 do {
  if ($8) {
   $14=$errcode_0;
  } else {
   $10=((_ENsolveQ())|0);
   $11=($10|0)>100;
   if ($11) {
    $14=$10;
    break;
   }
   $13=((_ENreport())|0);
   $14=$13;
  }
 } while(0);

 $15=((_ENclose())|0);
 return (($14)|0);
}


function _ENopen($f1,$f2,$f3){
 $f1=($f1)|0;
 $f2=($f2)|0;
 $f3=($f3)|0;
 var $strlenfirst=0,$1=0,$4=0,$5=0,$8=0,$9=0,$11=0,$12=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$or_cond=0,$22=0,$errcode_0=0,$24=0,$26=0;
 var $27=0,$_0=0,label=0;

 HEAP8[(14296)]=0;
 HEAP8[(14312)]=0;
 HEAP8[(14304)]=0;
 HEAP8[(13224)]=0;
 HEAP8[(13216)]=0;
 HEAP8[(12008)]=0;
 HEAP8[(14568)]=1;
 HEAP8[(13288)]=0;
 $strlenfirst=((HEAP8[($f3)])|0);
 $1=(($strlenfirst<<24)>>24)==0;
 if ($1) {
  HEAP8[(13288)]=1;
 }
 HEAP8[(13288)]=1;
 _initpointers();
 $4=((_openfiles($f1,$f2,$f3))|0);
 $5=($4|0)>0;
 if ($5) {
  _errmsg($4);
  $_0=$4;

  return (($_0)|0);
 }
 _writelogo();
 _writecon(((8952)|0));
 $8=((_netsize())|0);
 $9=($8|0)>100;
 do {
  if ($9) {
   $15=$8;
  } else {
   $11=((_allocdata())|0);
   $12=($11|0)>100;
   if ($12) {
    $15=$11;
    break;
   }
   $14=((_getdata())|0);
   $15=$14;
  }
 } while(0);

 $16=((HEAP32[((13952)>>2)])|0);
 _freeTmplist($16);
 $17=((HEAP32[((17640)>>2)])|0);
 _freeTmplist($17);
 $18=((HEAP8[(15288)])|0);
 $19=(($18<<24)>>24)!=0;
 $20=($15|0)>100;
 $or_cond=$19|$20;
 if ($or_cond) {
  $errcode_0=$15;
 } else {
  $22=((_openhydfile())|0);
  $errcode_0=$22;
 }

 $24=($errcode_0|0)==0;
 if (!($24)) {
  _errmsg($errcode_0);
  $_0=$errcode_0;

  return (($_0)|0);
 }
 $26=((HEAP8[(13184)])|0);
 $27=(($26<<24)>>24)==0;
 if (!($27)) {
  _writesummary();
 }
 _writetime(8912);
 HEAP8[(14296)]=1;
 $_0=$errcode_0;

 return (($_0)|0);
}


function _ENsolveH(){
 var $t=0,$tstep=0,$1=0,$2=0,$4=0,$5=0,$errcode_0=0,$6=0,$7=0,$8=0,$9=0,$10=0,$12=0,$13=0,$15=0,$16=0,$17=0,$18=0,$errcode_1=0,$19=0;
 var $20=0,$21=0,$22=0,$_errcode_1=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $t=((sp)|0);
 $tstep=(((sp)+(8))|0);
 $1=((_ENopenH())|0);
 $2=($1|0)==0;
 do {
  if ($2) {
   $4=((_ENinitH(1))|0);
   _writecon(((8800)|0));
   $5=($4|0)==0;
   if ($5) {
    $errcode_0=0;
   } else {
    $errcode_1=$4;
    break;
   }
   while(1) {

    $6=((HEAP32[((15576)>>2)])|0);
    $7=((_clocktime(17744,$6))|0);
    $8=((_sprintf(((14488)|0),((8784)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$7,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    _writecon(((14488)|0));
    $9=((_sprintf(((14488)|0),((8752)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=17744,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    HEAP32[(($tstep)>>2)]=0;
    $10=($errcode_0|0)>100;
    do {
     if ($10) {
      $16=$errcode_0;
     } else {
      $12=((_ENrunH($t))|0);
      $13=($12|0)>100;
      if ($13) {
       $16=$12;
       break;
      }
      $15=((_ENnextH($tstep))|0);
      $16=$15;
     }
    } while(0);

    _writecon(((8728)|0));
    $17=((HEAP32[(($tstep)>>2)])|0);
    $18=($17|0)>0;
    if ($18) {
     $errcode_0=$16;
    } else {
     $errcode_1=$16;
     break;
    }
   }
  } else {
   $errcode_1=$1;
  }
 } while(0);

 _writecon(((8696)|0));
 $19=((_ENcloseH())|0);
 $20=((HEAP8[(12008)])|0);
 $21=(($20<<24)>>24);
 $22=($errcode_1|0)<($21|0);
 $_errcode_1=($22?$21:$errcode_1);
 STACKTOP=sp;return (($_errcode_1)|0);
}


function _ENsolveQ(){
 var $t=0,$tstep=0,$1=0,$2=0,$4=0,$5=0,$6=0,$10=0,$errcode_0=0,$11=0,$12=0,$13=0,$14=0,$15=0,$17=0,$19=0,$21=0,$22=0,$24=0,$25=0;
 var $26=0,$27=0,$errcode_1=0,$28=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $t=((sp)|0);
 $tstep=(((sp)+(8))|0);
 $1=((_ENopenQ())|0);
 $2=($1|0)==0;
 if (!($2)) {
  $errcode_1=$1;

  _writecon(((8696)|0));
  $28=((_ENcloseQ())|0);
  STACKTOP=sp;return (($errcode_1)|0);
 }
 $4=((_ENinitQ(1))|0);
 $5=((HEAP8[(13856)])|0);
 $6=(($5<<24)>>24)==0;
 if ($6) {
  _writecon(((8608)|0));
 } else {
  _writecon(((8648)|0));
 }
 $10=($4|0)==0;
 if ($10) {
  $errcode_0=0;
 } else {
  $errcode_1=$4;

  _writecon(((8696)|0));
  $28=((_ENcloseQ())|0);
  STACKTOP=sp;return (($errcode_1)|0);
 }
 while(1) {

  $11=((HEAP32[((15576)>>2)])|0);
  $12=((_clocktime(17744,$11))|0);
  $13=((_sprintf(((14488)|0),((8784)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$12,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writecon(((14488)|0));
  $14=((HEAP8[(13856)])|0);
  $15=(($14<<24)>>24)==0;
  if (!($15)) {
   $17=((_sprintf(((14488)|0),((8480)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=17744,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  }
  HEAP32[(($tstep)>>2)]=0;
  $19=($errcode_0|0)>100;
  do {
   if ($19) {
    $25=$errcode_0;
   } else {
    $21=((_ENrunQ($t))|0);
    $22=($21|0)>100;
    if ($22) {
     $25=$21;
     break;
    }
    $24=((_ENnextQ($tstep))|0);
    $25=$24;
   }
  } while(0);

  _writecon(((8728)|0));
  $26=((HEAP32[(($tstep)>>2)])|0);
  $27=($26|0)>0;
  if ($27) {
   $errcode_0=$25;
  } else {
   $errcode_1=$25;
   break;
  }
 }

 _writecon(((8696)|0));
 $28=((_ENcloseQ())|0);
 STACKTOP=sp;return (($errcode_1)|0);
}


function _ENreport(){
 var $1=0,$2=0,$4=0,$5=0,$_0=0,label=0;

 $1=((HEAP8[(13216)])|0);
 $2=(($1<<24)>>24)==0;
 do {
  if ($2) {
   $_0=106;
  } else {
   $4=((_writereport())|0);
   $5=($4|0)==0;
   if ($5) {
    $_0=0;
    break;
   }
   _errmsg($4);
   $_0=$4;
  }
 } while(0);

 return (($_0)|0);
}


function _ENclose(){
 var $1=0,$2=0,$5=0,$6=0,$7=0,$9=0,$11=0,$13=0,$15=0,$16=0,$18=0,$20=0,$21=0,$23=0,$25=0,$26=0,$28=0,$30=0,$31=0,$33=0;
 var $35=0,$36=0,$38=0,$40=0,$41=0,$43=0,label=0;

 $1=((HEAP8[(14296)])|0);
 $2=(($1<<24)>>24)==0;
 if (!($2)) {
  _writetime(8888);
 }
 _freedata();
 $5=((HEAP32[((12392)>>2)])|0);
 $6=((HEAP32[((14280)>>2)])|0);
 $7=($5|0)==($6|0);
 if (!($7)) {
  $9=($5|0)==0;
  if (!($9)) {
   $11=((_fclose((($5)|0)))|0);
  }
  $13=((_remove(((12400)|0)))|0);
 }
 $15=((HEAP32[((15272)>>2)])|0);
 $16=($15|0)==0;
 if (!($16)) {
  $18=((_fclose((($15)|0)))|0);
 }
 $20=((HEAP32[((13296)>>2)])|0);
 $21=($20|0)==0;
 if (!($21)) {
  $23=((_fclose((($20)|0)))|0);
 }
 $25=((HEAP32[((15568)>>2)])|0);
 $26=($25|0)==0;
 if (!($26)) {
  $28=((_fclose((($25)|0)))|0);
 }
 $30=((HEAP32[((14280)>>2)])|0);
 $31=($30|0)==0;
 if (!($31)) {
  $33=((_fclose((($30)|0)))|0);
 }
 $35=((HEAP8[(15288)])|0);
 $36=(($35<<24)>>24)==2;
 if ($36) {
  $38=((_remove(((15304)|0)))|0);
 }
 $40=((HEAP8[(13984)])|0);
 $41=(($40<<24)>>24)==2;
 if (!($41)) {
  HEAP8[(14296)]=0;
  HEAP8[(14312)]=0;
  HEAP8[(13224)]=0;
  HEAP8[(14304)]=0;
  HEAP8[(13216)]=0;
  return ((0)|0);
 }
 $43=((_remove(((14016)|0)))|0);
 HEAP8[(14296)]=0;
 HEAP8[(14312)]=0;
 HEAP8[(13224)]=0;
 HEAP8[(14304)]=0;
 HEAP8[(13216)]=0;
 return ((0)|0);
}


function _initpointers(){
 var label=0;

 HEAP32[((17632)>>2)]=0;
 HEAP32[((17736)>>2)]=0;
 HEAP32[((15600)>>2)]=0;
 HEAP32[((13880)>>2)]=0;
 HEAP32[((13848)>>2)]=0;
 HEAP32[((13232)>>2)]=0;
 HEAP32[((15000)>>2)]=0;
 HEAP32[((14320)>>2)]=0;
 HEAP32[((14408)>>2)]=0;
 HEAP32[((14960)>>2)]=0;
 HEAP32[((13176)>>2)]=0;
 HEAP32[((13888)>>2)]=0;
 HEAP32[((12024)>>2)]=0;
 HEAP32[((13944)>>2)]=0;
 HEAP32[((17648)>>2)]=0;
 HEAP32[((17656)>>2)]=0;
 HEAP32[((12000)>>2)]=0;
 HEAP32[((13952)>>2)]=0;
 HEAP32[((17640)>>2)]=0;
 HEAP32[((17776)>>2)]=0;
 HEAP32[((17768)>>2)]=0;
 HEAP32[((17760)>>2)]=0;
 HEAP32[((17504)>>2)]=0;
 HEAP32[((13976)>>2)]=0;
 HEAP32[((11984)>>2)]=0;
 HEAP32[((14288)>>2)]=0;
 HEAP32[((13832)>>2)]=0;
 HEAP32[((14448)>>2)]=0;
 HEAP32[((11992)>>2)]=0;
 HEAP32[((14480)>>2)]=0;
 HEAP32[((14992)>>2)]=0;
 HEAP32[((14440)>>2)]=0;
 HEAP32[((14976)>>2)]=0;
 _initrules();
 return;
}


function _openfiles($f1,$f2,$f3){
 $f1=($f1)|0;
 $f2=($f2)|0;
 $f3=($f3)|0;
 var $1=0,$2=0,$3=0,$strlenfirst=0,$4=0,$_=0,$5=0,$6=0,$8=0,$9=0,$11=0,$12=0,$15=0,$16=0,$strlenfirst15=0,$19=0,$21=0,$23=0,$24=0,$_0=0;
 var label=0;

 HEAP32[((15272)>>2)]=0;
 HEAP32[((13296)>>2)]=0;
 HEAP32[((14280)>>2)]=0;
 HEAP32[((15568)>>2)]=0;
 $1=((_strncpy(((15008)|0),(($f1)|0),((259)|0)))|0);
 $2=((_strncpy(((13568)|0),(($f2)|0),((259)|0)))|0);
 $3=((_strncpy(((14016)|0),(($f3)|0),((259)|0)))|0);
 $strlenfirst=((HEAP8[($f3)])|0);
 $4=(($strlenfirst<<24)>>24)==0;
 $_=($4?2:1);
 HEAP8[(13984)]=$_;
 $5=((_strcomp($f1,$f2))|0);
 $6=($5|0)==0;
 do {
  if ($6) {
   $8=((_strcomp($f1,$f3))|0);
   $9=($8|0)==0;
   if (!($9)) {
    break;
   }
   $11=((_strcomp($f2,$f3))|0);
   $12=($11|0)==0;
   if (!($12)) {
    break;
   }
   $15=((_fopen((($f1)|0),((8232)|0)))|0);
   HEAP32[((15272)>>2)]=$15;
   $16=($15|0)==0;
   if ($16) {
    _writecon(((8192)|0));
    _writecon((($f1)|0));
    $_0=302;

    return (($_0)|0);
   }
   $strlenfirst15=((HEAP8[($f2)])|0);
   $19=(($strlenfirst15<<24)>>24)==0;
   if ($19) {
    $21=((HEAP32[((_stdout)>>2)])|0);
    HEAP32[((13296)>>2)]=$21;
    $_0=0;

    return (($_0)|0);
   }
   $23=((_fopen((($f2)|0),((8184)|0)))|0);
   HEAP32[((13296)>>2)]=$23;
   $24=($23|0)==0;
   if (!($24)) {
    $_0=0;

    return (($_0)|0);
   }
   _writecon(((8120)|0));
   $_0=303;

   return (($_0)|0);
  }
 } while(0);
 _writecon(((8288)|0));
 $_0=301;

 return (($_0)|0);
}


function _errmsg($errcode){
 $errcode=($errcode)|0;
 var $1=0,$3=0,$5=0,$6=0,$7=0,$8=0,$or_cond=0,$10=0,label=0;

 $1=($errcode|0)==309;
 if ($1) {
  _writecon(((5600)|0));
  $3=((_geterrmsg($errcode))|0);
  _writecon(((14488)|0));
  return;
 }
 $5=((HEAP32[((13296)>>2)])|0);
 $6=($5|0)==0;
 $7=((HEAP8[(14568)])|0);
 $8=(($7<<24)>>24)==0;
 $or_cond=$6|$8;
 if ($or_cond) {
  return;
 }
 $10=((_geterrmsg($errcode))|0);
 _writeline(14488);
 return;
}


function _allocdata(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$7=0,$8=0,$10=0,$11=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$21=0,$22=0,$23=0;
 var $24=0,$25=0,$27=0,$28=0,$29=0,$31=0,$32=0,$34=0,$35=0,$36=0,$38=0,$39=0,$40=0,$42=0,$43=0,$44=0,$45=0,$46=0,$47=0,$48=0;
 var $49=0,$50=0,$51=0,$52=0,$53=0,$55=0,$56=0,$57=0,$59=0,$60=0,$62=0,$63=0,$64=0,$65=0,$66=0,$67=0,$69=0,$70=0,$71=0,$72=0;
 var $73=0,$74=0,$75=0,$76=0,$77=0,$78=0,$79=0,$80=0,$81=0,$82=0,$83=0,$84=0,$85=0,$86=0,$87=0,$88=0,$89=0,$90=0,$91=0,$92=0;
 var $93=0,$94=0,$95=0,$97=0,$98=0,$99=0,$101=0,$102=0,$104=0,$105=0,$106=0,$108=0,$109=0,$110=0,$112=0,$113=0,$115=0,$116=0,$117=0,$119=0;
 var $120=0,$121=0,$errcode_2=0,$122=0,$123=0,$124=0,$125=0,$126=0,$n_074=0,$127=0,$128=0,$129=0,$130=0,$131=0,$132=0,$133=0,$134=0,$135=0,$n_171=0,$136=0;
 var $137=0,$138=0,$139=0,$140=0,$141=0,$142=0,$143=0,$144=0,$145=0,$146=0,$n_269=0,$147=0,$148=0,$149=0,$150=0,$151=0,$153=0,$errcode_3=0,label=0;

 $1=((_HTcreate())|0);
 HEAP32[((14440)>>2)]=$1;
 $2=((_HTcreate())|0);
 HEAP32[((14976)>>2)]=$2;
 $3=((HEAP32[((14440)>>2)])|0);
 $4=($3|0)==0;
 $5=($4?101:0);
 if ($4) {
  $10=$5;
 } else {
  $7=($2|0)==0;
  $8=($7?101:0);
  $10=$8;
 }

 $11=($10|0)==0;
 if (!($11)) {
  $errcode_3=$10;

  return (($errcode_3)|0);
 }
 $13=((HEAP32[((14624)>>2)])|0);
 $14=((($13)+(1))|0);
 $15=((_calloc($14,72))|0);
 $16=$15;
 HEAP32[((14408)>>2)]=$16;
 $17=((_calloc($14,8))|0);
 $18=$17;
 HEAP32[((17632)>>2)]=$18;
 $19=((_calloc($14,8))|0);
 $20=$19;
 HEAP32[((17736)>>2)]=$20;
 $21=((_calloc($14,8))|0);
 $22=$21;
 HEAP32[((15600)>>2)]=$22;
 $23=((HEAP32[((14408)>>2)])|0);
 $24=($23|0)==0;
 $25=($24?101:0);
 if ($24) {
  $31=$25;
 } else {
  $27=((HEAP32[((17632)>>2)])|0);
  $28=($27|0)==0;
  $29=($28?101:0);
  $31=$29;
 }

 $32=($31|0)==101;
 if ($32) {
  $errcode_3=101;

  return (($errcode_3)|0);
 }
 $34=((HEAP32[((17736)>>2)])|0);
 $35=($34|0)==0;
 $36=($35?101:0);
 if ($35) {
  $errcode_3=$36;

  return (($errcode_3)|0);
 }
 $38=((HEAP32[((15600)>>2)])|0);
 $39=($38|0)==0;
 $40=($39?101:0);
 do {
  if ($39) {
   $errcode_2=$40;
  } else {
   $42=((HEAP32[((14632)>>2)])|0);
   $43=((($42)+(1))|0);
   $44=((_calloc($43,104))|0);
   $45=$44;
   HEAP32[((14960)>>2)]=$45;
   $46=((_calloc($43,8))|0);
   $47=$46;
   HEAP32[((13880)>>2)]=$47;
   $48=((_calloc($43,8))|0);
   $49=$48;
   HEAP32[((15000)>>2)]=$49;
   $50=((_calloc($43,1))|0);
   HEAP32[((13232)>>2)]=$50;
   $51=((HEAP32[((14960)>>2)])|0);
   $52=($51|0)==0;
   $53=($52?101:0);
   if ($52) {
    $59=$53;
   } else {
    $55=((HEAP32[((13880)>>2)])|0);
    $56=($55|0)==0;
    $57=($56?101:0);
    $59=$57;
   }

   $60=($59|0)==101;
   if ($60) {
    $errcode_3=101;

    return (($errcode_3)|0);
   }
   $62=((HEAP32[((15000)>>2)])|0);
   $63=($62|0)==0;
   $64=($63?101:0);
   if ($63) {
    $errcode_2=$64;
    break;
   }
   $65=((HEAP32[((13232)>>2)])|0);
   $66=($65|0)==0;
   $67=($66?101:0);
   if ($66) {
    $errcode_3=$67;

    return (($errcode_3)|0);
   }
   $69=((HEAP32[((14584)>>2)])|0);
   $70=((($69)+(1))|0);
   $71=((_calloc($70,112))|0);
   $72=$71;
   HEAP32[((13176)>>2)]=$72;
   $73=((HEAP32[((14600)>>2)])|0);
   $74=((($73)+(1))|0);
   $75=((_calloc($74,128))|0);
   $76=$75;
   HEAP32[((13888)>>2)]=$76;
   $77=((HEAP32[((14576)>>2)])|0);
   $78=((($77)+(1))|0);
   $79=((_calloc($78,4))|0);
   $80=$79;
   HEAP32[((12024)>>2)]=$80;
   $81=((HEAP32[((14664)>>2)])|0);
   $82=((($81)+(1))|0);
   $83=((_calloc($82,40))|0);
   $84=$83;
   HEAP32[((17656)>>2)]=$84;
   $85=((HEAP32[((14616)>>2)])|0);
   $86=((($85)+(1))|0);
   $87=((_calloc($86,40))|0);
   $88=$87;
   HEAP32[((13944)>>2)]=$88;
   $89=((HEAP32[((14656)>>2)])|0);
   $90=((($89)+(1))|0);
   $91=((_calloc($90,48))|0);
   $92=$91;
   HEAP32[((17648)>>2)]=$92;
   $93=((HEAP32[((13176)>>2)])|0);
   $94=($93|0)==0;
   $95=($94?101:0);
   if ($94) {
    $101=$95;
   } else {
    $97=((HEAP32[((13888)>>2)])|0);
    $98=($97|0)==0;
    $99=($98?101:0);
    $101=$99;
   }

   $102=($101|0)==101;
   if ($102) {
    $errcode_3=101;

    return (($errcode_3)|0);
   }
   $104=((HEAP32[((12024)>>2)])|0);
   $105=($104|0)==0;
   $106=($105?101:0);
   if ($105) {
    $112=$106;
   } else {
    $108=((HEAP32[((17656)>>2)])|0);
    $109=($108|0)==0;
    $110=($109?101:0);
    $112=$110;
   }

   $113=($112|0)==101;
   if ($113) {
    $errcode_3=101;

    return (($errcode_3)|0);
   }
   $115=((HEAP32[((13944)>>2)])|0);
   $116=($115|0)==0;
   $117=($116?101:0);
   if ($116) {
    $errcode_2=$117;
    break;
   }
   $119=((HEAP32[((17648)>>2)])|0);
   $120=($119|0)==0;
   $121=($120?101:0);
   $errcode_2=$121;
  }
 } while(0);

 $122=($errcode_2|0)!=0;
 if ($122) {
  $errcode_3=$errcode_2;

  return (($errcode_3)|0);
 }
 $123=((HEAP32[((14616)>>2)])|0);
 $124=($123|0)<0;
 if (!($124)) {
  $n_074=0;
  while(1) {

   $127=((HEAP32[((13944)>>2)])|0);
   $128=(($127+((($n_074)*(40))&-1)+32)|0);
   HEAP32[(($128)>>2)]=0;
   $129=((HEAP32[((13944)>>2)])|0);
   $130=(($129+((($n_074)*(40))&-1)+36)|0);
   HEAP32[(($130)>>2)]=0;
   $131=((($n_074)+(1))|0);
   $132=((HEAP32[((14616)>>2)])|0);
   $133=($131|0)>($132|0);
   if ($133) {
    break;
   } else {
    $n_074=$131;
   }
  }
 }
 $125=((HEAP32[((14656)>>2)])|0);
 $126=($125|0)<0;
 if (!($126)) {
  $n_171=0;
  while(1) {

   $136=((HEAP32[((17648)>>2)])|0);
   $137=(($136+((($n_171)*(48))&-1)+36)|0);
   HEAP32[(($137)>>2)]=0;
   $138=((HEAP32[((17648)>>2)])|0);
   $139=(($138+((($n_171)*(48))&-1)+32)|0);
   HEAP32[(($139)>>2)]=-1;
   $140=((HEAP32[((17648)>>2)])|0);
   $141=(($140+((($n_171)*(48))&-1)+40)|0);
   HEAP32[(($141)>>2)]=0;
   $142=((HEAP32[((17648)>>2)])|0);
   $143=(($142+((($n_171)*(48))&-1)+44)|0);
   HEAP32[(($143)>>2)]=0;
   $144=((($n_171)+(1))|0);
   $145=((HEAP32[((14656)>>2)])|0);
   $146=($144|0)>($145|0);
   if ($146) {
    break;
   } else {
    $n_171=$144;
   }
  }
 }
 $134=((HEAP32[((14624)>>2)])|0);
 $135=($134|0)<0;
 if (!($135)) {
  $n_269=0;
  while(1) {

   $147=((HEAP32[((14408)>>2)])|0);
   $148=(($147+((($n_269)*(72))&-1)+40)|0);
   HEAP32[(($148)>>2)]=0;
   $149=((($n_269)+(1))|0);
   $150=((HEAP32[((14624)>>2)])|0);
   $151=($149|0)>($150|0);
   if ($151) {
    break;
   } else {
    $n_269=$149;
   }
  }
 }
 if ($122) {
  $errcode_3=$errcode_2;

  return (($errcode_3)|0);
 }
 $153=((_allocrules())|0);
 $errcode_3=$153;

 return (($errcode_3)|0);
}


function _freeTmplist($t){
 $t=($t)|0;
 var $1=0,$_05=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,label=0;

 $1=($t|0)==0;
 if ($1) {
  return;
 } else {
  $_05=$t;
 }
 while(1) {

  $2=(($_05+44)|0);
  $3=((HEAP32[(($2)>>2)])|0);
  $4=(($_05+36)|0);
  $5=((HEAP32[(($4)>>2)])|0);
  _freeFloatlist($5);
  $6=(($_05+40)|0);
  $7=((HEAP32[(($6)>>2)])|0);
  _freeFloatlist($7);
  $8=$_05;
  _free($8);
  $9=($3|0)==0;
  if ($9) {
   break;
  } else {
   $_05=$3;
  }
 }
 return;
}


function _openhydfile(){
 var $nsize=0,$magic=0,$version=0,$1=0,$2=0,$4=0,$5=0,$7=0,$9=0,$10=0,$12=0,$13=0,$15=0,$17=0,$19=0,$20=0,$22=0,$23=0,$25=0,$26=0;
 var $27=0,$28=0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0,$40=0,$41=0,$42=0,$43=0,$44=0,$45=0,$_pr=0;
 var $46=0,$47=0,$48=0,$49=0,$50=0,$51=0,$53=0,$54=0,$55=0,$56=0,$57=0,$59=0,$60=0,$61=0,$62=0,$64=0,$65=0,$66=0,$67=0,$69=0;
 var $70=0,$71=0,$72=0,$74=0,$75=0,$76=0,$77=0,$79=0,$80=0,$81=0,$82=0,$84=0,$85=0,$86=0,$87=0,$89=0,$90=0,$91=0,$92=0,$95=0;
 var $96=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+40)|0;
 $nsize=((sp)|0);
 $magic=(((sp)+(24))|0);
 $version=(((sp)+(32))|0);
 $1=((HEAP32[((15568)>>2)])|0);
 $2=($1|0)==0;
 do {
  if (!($2)) {
   $4=((HEAP8[(15288)])|0);
   $5=(($4<<24)>>24)==2;
   if ($5) {
    $_0=0;

    STACKTOP=sp;return (($_0)|0);
   } else {
    $7=((_fclose((($1)|0)))|0);
    break;
   }
  }
 } while(0);
 HEAP32[((15568)>>2)]=0;
 $9=((HEAP8[(15288)])|0);
 $10=(($9<<24)>>24);
 if (((($10|0))|0)==((2)|0)) {
  $12=((_getTmpName(15304))|0);
  $13=((_fopen(((15304)|0),((8688)|0)))|0);
  HEAP32[((15568)>>2)]=$13;
  $19=$13;
 } else if (((($10|0))|0)==((1)|0)) {
  $15=((_fopen(((15304)|0),((8688)|0)))|0);
  HEAP32[((15568)>>2)]=$15;
  $19=$15;
 } else if (((($10|0))|0)==((0)|0)) {
  $17=((_fopen(((15304)|0),((8112)|0)))|0);
  HEAP32[((15568)>>2)]=$17;
  $19=$17;
 } else {
  $_0=305;

  STACKTOP=sp;return (($_0)|0);
 }

 $20=($19|0)==0;
 if ($20) {
  $_0=305;

  STACKTOP=sp;return (($_0)|0);
 }
 $22=((HEAP8[(15288)])|0);
 $23=(($22<<24)>>24)==0;
 if ($23) {
  label = 11;
 } else {
  HEAP32[(($magic)>>2)]=516114521;
  HEAP32[(($version)>>2)]=200;
  $25=((HEAP32[((14416)>>2)])|0);
  $26=(($nsize)|0);
  HEAP32[(($26)>>2)]=$25;
  $27=((HEAP32[((14424)>>2)])|0);
  $28=(($nsize+4)|0);
  HEAP32[(($28)>>2)]=$27;
  $29=((HEAP32[((14352)>>2)])|0);
  $30=(($nsize+8)|0);
  HEAP32[(($30)>>2)]=$29;
  $31=((HEAP32[((14368)>>2)])|0);
  $32=(($nsize+12)|0);
  HEAP32[(($32)>>2)]=$31;
  $33=((HEAP32[((14328)>>2)])|0);
  $34=(($nsize+16)|0);
  HEAP32[(($34)>>2)]=$33;
  $35=((HEAP32[((17544)>>2)])|0);
  $36=(($nsize+20)|0);
  HEAP32[(($36)>>2)]=$35;
  $37=$magic;
  $38=((HEAP32[((15568)>>2)])|0);
  $39=((_fwrite((($37)|0),((4)|0),((1)|0),(($38)|0)))|0);
  $40=$version;
  $41=((HEAP32[((15568)>>2)])|0);
  $42=((_fwrite((($40)|0),((4)|0),((1)|0),(($41)|0)))|0);
  $43=$nsize;
  $44=((HEAP32[((15568)>>2)])|0);
  $45=((_fwrite((($43)|0),((4)|0),((6)|0),(($44)|0)))|0);
  $_pr=((HEAP8[(15288)])|0);
  $46=(($_pr<<24)>>24)==0;
  if ($46) {
   label = 11;
  }
 }
 do {
  if ((label|0) == 11) {
   $47=$magic;
   $48=((HEAP32[((15568)>>2)])|0);
   $49=((_fread((($47)|0),((4)|0),((1)|0),(($48)|0)))|0);
   $50=((HEAP32[(($magic)>>2)])|0);
   $51=($50|0)==516114521;
   if (!($51)) {
    $_0=306;

    STACKTOP=sp;return (($_0)|0);
   }
   $53=$version;
   $54=((HEAP32[((15568)>>2)])|0);
   $55=((_fread((($53)|0),((4)|0),((1)|0),(($54)|0)))|0);
   $56=((HEAP32[(($version)>>2)])|0);
   $57=($56|0)==200;
   if (!($57)) {
    $_0=306;

    STACKTOP=sp;return (($_0)|0);
   }
   $59=$nsize;
   $60=((HEAP32[((15568)>>2)])|0);
   $61=((_fread((($59)|0),((4)|0),((6)|0),(($60)|0)))|0);
   $62=($61>>>0)<((6)>>>0);
   if ($62) {
    $_0=306;

    STACKTOP=sp;return (($_0)|0);
   }
   $64=(($nsize)|0);
   $65=((HEAP32[(($64)>>2)])|0);
   $66=((HEAP32[((14416)>>2)])|0);
   $67=($65|0)==($66|0);
   if (!($67)) {
    $_0=306;

    STACKTOP=sp;return (($_0)|0);
   }
   $69=(($nsize+4)|0);
   $70=((HEAP32[(($69)>>2)])|0);
   $71=((HEAP32[((14424)>>2)])|0);
   $72=($70|0)==($71|0);
   if (!($72)) {
    $_0=306;

    STACKTOP=sp;return (($_0)|0);
   }
   $74=(($nsize+8)|0);
   $75=((HEAP32[(($74)>>2)])|0);
   $76=((HEAP32[((14352)>>2)])|0);
   $77=($75|0)==($76|0);
   if (!($77)) {
    $_0=306;

    STACKTOP=sp;return (($_0)|0);
   }
   $79=(($nsize+12)|0);
   $80=((HEAP32[(($79)>>2)])|0);
   $81=((HEAP32[((14368)>>2)])|0);
   $82=($80|0)==($81|0);
   if (!($82)) {
    $_0=306;

    STACKTOP=sp;return (($_0)|0);
   }
   $84=(($nsize+16)|0);
   $85=((HEAP32[(($84)>>2)])|0);
   $86=((HEAP32[((14328)>>2)])|0);
   $87=($85|0)==($86|0);
   if (!($87)) {
    $_0=306;

    STACKTOP=sp;return (($_0)|0);
   }
   $89=(($nsize+20)|0);
   $90=((HEAP32[(($89)>>2)])|0);
   $91=((HEAP32[((17544)>>2)])|0);
   $92=($90|0)==($91|0);
   if ($92) {
    HEAP8[(13224)]=1;
    break;
   } else {
    $_0=306;

    STACKTOP=sp;return (($_0)|0);
   }
  }
 } while(0);
 $95=((HEAP32[((15568)>>2)])|0);
 $96=((_ftell((($95)|0)))|0);
 HEAP32[((15296)>>2)]=$96;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _freedata(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$j_027=0,$18=0,$19=0;
 var $20=0,$demand_021=0,$21=0,$22=0,$23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$30=0,$32=0,$33=0,$34=0,$35=0,$_lcssa26=0,$36=0,$38=0,$39=0,$40=0;
 var $41=0,$42=0,$43=0,$44=0,$45=0,$46=0,$47=0,$48=0,$49=0,$50=0,$51=0,$52=0,$53=0,$j_117=0,$54=0,$55=0,$56=0,$57=0,$58=0,$59=0;
 var $60=0,$_lcssa16=0,$61=0,$63=0,$64=0,$65=0,$66=0,$67=0,$68=0,$j_214=0,$69=0,$70=0,$71=0,$72=0,$73=0,$74=0,$75=0,$76=0,$77=0,$78=0;
 var $79=0,$_lcssa=0,$80=0,$82=0,$83=0,$86=0,$87=0,label=0;

 $1=((HEAP32[((17632)>>2)])|0);
 $2=$1;
 _free($2);
 $3=((HEAP32[((17736)>>2)])|0);
 $4=$3;
 _free($4);
 $5=((HEAP32[((15600)>>2)])|0);
 $6=$5;
 _free($6);
 $7=((HEAP32[((13880)>>2)])|0);
 $8=$7;
 _free($8);
 $9=((HEAP32[((15000)>>2)])|0);
 $10=$9;
 _free($10);
 $11=((HEAP32[((13232)>>2)])|0);
 _free($11);
 $12=((HEAP32[((14408)>>2)])|0);
 $13=($12|0)==0;
 if (!($13)) {
  $14=((HEAP32[((14624)>>2)])|0);
  $15=($14|0)<0;
  $16=((HEAP32[((14408)>>2)])|0);
  if ($15) {
   $_lcssa26=$16;
  } else {
   $j_027=0;$17=$16;
   while(1) {


    $18=(($17+((($j_027)*(72))&-1)+40)|0);
    $19=((HEAP32[(($18)>>2)])|0);
    $20=($19|0)==0;
    if (!($20)) {
     $demand_021=$19;
     while(1) {

      $21=(($demand_021+12)|0);
      $22=((HEAP32[(($21)>>2)])|0);
      $23=$demand_021;
      _free($23);
      $24=($22|0)==0;
      if ($24) {
       break;
      } else {
       $demand_021=$22;
      }
     }
    }
    $25=((HEAP32[((14408)>>2)])|0);
    $26=(($25+((($j_027)*(72))&-1)+44)|0);
    $27=((HEAP32[(($26)>>2)])|0);
    $28=($27|0)==0;
    if (!($28)) {
     $30=$27;
     _free($30);
    }
    $32=((($j_027)+(1))|0);
    $33=((HEAP32[((14624)>>2)])|0);
    $34=($32|0)>($33|0);
    $35=((HEAP32[((14408)>>2)])|0);
    if ($34) {
     $_lcssa26=$35;
     break;
    } else {
     $j_027=$32;$17=$35;
    }
   }
  }

  $36=(($_lcssa26)|0);
  _free($36);
 }
 $38=((HEAP32[((14960)>>2)])|0);
 $39=(($38)|0);
 _free($39);
 $40=((HEAP32[((13176)>>2)])|0);
 $41=$40;
 _free($41);
 $42=((HEAP32[((13888)>>2)])|0);
 $43=$42;
 _free($43);
 $44=((HEAP32[((12024)>>2)])|0);
 $45=$44;
 _free($45);
 $46=((HEAP32[((17656)>>2)])|0);
 $47=$46;
 _free($47);
 $48=((HEAP32[((13944)>>2)])|0);
 $49=($48|0)==0;
 if (!($49)) {
  $50=((HEAP32[((14616)>>2)])|0);
  $51=($50|0)<0;
  $52=((HEAP32[((13944)>>2)])|0);
  if ($51) {
   $_lcssa16=$52;
  } else {
   $j_117=0;$53=$52;
   while(1) {


    $54=(($53+((($j_117)*(40))&-1)+36)|0);
    $55=((HEAP32[(($54)>>2)])|0);
    $56=$55;
    _free($56);
    $57=((($j_117)+(1))|0);
    $58=((HEAP32[((14616)>>2)])|0);
    $59=($57|0)>($58|0);
    $60=((HEAP32[((13944)>>2)])|0);
    if ($59) {
     $_lcssa16=$60;
     break;
    } else {
     $j_117=$57;$53=$60;
    }
   }
  }

  $61=(($_lcssa16)|0);
  _free($61);
 }
 $63=((HEAP32[((17648)>>2)])|0);
 $64=($63|0)==0;
 if (!($64)) {
  $65=((HEAP32[((14656)>>2)])|0);
  $66=($65|0)<0;
  $67=((HEAP32[((17648)>>2)])|0);
  if ($66) {
   $_lcssa=$67;
  } else {
   $j_214=0;$68=$67;
   while(1) {


    $69=(($68+((($j_214)*(48))&-1)+40)|0);
    $70=((HEAP32[(($69)>>2)])|0);
    $71=$70;
    _free($71);
    $72=((HEAP32[((17648)>>2)])|0);
    $73=(($72+((($j_214)*(48))&-1)+44)|0);
    $74=((HEAP32[(($73)>>2)])|0);
    $75=$74;
    _free($75);
    $76=((($j_214)+(1))|0);
    $77=((HEAP32[((14656)>>2)])|0);
    $78=($76|0)>($77|0);
    $79=((HEAP32[((17648)>>2)])|0);
    if ($78) {
     $_lcssa=$79;
     break;
    } else {
     $j_214=$76;$68=$79;
    }
   }
  }

  $80=(($_lcssa)|0);
  _free($80);
 }
 _freerules();
 $82=((HEAP32[((14440)>>2)])|0);
 $83=($82|0)==0;
 if (!($83)) {
  _HTfree($82);
 }
 $86=((HEAP32[((14976)>>2)])|0);
 $87=($86|0)==0;
 if ($87) {
  return;
 }
 _HTfree($86);
 return;
}


function _ENopenH(){
 var $1=0,$2=0,$4=0,$5=0,$7=0,$8=0,$_0=0,label=0;

 HEAP8[(14312)]=0;
 HEAP8[(13224)]=0;
 $1=((HEAP8[(14296)])|0);
 $2=(($1<<24)>>24)==0;
 do {
  if ($2) {
   $_0=102;
  } else {
   $4=((HEAP8[(15288)])|0);
   $5=(($4<<24)>>24)==0;
   if ($5) {
    $_0=107;
    break;
   }
   $7=((_openhyd())|0);
   $8=($7|0)==0;
   if ($8) {
    HEAP8[(14312)]=1;
    $_0=0;
    break;
   } else {
    _errmsg($7);
    $_0=$7;
    break;
   }
  }
 } while(0);

 return (($_0)|0);
}


function _ENinitH($flag){
 $flag=($flag)|0;
 var $1=0,$2=0,$3=0,$5=0,$6=0,$7=0,$9=0,$10=0,$errcode_0=0,$14=0,$15=0,$_0=0,label=0;

 HEAP8[(13224)]=0;
 HEAP8[(12008)]=0;
 $1=(((($flag|0))/(10))&-1);
 $2=((HEAP8[(14312)])|0);
 $3=(($2<<24)>>24)==0;
 if ($3) {
  $_0=103;

  return (($_0)|0);
 }
 $5=((($1)*(-10))&-1);
 $6=((($5)+($flag))|0);
 HEAP8[(13208)]=0;
 $7=($6|0)>0;
 do {
  if ($7) {
   $9=((_openhydfile())|0);
   $10=($9|0)==0;
   if ($10) {
    HEAP8[(13208)]=1;
    $errcode_0=0;
    break;
   } else {
    _errmsg($9);
    $errcode_0=$9;
    break;
   }
  } else {
   $errcode_0=0;
  }
 } while(0);

 _inithyd($1);
 $14=((HEAP8[(13192)])|0);
 $15=(($14<<24)>>24)>0;
 if (!($15)) {
  $_0=$errcode_0;

  return (($_0)|0);
 }
 _writeheader(0,0);
 $_0=$errcode_0;

 return (($_0)|0);
}


function _ENrunH($t){
 $t=($t)|0;
 var $1=0,$2=0,$4=0,$5=0,$_0=0,label=0;

 HEAP32[(($t)>>2)]=0;
 $1=((HEAP8[(14312)])|0);
 $2=(($1<<24)>>24)==0;
 do {
  if ($2) {
   $_0=103;
  } else {
   $4=((_runhyd($t))|0);
   $5=($4|0)==0;
   if ($5) {
    $_0=0;
    break;
   }
   _errmsg($4);
   $_0=$4;
  }
 } while(0);

 return (($_0)|0);
}


function _ENnextH($tstep){
 $tstep=($tstep)|0;
 var $1=0,$2=0,$4=0,$5=0,$8=0,$9=0,$11=0,$12=0,$_0=0,label=0;

 HEAP32[(($tstep)>>2)]=0;
 $1=((HEAP8[(14312)])|0);
 $2=(($1<<24)>>24)==0;
 do {
  if ($2) {
   $_0=103;
  } else {
   $4=((_nexthyd($tstep))|0);
   $5=($4|0)==0;
   if (!($5)) {
    _errmsg($4);
    $_0=$4;
    break;
   }
   $8=((HEAP8[(13208)])|0);
   $9=(($8<<24)>>24)==0;
   if ($9) {
    $_0=0;
    break;
   }
   $11=((HEAP32[(($tstep)>>2)])|0);
   $12=($11|0)==0;
   if (!($12)) {
    $_0=0;
    break;
   }
   HEAP8[(13224)]=1;
   $_0=0;
  }
 } while(0);

 return (($_0)|0);
}


function _ENcloseH(){
 var $1=0,$2=0,$_0=0,label=0;

 $1=((HEAP8[(14296)])|0);
 $2=(($1<<24)>>24)==0;
 if ($2) {
  $_0=102;

  return (($_0)|0);
 }
 _closehyd();
 HEAP8[(14312)]=0;
 $_0=0;

 return (($_0)|0);
}


function _ENopenQ(){
 var $1=0,$2=0,$4=0,$5=0,$7=0,$8=0,$_0=0,label=0;

 HEAP8[(14304)]=0;
 HEAP8[(13216)]=0;
 $1=((HEAP8[(14296)])|0);
 $2=(($1<<24)>>24)==0;
 do {
  if ($2) {
   $_0=102;
  } else {
   $4=((HEAP8[(13224)])|0);
   $5=(($4<<24)>>24)==0;
   if ($5) {
    $_0=104;
    break;
   }
   $7=((_openqual())|0);
   $8=($7|0)==0;
   if ($8) {
    HEAP8[(14304)]=1;
    $_0=0;
    break;
   } else {
    _errmsg($7);
    $_0=$7;
    break;
   }
  }
 } while(0);

 return (($_0)|0);
}


function _ENinitQ($saveflag){
 $saveflag=($saveflag)|0;
 var $1=0,$2=0,$4=0,$6=0,$7=0,$_0=0,label=0;

 $1=((HEAP8[(14304)])|0);
 $2=(($1<<24)>>24)==0;
 do {
  if ($2) {
   $_0=105;
  } else {
   _initqual();
   HEAP8[(13216)]=0;
   HEAP8[(13208)]=0;
   $4=($saveflag|0)==0;
   if ($4) {
    $_0=0;
    break;
   }
   $6=((_openoutfile())|0);
   $7=($6|0)==0;
   if (!($7)) {
    $_0=$6;
    break;
   }
   HEAP8[(13208)]=1;
   $_0=0;
  }
 } while(0);

 return (($_0)|0);
}


function _ENrunQ($t){
 $t=($t)|0;
 var $1=0,$2=0,$4=0,$5=0,$_0=0,label=0;

 HEAP32[(($t)>>2)]=0;
 $1=((HEAP8[(14304)])|0);
 $2=(($1<<24)>>24)==0;
 do {
  if ($2) {
   $_0=105;
  } else {
   $4=((_runqual($t))|0);
   $5=($4|0)==0;
   if ($5) {
    $_0=0;
    break;
   }
   _errmsg($4);
   $_0=$4;
  }
 } while(0);

 return (($_0)|0);
}


function _ENnextQ($tstep){
 $tstep=($tstep)|0;
 var $1=0,$2=0,$4=0,$5=0,$6=0,$7=0,$or_cond=0,$9=0,$10=0,$_0=0,label=0;

 HEAP32[(($tstep)>>2)]=0;
 $1=((HEAP8[(14304)])|0);
 $2=(($1<<24)>>24)==0;
 if ($2) {
  $_0=105;

  return (($_0)|0);
 }
 $4=((_nextqual($tstep))|0);
 $5=($4|0)!=0;
 $6=((HEAP8[(13208)])|0);
 $7=(($6<<24)>>24)==0;
 $or_cond=$5|$7;
 do {
  if (!($or_cond)) {
   $9=((HEAP32[(($tstep)>>2)])|0);
   $10=($9|0)==0;
   if (!($10)) {
    break;
   }
   HEAP8[(13216)]=1;
  }
 } while(0);
 if (!($5)) {
  $_0=0;

  return (($_0)|0);
 }
 _errmsg($4);
 $_0=$4;

 return (($_0)|0);
}


function _ENcloseQ(){
 var $1=0,$2=0,$4=0,$_0=0,label=0;

 $1=((HEAP8[(14296)])|0);
 $2=(($1<<24)>>24)==0;
 if ($2) {
  $_0=102;

  return (($_0)|0);
 }
 $4=((_closequal())|0);
 HEAP8[(14304)]=0;
 $_0=0;

 return (($_0)|0);
}


function _openoutfile(){
 var $1=0,$2=0,$4=0,$6=0,$7=0,$9=0,$11=0,$12=0,$14=0,$16=0,$17=0,$18=0,$20=0,$21=0,$24=0,$25=0,$26=0,$29=0,$30=0,$31=0;
 var $32=0,$33=0,$35=0,$37=0,$38=0,$39=0,$40=0,$42=0,$43=0,$45=0,$46=0,$47=0,$_=0,$49=0,label=0;

 $1=((HEAP32[((14280)>>2)])|0);
 $2=($1|0)==0;
 if (!($2)) {
  $4=((_fclose((($1)|0)))|0);
 }
 HEAP32[((14280)>>2)]=0;
 $6=((HEAP32[((12392)>>2)])|0);
 $7=($6|0)==0;
 if (!($7)) {
  $9=((_fclose((($6)|0)))|0);
 }
 HEAP32[((12392)>>2)]=0;
 $11=((HEAP8[(13984)])|0);
 $12=(($11<<24)>>24)==2;
 if ($12) {
  $14=((_remove(((14016)|0)))|0);
 }
 $16=((_remove(((12400)|0)))|0);
 $17=((HEAP8[(13984)])|0);
 $18=(($17<<24)>>24)==1;
 do {
  if ($18) {
   $20=((_fopen(((14016)|0),((8688)|0)))|0);
   HEAP32[((14280)>>2)]=$20;
   $21=($20|0)==0;
   if (!($21)) {
    label = 12;
    break;
   }
   _writecon(((8072)|0));
   $30=304;
  } else {
   $24=((_getTmpName(14016))|0);
   $25=((_fopen(((14016)|0),((8688)|0)))|0);
   HEAP32[((14280)>>2)]=$25;
   $26=($25|0)==0;
   if (!($26)) {
    label = 12;
    break;
   }
   _writecon(((8032)|0));
   $30=304;
  }
 } while(0);
 if ((label|0) == 12) {
  $29=((_savenetdata())|0);
  $30=$29;
 }

 $31=((HEAP32[((14280)>>2)])|0);
 $32=((_ftell((($31)|0)))|0);
 HEAP32[((14000)>>2)]=$32;
 $33=($30|0)>100;
 if ($33) {
  $37=$30;
 } else {
  $35=((_saveenergy())|0);
  $37=$35;
 }

 $38=((HEAP32[((14280)>>2)])|0);
 $39=((_ftell((($38)|0)))|0);
 HEAP32[((13992)>>2)]=$39;
 $40=($37|0)==0;
 if (!($40)) {
  return (($37)|0);
 }
 $42=((HEAP8[(12208)])|0);
 $43=(($42<<24)>>24)==0;
 if (!($43)) {
  $45=((_getTmpName(12400))|0);
  $46=((_fopen(((12400)|0),((8688)|0)))|0);
  HEAP32[((12392)>>2)]=$46;
  $47=($46|0)==0;
  $_=($47?304:$37);
  return (($_)|0);
 }
 $49=((HEAP32[((14280)>>2)])|0);
 HEAP32[((12392)>>2)]=$49;
 return (($37)|0);
}


function _geterrmsg($errcode){
 $errcode=($errcode)|0;
 var $16=0,$18=0,$20=0,$22=0,$24=0,$26=0,$28=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 switch (($errcode|0)) {
 case 302: {
  (_memcpy(((14488)|0), ((6088)|0), 40)|0);
  break;
 }
 case 104: {
  (_memcpy(((14488)|0), ((7664)|0), 60)|0);
  break;
 }
 case 301: {
  (_memcpy(((14488)|0), ((6144)|0), 38)|0);
  break;
 }
 case 103: {
  (_memcpy(((14488)|0), ((7744)|0), 46)|0);
  break;
 }
 case 307: {
  (_memcpy(((14488)|0), ((5768)|0), 45)|0);
  break;
 }
 case 308: {
  (_memcpy(((14488)|0), ((5720)|0), 45)|0);
  break;
 }
 case 303: {
  (_memcpy(((14488)|0), ((6040)|0), 41)|0);
  break;
 }
 case 250: {
  (_memcpy(((14488)|0), ((6256)|0), 56)|0);
  break;
 }
 case 306: {
  (_memcpy(((14488)|0), ((5880)|0), 61)|0);
  break;
 }
 case 304: {
  (_memcpy(((14488)|0), ((5992)|0), 48)|0);
  break;
 }
 case 101: {
  (_memcpy(((14488)|0), ((7888)|0), 49)|0);
  break;
 }
 case 106: {
  (_memcpy(((14488)|0), ((7520)|0), 49)|0);
  break;
 }
 case 107: {
  (_memcpy(((14488)|0), ((7456)|0), 58)|0);
  break;
 }
 case 251: {
  (_memcpy(((14488)|0), ((6184)|0), 64)|0);
  break;
 }
 case 105: {
  (_memcpy(((14488)|0), ((7608)|0), 49)|0);
  break;
 }
 case 108: {
  (_memcpy(((14488)|0), ((7376)|0), 78)|0);
  break;
 }
 case 109: {
  (_memcpy(((14488)|0), ((7304)|0), 70)|0);
  break;
 }
 case 110: {
  (_memcpy(((14488)|0), ((7240)|0), 60)|0);
  break;
 }
 case 120: {
  (_memcpy(((14488)|0), ((7112)|0), 66)|0);
  break;
 }
 case 200: {
  (_memcpy(((14488)|0), ((7056)|0), 51)|0);
  break;
 }
 case 223: {
  (_memcpy(((14488)|0), ((6960)|0), 45)|0);
  break;
 }
 case 224: {
  (_memcpy(((14488)|0), ((6896)|0), 52)|0);
  break;
 }
 case 202: {
  $16=((_sprintf(((14488)|0),((6840)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=6784,HEAP32[(((tempVarArgs)+(8))>>2)]=11504,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  break;
 }
 case 203: {
  $18=((_sprintf(((14488)|0),((6728)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=6784,HEAP32[(((tempVarArgs)+(8))>>2)]=11504,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  break;
 }
 case 204: {
  $20=((_sprintf(((14488)|0),((6672)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=6784,HEAP32[(((tempVarArgs)+(8))>>2)]=11504,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  break;
 }
 case 205: {
  $22=((_sprintf(((14488)|0),((6608)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=6784,HEAP32[(((tempVarArgs)+(8))>>2)]=11504,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  break;
 }
 case 207: {
  $24=((_sprintf(((14488)|0),((6544)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=6784,HEAP32[(((tempVarArgs)+(8))>>2)]=11504,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  break;
 }
 case 309: {
  (_memcpy(((14488)|0), ((5616)|0), 52)|0);
  break;
 }
 case 240: {
  $26=((_sprintf(((14488)|0),((6416)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=6784,HEAP32[(((tempVarArgs)+(8))>>2)]=11504,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  break;
 }
 case 241: {
  $28=((_sprintf(((14488)|0),((6360)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=6784,HEAP32[(((tempVarArgs)+(8))>>2)]=11504,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  break;
 }
 case 305: {
  (_memcpy(((14488)|0), ((5944)|0), 45)|0);
  break;
 }
 case 102: {
  (_memcpy(((14488)|0), ((7840)|0), 45)|0);
  break;
 }
 default: {
  HEAP8[(14488)]=0;
 }
 }
 STACKTOP=sp;return ((14488)|0);
}


function _findnode($id){
 $id=($id)|0;
 var $1=0,$2=0,label=0;

 $1=((HEAP32[((14440)>>2)])|0);
 $2=((_HTfind($1,$id))|0);
 return (($2)|0);
}


function _findlink($id){
 $id=($id)|0;
 var $1=0,$2=0,label=0;

 $1=((HEAP32[((14976)>>2)])|0);
 $2=((_HTfind($1,$id))|0);
 return (($2)|0);
}


function _strcomp($s1,$s2){
 $s1=($s1)|0;
 $s2=($s2)|0;
 var $1=0,$2=0,$_off23=0,$3=0,$4=0,$5=0,$6=0,$7=0,$_off2224=0,$8=0,$9=0,$10=0,$11=0,$i_025=0,$12=0,$13=0,$14=0,$15=0,$17=0,$18=0;
 var $19=0,$20=0,$21=0,$22=0,$_off=0,$23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$_off22=0,$29=0,$30=0,$31=0,$32=0,$_0=0,label=0;

 $1=((HEAP8[($s1)])|0);
 $2=(($1<<24)>>24);
 $_off23=((($1)-(97))&255);
 $3=((($_off23&255))>>>0)<((26)>>>0);
 $4=$2&-33;
 $5=($3?$4:$2);
 $6=((HEAP8[($s2)])|0);
 $7=(($6<<24)>>24);
 $_off2224=((($6)-(97))&255);
 $8=((($_off2224&255))>>>0)<((26)>>>0);
 $9=$7&-33;
 $10=($8?$9:$7);
 $11=($5|0)==($10|0);
 if ($11) {
  $i_025=0;
 } else {
  $_0=0;

  return (($_0)|0);
 }
 while(1) {

  $12=((($i_025)+(1))|0);
  $13=(($s1+$12)|0);
  $14=((HEAP8[($13)])|0);
  $15=(($14<<24)>>24)==0;
  if ($15) {
   $17=(($s2+$12)|0);
   $18=((HEAP8[($17)])|0);
   $19=(($18<<24)>>24)==0;
   if ($19) {
    $_0=1;
    label = 5;
    break;
   }
  }
  $20=(($s1+$12)|0);
  $21=((HEAP8[($20)])|0);
  $22=(($21<<24)>>24);
  $_off=((($21)-(97))&255);
  $23=((($_off&255))>>>0)<((26)>>>0);
  $24=$22&-33;
  $25=($23?$24:$22);
  $26=(($s2+$12)|0);
  $27=((HEAP8[($26)])|0);
  $28=(($27<<24)>>24);
  $_off22=((($27)-(97))&255);
  $29=((($_off22&255))>>>0)<((26)>>>0);
  $30=$28&-33;
  $31=($29?$30:$28);
  $32=($25|0)==($31|0);
  if ($32) {
   $i_025=$12;
  } else {
   $_0=0;
   label = 5;
   break;
  }
 }
 if ((label|0) == 5) {

  return (($_0)|0);
 }
  return 0;
}


function _getTmpName($fname){
 $fname=($fname)|0;
 var $1=0,label=0;

 (_memcpy((($fname)|0), ((8008)|0), 9)|0);
 $1=((_mkstemp((($fname)|0)))|0);
 return (($fname)|0);
}


function _freeFloatlist($f){
 $f=($f)|0;
 var $1=0,$_03=0,$2=0,$3=0,$4=0,$5=0,label=0;

 $1=($f|0)==0;
 if ($1) {
  return;
 } else {
  $_03=$f;
 }
 while(1) {

  $2=(($_03+8)|0);
  $3=((HEAP32[(($2)>>2)])|0);
  $4=$_03;
  _free($4);
  $5=($3|0)==0;
  if ($5) {
   break;
  } else {
   $_03=$3;
  }
 }
 return;
}


function _interp($n,$x,$y,$xx){
 $n=($n)|0;
 $x=($x)|0;
 $y=($y)|0;
 $xx=+($xx);
 var $1=0,$2=.0,$3=0,$5=.0,$k_0=0,$6=0,$8=0,$9=.0,$10=0,$11=0,$13=0,$14=0,$15=.0,$16=.0,$17=0,$18=.0,$19=0,$20=.0,$21=.0,$22=0;
 var $24=.0,$26=.0,$27=0,$28=.0,$30=.0,$31=.0,$32=.0,$33=.0,$34=.0,$36=0,$37=.0,$_0=.0,label=0;

 $1=((($n)-(1))|0);
 $2=(+(HEAPF64[(($x)>>3)]));
 $3=$2<$xx;
 if ($3) {
  $k_0=1;
 } else {
  $5=(+(HEAPF64[(($y)>>3)]));
  $_0=$5;

  return (+($_0));
 }
 while(1) {

  $6=($k_0|0)>($1|0);
  if ($6) {
   label = 9;
   break;
  }
  $8=(($x+($k_0<<3))|0);
  $9=(+(HEAPF64[(($8)>>3)]));
  $10=$9<$xx;
  $11=((($k_0)+(1))|0);
  if ($10) {
   $k_0=$11;
  } else {
   break;
  }
 }
 if ((label|0) == 9) {
  $36=(($y+($1<<3))|0);
  $37=(+(HEAPF64[(($36)>>3)]));
  $_0=$37;

  return (+($_0));
 }
 $13=((($k_0)-(1))|0);
 $14=(($x+($13<<3))|0);
 $15=(+(HEAPF64[(($14)>>3)]));
 $16=($9)-($15);
 $17=(($y+($k_0<<3))|0);
 $18=(+(HEAPF64[(($17)>>3)]));
 $19=(($y+($13<<3))|0);
 $20=(+(HEAPF64[(($19)>>3)]));
 $21=($18)-($20);
 $22=$16<(0.0);
 if ($22) {
  $24=((-.0))-($16);
  $26=$24;
 } else {
  $26=$16;
 }

 $27=$26<(0.000001);
 $28=(+(HEAPF64[(($17)>>3)]));
 if ($27) {
  $_0=$28;

  return (+($_0));
 }
 $30=(+(HEAPF64[(($8)>>3)]));
 $31=($30)-($xx);
 $32=($21)*($31);
 $33=($32)/($16);
 $34=($28)-($33);
 $_0=$34;

 return (+($_0));
}


function _hash($str){
 $str=($str)|0;
 var $1=0,$2=0,$3=0,$sum2_015=0,$_014=0,$sum1_013=0,$4=0,$5=0,$6=0,$7=0,$8=0,$_=0,$9=0,$10=0,$11=0,$phitmp=0,$sum2_0_lcssa=0,$sum1_0_lcssa=0,$13=0,$14=0;
 var $15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$21=0,label=0;

 $1=((HEAP8[($str)])|0);
 $2=(($1<<24)>>24)==0;
 if ($2) {
  $sum1_0_lcssa=0;$sum2_0_lcssa=0;
 } else {
  $sum1_013=0;$_014=$str;$sum2_015=0;$3=$1;
  while(1) {




   $4=(($3<<24)>>24);
   $5=((($4)+($sum1_013))|0);
   $6=(($_014+1)|0);
   $7=($5>>>0)>((254)>>>0);
   $8=((($5)-(255))|0);
   $_=($7?$8:$5);
   $9=((($_)+($sum2_015))|0);
   $10=((HEAP8[($6)])|0);
   $11=(($10<<24)>>24)==0;
   if ($11) {
    break;
   } else {
    $sum1_013=$_;$_014=$6;$sum2_015=$9;$3=$10;
   }
  }
  $phitmp=(((($9>>>0))%(255))&-1);
  $sum1_0_lcssa=$_;$sum2_0_lcssa=$phitmp;
 }


 $13=((($sum2_0_lcssa)+($sum1_0_lcssa))|0);
 $14=(((($13>>>0))%(255))&-1);
 $15=$14^255;
 $16=((($15)+($sum1_0_lcssa))|0);
 $17=(((($16>>>0))%(255))&-1);
 $18=$15<<8;
 $19=$18|$17;
 $20=$19^255;
 $21=(((($20>>>0))%(1999))&-1);
 return (($21)|0);
}


function _HTcreate(){
 var $1=0,$2=0,$3=0,label=0;

 $1=((_calloc(1999,4))|0);
 $2=$1;
 $3=($1|0)==0;
 if ($3) {
  return (($2)|0);
 }
 _memset((((($1)|0))|0), ((((0)|0))|0), ((((7996)|0))|0))|0;
 return (($2)|0);
}


function _HTinsert($ht,$key,$data){
 $ht=($ht)|0;
 $key=($key)|0;
 $data=($data)|0;
 var $1=0,$2=0,$4=0,$5=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$_0=0,label=0;

 $1=((_hash($key))|0);
 $2=($1>>>0)>((1998)>>>0);
 if ($2) {
  $_0=0;

  return (($_0)|0);
 }
 $4=((_malloc(12))|0);
 $5=($4|0)==0;
 if ($5) {
  $_0=0;

  return (($_0)|0);
 }
 $7=$4;
 $8=$4;
 HEAP32[(($8)>>2)]=$key;
 $9=(($4+4)|0);
 $10=$9;
 HEAP32[(($10)>>2)]=$data;
 $11=(($ht+($1<<2))|0);
 $12=((HEAP32[(($11)>>2)])|0);
 $13=(($4+8)|0);
 $14=$13;
 HEAP32[(($14)>>2)]=$12;
 HEAP32[(($11)>>2)]=$7;
 $_0=1;

 return (($_0)|0);
}


function _HTfind($ht,$key){
 $ht=($ht)|0;
 $key=($key)|0;
 var $1=0,$2=0,$4=0,$entry_0_in=0,$entry_0=0,$6=0,$8=0,$9=0,$10=0,$11=0,$12=0,$14=0,$15=0,$_0=0,label=0;

 $1=((_hash($key))|0);
 $2=($1>>>0)>((1998)>>>0);
 if ($2) {
  $_0=0;

  return (($_0)|0);
 }
 $4=(($ht+($1<<2))|0);
 $entry_0_in=$4;
 while(1) {

  $entry_0=((HEAP32[(($entry_0_in)>>2)])|0);
  $6=($entry_0|0)==0;
  if ($6) {
   $_0=0;
   label = 6;
   break;
  }
  $8=(($entry_0)|0);
  $9=((HEAP32[(($8)>>2)])|0);
  $10=((_strcmp((($9)|0),(($key)|0)))|0);
  $11=($10|0)==0;
  $12=(($entry_0+8)|0);
  if ($11) {
   break;
  } else {
   $entry_0_in=$12;
  }
 }
 if ((label|0) == 6) {

  return (($_0)|0);
 }
 $14=(($entry_0+4)|0);
 $15=((HEAP32[(($14)>>2)])|0);
 $_0=$15;

 return (($_0)|0);
}


function _HTfree($ht){
 $ht=($ht)|0;
 var $i_07=0,$2=0,$3=0,$4=0,$entry_06=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$12=0,label=0;

 $i_07=0;
 while(1) {

  $2=(($ht+($i_07<<2))|0);
  $3=((HEAP32[(($2)>>2)])|0);
  $4=($3|0)==0;
  if (!($4)) {
   $entry_06=$3;
   while(1) {

    $5=(($entry_06+8)|0);
    $6=((HEAP32[(($5)>>2)])|0);
    _free($entry_06);
    $8=($6|0)==0;
    if ($8) {
     break;
    } else {
     $entry_06=$6;
    }
   }
  }
  $9=((($i_07)+(1))|0);
  $10=($9|0)<1999;
  if ($10) {
   $i_07=$9;
  } else {
   break;
  }
 }
 _free($ht);
 return;
}


function _openhyd(){
 var $1=0,$2=0,$4=0,$6=0,$7=0,$8=0,$i_09=0,$9=0,$10=0,$11=0,$12=0,$13=.0,$14=0,$15=0,$16=0,label=0;

 $1=((_createsparse())|0);
 $2=($1|0)>100;
 if ($2) {
  $6=$1;
 } else {
  $4=((_allocmatrix())|0);
  $6=$4;
 }

 $7=((HEAP32[((14424)>>2)])|0);
 $8=($7|0)<1;
 if ($8) {
  return (($6)|0);
 } else {
  $i_09=1;
 }
 while(1) {

  $9=((HEAP32[((14960)>>2)])|0);
  $10=(($9+((($i_09)*(104))&-1)+97)|0);
  $11=((HEAP8[($10)])|0);
  $12=(($9+((($i_09)*(104))&-1)+56)|0);
  $13=(+(HEAPF64[(($12)>>3)]));
  _initlinkflow($i_09,$11,$13);
  $14=((($i_09)+(1))|0);
  $15=((HEAP32[((14424)>>2)])|0);
  $16=($14|0)>($15|0);
  if ($16) {
   break;
  } else {
   $i_09=$14;
  }
 }
 return (($6)|0);
}


function _allocmatrix(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0;
 var $21=0,$22=0,$23=0,$24=0,$25=0,$26=0,$27=0,$_sink=0,$28=0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0,$37=0,$38=0,$40=0;
 var $41=0,$42=0,$44=0,$45=0,$47=0,$48=0,$49=0,$51=0,$52=0,$53=0,$55=0,$56=0,$58=0,$59=0,$60=0,$62=0,$63=0,$64=0,$65=0,$66=0;
 var $68=0,$69=0,$70=0,$72=0,$73=0,$74=0,$75=0,label=0;

 $1=((HEAP32[((14416)>>2)])|0);
 $2=((($1)+(1))|0);
 $3=((_calloc($2,8))|0);
 $4=$3;
 HEAP32[((17768)>>2)]=$4;
 $5=((HEAP32[((14472)>>2)])|0);
 $6=((($5)+(1))|0);
 $7=((_calloc($6,8))|0);
 $8=$7;
 HEAP32[((17760)>>2)]=$8;
 $9=((HEAP32[((14416)>>2)])|0);
 $10=((($9)+(1))|0);
 $11=((_calloc($10,8))|0);
 $12=$11;
 HEAP32[((17504)>>2)]=$12;
 $13=((HEAP32[((14416)>>2)])|0);
 $14=((($13)+(1))|0);
 $15=((_calloc($14,8))|0);
 $16=$15;
 HEAP32[((17536)>>2)]=$16;
 $17=((HEAP32[((14424)>>2)])|0);
 $18=((($17)+(1))|0);
 $19=((_calloc($18,8))|0);
 $20=$19;
 HEAP32[((13976)>>2)]=$20;
 $21=((HEAP32[((14424)>>2)])|0);
 $22=((($21)+(1))|0);
 $23=((_calloc($22,8))|0);
 $24=$23;
 HEAP32[((11984)>>2)]=$24;
 $25=((HEAP32[((14416)>>2)])|0);
 $26=((HEAP32[((14424)>>2)])|0);
 $27=($25|0)>=($26|0);
 $_sink=($27?$25:$26);
 $28=((($_sink)+(1))|0);
 $29=((_calloc($28,8))|0);
 $30=$29;
 HEAP32[((12000)>>2)]=$30;
 $31=((HEAP32[((14424)>>2)])|0);
 $32=((HEAP32[((14352)>>2)])|0);
 $33=((($31)+(1))|0);
 $34=((($33)+($32))|0);
 $35=((_calloc($34,1))|0);
 HEAP32[((14320)>>2)]=$35;
 $36=((HEAP32[((17768)>>2)])|0);
 $37=($36|0)==0;
 $38=($37?101:0);
 if ($37) {
  $44=$38;
 } else {
  $40=((HEAP32[((17760)>>2)])|0);
  $41=($40|0)==0;
  $42=($41?101:0);
  $44=$42;
 }

 $45=($44|0)==101;
 if ($45) {
  $75=101;

  return (($75)|0);
 }
 $47=((HEAP32[((17504)>>2)])|0);
 $48=($47|0)==0;
 $49=($48?101:0);
 if ($48) {
  $55=$49;
 } else {
  $51=((HEAP32[((17536)>>2)])|0);
  $52=($51|0)==0;
  $53=($52?101:0);
  $55=$53;
 }

 $56=($55|0)==101;
 if ($56) {
  $75=101;

  return (($75)|0);
 }
 $58=((HEAP32[((13976)>>2)])|0);
 $59=($58|0)==0;
 $60=($59?101:0);
 if ($59) {
  $65=$60;
 } else {
  $62=((HEAP32[((11984)>>2)])|0);
  $63=($62|0)==0;
  $64=($63?101:0);
  $65=$64;
 }

 $66=($65|0)==101;
 if ($66) {
  $75=101;

  return (($75)|0);
 }
 $68=((HEAP32[((12000)>>2)])|0);
 $69=($68|0)==0;
 $70=($69?101:0);
 if ($69) {
  $75=$70;

  return (($75)|0);
 }
 $72=((HEAP32[((14320)>>2)])|0);
 $73=($72|0)==0;
 $74=($73?101:0);
 $75=$74;

 return (($75)|0);
}


function _initlinkflow($i,$s,$k){
 $i=($i)|0;
 $s=($s)|0;
 $k=+($k);
 var $1=0,$3=0,$4=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=.0,$13=0,$15=.0,$17=.0,$_sink=.0,$19=0,$20=0,$21=0,$22=.0,$23=.0,$24=0,$25=0;
 var $27=.0,$28=.0,$29=.0,$30=0,$31=0,label=0;

 $1=(($s<<24)>>24)==2;
 if ($1) {
  $3=((HEAP32[((13880)>>2)])|0);
  $4=(($3+($i<<3))|0);
  HEAPF64[(($4)>>3)]=0.000001;
  return;
 }
 $6=((HEAP32[((14960)>>2)])|0);
 $7=(($6+((($i)*(104))&-1)+96)|0);
 $8=((HEAP8[($7)])|0);
 $9=(($8<<24)>>24)==2;
 $10=(($6+((($i)*(104))&-1)+40)|0);
 $11=(+(HEAPF64[(($10)>>3)]));
 if (!($9)) {
  $27=($11)*($11);
  $28=($27)*((3.141592654));
  $29=($28)*((0.25));
  $30=((HEAP32[((13880)>>2)])|0);
  $31=(($30+($i<<3))|0);
  HEAPF64[(($31)>>3)]=$29;
  return;
 }
 $13=$11<(0.0);
 if ($13) {
  $17=($11)+((-0.5));
  $_sink=$17;
 } else {
  $15=($11)+((0.5));
  $_sink=$15;
 }

 $19=(~~($_sink));
 $20=((HEAP32[((13888)>>2)])|0);
 $21=(($20+($19<<7)+8)|0);
 $22=(+(HEAPF64[(($21)>>3)]));
 $23=($22)*($k);
 $24=((HEAP32[((13880)>>2)])|0);
 $25=(($24+($i<<3))|0);
 HEAPF64[(($25)>>3)]=$23;
 return;
}


function _inithyd($initflag){
 $initflag=($initflag)|0;
 var $1=0,$2=0,$i_046=0,$3=0,$4=0,$5=.0,$6=0,$7=0,$8=0,$9=.0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0;
 var $20=0,$21=0,$22=0,$23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$i_143=0,$36=0,$37=0,$38=.0;
 var $39=0,$41=0,$42=0,$44=0,$45=0,$46=0,$47=0,$48=0,$i_240=0,$50=0,$51=0,$52=0,$53=0,$54=0,$55=0,$56=0,$57=.0,$58=0,$59=0,$60=0;
 var $61=0,$62=0,$64=0,$65=0,$66=.0,$67=0,$69=0,$70=0,$72=0,$73=0,$74=0,$75=0,$76=0,$77=0,$80=.0,$81=0,$83=.0,$85=.0,$86=0,$or_cond=0;
 var $88=0,$89=0,$90=0,$91=0,$92=0,$93=.0,$95=0,$96=0,$97=0,$98=0,$99=0,$100=0,$101=0,$102=0,$i_338=0,$103=0,$104=0,$105=0,$106=0,$107=0;
 var $108=0,$109=0,$110=0,$111=0,$112=0,$113=0,$114=0,$115=0,$116=0,$117=0,$118=0,$119=0,$121=0,$122=0,$123=0,$125=0,label=0;

 $1=((HEAP32[((14352)>>2)])|0);
 $2=($1|0)<1;
 if (!($2)) {
  $i_046=1;
  while(1) {

   $3=((HEAP32[((13176)>>2)])|0);
   $4=(($3+((($i_046)*(112))&-1)+56)|0);
   $5=(+(HEAPF64[(($4)>>3)]));
   $6=(($3+((($i_046)*(112))&-1)+72)|0);
   HEAPF64[(($6)>>3)]=$5;
   $7=((HEAP32[((13176)>>2)])|0);
   $8=(($7+((($i_046)*(112))&-1)+32)|0);
   $9=(+(HEAPF64[(($8)>>3)]));
   $10=(($7+((($i_046)*(112))&-1))|0);
   $11=((HEAP32[(($10)>>2)])|0);
   $12=((HEAP32[((15600)>>2)])|0);
   $13=(($12+($11<<3))|0);
   HEAPF64[(($13)>>3)]=$9;
   $14=((HEAP32[((13176)>>2)])|0);
   $15=(($14+((($i_046)*(112))&-1))|0);
   $16=((HEAP32[(($15)>>2)])|0);
   $17=((HEAP32[((17632)>>2)])|0);
   $18=(($17+($16<<3))|0);
   HEAPF64[(($18)>>3)]=0.0;
   $19=((HEAP32[((14424)>>2)])|0);
   $20=((($19)+($i_046))|0);
   $21=((HEAP32[((14320)>>2)])|0);
   $22=(($21+$20)|0);
   HEAP8[($22)]=1;
   $23=((($i_046)+(1))|0);
   $24=((HEAP32[((14352)>>2)])|0);
   $25=($23|0)>($24|0);
   if ($25) {
    break;
   } else {
    $i_046=$23;
   }
  }
 }
 $26=((HEAP32[((17536)>>2)])|0);
 $27=$26;
 $28=((HEAP32[((14416)>>2)])|0);
 $29=$28<<3;
 $30=((($29)+(8))|0);
 _memset((((($27)|0))|0), ((((0)|0))|0), (((($30)|0))|0))|0;
 $31=((HEAP32[((14432)>>2)])|0);
 $32=($31|0)<1;
 if (!($32)) {
  $i_143=1;
  while(1) {

   $36=((HEAP32[((14408)>>2)])|0);
   $37=(($36+((($i_143)*(72))&-1)+56)|0);
   $38=(+(HEAPF64[(($37)>>3)]));
   $39=$38>(0.0);
   if ($39) {
    $41=((HEAP32[((17536)>>2)])|0);
    $42=(($41+($i_143<<3))|0);
    HEAPF64[(($42)>>3)]=1.0;
   }
   $44=((($i_143)+(1))|0);
   $45=((HEAP32[((14432)>>2)])|0);
   $46=($44|0)>($45|0);
   if ($46) {
    break;
   } else {
    $i_143=$44;
   }
  }
 }
 $33=((HEAP32[((14424)>>2)])|0);
 $34=($33|0)<1;
 if (!($34)) {
  $35=($initflag|0)>0;
  $i_240=1;
  while(1) {

   $50=((HEAP32[((14960)>>2)])|0);
   $51=(($50+((($i_240)*(104))&-1)+97)|0);
   $52=((HEAP8[($51)])|0);
   $53=((HEAP32[((13232)>>2)])|0);
   $54=(($53+$i_240)|0);
   HEAP8[($54)]=$52;
   $55=((HEAP32[((14960)>>2)])|0);
   $56=(($55+((($i_240)*(104))&-1)+56)|0);
   $57=(+(HEAPF64[(($56)>>3)]));
   $58=((HEAP32[((15000)>>2)])|0);
   $59=(($58+($i_240<<3))|0);
   HEAPF64[(($59)>>3)]=$57;
   $60=((HEAP32[((14960)>>2)])|0);
   $61=(($60+((($i_240)*(104))&-1)+96)|0);
   $62=((HEAP8[($61)])|0);
   do {
    if ((((($62<<24)>>24))|0)==((3)|0)|(((($62<<24)>>24))|0)==((4)|0)|(((($62<<24)>>24))|0)==((6)|0)) {
     $64=((HEAP32[((14960)>>2)])|0);
     $65=(($64+((($i_240)*(104))&-1)+56)|0);
     $66=(+(HEAPF64[(($65)>>3)]));
     $67=$66!=(-10000000000.0);
     if (!($67)) {
      break;
     }
     $69=((HEAP32[((13232)>>2)])|0);
     $70=(($69+$i_240)|0);
     HEAP8[($70)]=4;
    }
   } while(0);
   $72=((HEAP32[((13232)>>2)])|0);
   $73=(($72+$i_240)|0);
   $74=((HEAP8[($73)])|0);
   $75=(($74<<24)>>24)<3;
   $76=((HEAP32[((13880)>>2)])|0);
   $77=(($76+($i_240<<3))|0);
   do {
    if ($75) {
     HEAPF64[(($77)>>3)]=0.000001;
    } else {
     $80=(+(HEAPF64[(($77)>>3)]));
     $81=$80<(0.0);
     if ($81) {
      $83=((-.0))-($80);
      $85=$83;
     } else {
      $85=$80;
     }

     $86=$85<=(0.000001);
     $or_cond=$86|$35;
     if (!($or_cond)) {
      break;
     }
     $88=((HEAP32[((13232)>>2)])|0);
     $89=(($88+$i_240)|0);
     $90=((HEAP8[($89)])|0);
     $91=((HEAP32[((15000)>>2)])|0);
     $92=(($91+($i_240<<3))|0);
     $93=(+(HEAPF64[(($92)>>3)]));
     _initlinkflow($i_240,$90,$93);
    }
   } while(0);
   $95=((HEAP32[((13232)>>2)])|0);
   $96=(($95+$i_240)|0);
   $97=((HEAP8[($96)])|0);
   $98=((HEAP32[((14320)>>2)])|0);
   $99=(($98+$i_240)|0);
   HEAP8[($99)]=$97;
   $100=((($i_240)+(1))|0);
   $101=((HEAP32[((14424)>>2)])|0);
   $102=($100|0)>($101|0);
   if ($102) {
    break;
   } else {
    $i_240=$100;
   }
  }
 }
 $47=((HEAP32[((14368)>>2)])|0);
 $48=($47|0)<1;
 if (!($48)) {
  $i_338=1;
  while(1) {

   $103=((HEAP32[((13888)>>2)])|0);
   $104=(($103+($i_338<<7)+80)|0);
   HEAPF64[(($104)>>3)]=0.0;
   $105=((HEAP32[((13888)>>2)])|0);
   $106=(($105+($i_338<<7)+88)|0);
   HEAPF64[(($106)>>3)]=0.0;
   $107=((HEAP32[((13888)>>2)])|0);
   $108=(($107+($i_338<<7)+96)|0);
   HEAPF64[(($108)>>3)]=0.0;
   $109=((HEAP32[((13888)>>2)])|0);
   $110=(($109+($i_338<<7)+104)|0);
   HEAPF64[(($110)>>3)]=0.0;
   $111=((HEAP32[((13888)>>2)])|0);
   $112=(($111+($i_338<<7)+112)|0);
   HEAPF64[(($112)>>3)]=0.0;
   $113=((HEAP32[((13888)>>2)])|0);
   $114=(($113+($i_338<<7)+120)|0);
   HEAPF64[(($114)>>3)]=0.0;
   $115=((($i_338)+(1))|0);
   $116=((HEAP32[((14368)>>2)])|0);
   $117=($115|0)>($116|0);
   if ($117) {
    break;
   } else {
    $i_338=$115;
   }
  }
 }
 $118=((HEAP8[(13208)])|0);
 $119=(($118<<24)>>24)==0;
 if ($119) {
  HEAP32[((15592)>>2)]=0;
  HEAP32[((15576)>>2)]=0;
  HEAP32[((15280)>>2)]=0;
  $125=((HEAP32[((13272)>>2)])|0);
  HEAP32[((13264)>>2)]=$125;
  return;
 }
 $121=((HEAP32[((15568)>>2)])|0);
 $122=((HEAP32[((15296)>>2)])|0);
 $123=((_fseek((($121)|0),(($122)|0),((0)|0)))|0);
 HEAP32[((15592)>>2)]=0;
 HEAP32[((15576)>>2)]=0;
 HEAP32[((15280)>>2)]=0;
 $125=((HEAP32[((13272)>>2)])|0);
 HEAP32[((13264)>>2)]=$125;
 return;
}


function _runhyd($t){
 $t=($t)|0;
 var $iter=0,$relerr=0,$1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$9=0,$10=.0,$12=.0,$13=.0,$14=0,$15=0,$16=0,$or_cond=0,$20=0,$21=.0,$22=0,$errcode_0=0;
 var label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $iter=((sp)|0);
 $relerr=(((sp)+(8))|0);
 $1=((HEAP32[((15576)>>2)])|0);
 HEAP32[(($t)>>2)]=$1;
 _demands();
 $2=((_controls())|0);
 $3=((_netsolve($iter,$relerr))|0);
 $4=($3|0)!=0;
 if ($4) {
  $errcode_0=$3;

  STACKTOP=sp;return (($errcode_0)|0);
 }
 $6=((HEAP8[(13192)])|0);
 $7=(($6<<24)>>24)==0;
 if (!($7)) {
  $9=((HEAP32[(($iter)>>2)])|0);
  $10=(+(HEAPF64[(($relerr)>>3)]));
  _writehydstat($9,$10);
 }
 $12=(+(HEAPF64[(($relerr)>>3)]));
 $13=(+(HEAPF64[((11240)>>3)]));
 $14=$12>$13;
 $15=((HEAP32[((17512)>>2)])|0);
 $16=($15|0)==-1;
 $or_cond=$14&$16;
 if ($or_cond) {
  HEAP32[((15592)>>2)]=1;
 }
 if ($4) {
  $errcode_0=$3;

  STACKTOP=sp;return (($errcode_0)|0);
 }
 $20=((HEAP32[(($iter)>>2)])|0);
 $21=(+(HEAPF64[(($relerr)>>3)]));
 $22=((_writehydwarn($20,$21))|0);
 $errcode_0=$22;

 STACKTOP=sp;return (($errcode_0)|0);
}


function _demands(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$i_044=0,$10=0,$11=0,$demand_038=0,$12=0,$demand_040=0,$sum_039=.0,$13=0,$14=0,$15=0,$16=0;
 var $17=0,$18=0,$19=0,$20=.0,$21=0,$22=0,$23=0,$24=.0,$25=.0,$26=.0,$27=.0,$28=0,$30=.0,$31=.0,$33=.0,$34=0,$demand_0=0,$35=0,$sum_0_lcssa=.0,$36=0;
 var $37=0,$38=0,$39=0,$40=0,$41=0,$42=0,$n_036=0,$43=0,$44=0,$45=.0,$46=0,$48=0,$49=0,$50=0,$52=0,$53=0,$54=0,$55=0,$56=0,$57=0;
 var $58=0,$59=0,$60=.0,$61=0,$62=0,$63=0,$64=.0,$65=.0,$66=0,$67=0,$69=0,$70=0,$71=0,$n_134=0,$72=0,$73=0,$74=0,$75=0,$77=0,$78=0;
 var $79=0,$80=0,$81=0,$82=0,$83=0,$84=0,$85=0,$86=.0,$87=0,$88=0,$89=0,$90=0,$92=0,$93=0,$94=0,label=0;

 $1=((HEAP32[((15576)>>2)])|0);
 $2=((HEAP32[((13904)>>2)])|0);
 $3=((($2)+($1))|0);
 $4=((HEAP32[((13896)>>2)])|0);
 $5=(((($3|0))/(($4|0)))&-1);
 HEAPF64[((11360)>>3)]=0.0;
 $6=((HEAP32[((14432)>>2)])|0);
 $7=($6|0)<1;
 if (!($7)) {
  $i_044=1;
  while(1) {

   $10=((HEAP32[((14408)>>2)])|0);
   $11=(($10+((($i_044)*(72))&-1)+40)|0);
   $demand_038=((HEAP32[(($11)>>2)])|0);
   $12=($demand_038|0)==0;
   if ($12) {
    $sum_0_lcssa=0.0;
   } else {
    $sum_039=0.0;$demand_040=$demand_038;
    while(1) {


     $13=(($demand_040+8)|0);
     $14=((HEAP32[(($13)>>2)])|0);
     $15=((HEAP32[((13944)>>2)])|0);
     $16=(($15+((($14)*(40))&-1)+32)|0);
     $17=((HEAP32[(($16)>>2)])|0);
     $18=(((($5|0))%(($17|0)))&-1);
     $19=(($demand_040)|0);
     $20=(+(HEAPF64[(($19)>>3)]));
     $21=(($15+((($14)*(40))&-1)+36)|0);
     $22=((HEAP32[(($21)>>2)])|0);
     $23=(($22+($18<<3))|0);
     $24=(+(HEAPF64[(($23)>>3)]));
     $25=($20)*($24);
     $26=(+(HEAPF64[((11368)>>3)]));
     $27=($25)*($26);
     $28=$27>(0.0);
     if ($28) {
      $30=(+(HEAPF64[((11360)>>3)]));
      $31=($27)+($30);
      HEAPF64[((11360)>>3)]=$31;
     }
     $33=($sum_039)+($27);
     $34=(($demand_040+12)|0);
     $demand_0=((HEAP32[(($34)>>2)])|0);
     $35=($demand_0|0)==0;
     if ($35) {
      $sum_0_lcssa=$33;
      break;
     } else {
      $sum_039=$33;$demand_040=$demand_0;
     }
    }
   }

   $36=((HEAP32[((17632)>>2)])|0);
   $37=(($36+($i_044<<3))|0);
   HEAPF64[(($37)>>3)]=$sum_0_lcssa;
   $38=((($i_044)+(1))|0);
   $39=((HEAP32[((14432)>>2)])|0);
   $40=($38|0)>($39|0);
   if ($40) {
    break;
   } else {
    $i_044=$38;
   }
  }
 }
 $8=((HEAP32[((14352)>>2)])|0);
 $9=($8|0)<1;
 if (!($9)) {
  $n_036=1;
  while(1) {

   $43=((HEAP32[((13176)>>2)])|0);
   $44=(($43+((($n_036)*(112))&-1)+8)|0);
   $45=(+(HEAPF64[(($44)>>3)]));
   $46=$45==(0.0);
   do {
    if ($46) {
     $48=(($43+((($n_036)*(112))&-1)+88)|0);
     $49=((HEAP32[(($48)>>2)])|0);
     $50=($49|0)>0;
     if (!($50)) {
      break;
     }
     $52=((HEAP32[((13944)>>2)])|0);
     $53=(($52+((($49)*(40))&-1)+32)|0);
     $54=((HEAP32[(($53)>>2)])|0);
     $55=(((($5|0))%(($54|0)))&-1);
     $56=(($43+((($n_036)*(112))&-1))|0);
     $57=((HEAP32[(($56)>>2)])|0);
     $58=((HEAP32[((14408)>>2)])|0);
     $59=(($58+((($57)*(72))&-1)+32)|0);
     $60=(+(HEAPF64[(($59)>>3)]));
     $61=(($52+((($49)*(40))&-1)+36)|0);
     $62=((HEAP32[(($61)>>2)])|0);
     $63=(($62+($55<<3))|0);
     $64=(+(HEAPF64[(($63)>>3)]));
     $65=($60)*($64);
     $66=((HEAP32[((15600)>>2)])|0);
     $67=(($66+($57<<3))|0);
     HEAPF64[(($67)>>3)]=$65;
    }
   } while(0);
   $69=((($n_036)+(1))|0);
   $70=((HEAP32[((14352)>>2)])|0);
   $71=($69|0)>($70|0);
   if ($71) {
    break;
   } else {
    $n_036=$69;
   }
  }
 }
 $41=((HEAP32[((14368)>>2)])|0);
 $42=($41|0)<1;
 if ($42) {
  return;
 } else {
  $n_134=1;
 }
 while(1) {

  $72=((HEAP32[((13888)>>2)])|0);
  $73=(($72+($n_134<<7)+64)|0);
  $74=((HEAP32[(($73)>>2)])|0);
  $75=($74|0)>0;
  if ($75) {
   $77=(($72+($n_134<<7))|0);
   $78=((HEAP32[(($77)>>2)])|0);
   $79=((HEAP32[((13944)>>2)])|0);
   $80=(($79+((($74)*(40))&-1)+32)|0);
   $81=((HEAP32[(($80)>>2)])|0);
   $82=(((($5|0))%(($81|0)))&-1);
   $83=(($79+((($74)*(40))&-1)+36)|0);
   $84=((HEAP32[(($83)>>2)])|0);
   $85=(($84+($82<<3))|0);
   $86=(+(HEAPF64[(($85)>>3)]));
   $87=((HEAP32[((13232)>>2)])|0);
   $88=(($87+$78)|0);
   $89=((HEAP32[((15000)>>2)])|0);
   $90=(($89+($78<<3))|0);
   _setlinksetting($78,$86,$88,$90);
  }
  $92=((($n_134)+(1))|0);
  $93=((HEAP32[((14368)>>2)])|0);
  $94=($92|0)>($93|0);
  if ($94) {
   break;
  } else {
   $n_134=$92;
  }
 }
 return;
}


function _controls(){
 var $1=0,$2=0,$i_034=0,$setsum_033=0,$3=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$12=0,$or_cond=0,$14=0,$15=0,$16=.0,$17=0,$18=0,$19=.0;
 var $20=0,$22=.0,$24=.0,$25=0,$26=0,$27=.0,$28=0,$29=0,$30=0,$31=0,$32=.0,$33=.0,$34=0,$35=0,$36=0,$37=0,$39=.0,$40=0,$reset_0=0,$43=0;
 var $44=0,$45=0,$46=0,$48=.0,$49=0,$reset_1=0,$52=0,$53=0,$54=0,$55=0,$57=0,$58=0,$59=0,$60=0,$_reset_1=0,$reset_2=0,$62=0,$63=0,$64=0,$65=0;
 var $67=0,$68=0,$69=0,$70=0,$71=0,$72=0,$73=0,$_reset_2=0,$reset_3=0,$75=0,$77=0,$78=0,$79=0,$80=0,$_=0,$81=0,$82=0,$83=0,$84=0,$85=0;
 var $86=.0,$87=0,$88=0,$89=0,$90=0,$92=0,$93=.0,$k2_0=.0,$95=0,$96=0,$97=0,$or_cond32=0,$99=0,$100=0,$101=0,$102=0,$103=0,$104=0,$107=0,$setsum_1=0;
 var $109=0,$110=0,$111=0,$setsum_0_lcssa=0,label=0;

 $1=((HEAP32[((14464)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  $setsum_0_lcssa=0;

  return (($setsum_0_lcssa)|0);
 } else {
  $setsum_033=0;$i_034=1;
 }
 while(1) {


  $3=((HEAP32[((17656)>>2)])|0);
  $4=(($3+((($i_034)*(40))&-1))|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=($5|0)<1;
  do {
   if ($6) {
    $setsum_1=$setsum_033;
   } else {
    $8=(($3+((($i_034)*(40))&-1)+4)|0);
    $9=((HEAP32[(($8)>>2)])|0);
    $10=($9|0)>0;
    $11=((HEAP32[((14432)>>2)])|0);
    $12=($9|0)>($11|0);
    $or_cond=$10&$12;
    do {
     if ($or_cond) {
      $14=((HEAP32[((15600)>>2)])|0);
      $15=(($14+($9<<3))|0);
      $16=(+(HEAPF64[(($15)>>3)]));
      $17=((HEAP32[((17632)>>2)])|0);
      $18=(($17+($9<<3))|0);
      $19=(+(HEAPF64[(($18)>>3)]));
      $20=$19<(0.0);
      if ($20) {
       $22=((-.0))-($19);
       $24=$22;
      } else {
       $24=$19;
      }

      $25=((HEAP32[((14432)>>2)])|0);
      $26=((($9)-($25))|0);
      $27=(+(_tankvolume($26,$16)));
      $28=((HEAP32[((14432)>>2)])|0);
      $29=((($9)-($28))|0);
      $30=((HEAP32[((17656)>>2)])|0);
      $31=(($30+((($i_034)*(40))&-1)+16)|0);
      $32=(+(HEAPF64[(($31)>>3)]));
      $33=(+(_tankvolume($29,$32)));
      $34=((HEAP32[((17656)>>2)])|0);
      $35=(($34+((($i_034)*(40))&-1)+33)|0);
      $36=((HEAP8[($35)])|0);
      $37=(($36<<24)>>24)==0;
      do {
       if ($37) {
        $39=($24)+($33);
        $40=$27>$39;
        if ($40) {
         $reset_0=0;
         break;
        }
        $reset_0=1;
       } else {
        $reset_0=0;
       }
      } while(0);

      $43=((HEAP32[((17656)>>2)])|0);
      $44=(($43+((($i_034)*(40))&-1)+33)|0);
      $45=((HEAP8[($44)])|0);
      $46=(($45<<24)>>24)==1;
      if (!($46)) {
       $reset_1=$reset_0;
       break;
      }
      $48=($33)-($24);
      $49=$27<$48;
      if ($49) {
       $reset_1=$reset_0;
       break;
      }
      $reset_1=1;
     } else {
      $reset_1=0;
     }
    } while(0);

    $52=((HEAP32[((17656)>>2)])|0);
    $53=(($52+((($i_034)*(40))&-1)+33)|0);
    $54=((HEAP8[($53)])|0);
    $55=(($54<<24)>>24)==2;
    if ($55) {
     $57=(($52+((($i_034)*(40))&-1)+8)|0);
     $58=((HEAP32[(($57)>>2)])|0);
     $59=((HEAP32[((15576)>>2)])|0);
     $60=($58|0)==($59|0);
     $_reset_1=($60?1:$reset_1);
     $reset_2=$_reset_1;
    } else {
     $reset_2=$reset_1;
    }

    $62=((HEAP32[((17656)>>2)])|0);
    $63=(($62+((($i_034)*(40))&-1)+33)|0);
    $64=((HEAP8[($63)])|0);
    $65=(($64<<24)>>24)==3;
    if ($65) {
     $67=((HEAP32[((15576)>>2)])|0);
     $68=((HEAP32[((12216)>>2)])|0);
     $69=((($68)+($67))|0);
     $70=(((($69|0))%(86400))&-1);
     $71=(($62+((($i_034)*(40))&-1)+8)|0);
     $72=((HEAP32[(($71)>>2)])|0);
     $73=($70|0)==($72|0);
     $_reset_2=($73?1:$reset_2);
     $reset_3=$_reset_2;
    } else {
     $reset_3=$reset_2;
    }

    $75=($reset_3|0)==1;
    if (!($75)) {
     $setsum_1=$setsum_033;
     break;
    }
    $77=((HEAP32[((13232)>>2)])|0);
    $78=(($77+$5)|0);
    $79=((HEAP8[($78)])|0);
    $80=(($79<<24)>>24)<3;
    $_=($80?2:3);
    $81=((HEAP32[((17656)>>2)])|0);
    $82=(($81+((($i_034)*(40))&-1)+32)|0);
    $83=((HEAP8[($82)])|0);
    $84=((HEAP32[((15000)>>2)])|0);
    $85=(($84+($5<<3))|0);
    $86=(+(HEAPF64[(($85)>>3)]));
    $87=((HEAP32[((14960)>>2)])|0);
    $88=(($87+((($5)*(104))&-1)+96)|0);
    $89=((HEAP8[($88)])|0);
    $90=(($89<<24)>>24)>1;
    if ($90) {
     $92=(($81+((($i_034)*(40))&-1)+24)|0);
     $93=(+(HEAPF64[(($92)>>3)]));
     $k2_0=$93;
    } else {
     $k2_0=$86;
    }

    $95=(($83<<24)>>24);
    $96=($_|0)!=($95|0);
    $97=$86!=$k2_0;
    $or_cond32=$96|$97;
    if (!($or_cond32)) {
     $setsum_1=$setsum_033;
     break;
    }
    $99=((HEAP32[((13232)>>2)])|0);
    $100=(($99+$5)|0);
    HEAP8[($100)]=$83;
    $101=((HEAP32[((15000)>>2)])|0);
    $102=(($101+($5<<3))|0);
    HEAPF64[(($102)>>3)]=$k2_0;
    $103=((HEAP8[(13192)])|0);
    $104=(($103<<24)>>24)==0;
    if (!($104)) {
     _writecontrolaction($5,$i_034);
    }
    $107=((($setsum_033)+(1))|0);
    $setsum_1=$107;
   }
  } while(0);

  $109=((($i_034)+(1))|0);
  $110=((HEAP32[((14464)>>2)])|0);
  $111=($109|0)>($110|0);
  if ($111) {
   $setsum_0_lcssa=$setsum_1;
   break;
  } else {
   $setsum_033=$setsum_1;$i_034=$109;
  }
 }

 return (($setsum_0_lcssa)|0);
}


function _netsolve($iter,$relerr){
 $iter=($iter)|0;
 $relerr=($relerr)|0;
 var $1=0,$2=0,$3=0,$6=0,$7=0,$8=0,$9=0,$maxtrials_0=0,$storemerge=0,$errcode_0_ph=0,$nextcheck_0_ph=0,$errcode_0=0,$11=0,$12=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0;
 var $21=0,$22=0,$23=0,$25=0,$26=0,$27=0,$28=0,$29=0,$i_027=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=.0,$36=0,$37=0,$38=0,$39=0,$40=0;
 var $41=.0,$42=0,$43=0,$45=0,$47=.0,$48=0,$50=.0,$51=0,$53=0,$55=0,$valveChange_0=0,$57=.0,$58=.0,$59=0,$60=0,$62=0,$63=0,$not_=0,$_=0,$65=0;
 var $66=0,$statChange_1=0,$67=0,$68=0,$69=0,$71=0,$72=0,$73=0,$75=0,$76=0,$77=0,$or_cond=0,$79=0,$80=0,$81=0,$nextcheck_1=0,$83=0,$84=0,$errcode_1=0,$85=0;
 var $87=0,$89=0,$90=0,$91=0,$errcode_2=0,$92=0,$93=0,$i_126=0,$94=0,$95=0,$96=.0,$97=0,$98=0,$99=.0,$100=.0,$101=0,$102=0,$103=0,label=0;

 $1=((HEAP32[((17728)>>2)])|0);
 HEAPF64[((10976)>>3)]=1.0;
 $2=((HEAP8[(13192)])|0);
 $3=(($2<<24)>>24)==2;
 if ($3) {
  _writerelerr(0,0.0);
 }
 $6=((HEAP32[((14648)>>2)])|0);
 $7=((HEAP32[((17512)>>2)])|0);
 $8=($7|0)>0;
 $9=($8?$7:0);
 $maxtrials_0=((($9)+($6))|0);
 $nextcheck_0_ph=$1;$errcode_0_ph=0;$storemerge=1;
 L4: while(1) {



  HEAP32[(($iter)>>2)]=$storemerge;
  $errcode_0=$errcode_0_ph;
  while(1) {

   $11=((HEAP32[(($iter)>>2)])|0);
   $12=($11|0)>($maxtrials_0|0);
   if ($12) {
    $errcode_1=$errcode_0;
    label = 24;
    break L4;
   }
   _newcoeffs();
   $14=((HEAP32[((14432)>>2)])|0);
   $15=((HEAP32[((17768)>>2)])|0);
   $16=((HEAP32[((17760)>>2)])|0);
   $17=((HEAP32[((17504)>>2)])|0);
   $18=((_linsolve($14,$15,$16,$17))|0);
   $19=($18|0)<0;
   if ($19) {
    $errcode_2=101;
    break L4;
   }
   $21=($18|0)>0;
   if (!($21)) {
    break;
   }
   $25=((HEAP32[((14288)>>2)])|0);
   $26=(($25+($18<<2))|0);
   $27=((HEAP32[(($26)>>2)])|0);
   $28=((_badvalve($27))|0);
   $29=($28|0)==0;
   if ($29) {
    $errcode_1=$18;
    label = 24;
    break L4;
   } else {
    $errcode_0=$18;
   }
  }
  $22=((HEAP32[((14432)>>2)])|0);
  $23=($22|0)<1;
  if (!($23)) {
   $i_027=1;
   while(1) {

    $30=((HEAP32[((13832)>>2)])|0);
    $31=(($30+($i_027<<2))|0);
    $32=((HEAP32[(($31)>>2)])|0);
    $33=((HEAP32[((17504)>>2)])|0);
    $34=(($33+($32<<3))|0);
    $35=(+(HEAPF64[(($34)>>3)]));
    $36=((HEAP32[((15600)>>2)])|0);
    $37=(($36+($i_027<<3))|0);
    HEAPF64[(($37)>>3)]=$35;
    $38=((($i_027)+(1))|0);
    $39=((HEAP32[((14432)>>2)])|0);
    $40=($38|0)>($39|0);
    if ($40) {
     break;
    } else {
     $i_027=$38;
    }
   }
  }
  $41=(+(_newflows()));
  HEAPF64[(($relerr)>>3)]=$41;
  $42=((HEAP8[(13192)])|0);
  $43=(($42<<24)>>24)==2;
  if ($43) {
   $45=((HEAP32[(($iter)>>2)])|0);
   _writerelerr($45,$41);
  }
  HEAPF64[((10976)>>3)]=1.0;
  $47=(+(HEAPF64[((11392)>>3)]));
  $48=$47>(0.0);
  do {
   if ($48) {
    $50=(+(HEAPF64[(($relerr)>>3)]));
    $51=$50>$47;
    if ($51) {
     $valveChange_0=0;
     break;
    }
    HEAPF64[((10976)>>3)]=0.6;
    $53=((_valvestatus())|0);
    $valveChange_0=$53;
   } else {
    $55=((_valvestatus())|0);
    $valveChange_0=$55;
   }
  } while(0);

  $57=(+(HEAPF64[(($relerr)>>3)]));
  $58=(+(HEAPF64[((11240)>>3)]));
  $59=$57>$58;
  $60=((HEAP32[(($iter)>>2)])|0);
  do {
   if ($59) {
    $75=((HEAP32[((14672)>>2)])|0);
    $76=($60|0)<=($75|0);
    $77=($60|0)==($nextcheck_0_ph|0);
    $or_cond=$76&$77;
    if (!($or_cond)) {
     $nextcheck_1=$nextcheck_0_ph;
     break;
    }
    $79=((_linkstatus())|0);
    $80=((HEAP32[((17728)>>2)])|0);
    $81=((($80)+($nextcheck_0_ph))|0);
    $nextcheck_1=$81;
   } else {
    $62=((HEAP32[((14648)>>2)])|0);
    $63=($60|0)>($62|0);
    if ($63) {
     $errcode_1=$18;
     label = 24;
     break L4;
    }
    $not_=($valveChange_0|0)!=0;
    $_=($not_&1);
    $65=((_linkstatus())|0);
    $66=($65|0)==0;
    $statChange_1=($66?$_:1);
    $67=((_pswitch())|0);
    $68=$statChange_1|$67;
    $69=($68|0)==0;
    if ($69) {
     $errcode_1=$18;
     label = 24;
     break L4;
    }
    $71=((HEAP32[(($iter)>>2)])|0);
    $72=((HEAP32[((17728)>>2)])|0);
    $73=((($72)+($71))|0);
    $nextcheck_1=$73;
   }
  } while(0);

  $83=((HEAP32[(($iter)>>2)])|0);
  $84=((($83)+(1))|0);
  $nextcheck_0_ph=$nextcheck_1;$errcode_0_ph=$18;$storemerge=$84;
 }
 do {
  if ((label|0) == 24) {

   $85=($errcode_1|0)<0;
   if ($85) {
    $errcode_2=101;
    break;
   }
   $87=($errcode_1|0)>0;
   if (!($87)) {
    $errcode_2=0;
    break;
   }
   $89=((HEAP32[((14288)>>2)])|0);
   $90=(($89+($errcode_1<<2))|0);
   $91=((HEAP32[(($90)>>2)])|0);
   _writehyderr($91);
   $errcode_2=110;
  }
 } while(0);

 $92=((HEAP32[((14432)>>2)])|0);
 $93=($92|0)<1;
 if ($93) {
  return (($errcode_2)|0);
 } else {
  $i_126=1;
 }
 while(1) {

  $94=((HEAP32[((17536)>>2)])|0);
  $95=(($94+($i_126<<3))|0);
  $96=(+(HEAPF64[(($95)>>3)]));
  $97=((HEAP32[((17632)>>2)])|0);
  $98=(($97+($i_126<<3))|0);
  $99=(+(HEAPF64[(($98)>>3)]));
  $100=($96)+($99);
  HEAPF64[(($98)>>3)]=$100;
  $101=((($i_126)+(1))|0);
  $102=((HEAP32[((14432)>>2)])|0);
  $103=($101|0)>($102|0);
  if ($103) {
   break;
  } else {
   $i_126=$101;
  }
 }
 return (($errcode_2)|0);
}


function _nexthyd($tstep){
 $tstep=($tstep)|0;
 var $hydstep=0,$1=0,$2=0,$4=0,$errcode_0=0,$6=0,$7=0,$9=0,$11=0,$12=0,$13=0,$15=0,$17=0,$18=0,$20=0,$errcode_1=0,$22=0,$23=0,$26=0,$27=0;
 var $29=0,$31=0,$32=0,$33=0,$35=0,$36=0,$37=0,$38=0,$40=0,$41=0,$43=0,$45=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $hydstep=((sp)|0);
 $1=((HEAP8[(13208)])|0);
 $2=(($1<<24)>>24)==0;
 if ($2) {
  $errcode_0=0;
 } else {
  $4=((_savehyd(15576))|0);
  $errcode_0=$4;
 }

 $6=((HEAP32[((15592)>>2)])|0);
 $7=($6|0)==0;
 if (!($7)) {
  $9=((HEAP32[((17544)>>2)])|0);
  HEAP32[((15576)>>2)]=$9;
 }
 HEAP32[(($tstep)>>2)]=0;
 HEAP32[(($hydstep)>>2)]=0;
 $11=((HEAP32[((15576)>>2)])|0);
 $12=((HEAP32[((17544)>>2)])|0);
 $13=($11|0)<($12|0);
 if ($13) {
  $15=((_timestep())|0);
  HEAP32[(($hydstep)>>2)]=$15;
 }
 $17=((HEAP8[(13208)])|0);
 $18=(($17<<24)>>24)==0;
 if ($18) {
  $errcode_1=$errcode_0;
 } else {
  $20=((_savehydstep($hydstep))|0);
  $errcode_1=$20;
 }

 $22=((HEAP32[((17544)>>2)])|0);
 $23=($22|0)==0;
 do {
  if ($23) {
   _addenergy(0);
  } else {
   $26=((HEAP32[((15576)>>2)])|0);
   $27=($26|0)<($22|0);
   if (!($27)) {
    break;
   }
   $29=((HEAP32[(($hydstep)>>2)])|0);
   _addenergy($29);
  }
 } while(0);
 $31=((HEAP32[((15576)>>2)])|0);
 $32=((HEAP32[((17544)>>2)])|0);
 $33=($31|0)<($32|0);
 if (!($33)) {
  $43=((($31)+(1))|0);
  HEAP32[((15576)>>2)]=$43;
  $45=((HEAP32[(($hydstep)>>2)])|0);
  HEAP32[(($tstep)>>2)]=$45;
  STACKTOP=sp;return (($errcode_1)|0);
 }
 $35=((HEAP32[(($hydstep)>>2)])|0);
 $36=((($35)+($31))|0);
 HEAP32[((15576)>>2)]=$36;
 $37=((HEAP32[((13264)>>2)])|0);
 $38=($36|0)<($37|0);
 if ($38) {
  $45=((HEAP32[(($hydstep)>>2)])|0);
  HEAP32[(($tstep)>>2)]=$45;
  STACKTOP=sp;return (($errcode_1)|0);
 }
 $40=((HEAP32[((13272)>>2)])|0);
 $41=((($40)+($37))|0);
 HEAP32[((13264)>>2)]=$41;
 $45=((HEAP32[(($hydstep)>>2)])|0);
 HEAP32[(($tstep)>>2)]=$45;
 STACKTOP=sp;return (($errcode_1)|0);
}


function _timestep(){
 var $tstep=0,$1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$or_cond=0,$14=0,$15=0,$16=0,$17=0,$19=0,$20=0,$23=0;
 var $24=0,$27=0,$29=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $tstep=((sp)|0);
 $1=((HEAP32[((15584)>>2)])|0);
 HEAP32[(($tstep)>>2)]=$1;
 $2=((HEAP32[((15576)>>2)])|0);
 $3=((HEAP32[((13904)>>2)])|0);
 $4=((($3)+($2))|0);
 $5=((HEAP32[((13896)>>2)])|0);
 $6=(((($4|0))/(($5|0)))&-1);
 $7=((($6)+(1))|0);
 $8=(Math_imul($7,$5)|0);
 $9=((($8)-($2))|0);
 $10=($9|0)>0;
 $11=($9|0)<($1|0);
 $or_cond=$10&$11;
 if ($or_cond) {
  HEAP32[(($tstep)>>2)]=$9;
 }
 $14=((HEAP32[((13264)>>2)])|0);
 $15=((HEAP32[((15576)>>2)])|0);
 $16=((($14)-($15))|0);
 $17=($16|0)>0;
 do {
  if ($17) {
   $19=((HEAP32[(($tstep)>>2)])|0);
   $20=($16|0)<($19|0);
   if (!($20)) {
    break;
   }
   HEAP32[(($tstep)>>2)]=$16;
  }
 } while(0);
 _tanktimestep($tstep);
 _controltimestep($tstep);
 $23=((HEAP32[((14360)>>2)])|0);
 $24=($23|0)>0;
 if ($24) {
  _ruletimestep($tstep);
  $29=((HEAP32[(($tstep)>>2)])|0);
  STACKTOP=sp;return (($29)|0);
 } else {
  $27=((HEAP32[(($tstep)>>2)])|0);
  _tanklevels($27);
  $29=((HEAP32[(($tstep)>>2)])|0);
  STACKTOP=sp;return (($29)|0);
 }
}


function _addenergy($hstep){
 $hstep=($hstep)|0;
 var $e=0,$p=0,$1=0,$2=0,$4=0,$5=0,$7=.0,$8=.0,$9=0,$dt_033=.0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=.0,$16=0,$17=0,$19=0,$20=0;
 var $21=0,$22=0,$23=0,$24=0,$25=0,$26=.0,$f0_0=.0,$28=0,$29=0,$psum_036=.0,$j_034=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0,$38=0,$39=0;
 var $40=.0,$41=0,$43=.0,$45=.0,$46=0,$48=0,$49=0,$50=.0,$51=0,$53=.0,$55=.0,$56=0,$57=0,$58=.0,$59=0,$_=.0,$60=0,$61=0,$62=0,$64=0;
 var $65=0,$66=0,$67=0,$68=0,$69=0,$70=0,$71=.0,$_pn=.0,$c_1=.0,$73=.0,$74=.0,$75=0,$76=0,$77=.0,$78=.0,$79=.0,$80=.0,$81=0,$82=0,$83=.0;
 var $84=.0,$85=.0,$86=.0,$87=.0,$88=0,$89=0,$90=.0,$91=.0,$92=.0,$93=.0,$94=0,$95=0,$96=.0,$97=.0,$98=0,$99=0,$100=.0,$101=.0,$102=0,$_31=.0;
 var $103=.0,$104=.0,$105=.0,$106=0,$107=0,$108=.0,$109=.0,$psum_1=.0,$111=0,$112=0,$113=0,$psum_0_lcssa=.0,$114=.0,$115=0,$116=.0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $e=((sp)|0);
 $p=(((sp)+(8))|0);
 $1=((HEAP32[((17544)>>2)])|0);
 $2=($1|0)==0;
 do {
  if ($2) {
   $dt_033=1.0;
  } else {
   $4=((HEAP32[((15576)>>2)])|0);
   $5=($4|0)<($1|0);
   if (!($5)) {
    STACKTOP=sp;return;
   }
   $7=(+((($hstep|0))|0));
   $8=($7)/((3600.0));
   $9=$8==(0.0);
   if (!($9)) {
    $dt_033=$8;
    break;
   }
   STACKTOP=sp;return;
  }
 } while(0);

 $10=((HEAP32[((15576)>>2)])|0);
 $11=((HEAP32[((13904)>>2)])|0);
 $12=((($11)+($10))|0);
 $13=((HEAP32[((13896)>>2)])|0);
 $14=(((($12|0))/(($13|0)))&-1);
 $15=(+(HEAPF64[((11352)>>3)]));
 $16=((HEAP32[((17520)>>2)])|0);
 $17=($16|0)>0;
 if ($17) {
  $19=((HEAP32[((13944)>>2)])|0);
  $20=(($19+((($16)*(40))&-1)+32)|0);
  $21=((HEAP32[(($20)>>2)])|0);
  $22=(((($14|0))%(($21|0)))&-1);
  $23=(($19+((($16)*(40))&-1)+36)|0);
  $24=((HEAP32[(($23)>>2)])|0);
  $25=(($24+($22<<3))|0);
  $26=(+(HEAPF64[(($25)>>3)]));
  $f0_0=$26;
 } else {
  $f0_0=1.0;
 }

 $28=((HEAP32[((14368)>>2)])|0);
 $29=($28|0)<1;
 if ($29) {
  $psum_0_lcssa=0.0;
 } else {
  $j_034=1;$psum_036=0.0;
  while(1) {


   $30=((HEAP32[((13888)>>2)])|0);
   $31=(($30+($j_034<<7))|0);
   $32=((HEAP32[(($31)>>2)])|0);
   $33=((HEAP32[((13232)>>2)])|0);
   $34=(($33+$32)|0);
   $35=((HEAP8[($34)])|0);
   $36=(($35<<24)>>24)<3;
   if ($36) {
    $psum_1=$psum_036;
   } else {
    $38=((HEAP32[((13880)>>2)])|0);
    $39=(($38+($32<<3))|0);
    $40=(+(HEAPF64[(($39)>>3)]));
    $41=$40<(0.0);
    if ($41) {
     $43=((-.0))-($40);
     $45=$43;
    } else {
     $45=$40;
    }

    $46=$45>(0.000001);
    do {
     if ($46) {
      $48=((HEAP32[((13880)>>2)])|0);
      $49=(($48+($32<<3))|0);
      $50=(+(HEAPF64[(($49)>>3)]));
      $51=$50<(0.0);
      if (!($51)) {
       $55=$50;
       break;
      }
      $53=((-.0))-($50);
      $55=$53;
     } else {
      $55=0.000001;
     }
    } while(0);

    $56=((HEAP32[((13888)>>2)])|0);
    $57=(($56+($j_034<<7)+72)|0);
    $58=(+(HEAPF64[(($57)>>3)]));
    $59=$58>(0.0);
    $_=($59?$58:$15);
    $60=(($56+($j_034<<7)+68)|0);
    $61=((HEAP32[(($60)>>2)])|0);
    $62=($61|0)>0;
    if ($62) {
     $64=((HEAP32[((13944)>>2)])|0);
     $65=(($64+((($61)*(40))&-1)+32)|0);
     $66=((HEAP32[(($65)>>2)])|0);
     $67=(((($14|0))%(($66|0)))&-1);
     $68=(($64+((($61)*(40))&-1)+36)|0);
     $69=((HEAP32[(($68)>>2)])|0);
     $70=(($69+($67<<3))|0);
     $71=(+(HEAPF64[(($70)>>3)]));
     $_pn=$71;
    } else {
     $_pn=$f0_0;
    }

    $c_1=($_)*($_pn);
    _getenergy($32,$p,$e);
    $73=(+(HEAPF64[(($p)>>3)]));
    $74=($psum_036)+($73);
    $75=((HEAP32[((13888)>>2)])|0);
    $76=(($75+($j_034<<7)+80)|0);
    $77=(+(HEAPF64[(($76)>>3)]));
    $78=($dt_033)+($77);
    HEAPF64[(($76)>>3)]=$78;
    $79=(+(HEAPF64[(($e)>>3)]));
    $80=($dt_033)*($79);
    $81=((HEAP32[((13888)>>2)])|0);
    $82=(($81+($j_034<<7)+88)|0);
    $83=(+(HEAPF64[(($82)>>3)]));
    $84=($80)+($83);
    HEAPF64[(($82)>>3)]=$84;
    $85=(+(HEAPF64[(($p)>>3)]));
    $86=($85)/($55);
    $87=($dt_033)*($86);
    $88=((HEAP32[((13888)>>2)])|0);
    $89=(($88+($j_034<<7)+96)|0);
    $90=(+(HEAPF64[(($89)>>3)]));
    $91=($87)+($90);
    HEAPF64[(($89)>>3)]=$91;
    $92=(+(HEAPF64[(($p)>>3)]));
    $93=($dt_033)*($92);
    $94=((HEAP32[((13888)>>2)])|0);
    $95=(($94+($j_034<<7)+104)|0);
    $96=(+(HEAPF64[(($95)>>3)]));
    $97=($93)+($96);
    HEAPF64[(($95)>>3)]=$97;
    $98=((HEAP32[((13888)>>2)])|0);
    $99=(($98+($j_034<<7)+112)|0);
    $100=(+(HEAPF64[(($99)>>3)]));
    $101=(+(HEAPF64[(($p)>>3)]));
    $102=$100<$101;
    $_31=($102?$101:$100);
    HEAPF64[(($99)>>3)]=$_31;
    $103=(+(HEAPF64[(($p)>>3)]));
    $104=($c_1)*($103);
    $105=($dt_033)*($104);
    $106=((HEAP32[((13888)>>2)])|0);
    $107=(($106+($j_034<<7)+120)|0);
    $108=(+(HEAPF64[(($107)>>3)]));
    $109=($108)+($105);
    HEAPF64[(($107)>>3)]=$109;
    $psum_1=$74;
   }

   $111=((($j_034)+(1))|0);
   $112=((HEAP32[((14368)>>2)])|0);
   $113=($111|0)>($112|0);
   if ($113) {
    $psum_0_lcssa=$psum_1;
    break;
   } else {
    $j_034=$111;$psum_036=$psum_1;
   }
  }
 }

 $114=(+(HEAPF64[((11344)>>3)]));
 $115=$114>=$psum_0_lcssa;
 $116=($115?$114:$psum_0_lcssa);
 HEAPF64[((11344)>>3)]=$116;
 STACKTOP=sp;return;
}


function _closehyd(){
 var label=0;

 _freesparse();
 _freematrix();
 return;
}


function _freematrix(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,label=0;

 $1=((HEAP32[((17768)>>2)])|0);
 _free($1);
 $3=((HEAP32[((17760)>>2)])|0);
 _free($3);
 $5=((HEAP32[((17504)>>2)])|0);
 _free($5);
 $7=((HEAP32[((17536)>>2)])|0);
 _free($7);
 $9=((HEAP32[((13976)>>2)])|0);
 _free($9);
 $11=((HEAP32[((11984)>>2)])|0);
 _free($11);
 $13=((HEAP32[((12000)>>2)])|0);
 _free($13);
 $15=((HEAP32[((14320)>>2)])|0);
 _free($15);
 return;
}


function _setlinkstatus($index,$value,$s,$k){
 $index=($index)|0;
 $value=($value)|0;
 $s=($s)|0;
 $k=($k)|0;
 var $2=0,$3=0,$4=0,$5=0,$8=0,$9=0,$10=0,$11=0,$12=0,$or_cond=0,$16=0,$17=0,$18=0,$19=0,$22=0,$23=0,$24=0,$25=0,$26=0,$or_cond14=0;
 var label=0;

 if ((((($value<<24)>>24))|0)==((0)|0)) {
  $16=((HEAP32[((14960)>>2)])|0);
  $17=(($16+((($index)*(104))&-1)+96)|0);
  $18=((HEAP8[($17)])|0);
  $19=(($18<<24)>>24)==2;
  if ($19) {
   HEAPF64[(($k)>>3)]=0.0;
  }
  $22=((HEAP32[((14960)>>2)])|0);
  $23=(($22+((($index)*(104))&-1)+96)|0);
  $24=((HEAP8[($23)])|0);
  $25=(($24<<24)>>24)<3;
  $26=(($24<<24)>>24)==8;
  $or_cond14=$25|$26;
  if (!($or_cond14)) {
   HEAPF64[(($k)>>3)]=-10000000000.0;
  }
  HEAP8[($s)]=2;
  return;
 } else if ((((($value<<24)>>24))|0)==((1)|0)) {
  $2=((HEAP32[((14960)>>2)])|0);
  $3=(($2+((($index)*(104))&-1)+96)|0);
  $4=((HEAP8[($3)])|0);
  $5=(($4<<24)>>24)==2;
  if ($5) {
   HEAPF64[(($k)>>3)]=1.0;
  }
  $8=((HEAP32[((14960)>>2)])|0);
  $9=(($8+((($index)*(104))&-1)+96)|0);
  $10=((HEAP8[($9)])|0);
  $11=(($10<<24)>>24)<3;
  $12=(($10<<24)>>24)==8;
  $or_cond=$11|$12;
  if (!($or_cond)) {
   HEAPF64[(($k)>>3)]=-10000000000.0;
  }
  HEAP8[($s)]=3;
  return;
 } else {
  return;
 }
}


function _setlinksetting($index,$value,$s,$k){
 $index=($index)|0;
 $value=+($value);
 $s=($s)|0;
 $k=($k)|0;
 var $1=0,$2=0,$3=0,$5=0,$7=0,$8=0,$11=0,$13=0,$14=0,$18=.0,$19=0,$21=0,$22=0,label=0;

 $1=((HEAP32[((14960)>>2)])|0);
 $2=(($1+((($index)*(104))&-1)+96)|0);
 $3=((HEAP8[($2)])|0);
 if ((((($3<<24)>>24))|0)==((6)|0)) {
  HEAPF64[(($k)>>3)]=$value;
  HEAP8[($s)]=4;
  return;
 } else if ((((($3<<24)>>24))|0)==((2)|0)) {
  HEAPF64[(($k)>>3)]=$value;
  $5=$value>(0.0);
  do {
   if ($5) {
    $7=((HEAP8[($s)])|0);
    $8=(($7<<24)>>24)<3;
    if (!($8)) {
     break;
    }
    HEAP8[($s)]=3;
   }
  } while(0);
  $11=$value==(0.0);
  if (!($11)) {
   return;
  }
  $13=((HEAP8[($s)])|0);
  $14=(($13<<24)>>24)>2;
  if (!($14)) {
   return;
  }
  HEAP8[($s)]=2;
  return;
 } else {
  $18=(+(HEAPF64[(($k)>>3)]));
  $19=$18==(-10000000000.0);
  do {
   if ($19) {
    $21=((HEAP8[($s)])|0);
    $22=(($21<<24)>>24)<3;
    if (!($22)) {
     break;
    }
    HEAP8[($s)]=3;
   }
  } while(0);
  HEAPF64[(($k)>>3)]=$value;
  return;
 }
}


function _resistance($k){
 $k=($k)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=.0,$11=0,$12=.0,$13=0,$14=.0,$15=0,$16=0,$18=.0,$19=.0,$20=.0,$21=.0,$22=.0;
 var $23=.0,$24=0,$26=.0,$27=.0,$28=.0,$29=.0,$30=.0,$31=.0,$32=.0,$33=.0,$34=0,$36=.0,$37=.0,$38=.0,$39=.0,$40=.0,$41=.0,$42=.0,$43=.0,$44=.0;
 var $45=0,$47=0,label=0;

 $1=((HEAP32[((14960)>>2)])|0);
 $2=(($1+((($k)*(104))&-1)+88)|0);
 HEAPF64[(($2)>>3)]=0.000001;
 $3=((HEAP32[((14960)>>2)])|0);
 $4=(($3+((($k)*(104))&-1)+96)|0);
 $5=((HEAP8[($4)])|0);
 $6=(($5<<24)>>24);
 if (((($6|0))|0)==((2)|0)) {
  $47=(($3+((($k)*(104))&-1)+88)|0);
  HEAPF64[(($47)>>3)]=100000000.0;
  return;
 } else if (((($6|0))|0)==((0)|0)|((($6|0))|0)==((1)|0)) {
  $8=((HEAP32[((14960)>>2)])|0);
  $9=(($8+((($k)*(104))&-1)+56)|0);
  $10=(+(HEAPF64[(($9)>>3)]));
  $11=(($8+((($k)*(104))&-1)+40)|0);
  $12=(+(HEAPF64[(($11)>>3)]));
  $13=(($8+((($k)*(104))&-1)+48)|0);
  $14=(+(HEAPF64[(($13)>>3)]));
  $15=((HEAP8[(15624)])|0);
  $16=(($15<<24)>>24);
  if (((($16|0))|0)==((1)|0)) {
   $26=($14)*((0.5));
   $27=($26)/((32.2));
   $28=($27)/($12);
   $29=($12)*($12);
   $30=($29)*((3.141592654));
   $31=($30)*((0.25));
   $32=($31)*($31);
   $33=($28)/($32);
   $34=(($8+((($k)*(104))&-1)+88)|0);
   HEAPF64[(($34)>>3)]=$33;
   return;
  } else if (((($16|0))|0)==((2)|0)) {
   $36=($10)*((4.0));
   $37=($12)*((4.68097305446));
   $38=($12)*($37);
   $39=($36)/($38);
   $40=($39)*($39);
   $41=($12)*((0.25));
   $42=(+(Math_pow((+($41)),-1.333)));
   $43=($40)*($42);
   $44=($14)*($43);
   $45=(($8+((($k)*(104))&-1)+88)|0);
   HEAPF64[(($45)>>3)]=$44;
   return;
  } else if (((($16|0))|0)==((0)|0)) {
   $18=($14)*((4.727));
   $19=(+(HEAPF64[((11232)>>3)]));
   $20=(+(Math_pow((+($10)),(+($19)))));
   $21=($18)/($20);
   $22=(+(Math_pow((+($12)),4.871)));
   $23=($21)/($22);
   $24=(($8+((($k)*(104))&-1)+88)|0);
   HEAPF64[(($24)>>3)]=$23;
   return;
  } else {
   return;
  }
 } else {
  return;
 }
}


function _tankvolume($i,$h){
 $i=($i)|0;
 $h=+($h);
 var $1=0,$2=0,$3=0,$4=0,$6=0,$7=.0,$8=0,$9=.0,$10=.0,$11=0,$12=.0,$13=.0,$14=.0,$16=0,$17=0,$18=0,$19=0,$20=0,$21=0,$22=0;
 var $23=0,$24=0,$25=0,$26=0,$27=.0,$28=.0,$29=.0,$30=.0,$31=.0,$32=.0,$33=.0,$_0=.0,label=0;

 $1=((HEAP32[((13176)>>2)])|0);
 $2=(($1+((($i)*(112))&-1)+92)|0);
 $3=((HEAP32[(($2)>>2)])|0);
 $4=($3|0)==0;
 if ($4) {
  $6=(($1+((($i)*(112))&-1)+40)|0);
  $7=(+(HEAPF64[(($6)>>3)]));
  $8=(($1+((($i)*(112))&-1)+16)|0);
  $9=(+(HEAPF64[(($8)>>3)]));
  $10=($h)-($9);
  $11=(($1+((($i)*(112))&-1)+8)|0);
  $12=(+(HEAPF64[(($11)>>3)]));
  $13=($10)*($12);
  $14=($7)+($13);
  $_0=$14;

  return (+($_0));
 } else {
  $16=((HEAP32[((17648)>>2)])|0);
  $17=(($16+((($3)*(48))&-1)+36)|0);
  $18=((HEAP32[(($17)>>2)])|0);
  $19=(($16+((($3)*(48))&-1)+40)|0);
  $20=((HEAP32[(($19)>>2)])|0);
  $21=(($16+((($3)*(48))&-1)+44)|0);
  $22=((HEAP32[(($21)>>2)])|0);
  $23=(($1+((($i)*(112))&-1))|0);
  $24=((HEAP32[(($23)>>2)])|0);
  $25=((HEAP32[((14408)>>2)])|0);
  $26=(($25+((($24)*(72))&-1)+32)|0);
  $27=(+(HEAPF64[(($26)>>3)]));
  $28=($h)-($27);
  $29=(+(HEAPF64[((12056)>>3)]));
  $30=($28)*($29);
  $31=(+(_interp($18,$20,$22,$30)));
  $32=(+(HEAPF64[((12176)>>3)]));
  $33=($31)/($32);
  $_0=$33;

  return (+($_0));
 }
}


function _tanktimestep($tstep){
 $tstep=($tstep)|0;
 var $1=0,$2=0,$i_021=0,$3=0,$4=0,$5=.0,$6=0,$8=0,$9=0,$10=0,$11=0,$12=.0,$13=0,$14=0,$15=.0,$16=0,$18=.0,$20=.0,$21=0,$23=0;
 var $25=0,$26=0,$27=.0,$28=0,$30=0,$31=.0,$32=0,$33=.0,$34=.0,$37=0,$38=0,$39=.0,$40=0,$42=0,$43=.0,$44=0,$45=.0,$46=.0,$v_0=.0,$48=.0;
 var $49=0,$51=.0,$53=.0,$_sink=.0,$55=0,$56=0,$58=0,$59=0,$62=0,$63=0,$64=0,label=0;

 $1=((HEAP32[((14352)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $i_021=1;
 }
 while(1) {

  $3=((HEAP32[((13176)>>2)])|0);
  $4=(($3+((($i_021)*(112))&-1)+8)|0);
  $5=(+(HEAPF64[(($4)>>3)]));
  $6=$5==(0.0);
  do {
   if (!($6)) {
    $8=(($3+((($i_021)*(112))&-1))|0);
    $9=((HEAP32[(($8)>>2)])|0);
    $10=((HEAP32[((15600)>>2)])|0);
    $11=(($10+($9<<3))|0);
    $12=(+(HEAPF64[(($11)>>3)]));
    $13=((HEAP32[((17632)>>2)])|0);
    $14=(($13+($9<<3))|0);
    $15=(+(HEAPF64[(($14)>>3)]));
    $16=$15<(0.0);
    if ($16) {
     $18=((-.0))-($15);
     $20=$18;
    } else {
     $20=$15;
    }

    $21=$20>(0.000001);
    if (!($21)) {
     break;
    }
    $23=$15>(0.0);
    do {
     if ($23) {
      $25=((HEAP32[((13176)>>2)])|0);
      $26=(($25+((($i_021)*(112))&-1)+24)|0);
      $27=(+(HEAPF64[(($26)>>3)]));
      $28=$12<$27;
      if (!($28)) {
       label = 9;
       break;
      }
      $30=(($25+((($i_021)*(112))&-1)+48)|0);
      $31=(+(HEAPF64[(($30)>>3)]));
      $32=(($25+((($i_021)*(112))&-1)+72)|0);
      $33=(+(HEAPF64[(($32)>>3)]));
      $34=($31)-($33);
      $v_0=$34;
     } else {
      label = 9;
     }
    } while(0);
    if ((label|0) == 9) {
     label = 0;
     if (!($16)) {
      break;
     }
     $37=((HEAP32[((13176)>>2)])|0);
     $38=(($37+((($i_021)*(112))&-1)+16)|0);
     $39=(+(HEAPF64[(($38)>>3)]));
     $40=$12>$39;
     if (!($40)) {
      break;
     }
     $42=(($37+((($i_021)*(112))&-1)+40)|0);
     $43=(+(HEAPF64[(($42)>>3)]));
     $44=(($37+((($i_021)*(112))&-1)+72)|0);
     $45=(+(HEAPF64[(($44)>>3)]));
     $46=($43)-($45);
     $v_0=$46;
    }

    $48=($v_0)/($15);
    $49=$48<(0.0);
    if ($49) {
     $53=($48)+((-0.5));
     $_sink=$53;
    } else {
     $51=($48)+((0.5));
     $_sink=$51;
    }

    $55=(~~($_sink));
    $56=($55|0)>0;
    if (!($56)) {
     break;
    }
    $58=((HEAP32[(($tstep)>>2)])|0);
    $59=($55|0)<($58|0);
    if (!($59)) {
     break;
    }
    HEAP32[(($tstep)>>2)]=$55;
   }
  } while(0);
  $62=((($i_021)+(1))|0);
  $63=((HEAP32[((14352)>>2)])|0);
  $64=($62|0)>($63|0);
  if ($64) {
   break;
  } else {
   $i_021=$62;
  }
 }
 return;
}


function _controltimestep($tstep){
 $tstep=($tstep)|0;
 var $1=0,$2=0,$i_036=0,$3=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$12=0,$13=0,$14=.0,$15=0,$16=0,$17=.0,$18=0,$20=.0,$22=.0,$23=0;
 var $25=0,$26=0,$27=.0,$28=0,$30=0,$31=0,$32=0,$33=0,$or_cond=0,$35=0,$36=0,$37=.0,$38=0,$40=0,$41=0,$_not=0,$_not35=0,$brmerge=0,$43=0,$44=0;
 var $45=.0,$46=.0,$47=0,$48=0,$49=.0,$50=.0,$51=.0,$52=0,$54=.0,$56=.0,$_sink=.0,$58=0,$t_0=0,$60=0,$61=0,$62=0,$63=0,$65=0,$66=0,$67=0;
 var $68=0,$69=0,$_t_0=0,$t_1=0,$71=0,$72=0,$73=0,$74=0,$76=0,$77=0,$78=0,$79=0,$80=0,$81=0,$82=0,$84=0,$86=0,$87=0,$t_2=0,$89=0;
 var $91=0,$92=0,$94=0,$95=0,$96=0,$97=0,$98=0,$99=0,$100=0,$102=0,$103=0,$104=.0,$105=0,$106=.0,$107=0,$109=0,$110=0,$111=0,$112=0,$113=0;
 var $114=0,$115=0,$118=0,$119=0,$120=0,label=0;

 $1=((HEAP32[((14464)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $i_036=1;
 }
 while(1) {

  $3=((HEAP32[((17656)>>2)])|0);
  $4=(($3+((($i_036)*(40))&-1)+4)|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=($5|0)>0;
  do {
   if ($6) {
    $8=((HEAP32[((14432)>>2)])|0);
    $9=((($5)-($8))|0);
    $10=($9|0)<1;
    if ($10) {
     break;
    }
    $12=((HEAP32[((15600)>>2)])|0);
    $13=(($12+($5<<3))|0);
    $14=(+(HEAPF64[(($13)>>3)]));
    $15=((HEAP32[((17632)>>2)])|0);
    $16=(($15+($5<<3))|0);
    $17=(+(HEAPF64[(($16)>>3)]));
    $18=$17<(0.0);
    if ($18) {
     $20=((-.0))-($17);
     $22=$20;
    } else {
     $22=$17;
    }

    $23=$22>(0.000001);
    if (!($23)) {
     break;
    }
    $25=((HEAP32[((17656)>>2)])|0);
    $26=(($25+((($i_036)*(40))&-1)+16)|0);
    $27=(+(HEAPF64[(($26)>>3)]));
    $28=$14<$27;
    if ($28) {
     $30=(($25+((($i_036)*(40))&-1)+33)|0);
     $31=((HEAP8[($30)])|0);
     $32=(($31<<24)>>24)==1;
     $33=$17>(0.0);
     $or_cond=$32&$33;
     if (!($or_cond)) {
      label = 9;
     }
    } else {
     label = 9;
    }
    if ((label|0) == 9) {
     label = 0;
     $35=((HEAP32[((17656)>>2)])|0);
     $36=(($35+((($i_036)*(40))&-1)+16)|0);
     $37=(+(HEAPF64[(($36)>>3)]));
     $38=$14>$37;
     if (!($38)) {
      $t_0=0;
      label = 15;
      break;
     }
     $40=(($35+((($i_036)*(40))&-1)+33)|0);
     $41=((HEAP8[($40)])|0);
     $_not=(($41<<24)>>24)!=0;
     $_not35=$18^1;
     $brmerge=$_not|$_not35;
     if ($brmerge) {
      $t_0=0;
      label = 15;
      break;
     }
    }
    $43=((HEAP32[((17656)>>2)])|0);
    $44=(($43+((($i_036)*(40))&-1)+16)|0);
    $45=(+(HEAPF64[(($44)>>3)]));
    $46=(+(_tankvolume($9,$45)));
    $47=((HEAP32[((13176)>>2)])|0);
    $48=(($47+((($9)*(112))&-1)+72)|0);
    $49=(+(HEAPF64[(($48)>>3)]));
    $50=($46)-($49);
    $51=($50)/($17);
    $52=$51<(0.0);
    if ($52) {
     $56=($51)+((-0.5));
     $_sink=$56;
    } else {
     $54=($51)+((0.5));
     $_sink=$54;
    }

    $58=(~~($_sink));
    $t_0=$58;
    label = 15;
   } else {
    $t_0=0;
    label = 15;
   }
  } while(0);
  do {
   if ((label|0) == 15) {
    label = 0;

    $60=((HEAP32[((17656)>>2)])|0);
    $61=(($60+((($i_036)*(40))&-1)+33)|0);
    $62=((HEAP8[($61)])|0);
    $63=(($62<<24)>>24)==2;
    if ($63) {
     $65=(($60+((($i_036)*(40))&-1)+8)|0);
     $66=((HEAP32[(($65)>>2)])|0);
     $67=((HEAP32[((15576)>>2)])|0);
     $68=($66|0)>($67|0);
     $69=((($66)-($67))|0);
     $_t_0=($68?$69:$t_0);
     $t_1=$_t_0;
    } else {
     $t_1=$t_0;
    }

    $71=((HEAP32[((17656)>>2)])|0);
    $72=(($71+((($i_036)*(40))&-1)+33)|0);
    $73=((HEAP8[($72)])|0);
    $74=(($73<<24)>>24)==3;
    do {
     if ($74) {
      $76=((HEAP32[((15576)>>2)])|0);
      $77=((HEAP32[((12216)>>2)])|0);
      $78=((($77)+($76))|0);
      $79=(((($78|0))%(86400))&-1);
      $80=(($71+((($i_036)*(40))&-1)+8)|0);
      $81=((HEAP32[(($80)>>2)])|0);
      $82=($81|0)<($79|0);
      if ($82) {
       $86=(((86400)-($79))|0);
       $87=((($86)+($81))|0);
       $t_2=$87;
       break;
      } else {
       $84=((($81)-($79))|0);
       $t_2=$84;
       break;
      }
     } else {
      $t_2=$t_1;
     }
    } while(0);

    $89=($t_2|0)>0;
    if (!($89)) {
     break;
    }
    $91=((HEAP32[(($tstep)>>2)])|0);
    $92=($t_2|0)<($91|0);
    if (!($92)) {
     break;
    }
    $94=((HEAP32[((17656)>>2)])|0);
    $95=(($94+((($i_036)*(40))&-1))|0);
    $96=((HEAP32[(($95)>>2)])|0);
    $97=((HEAP32[((14960)>>2)])|0);
    $98=(($97+((($96)*(104))&-1)+96)|0);
    $99=((HEAP8[($98)])|0);
    $100=(($99<<24)>>24)>1;
    if ($100) {
     $102=((HEAP32[((15000)>>2)])|0);
     $103=(($102+($96<<3))|0);
     $104=(+(HEAPF64[(($103)>>3)]));
     $105=(($94+((($i_036)*(40))&-1)+24)|0);
     $106=(+(HEAPF64[(($105)>>3)]));
     $107=$104!=$106;
     if (!($107)) {
      label = 25;
     }
    } else {
     label = 25;
    }
    if ((label|0) == 25) {
     label = 0;
     $109=((HEAP32[((13232)>>2)])|0);
     $110=(($109+$96)|0);
     $111=((HEAP8[($110)])|0);
     $112=((HEAP32[((17656)>>2)])|0);
     $113=(($112+((($i_036)*(40))&-1)+32)|0);
     $114=((HEAP8[($113)])|0);
     $115=(($111<<24)>>24)==(($114<<24)>>24);
     if ($115) {
      break;
     }
    }
    HEAP32[(($tstep)>>2)]=$t_2;
   }
  } while(0);
  $118=((($i_036)+(1))|0);
  $119=((HEAP32[((14464)>>2)])|0);
  $120=($118|0)>($119|0);
  if ($120) {
   break;
  } else {
   $i_036=$118;
  }
 }
 return;
}


function _ruletimestep($tstep){
 $tstep=($tstep)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$7=0,$8=0,$9=0,$dt_0=0,$dt1_0=0,$11=0,$12=0,$_dt_0=0,$13=0,$14=0,$15=0,$_dt_0_=0,$dt_1=0,$dt1_1=0,$17=0;
 var $18=0,$19=0,$20=0,$22=0,$23=0,$24=0,$_dt_1=0,$25=0,$27=0,$28=0,label=0;

 $1=((HEAP32[((15576)>>2)])|0);
 $2=((HEAP32[(($tstep)>>2)])|0);
 $3=((($2)+($1))|0);
 $4=((HEAP32[((14360)>>2)])|0);
 $5=($4|0)==0;
 if ($5) {
  $dt1_0=$2;$dt_0=$2;
 } else {
  $7=((HEAP32[((13240)>>2)])|0);
  $8=(((($1|0))%(($7|0)))&-1);
  $9=((($7)-($8))|0);
  $dt1_0=$9;$dt_0=$7;
 }


 $11=((HEAP32[(($tstep)>>2)])|0);
 $12=($dt_0|0)>($11|0);
 $_dt_0=($12?$11:$dt_0);
 $13=($dt1_0|0)>($11|0);
 $14=($13?$11:$dt1_0);
 $15=($14|0)==0;
 $_dt_0_=($15?$_dt_0:$14);
 $dt1_1=$_dt_0_;$dt_1=$_dt_0;
 while(1) {


  $17=((HEAP32[((15576)>>2)])|0);
  $18=((($17)+($dt1_1))|0);
  HEAP32[((15576)>>2)]=$18;
  _tanklevels($dt1_1);
  $19=((_checkrules($dt1_1))|0);
  $20=($19|0)==0;
  if (!($20)) {
   label = 6;
   break;
  }
  $22=((HEAP32[((15576)>>2)])|0);
  $23=((($3)-($22))|0);
  $24=($dt_1|0)>($23|0);
  $_dt_1=($24?$23:$dt_1);
  $25=($_dt_1|0)>0;
  if ($25) {
   $dt1_1=$_dt_1;$dt_1=$_dt_1;
  } else {
   label = 6;
   break;
  }
 }
 if ((label|0) == 6) {
  $27=((HEAP32[((15576)>>2)])|0);
  $28=((($27)-($1))|0);
  HEAP32[(($tstep)>>2)]=$28;
  HEAP32[((15576)>>2)]=$1;
  return;
 }
}


function _tanklevels($tstep){
 $tstep=($tstep)|0;
 var $1=0,$2=0,$3=.0,$i_018=0,$5=0,$6=0,$7=.0,$8=0,$10=0,$11=0,$12=0,$13=0,$14=.0,$15=.0,$16=0,$17=.0,$18=.0,$19=0,$20=0,$21=.0;
 var $22=0,$23=0,$24=.0,$25=.0,$26=0,$27=.0,$28=0,$31=0,$32=0,$33=.0,$34=0,$35=0,$36=.0,$37=.0,$38=0,$39=.0,$40=0,$43=0,$44=0,$45=.0;
 var $46=.0,$47=0,$48=0,$50=0,$51=0,$52=0,label=0;

 $1=((HEAP32[((14352)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 }
 $3=(+((($tstep|0))|0));
 $i_018=1;
 while(1) {

  $5=((HEAP32[((13176)>>2)])|0);
  $6=(($5+((($i_018)*(112))&-1)+8)|0);
  $7=(+(HEAPF64[(($6)>>3)]));
  $8=$7==(0.0);
  if (!($8)) {
   $10=(($5+((($i_018)*(112))&-1))|0);
   $11=((HEAP32[(($10)>>2)])|0);
   $12=((HEAP32[((17632)>>2)])|0);
   $13=(($12+($11<<3))|0);
   $14=(+(HEAPF64[(($13)>>3)]));
   $15=($3)*($14);
   $16=(($5+((($i_018)*(112))&-1)+72)|0);
   $17=(+(HEAPF64[(($16)>>3)]));
   $18=($17)+($15);
   HEAPF64[(($16)>>3)]=$18;
   $19=((HEAP32[((13176)>>2)])|0);
   $20=(($19+((($i_018)*(112))&-1)+72)|0);
   $21=(+(HEAPF64[(($20)>>3)]));
   $22=((HEAP32[((17632)>>2)])|0);
   $23=(($22+($11<<3))|0);
   $24=(+(HEAPF64[(($23)>>3)]));
   $25=($21)+($24);
   $26=(($19+((($i_018)*(112))&-1)+48)|0);
   $27=(+(HEAPF64[(($26)>>3)]));
   $28=$25<$27;
   if (!($28)) {
    HEAPF64[(($20)>>3)]=$27;
   }
   $31=((HEAP32[((13176)>>2)])|0);
   $32=(($31+((($i_018)*(112))&-1)+72)|0);
   $33=(+(HEAPF64[(($32)>>3)]));
   $34=((HEAP32[((17632)>>2)])|0);
   $35=(($34+($11<<3))|0);
   $36=(+(HEAPF64[(($35)>>3)]));
   $37=($33)-($36);
   $38=(($31+((($i_018)*(112))&-1)+40)|0);
   $39=(+(HEAPF64[(($38)>>3)]));
   $40=$37>$39;
   if (!($40)) {
    HEAPF64[(($32)>>3)]=$39;
   }
   $43=((HEAP32[((13176)>>2)])|0);
   $44=(($43+((($i_018)*(112))&-1)+72)|0);
   $45=(+(HEAPF64[(($44)>>3)]));
   $46=(+(_tankgrade($i_018,$45)));
   $47=((HEAP32[((15600)>>2)])|0);
   $48=(($47+($11<<3))|0);
   HEAPF64[(($48)>>3)]=$46;
  }
  $50=((($i_018)+(1))|0);
  $51=((HEAP32[((14352)>>2)])|0);
  $52=($50|0)>($51|0);
  if ($52) {
   break;
  } else {
   $i_018=$50;
  }
 }
 return;
}


function _getenergy($k,$kw,$eff){
 $k=($k)|0;
 $kw=($kw)|0;
 $eff=($eff)|0;
 var $1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=.0,$9=0,$11=.0,$13=.0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=.0,$20=0,$21=0,$22=0,$23=.0;
 var $24=.0,$25=0,$27=.0,$29=.0,$30=0,$31=0,$32=0,$33=0,$35=0,$36=.0,$37=0,$39=.0,$41=.0,$_sink=.0,$43=0,$44=.0,$45=0,$46=0,$47=0,$48=0;
 var $50=0,$51=0,$52=0,$53=0,$54=0,$55=0,$56=0,$57=.0,$58=.0,$59=.0,$e_0=.0,$61=0,$62=.0,$63=0,$64=.0,$65=.0,$e_1=.0,$67=.0,$68=.0,$69=.0;
 var $70=.0,$71=.0,$72=.0,$storemerge23=.0,$storemerge=.0,label=0;

 $1=((HEAP32[((13232)>>2)])|0);
 $2=(($1+$k)|0);
 $3=((HEAP8[($2)])|0);
 $4=(($3<<24)>>24)<3;
 if ($4) {
  $storemerge=0.0;$storemerge23=0.0;


  HEAPF64[(($kw)>>3)]=$storemerge23;
  HEAPF64[(($eff)>>3)]=$storemerge;
  return;
 }
 $6=((HEAP32[((13880)>>2)])|0);
 $7=(($6+($k<<3))|0);
 $8=(+(HEAPF64[(($7)>>3)]));
 $9=$8<(0.0);
 if ($9) {
  $11=((-.0))-($8);
  $13=$11;
 } else {
  $13=$8;
 }

 $14=((HEAP32[((14960)>>2)])|0);
 $15=(($14+((($k)*(104))&-1)+32)|0);
 $16=((HEAP32[(($15)>>2)])|0);
 $17=((HEAP32[((15600)>>2)])|0);
 $18=(($17+($16<<3))|0);
 $19=(+(HEAPF64[(($18)>>3)]));
 $20=(($14+((($k)*(104))&-1)+36)|0);
 $21=((HEAP32[(($20)>>2)])|0);
 $22=(($17+($21<<3))|0);
 $23=(+(HEAPF64[(($22)>>3)]));
 $24=($19)-($23);
 $25=$24<(0.0);
 if ($25) {
  $27=((-.0))-($24);
  $29=$27;
 } else {
  $29=$24;
 }

 $30=((HEAP32[((14960)>>2)])|0);
 $31=(($30+((($k)*(104))&-1)+96)|0);
 $32=((HEAP8[($31)])|0);
 $33=(($32<<24)>>24)==2;
 if ($33) {
  $35=(($30+((($k)*(104))&-1)+40)|0);
  $36=(+(HEAPF64[(($35)>>3)]));
  $37=$36<(0.0);
  if ($37) {
   $41=($36)+((-0.5));
   $_sink=$41;
  } else {
   $39=($36)+((0.5));
   $_sink=$39;
  }

  $43=(~~($_sink));
  $44=(+(HEAPF64[((11336)>>3)]));
  $45=((HEAP32[((13888)>>2)])|0);
  $46=(($45+($43<<7)+60)|0);
  $47=((HEAP32[(($46)>>2)])|0);
  $48=($47|0)>0;
  if ($48) {
   $50=((HEAP32[((17648)>>2)])|0);
   $51=(($50+((($47)*(48))&-1)+36)|0);
   $52=((HEAP32[(($51)>>2)])|0);
   $53=(($50+((($47)*(48))&-1)+40)|0);
   $54=((HEAP32[(($53)>>2)])|0);
   $55=(($50+((($47)*(48))&-1)+44)|0);
   $56=((HEAP32[(($55)>>2)])|0);
   $57=(+(HEAPF64[((12096)>>3)]));
   $58=($13)*($57);
   $59=(+(_interp($52,$54,$56,$58)));
   $e_0=$59;
  } else {
   $e_0=$44;
  }

  $61=$e_0<=(100.0);
  $62=($61?$e_0:(100.0));
  $63=$62>=(1.0);
  $64=($63?$62:(1.0));
  $65=($64)/((100.0));
  $e_1=$65;
 } else {
  $e_1=1.0;
 }

 $67=($13)*($29);
 $68=(+(HEAPF64[((10648)>>3)]));
 $69=($67)*($68);
 $70=($69)/((8.814));
 $71=($70)/($e_1);
 $72=($71)*((0.7457));
 $storemerge=$e_1;$storemerge23=$72;


 HEAPF64[(($kw)>>3)]=$storemerge23;
 HEAPF64[(($eff)>>3)]=$storemerge;
 return;
}


function _tankgrade($i,$v){
 $i=($i)|0;
 $v=+($v);
 var $1=0,$2=0,$3=0,$4=0,$6=0,$7=.0,$8=0,$9=.0,$10=.0,$11=0,$12=.0,$13=.0,$14=.0,$16=0,$17=0,$18=0,$19=0,$20=.0,$21=0,$22=0;
 var $23=0,$24=0,$25=0,$26=0,$27=0,$28=.0,$29=.0,$30=.0,$31=.0,$32=.0,$33=.0,$_0=.0,label=0;

 $1=((HEAP32[((13176)>>2)])|0);
 $2=(($1+((($i)*(112))&-1)+92)|0);
 $3=((HEAP32[(($2)>>2)])|0);
 $4=($3|0)==0;
 if ($4) {
  $6=(($1+((($i)*(112))&-1)+16)|0);
  $7=(+(HEAPF64[(($6)>>3)]));
  $8=(($1+((($i)*(112))&-1)+40)|0);
  $9=(+(HEAPF64[(($8)>>3)]));
  $10=($v)-($9);
  $11=(($1+((($i)*(112))&-1)+8)|0);
  $12=(+(HEAPF64[(($11)>>3)]));
  $13=($10)/($12);
  $14=($7)+($13);
  $_0=$14;

  return (+($_0));
 } else {
  $16=(($1+((($i)*(112))&-1))|0);
  $17=((HEAP32[(($16)>>2)])|0);
  $18=((HEAP32[((14408)>>2)])|0);
  $19=(($18+((($17)*(72))&-1)+32)|0);
  $20=(+(HEAPF64[(($19)>>3)]));
  $21=((HEAP32[((17648)>>2)])|0);
  $22=(($21+((($3)*(48))&-1)+36)|0);
  $23=((HEAP32[(($22)>>2)])|0);
  $24=(($21+((($3)*(48))&-1)+44)|0);
  $25=((HEAP32[(($24)>>2)])|0);
  $26=(($21+((($3)*(48))&-1)+40)|0);
  $27=((HEAP32[(($26)>>2)])|0);
  $28=(+(HEAPF64[((12176)>>3)]));
  $29=($28)*($v);
  $30=(+(_interp($23,$25,$27,$29)));
  $31=(+(HEAPF64[((12056)>>3)]));
  $32=($30)/($31);
  $33=($20)+($32);
  $_0=$33;

  return (+($_0));
 }
}


function _newcoeffs(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0;
 var $21=0,$22=0,$23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,label=0;

 $1=((HEAP32[((17768)>>2)])|0);
 $2=$1;
 $3=((HEAP32[((14416)>>2)])|0);
 $4=$3<<3;
 $5=((($4)+(8))|0);
 _memset((((($2)|0))|0), ((((0)|0))|0), (((($5)|0))|0))|0;
 $6=((HEAP32[((17760)>>2)])|0);
 $7=$6;
 $8=((HEAP32[((14472)>>2)])|0);
 $9=$8<<3;
 $10=((($9)+(8))|0);
 _memset((((($7)|0))|0), ((((0)|0))|0), (((($10)|0))|0))|0;
 $11=((HEAP32[((17504)>>2)])|0);
 $12=$11;
 $13=((HEAP32[((14416)>>2)])|0);
 $14=$13<<3;
 $15=((($14)+(8))|0);
 _memset((((($12)|0))|0), ((((0)|0))|0), (((($15)|0))|0))|0;
 $16=((HEAP32[((12000)>>2)])|0);
 $17=$16;
 $18=((HEAP32[((14416)>>2)])|0);
 $19=$18<<3;
 $20=((($19)+(8))|0);
 _memset((((($17)|0))|0), ((((0)|0))|0), (((($20)|0))|0))|0;
 $21=((HEAP32[((13976)>>2)])|0);
 $22=$21;
 $23=((HEAP32[((14424)>>2)])|0);
 $24=$23<<3;
 $25=((($24)+(8))|0);
 _memset((((($22)|0))|0), ((((0)|0))|0), (((($25)|0))|0))|0;
 $26=((HEAP32[((11984)>>2)])|0);
 $27=$26;
 $28=((HEAP32[((14424)>>2)])|0);
 $29=$28<<3;
 $30=((($29)+(8))|0);
 _memset((((($27)|0))|0), ((((0)|0))|0), (((($30)|0))|0))|0;
 _linkcoeffs();
 _emittercoeffs();
 _nodecoeffs();
 _valvecoeffs();
 return;
}


function _badvalve($n){
 $n=($n)|0;
 var $1=0,$2=0,$3=0,$i_0=0,$5=0,$7=0,$8=0,$9=0,$10=0,$11=0,$13=0,$14=0,$15=0,$16=0,$18=0,$19=0,$20=0,$22=0,$23=0,$24=0;
 var $25=0,$27=0,$28=0,$30=0,$31=0,$32=0,$33=0,$34=0,$36=0,$37=0,$38=0,$39=0,$40=0,$41=0,$_=0,$_0=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=((HEAP32[((14328)>>2)])|0);
 $2=((HEAP32[((12024)>>2)])|0);
 $3=((HEAP32[((14960)>>2)])|0);
 $i_0=1;
 while(1) {

  $5=($i_0|0)>($1|0);
  if ($5) {
   $_0=0;
   label = 10;
   break;
  }
  $7=(($2+($i_0<<2))|0);
  $8=((HEAP32[(($7)>>2)])|0);
  $9=(($3+((($8)*(104))&-1)+32)|0);
  $10=((HEAP32[(($9)>>2)])|0);
  $11=($10|0)==($n|0);
  if ($11) {
   break;
  }
  $13=(($3+((($8)*(104))&-1)+36)|0);
  $14=((HEAP32[(($13)>>2)])|0);
  $15=($14|0)==($n|0);
  $16=((($i_0)+(1))|0);
  if ($15) {
   break;
  } else {
   $i_0=$16;
  }
 }
 if ((label|0) == 10) {

  STACKTOP=sp;return (($_0)|0);
 }
 $18=((HEAP32[((14960)>>2)])|0);
 $19=(($18+((($8)*(104))&-1)+96)|0);
 $20=((HEAP8[($19)])|0);
 if (!((((($20<<24)>>24))|0)==((3)|0)|(((($20<<24)>>24))|0)==((4)|0)|(((($20<<24)>>24))|0)==((6)|0))) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $22=((HEAP32[((13232)>>2)])|0);
 $23=(($22+$8)|0);
 $24=((HEAP8[($23)])|0);
 $25=(($24<<24)>>24)==4;
 if (!($25)) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $27=((HEAP8[(13192)])|0);
 $28=(($27<<24)>>24)==2;
 if ($28) {
  $30=((HEAP32[((15576)>>2)])|0);
  $31=((_clocktime(17744,$30))|0);
  $32=((HEAP32[((14960)>>2)])|0);
  $33=(($32+((($8)*(104))&-1))|0);
  $34=((_sprintf(((14488)|0),((5560)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$31,HEAP32[(((tempVarArgs)+(8))>>2)]=$33,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline(14488);
 }
 $36=((HEAP32[((14960)>>2)])|0);
 $37=(($36+((($8)*(104))&-1)+96)|0);
 $38=((HEAP8[($37)])|0);
 $39=(($38<<24)>>24)==6;
 $40=((HEAP32[((13232)>>2)])|0);
 $41=(($40+$8)|0);
 $_=($39?6:7);
 HEAP8[($41)]=$_;
 $_0=1;

 STACKTOP=sp;return (($_0)|0);
}


function _newflows(){
 var $1=0,$n_054=0,$2=0,$3=0,$4=0,$5=0,$n_055=0,$6=0,$7=0,$n_0=0,$8=0,$9=0,$qsum_0_lcssa=.0,$dqsum_0_lcssa=.0,$10=0,$11=0,$k_050=0,$qsum_049=.0,$dqsum_048=.0,$12=0;
 var $13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=.0,$20=0,$21=.0,$22=.0,$23=0,$24=0,$25=.0,$26=0,$27=0,$28=.0,$29=.0,$30=.0,$31=.0,$32=.0;
 var $33=0,$34=0,$35=0,$37=0,$38=.0,$39=0,$41=.0,$43=.0,$_sink=.0,$45=0,$46=0,$47=0,$48=0,$49=0,$51=0,$52=0,$53=.0,$54=0,$56=.0,$dq_0=.0;
 var $58=0,$59=0,$60=.0,$61=.0,$62=0,$63=0,$64=.0,$65=0,$67=.0,$69=.0,$70=.0,$71=0,$73=.0,$75=.0,$76=.0,$77=0,$78=0,$79=0,$80=0,$82=0;
 var $83=0,$85=0,$86=0,$87=.0,$88=0,$89=0,$90=.0,$91=.0,$93=0,$94=0,$96=0,$97=0,$98=.0,$99=0,$100=0,$101=.0,$102=.0,$104=0,$105=0,$106=0;
 var $k_145=0,$qsum_144=.0,$dqsum_143=.0,$107=0,$108=0,$109=.0,$110=0,$112=.0,$113=0,$114=0,$115=.0,$116=.0,$117=0,$118=0,$119=.0,$120=0,$122=.0,$124=.0,$125=.0,$126=0;
 var $128=.0,$130=.0,$131=.0,$dqsum_2=.0,$qsum_2=.0,$133=0,$134=0,$135=0,$qsum_1_lcssa=.0,$dqsum_1_lcssa=.0,$136=.0,$137=0,$139=.0,$_0=.0,label=0;

 $1=((HEAP32[((14432)>>2)])|0);
 $n_054=((($1)+(1))|0);
 $2=((HEAP32[((14416)>>2)])|0);
 $3=($n_054|0)>($2|0);
 if (!($3)) {
  $n_055=$n_054;
  while(1) {

   $6=((HEAP32[((17632)>>2)])|0);
   $7=(($6+($n_055<<3))|0);
   HEAPF64[(($7)>>3)]=0.0;
   $n_0=((($n_055)+(1))|0);
   $8=((HEAP32[((14416)>>2)])|0);
   $9=($n_0|0)>($8|0);
   if ($9) {
    break;
   } else {
    $n_055=$n_0;
   }
  }
 }
 $4=((HEAP32[((14424)>>2)])|0);
 $5=($4|0)<1;
 if ($5) {
  $dqsum_0_lcssa=0.0;$qsum_0_lcssa=0.0;
 } else {
  $dqsum_048=0.0;$qsum_049=0.0;$k_050=1;
  while(1) {



   $12=((HEAP32[((14960)>>2)])|0);
   $13=(($12+((($k_050)*(104))&-1)+32)|0);
   $14=((HEAP32[(($13)>>2)])|0);
   $15=(($12+((($k_050)*(104))&-1)+36)|0);
   $16=((HEAP32[(($15)>>2)])|0);
   $17=((HEAP32[((15600)>>2)])|0);
   $18=(($17+($14<<3))|0);
   $19=(+(HEAPF64[(($18)>>3)]));
   $20=(($17+($16<<3))|0);
   $21=(+(HEAPF64[(($20)>>3)]));
   $22=($19)-($21);
   $23=((HEAP32[((11984)>>2)])|0);
   $24=(($23+($k_050<<3))|0);
   $25=(+(HEAPF64[(($24)>>3)]));
   $26=((HEAP32[((13976)>>2)])|0);
   $27=(($26+($k_050<<3))|0);
   $28=(+(HEAPF64[(($27)>>3)]));
   $29=($22)*($28);
   $30=($25)-($29);
   $31=(+(HEAPF64[((10976)>>3)]));
   $32=($31)*($30);
   $33=(($12+((($k_050)*(104))&-1)+96)|0);
   $34=((HEAP8[($33)])|0);
   $35=(($34<<24)>>24)==2;
   do {
    if ($35) {
     $37=(($12+((($k_050)*(104))&-1)+40)|0);
     $38=(+(HEAPF64[(($37)>>3)]));
     $39=$38<(0.0);
     if ($39) {
      $43=($38)+((-0.5));
      $_sink=$43;
     } else {
      $41=($38)+((0.5));
      $_sink=$41;
     }

     $45=(~~($_sink));
     $46=((HEAP32[((13888)>>2)])|0);
     $47=(($46+($45<<7)+4)|0);
     $48=((HEAP32[(($47)>>2)])|0);
     $49=($48|0)==0;
     if (!($49)) {
      $dq_0=$32;
      break;
     }
     $51=((HEAP32[((13880)>>2)])|0);
     $52=(($51+($k_050<<3))|0);
     $53=(+(HEAPF64[(($52)>>3)]));
     $54=$32>$53;
     if (!($54)) {
      $dq_0=$32;
      break;
     }
     $56=($53)*((0.5));
     $dq_0=$56;
    } else {
     $dq_0=$32;
    }
   } while(0);

   $58=((HEAP32[((13880)>>2)])|0);
   $59=(($58+($k_050<<3))|0);
   $60=(+(HEAPF64[(($59)>>3)]));
   $61=($60)-($dq_0);
   HEAPF64[(($59)>>3)]=$61;
   $62=((HEAP32[((13880)>>2)])|0);
   $63=(($62+($k_050<<3))|0);
   $64=(+(HEAPF64[(($63)>>3)]));
   $65=$64<(0.0);
   if ($65) {
    $67=((-.0))-($64);
    $69=$67;
   } else {
    $69=$64;
   }

   $70=($qsum_049)+($69);
   $71=$dq_0<(0.0);
   if ($71) {
    $73=((-.0))-($dq_0);
    $75=$73;
   } else {
    $75=$dq_0;
   }

   $76=($dqsum_048)+($75);
   $77=((HEAP32[((13232)>>2)])|0);
   $78=(($77+$k_050)|0);
   $79=((HEAP8[($78)])|0);
   $80=(($79<<24)>>24)>2;
   do {
    if ($80) {
     $82=((HEAP32[((14432)>>2)])|0);
     $83=($14|0)>($82|0);
     if ($83) {
      $85=((HEAP32[((13880)>>2)])|0);
      $86=(($85+($k_050<<3))|0);
      $87=(+(HEAPF64[(($86)>>3)]));
      $88=((HEAP32[((17632)>>2)])|0);
      $89=(($88+($14<<3))|0);
      $90=(+(HEAPF64[(($89)>>3)]));
      $91=($90)-($87);
      HEAPF64[(($89)>>3)]=$91;
     }
     $93=((HEAP32[((14432)>>2)])|0);
     $94=($16|0)>($93|0);
     if (!($94)) {
      break;
     }
     $96=((HEAP32[((13880)>>2)])|0);
     $97=(($96+($k_050<<3))|0);
     $98=(+(HEAPF64[(($97)>>3)]));
     $99=((HEAP32[((17632)>>2)])|0);
     $100=(($99+($16<<3))|0);
     $101=(+(HEAPF64[(($100)>>3)]));
     $102=($98)+($101);
     HEAPF64[(($100)>>3)]=$102;
    }
   } while(0);
   $104=((($k_050)+(1))|0);
   $105=((HEAP32[((14424)>>2)])|0);
   $106=($104|0)>($105|0);
   if ($106) {
    $dqsum_0_lcssa=$76;$qsum_0_lcssa=$70;
    break;
   } else {
    $dqsum_048=$76;$qsum_049=$70;$k_050=$104;
   }
  }
 }


 $10=((HEAP32[((14432)>>2)])|0);
 $11=($10|0)<1;
 if ($11) {
  $dqsum_1_lcssa=$dqsum_0_lcssa;$qsum_1_lcssa=$qsum_0_lcssa;
 } else {
  $dqsum_143=$dqsum_0_lcssa;$qsum_144=$qsum_0_lcssa;$k_145=1;
  while(1) {



   $107=((HEAP32[((14408)>>2)])|0);
   $108=(($107+((($k_145)*(72))&-1)+56)|0);
   $109=(+(HEAPF64[(($108)>>3)]));
   $110=$109==(0.0);
   if ($110) {
    $qsum_2=$qsum_144;$dqsum_2=$dqsum_143;
   } else {
    $112=(+(_emitflowchange($k_145)));
    $113=((HEAP32[((17536)>>2)])|0);
    $114=(($113+($k_145<<3))|0);
    $115=(+(HEAPF64[(($114)>>3)]));
    $116=($115)-($112);
    HEAPF64[(($114)>>3)]=$116;
    $117=((HEAP32[((17536)>>2)])|0);
    $118=(($117+($k_145<<3))|0);
    $119=(+(HEAPF64[(($118)>>3)]));
    $120=$119<(0.0);
    if ($120) {
     $122=((-.0))-($119);
     $124=$122;
    } else {
     $124=$119;
    }

    $125=($qsum_144)+($124);
    $126=$112<(0.0);
    if ($126) {
     $128=((-.0))-($112);
     $130=$128;
    } else {
     $130=$112;
    }

    $131=($dqsum_143)+($130);
    $qsum_2=$125;$dqsum_2=$131;
   }


   $133=((($k_145)+(1))|0);
   $134=((HEAP32[((14432)>>2)])|0);
   $135=($133|0)>($134|0);
   if ($135) {
    $dqsum_1_lcssa=$dqsum_2;$qsum_1_lcssa=$qsum_2;
    break;
   } else {
    $dqsum_143=$dqsum_2;$qsum_144=$qsum_2;$k_145=$133;
   }
  }
 }


 $136=(+(HEAPF64[((11240)>>3)]));
 $137=$qsum_1_lcssa>$136;
 if (!($137)) {
  $_0=$dqsum_1_lcssa;

  return (+($_0));
 }
 $139=($dqsum_1_lcssa)/($qsum_1_lcssa);
 $_0=$139;

 return (+($_0));
}


function _valvestatus(){
 var $1=0,$2=0,$change_025=0,$i_024=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=.0,$9=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0;
 var $20=0,$21=0,$23=0,$24=0,$25=.0,$26=.0,$27=0,$28=0,$29=.0,$30=0,$31=.0,$32=0,$34=0,$35=0,$36=.0,$37=.0,$38=0,$39=0,$40=.0,$41=0;
 var $42=.0,$43=0,$storemerge=0,$45=0,$46=0,$47=0,$48=0,$50=0,$51=0,$change_1=0,$54=0,$55=0,$56=0,$change_0_lcssa=0,label=0;

 $1=((HEAP32[((14328)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  $change_0_lcssa=0;

  return (($change_0_lcssa)|0);
 } else {
  $i_024=1;$change_025=0;
 }
 while(1) {


  $3=((HEAP32[((12024)>>2)])|0);
  $4=(($3+($i_024<<2))|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=((HEAP32[((15000)>>2)])|0);
  $7=(($6+($5<<3))|0);
  $8=(+(HEAPF64[(($7)>>3)]));
  $9=$8==(-10000000000.0);
  do {
   if ($9) {
    $change_1=$change_025;
   } else {
    $11=((HEAP32[((14960)>>2)])|0);
    $12=(($11+((($5)*(104))&-1)+32)|0);
    $13=((HEAP32[(($12)>>2)])|0);
    $14=(($11+((($5)*(104))&-1)+36)|0);
    $15=((HEAP32[(($14)>>2)])|0);
    $16=((HEAP32[((13232)>>2)])|0);
    $17=(($16+$5)|0);
    $18=((HEAP8[($17)])|0);
    $19=(($11+((($5)*(104))&-1)+96)|0);
    $20=((HEAP8[($19)])|0);
    $21=(($20<<24)>>24);
    if (((($21|0))|0)==((3)|0)) {
     $23=((HEAP32[((14408)>>2)])|0);
     $24=(($23+((($15)*(72))&-1)+32)|0);
     $25=(+(HEAPF64[(($24)>>3)]));
     $26=($8)+($25);
     $27=((HEAP32[((15600)>>2)])|0);
     $28=(($27+($13<<3))|0);
     $29=(+(HEAPF64[(($28)>>3)]));
     $30=(($27+($15<<3))|0);
     $31=(+(HEAPF64[(($30)>>3)]));
     $32=((_prvstatus($5,$18,$26,$29,$31))|0);
     $storemerge=$32;
    } else if (((($21|0))|0)==((4)|0)) {
     $34=((HEAP32[((14408)>>2)])|0);
     $35=(($34+((($13)*(72))&-1)+32)|0);
     $36=(+(HEAPF64[(($35)>>3)]));
     $37=($8)+($36);
     $38=((HEAP32[((15600)>>2)])|0);
     $39=(($38+($13<<3))|0);
     $40=(+(HEAPF64[(($39)>>3)]));
     $41=(($38+($15<<3))|0);
     $42=(+(HEAPF64[(($41)>>3)]));
     $43=((_psvstatus($5,$18,$37,$40,$42))|0);
     $storemerge=$43;
    } else {
     $change_1=$change_025;
     break;
    }

    HEAP8[($17)]=$storemerge;
    $45=((HEAP32[((13232)>>2)])|0);
    $46=(($45+$5)|0);
    $47=((HEAP8[($46)])|0);
    $48=(($18<<24)>>24)==(($47<<24)>>24);
    if ($48) {
     $change_1=$change_025;
     break;
    }
    $50=((HEAP8[(13192)])|0);
    $51=(($50<<24)>>24)==2;
    if (!($51)) {
     $change_1=1;
     break;
    }
    _writestatchange($5,$18,$47);
    $change_1=1;
   }
  } while(0);

  $54=((($i_024)+(1))|0);
  $55=((HEAP32[((14328)>>2)])|0);
  $56=($54|0)>($55|0);
  if ($56) {
   $change_0_lcssa=$change_1;
   break;
  } else {
   $i_024=$54;$change_025=$change_1;
  }
 }

 return (($change_0_lcssa)|0);
}


function _linkstatus(){
 var $1=0,$2=0,$change_035=0,$k_034=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=.0,$11=0,$12=.0,$13=.0,$14=0,$15=0,$16=0,$switch=0,$19=0;
 var $20=0,$21=0,$22=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=.0,$30=0,$32=0,$33=0,$34=0,$35=0,$37=0,$38=0,$39=0,$40=0,$42=0,$43=0;
 var $44=.0,$45=0,$47=.0,$48=0,$50=0,$51=0,$52=0,$53=0,$55=0,$56=0,$57=.0,$58=0,$60=0,$61=0,$62=.0,$63=0,$64=.0,$65=0,$66=0,$67=0;
 var $69=0,$70=0,$71=0,$or_cond=0,$74=0,$75=0,$76=0,$77=0,$79=0,$80=0,$change_1=0,$83=0,$84=0,$85=0,$change_0_lcssa=0,label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  $change_0_lcssa=0;

  return (($change_0_lcssa)|0);
 } else {
  $k_034=1;$change_035=0;
 }
 while(1) {


  $3=((HEAP32[((14960)>>2)])|0);
  $4=(($3+((($k_034)*(104))&-1)+32)|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=(($3+((($k_034)*(104))&-1)+36)|0);
  $7=((HEAP32[(($6)>>2)])|0);
  $8=((HEAP32[((15600)>>2)])|0);
  $9=(($8+($5<<3))|0);
  $10=(+(HEAPF64[(($9)>>3)]));
  $11=(($8+($7<<3))|0);
  $12=(+(HEAPF64[(($11)>>3)]));
  $13=($10)-($12);
  $14=((HEAP32[((13232)>>2)])|0);
  $15=(($14+$k_034)|0);
  $16=((HEAP8[($15)])|0);
  $switch=((($16&255))>>>0)<((2)>>>0);
  if ($switch) {
   HEAP8[($15)]=3;
  }
  $19=((HEAP32[((14960)>>2)])|0);
  $20=(($19+((($k_034)*(104))&-1)+96)|0);
  $21=((HEAP8[($20)])|0);
  $22=(($21<<24)>>24)==0;
  if ($22) {
   $24=((HEAP32[((13232)>>2)])|0);
   $25=(($24+$k_034)|0);
   $26=((HEAP8[($25)])|0);
   $27=((HEAP32[((13880)>>2)])|0);
   $28=(($27+($k_034<<3))|0);
   $29=(+(HEAPF64[(($28)>>3)]));
   $30=((_cvstatus($26,$13,$29))|0);
   HEAP8[($25)]=$30;
  }
  $32=((HEAP32[((14960)>>2)])|0);
  $33=(($32+((($k_034)*(104))&-1)+96)|0);
  $34=((HEAP8[($33)])|0);
  $35=(($34<<24)>>24)==2;
  do {
   if ($35) {
    $37=((HEAP32[((13232)>>2)])|0);
    $38=(($37+$k_034)|0);
    $39=((HEAP8[($38)])|0);
    $40=(($39<<24)>>24)>2;
    if (!($40)) {
     break;
    }
    $42=((HEAP32[((15000)>>2)])|0);
    $43=(($42+($k_034<<3))|0);
    $44=(+(HEAPF64[(($43)>>3)]));
    $45=$44>(0.0);
    if (!($45)) {
     break;
    }
    $47=((-.0))-($13);
    $48=((_pumpstatus($k_034,$47))|0);
    HEAP8[($38)]=$48;
   }
  } while(0);
  $50=((HEAP32[((14960)>>2)])|0);
  $51=(($50+((($k_034)*(104))&-1)+96)|0);
  $52=((HEAP8[($51)])|0);
  $53=(($52<<24)>>24)==6;
  do {
   if ($53) {
    $55=((HEAP32[((15000)>>2)])|0);
    $56=(($55+($k_034<<3))|0);
    $57=(+(HEAPF64[(($56)>>3)]));
    $58=$57!=(-10000000000.0);
    if (!($58)) {
     break;
    }
    $60=((HEAP32[((15600)>>2)])|0);
    $61=(($60+($5<<3))|0);
    $62=(+(HEAPF64[(($61)>>3)]));
    $63=(($60+($7<<3))|0);
    $64=(+(HEAPF64[(($63)>>3)]));
    $65=((_fcvstatus($k_034,$16,$62,$64))|0);
    $66=((HEAP32[((13232)>>2)])|0);
    $67=(($66+$k_034)|0);
    HEAP8[($67)]=$65;
   }
  } while(0);
  $69=((HEAP32[((14432)>>2)])|0);
  $70=($5|0)>($69|0);
  $71=($7|0)>($69|0);
  $or_cond=$70|$71;
  if ($or_cond) {
   _tankstatus($k_034,$5,$7);
  }
  $74=((HEAP32[((13232)>>2)])|0);
  $75=(($74+$k_034)|0);
  $76=((HEAP8[($75)])|0);
  $77=(($16<<24)>>24)==(($76<<24)>>24);
  do {
   if ($77) {
    $change_1=$change_035;
   } else {
    $79=((HEAP8[(13192)])|0);
    $80=(($79<<24)>>24)==2;
    if (!($80)) {
     $change_1=1;
     break;
    }
    _writestatchange($k_034,$16,$76);
    $change_1=1;
   }
  } while(0);

  $83=((($k_034)+(1))|0);
  $84=((HEAP32[((14424)>>2)])|0);
  $85=($83|0)>($84|0);
  if ($85) {
   $change_0_lcssa=$change_1;
   break;
  } else {
   $k_034=$83;$change_035=$change_1;
  }
 }

 return (($change_0_lcssa)|0);
}


function _pswitch(){
 var $1=0,$2=0,$i_034=0,$anychange_033=0,$3=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$12=0,$or_cond=0,$14=0,$15=0,$16=0,$18=0,$19=0,$20=.0;
 var $21=0,$22=.0,$23=.0,$24=.0,$25=0,$reset_0=0,$28=0,$29=0,$30=0,$31=0,$33=0,$34=0,$35=.0,$36=0,$37=.0,$38=.0,$39=.0,$40=0,$41=0,$or_cond32=0;
 var $_old=0,$43=0,$44=0,$45=0,$46=0,$47=0,$48=0,$49=0,$51=0,$52=0,$53=0,$not_=0,$_=0,$change_0=0,$55=0,$56=0,$57=0,$58=0,$60=0,$61=0;
 var $62=.0,$63=0,$64=0,$65=.0,$66=0,$change_1=0,$69=0,$70=0,$71=0,$72=0,$74=0,$75=0,$76=.0,$77=0,$78=0,$79=.0,$80=0,$82=0,$84=0,$85=0;
 var $86=0,$change_1_=0,$change_2=0,$88=0,$89=0,$90=0,$91=0,$92=0,$93=0,$94=0,$95=0,$96=0,$97=0,$99=0,$100=0,$101=.0,$102=0,$103=0,$105=0,$106=0;
 var $108=0,$109=0,$110=0,$anychange_1=0,$111=0,$112=0,$113=0,$anychange_0_lcssa=0,label=0;

 $1=((HEAP32[((14464)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  $anychange_0_lcssa=0;

  return (($anychange_0_lcssa)|0);
 } else {
  $anychange_033=0;$i_034=1;
 }
 while(1) {


  $3=((HEAP32[((17656)>>2)])|0);
  $4=(($3+((($i_034)*(40))&-1))|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=($5|0)<1;
  do {
   if ($6) {
    $anychange_1=$anychange_033;
   } else {
    $8=(($3+((($i_034)*(40))&-1)+4)|0);
    $9=((HEAP32[(($8)>>2)])|0);
    $10=($9|0)<1;
    $11=((HEAP32[((14432)>>2)])|0);
    $12=($9|0)>($11|0);
    $or_cond=$10|$12;
    if ($or_cond) {
     $anychange_1=$anychange_033;
     break;
    }
    $14=(($3+((($i_034)*(40))&-1)+33)|0);
    $15=((HEAP8[($14)])|0);
    $16=(($15<<24)>>24)==0;
    do {
     if ($16) {
      $18=((HEAP32[((15600)>>2)])|0);
      $19=(($18+($9<<3))|0);
      $20=(+(HEAPF64[(($19)>>3)]));
      $21=(($3+((($i_034)*(40))&-1)+16)|0);
      $22=(+(HEAPF64[(($21)>>3)]));
      $23=(+(HEAPF64[((11224)>>3)]));
      $24=($22)+($23);
      $25=$20>$24;
      if ($25) {
       $reset_0=0;
       break;
      }
      $reset_0=1;
     } else {
      $reset_0=0;
     }
    } while(0);

    $28=((HEAP32[((17656)>>2)])|0);
    $29=(($28+((($i_034)*(40))&-1)+33)|0);
    $30=((HEAP8[($29)])|0);
    $31=(($30<<24)>>24)==1;
    if ($31) {
     $33=((HEAP32[((15600)>>2)])|0);
     $34=(($33+($9<<3))|0);
     $35=(+(HEAPF64[(($34)>>3)]));
     $36=(($28+((($i_034)*(40))&-1)+16)|0);
     $37=(+(HEAPF64[(($36)>>3)]));
     $38=(+(HEAPF64[((11224)>>3)]));
     $39=($37)-($38);
     $40=$35>=$39;
     $41=($reset_0|0)==1;
     $or_cond32=$40|$41;
     if (!($or_cond32)) {
      $anychange_1=$anychange_033;
      break;
     }
    } else {
     $_old=($reset_0|0)==1;
     if (!($_old)) {
      $anychange_1=$anychange_033;
      break;
     }
    }
    $43=((HEAP32[((13232)>>2)])|0);
    $44=(($43+$5)|0);
    $45=((HEAP8[($44)])|0);
    $46=((HEAP32[((14960)>>2)])|0);
    $47=(($46+((($5)*(104))&-1)+96)|0);
    $48=((HEAP8[($47)])|0);
    $49=(($48<<24)>>24)==1;
    if ($49) {
     $51=((HEAP32[((17656)>>2)])|0);
     $52=(($51+((($i_034)*(40))&-1)+32)|0);
     $53=((HEAP8[($52)])|0);
     $not_=(($45<<24)>>24)!=(($53<<24)>>24);
     $_=($not_&1);
     $change_0=$_;
    } else {
     $change_0=0;
    }

    $55=((HEAP32[((14960)>>2)])|0);
    $56=(($55+((($5)*(104))&-1)+96)|0);
    $57=((HEAP8[($56)])|0);
    $58=(($57<<24)>>24)==2;
    do {
     if ($58) {
      $60=((HEAP32[((15000)>>2)])|0);
      $61=(($60+($5<<3))|0);
      $62=(+(HEAPF64[(($61)>>3)]));
      $63=((HEAP32[((17656)>>2)])|0);
      $64=(($63+((($i_034)*(40))&-1)+24)|0);
      $65=(+(HEAPF64[(($64)>>3)]));
      $66=$62!=$65;
      if (!($66)) {
       $change_1=$change_0;
       break;
      }
      $change_1=1;
     } else {
      $change_1=$change_0;
     }
    } while(0);

    $69=((HEAP32[((14960)>>2)])|0);
    $70=(($69+((($5)*(104))&-1)+96)|0);
    $71=((HEAP8[($70)])|0);
    $72=(($71<<24)>>24)>2;
    do {
     if ($72) {
      $74=((HEAP32[((15000)>>2)])|0);
      $75=(($74+($5<<3))|0);
      $76=(+(HEAPF64[(($75)>>3)]));
      $77=((HEAP32[((17656)>>2)])|0);
      $78=(($77+((($i_034)*(40))&-1)+24)|0);
      $79=(+(HEAPF64[(($78)>>3)]));
      $80=$76!=$79;
      if ($80) {
       break;
      }
      $82=$76==(-10000000000.0);
      if (!($82)) {
       $change_2=$change_1;
       label = 19;
       break;
      }
      $84=(($77+((($i_034)*(40))&-1)+32)|0);
      $85=((HEAP8[($84)])|0);
      $86=(($45<<24)>>24)==(($85<<24)>>24);
      $change_1_=($86?$change_1:1);
      $change_2=$change_1_;
      label = 19;
     } else {
      $change_2=$change_1;
      label = 19;
     }
    } while(0);
    if ((label|0) == 19) {
     label = 0;

     $88=($change_2|0)==0;
     if ($88) {
      $anychange_1=$anychange_033;
      break;
     }
    }
    $89=((HEAP32[((17656)>>2)])|0);
    $90=(($89+((($i_034)*(40))&-1)+32)|0);
    $91=((HEAP8[($90)])|0);
    $92=((HEAP32[((13232)>>2)])|0);
    $93=(($92+$5)|0);
    HEAP8[($93)]=$91;
    $94=((HEAP32[((14960)>>2)])|0);
    $95=(($94+((($5)*(104))&-1)+96)|0);
    $96=((HEAP8[($95)])|0);
    $97=(($96<<24)>>24)>1;
    if ($97) {
     $99=((HEAP32[((17656)>>2)])|0);
     $100=(($99+((($i_034)*(40))&-1)+24)|0);
     $101=(+(HEAPF64[(($100)>>3)]));
     $102=((HEAP32[((15000)>>2)])|0);
     $103=(($102+($5<<3))|0);
     HEAPF64[(($103)>>3)]=$101;
    }
    $105=((HEAP8[(13192)])|0);
    $106=(($105<<24)>>24)==2;
    if (!($106)) {
     $anychange_1=1;
     break;
    }
    $108=((HEAP32[((13232)>>2)])|0);
    $109=(($108+$5)|0);
    $110=((HEAP8[($109)])|0);
    _writestatchange($5,$45,$110);
    $anychange_1=1;
   }
  } while(0);

  $111=((($i_034)+(1))|0);
  $112=((HEAP32[((14464)>>2)])|0);
  $113=($111|0)>($112|0);
  if ($113) {
   $anychange_0_lcssa=$anychange_1;
   break;
  } else {
   $anychange_033=$anychange_1;$i_034=$111;
  }
 }

 return (($anychange_0_lcssa)|0);
}


function _prvstatus($k,$s,$hset,$h1,$h2){
 $k=($k)|0;
 $s=($s)|0;
 $hset=+($hset);
 $h1=+($h1);
 $h2=+($h2);
 var $1=.0,$2=0,$3=0,$4=.0,$5=0,$7=0,$8=0,$9=.0,$10=0,$11=0,$12=.0,$13=.0,$14=.0,$15=0,$17=.0,$18=.0,$19=0,$21=.0,$22=.0,$23=0;
 var $_=0,$25=.0,$26=.0,$27=0,$29=.0,$30=0,$_28=0,$32=.0,$33=0,$34=.0,$35=0,$or_cond=0,$37=0,$39=.0,$40=0,$43=.0,$44=.0,$45=0,$_0=0,label=0;

 $1=(+(HEAPF64[((11224)>>3)]));
 $2=((HEAP32[((15000)>>2)])|0);
 $3=(($2+($k<<3))|0);
 $4=(+(HEAPF64[(($3)>>3)]));
 $5=$4==(-10000000000.0);
 do {
  if ($5) {
   $_0=$s;
  } else {
   $7=((HEAP32[((14960)>>2)])|0);
   $8=(($7+((($k)*(104))&-1)+64)|0);
   $9=(+(HEAPF64[(($8)>>3)]));
   $10=((HEAP32[((13880)>>2)])|0);
   $11=(($10+($k<<3))|0);
   $12=(+(HEAPF64[(($11)>>3)]));
   $13=($12)*($12);
   $14=($9)*($13);
   $15=(($s<<24)>>24);
   if (((($15|0))|0)==((3)|0)) {
    $25=(+(HEAPF64[((10992)>>3)]));
    $26=((-.0))-($25);
    $27=$12<$26;
    if ($27) {
     $_0=2;
     break;
    }
    $29=($1)+($hset);
    $30=$29>$h2;
    $_28=($30?3:4);
    $_0=$_28;
    break;
   } else if (((($15|0))|0)==((7)|0)) {
    $43=(+(HEAPF64[((10992)>>3)]));
    $44=((-.0))-($43);
    $45=$12<$44;
    if (!($45)) {
     $_0=$s;
     break;
    }
    $_0=2;
    break;
   } else if (((($15|0))|0)==((2)|0)) {
    $32=($1)+($hset);
    $33=$32<=$h1;
    $34=($hset)-($1);
    $35=$34>$h2;
    $or_cond=$33&$35;
    if ($or_cond) {
     $_0=4;
     break;
    }
    $37=$34>$h1;
    if ($37) {
     $39=($1)+($h2);
     $40=$39<$h1;
     if ($40) {
      $_0=3;
      break;
     }
    }
    $_0=2;
    break;
   } else if (((($15|0))|0)==((4)|0)) {
    $17=(+(HEAPF64[((10992)>>3)]));
    $18=((-.0))-($17);
    $19=$12<$18;
    if ($19) {
     $_0=2;
     break;
    }
    $21=($h1)-($14);
    $22=($hset)-($1);
    $23=$21<$22;
    $_=($23?3:4);
    $_0=$_;
    break;
   } else {
    $_0=$s;
    break;
   }
  }
 } while(0);

 return (($_0)|0);
}


function _psvstatus($k,$s,$hset,$h1,$h2){
 $k=($k)|0;
 $s=($s)|0;
 $hset=+($hset);
 $h1=+($h1);
 $h2=+($h2);
 var $1=.0,$2=0,$3=0,$4=.0,$5=0,$7=0,$8=0,$9=.0,$10=0,$11=0,$12=.0,$13=.0,$14=.0,$15=0,$17=.0,$18=.0,$19=0,$21=.0,$22=.0,$23=0;
 var $_=0,$25=.0,$26=.0,$27=0,$29=.0,$30=0,$_28=0,$32=.0,$33=0,$34=.0,$35=0,$or_cond=0,$37=0,$_not=0,$brmerge=0,$_30=0,$39=.0,$40=.0,$41=0,$_0=0;
 var label=0;

 $1=(+(HEAPF64[((11224)>>3)]));
 $2=((HEAP32[((15000)>>2)])|0);
 $3=(($2+($k<<3))|0);
 $4=(+(HEAPF64[(($3)>>3)]));
 $5=$4==(-10000000000.0);
 if ($5) {
  $_0=$s;

  return (($_0)|0);
 }
 $7=((HEAP32[((14960)>>2)])|0);
 $8=(($7+((($k)*(104))&-1)+64)|0);
 $9=(+(HEAPF64[(($8)>>3)]));
 $10=((HEAP32[((13880)>>2)])|0);
 $11=(($10+($k<<3))|0);
 $12=(+(HEAPF64[(($11)>>3)]));
 $13=($12)*($12);
 $14=($9)*($13);
 $15=(($s<<24)>>24);
 if (((($15|0))|0)==((2)|0)) {
  $32=($1)+($hset);
  $33=$32<$h2;
  $34=($1)+($h2);
  $35=$34<$h1;
  $or_cond=$33&$35;
  if ($or_cond) {
   $_0=3;

   return (($_0)|0);
  } else {
   $37=$32>$h1;
   $_not=$35^1;
   $brmerge=$37|$_not;
   $_30=($brmerge?2:4);
   return (($_30)|0);
  }
 } else if (((($15|0))|0)==((3)|0)) {
  $25=(+(HEAPF64[((10992)>>3)]));
  $26=((-.0))-($25);
  $27=$12<$26;
  if ($27) {
   $_0=2;

   return (($_0)|0);
  }
  $29=($hset)-($1);
  $30=$29>$h1;
  $_28=($30?4:3);
  $_0=$_28;

  return (($_0)|0);
 } else if (((($15|0))|0)==((7)|0)) {
  $39=(+(HEAPF64[((10992)>>3)]));
  $40=((-.0))-($39);
  $41=$12<$40;
  if (!($41)) {
   $_0=$s;

   return (($_0)|0);
  }
  $_0=2;

  return (($_0)|0);
 } else if (((($15|0))|0)==((4)|0)) {
  $17=(+(HEAPF64[((10992)>>3)]));
  $18=((-.0))-($17);
  $19=$12<$18;
  if ($19) {
   $_0=2;

   return (($_0)|0);
  }
  $21=($14)+($h2);
  $22=($1)+($hset);
  $23=$21>$22;
  $_=($23?3:4);
  $_0=$_;

  return (($_0)|0);
 } else {
  $_0=$s;

  return (($_0)|0);
 }
}


function _cvstatus($s,$dh,$q){
 $s=($s)|0;
 $dh=+($dh);
 $q=+($q);
 var $1=0,$3=.0,$5=.0,$6=.0,$7=0,$9=.0,$10=0,$12=.0,$13=.0,$14=0,$_=0,$16=.0,$17=.0,$18=0,$_s=0,$_0=0,label=0;

 $1=$dh<(0.0);
 if ($1) {
  $3=((-.0))-($dh);
  $5=$3;
 } else {
  $5=$dh;
 }

 $6=(+(HEAPF64[((11224)>>3)]));
 $7=$5>$6;
 if (!($7)) {
  $16=(+(HEAPF64[((10992)>>3)]));
  $17=((-.0))-($16);
  $18=$q<$17;
  $_s=($18?2:$s);
  $_0=$_s;

  return (($_0)|0);
 }
 $9=((-.0))-($6);
 $10=$dh<$9;
 if ($10) {
  $_0=2;

  return (($_0)|0);
 }
 $12=(+(HEAPF64[((10992)>>3)]));
 $13=((-.0))-($12);
 $14=$q<$13;
 $_=($14?2:3);
 $_0=$_;

 return (($_0)|0);
}


function _pumpstatus($k,$dh){
 $k=($k)|0;
 $dh=+($dh);
 var $1=0,$2=0,$3=.0,$4=0,$6=.0,$8=.0,$_sink=.0,$10=0,$11=0,$12=0,$13=0,$14=0,$16=0,$17=0,$18=.0,$19=.0,$20=0,$21=.0,$22=.0,$hmax_0=.0;
 var $24=.0,$25=.0,$26=0,$_=0,label=0;

 $1=((HEAP32[((14960)>>2)])|0);
 $2=(($1+((($k)*(104))&-1)+40)|0);
 $3=(+(HEAPF64[(($2)>>3)]));
 $4=$3<(0.0);
 if ($4) {
  $8=($3)+((-0.5));
  $_sink=$8;
 } else {
  $6=($3)+((0.5));
  $_sink=$6;
 }

 $10=(~~($_sink));
 $11=((HEAP32[((13888)>>2)])|0);
 $12=(($11+($10<<7)+4)|0);
 $13=((HEAP32[(($12)>>2)])|0);
 $14=($13|0)==0;
 if ($14) {
  $hmax_0=10000000000.0;

  $24=(+(HEAPF64[((11224)>>3)]));
  $25=($hmax_0)+($24);
  $26=$25<$dh;
  $_=($26?0:3);
  return (($_)|0);
 }
 $16=((HEAP32[((15000)>>2)])|0);
 $17=(($16+($k<<3))|0);
 $18=(+(HEAPF64[(($17)>>3)]));
 $19=($18)*($18);
 $20=(($11+($10<<7)+24)|0);
 $21=(+(HEAPF64[(($20)>>3)]));
 $22=($19)*($21);
 $hmax_0=$22;

 $24=(+(HEAPF64[((11224)>>3)]));
 $25=($hmax_0)+($24);
 $26=$25<$dh;
 $_=($26?0:3);
 return (($_)|0);
}


function _fcvstatus($k,$s,$h1,$h2){
 $k=($k)|0;
 $s=($s)|0;
 $h1=+($h1);
 $h2=+($h2);
 var $1=.0,$2=.0,$3=.0,$4=0,$6=0,$7=0,$8=.0,$9=.0,$10=.0,$11=0,$13=0,$15=0,$16=0,$17=.0,$18=0,$status_0=0,label=0;

 $1=($h1)-($h2);
 $2=(+(HEAPF64[((11224)>>3)]));
 $3=((-.0))-($2);
 $4=$1<$3;
 do {
  if ($4) {
   $status_0=6;
  } else {
   $6=((HEAP32[((13880)>>2)])|0);
   $7=(($6+($k<<3))|0);
   $8=(+(HEAPF64[(($7)>>3)]));
   $9=(+(HEAPF64[((10992)>>3)]));
   $10=((-.0))-($9);
   $11=$8<$10;
   if ($11) {
    $status_0=6;
    break;
   }
   $13=(($s<<24)>>24)==6;
   if (!($13)) {
    $status_0=$s;
    break;
   }
   $15=((HEAP32[((15000)>>2)])|0);
   $16=(($15+($k<<3))|0);
   $17=(+(HEAPF64[(($16)>>3)]));
   $18=$8<$17;
   if ($18) {
    $status_0=6;
    break;
   }
   $status_0=4;
  }
 } while(0);

 return (($status_0)|0);
}


function _tankstatus($k,$n1,$n2){
 $k=($k)|0;
 $n1=($n1)|0;
 $n2=($n2)|0;
 var $1=0,$2=0,$3=.0,$4=0,$5=0,$6=0,$8=0,$9=0,$11=.0,$i_0=0,$_027=0,$_0=0,$q_0=.0,$13=0,$14=0,$15=.0,$16=0,$17=.0,$18=.0,$19=0;
 var $20=0,$21=.0,$22=0,$24=0,$25=0,$26=0,$27=0,$29=0,$30=.0,$31=.0,$32=.0,$33=0,$35=0,$36=0,$37=0,$38=0,$40=0,$41=0,$42=0,$45=0;
 var $46=0,$49=0,$50=0,$51=.0,$52=0,$53=0,$54=.0,$55=.0,$56=.0,$57=0,$59=0,$60=0,$61=0,$62=0,$64=0,$65=0,$66=0,$68=0,$69=0,$71=0;
 var $72=0,$74=0,$75=0,label=0;

 $1=((HEAP32[((13880)>>2)])|0);
 $2=(($1+($k<<3))|0);
 $3=(+(HEAPF64[(($2)>>3)]));
 $4=((HEAP32[((14432)>>2)])|0);
 $5=((($n1)-($4))|0);
 $6=($5|0)<1;
 do {
  if ($6) {
   $8=((($n2)-($4))|0);
   $9=($8|0)<1;
   if ($9) {
    return;
   } else {
    $11=((-.0))-($3);
    $q_0=$11;$_0=$n2;$_027=$n1;$i_0=$8;
    break;
   }
  } else {
   $q_0=$3;$_0=$n1;$_027=$n2;$i_0=$5;
  }
 } while(0);




 $13=((HEAP32[((15600)>>2)])|0);
 $14=(($13+($_0<<3))|0);
 $15=(+(HEAPF64[(($14)>>3)]));
 $16=(($13+($_027<<3))|0);
 $17=(+(HEAPF64[(($16)>>3)]));
 $18=($15)-($17);
 $19=((HEAP32[((13176)>>2)])|0);
 $20=(($19+((($i_0)*(112))&-1)+8)|0);
 $21=(+(HEAPF64[(($20)>>3)]));
 $22=$21==(0.0);
 if ($22) {
  return;
 }
 $24=((HEAP32[((13232)>>2)])|0);
 $25=(($24+$k)|0);
 $26=((HEAP8[($25)])|0);
 $27=(($26<<24)>>24)<3;
 if ($27) {
  return;
 }
 $29=(($19+((($i_0)*(112))&-1)+24)|0);
 $30=(+(HEAPF64[(($29)>>3)]));
 $31=(+(HEAPF64[((11224)>>3)]));
 $32=($30)-($31);
 $33=$15<$32;
 do {
  if (!($33)) {
   $35=((HEAP32[((14960)>>2)])|0);
   $36=(($35+((($k)*(104))&-1)+96)|0);
   $37=((HEAP8[($36)])|0);
   $38=(($37<<24)>>24)==2;
   if ($38) {
    $40=(($35+((($k)*(104))&-1)+36)|0);
    $41=((HEAP32[(($40)>>2)])|0);
    $42=($41|0)==($_0|0);
    if (!($42)) {
     break;
    }
    HEAP8[($25)]=1;
    break;
   } else {
    $45=((_cvstatus(3,$18,$q_0))|0);
    $46=(($45<<24)>>24)==2;
    if (!($46)) {
     break;
    }
    HEAP8[($25)]=1;
    break;
   }
  }
 } while(0);
 $49=((HEAP32[((15600)>>2)])|0);
 $50=(($49+($_0<<3))|0);
 $51=(+(HEAPF64[(($50)>>3)]));
 $52=((HEAP32[((13176)>>2)])|0);
 $53=(($52+((($i_0)*(112))&-1)+16)|0);
 $54=(+(HEAPF64[(($53)>>3)]));
 $55=(+(HEAPF64[((11224)>>3)]));
 $56=($54)+($55);
 $57=$51>$56;
 if ($57) {
  return;
 }
 $59=((HEAP32[((14960)>>2)])|0);
 $60=(($59+((($k)*(104))&-1)+96)|0);
 $61=((HEAP8[($60)])|0);
 $62=(($61<<24)>>24)==2;
 if ($62) {
  $64=(($59+((($k)*(104))&-1)+32)|0);
  $65=((HEAP32[(($64)>>2)])|0);
  $66=($65|0)==($_0|0);
  if (!($66)) {
   return;
  }
  $68=((HEAP32[((13232)>>2)])|0);
  $69=(($68+$k)|0);
  HEAP8[($69)]=1;
  return;
 } else {
  $71=((_cvstatus(2,$18,$q_0))|0);
  $72=(($71<<24)>>24)==3;
  if (!($72)) {
   return;
  }
  $74=((HEAP32[((13232)>>2)])|0);
  $75=(($74+$k)|0);
  HEAP8[($75)]=1;
  return;
 }
}


function _emitflowchange($i){
 $i=($i)|0;
 var $1=0,$2=0,$3=.0,$4=0,$5=.0,$6=.0,$7=.0,$8=0,$9=0,$10=.0,$11=0,$13=.0,$15=.0,$16=.0,$17=.0,$18=.0,$19=.0,$20=.0,$21=0,$_=.0;
 var $p_0=.0,$22=0,$23=0,$24=.0,$25=.0,$26=0,$27=0,$28=.0,$29=0,$30=0,$31=.0,$32=.0,$33=.0,$34=.0,label=0;

 $1=((HEAP32[((14408)>>2)])|0);
 $2=(($1+((($i)*(72))&-1)+56)|0);
 $3=(+(HEAPF64[(($2)>>3)]));
 $4=$3>(0.000001);
 $5=($4?$3:(0.000001));
 $6=(+(HEAPF64[((11000)>>3)]));
 $7=($6)*($5);
 $8=((HEAP32[((17536)>>2)])|0);
 $9=(($8+($i<<3))|0);
 $10=(+(HEAPF64[(($9)>>3)]));
 $11=$10<(0.0);
 if ($11) {
  $13=((-.0))-($10);
  $15=$13;
 } else {
  $15=$10;
 }

 $16=(+(HEAPF64[((11000)>>3)]));
 $17=($16)+((-1.0));
 $18=(+(Math_pow((+($15)),(+($17)))));
 $19=($7)*($18);
 $20=(+(HEAPF64[((10984)>>3)]));
 $21=$19<$20;
 $_=($21?$20:$19);
 $p_0=((1.0))/($_);
 $22=((HEAP32[((17536)>>2)])|0);
 $23=(($22+($i<<3))|0);
 $24=(+(HEAPF64[(($23)>>3)]));
 $25=($24)/($16);
 $26=((HEAP32[((15600)>>2)])|0);
 $27=(($26+($i<<3))|0);
 $28=(+(HEAPF64[(($27)>>3)]));
 $29=((HEAP32[((14408)>>2)])|0);
 $30=(($29+((($i)*(72))&-1)+32)|0);
 $31=(+(HEAPF64[(($30)>>3)]));
 $32=($28)-($31);
 $33=($p_0)*($32);
 $34=($25)-($33);
 return (+($34));
}


function _linkcoeffs(){
 var $1=0,$2=0,$k_028=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$17=0,$18=0,$19=.0,$20=0,$23=0,$24=0,$25=.0,$26=0,$27=0;
 var $28=.0,$29=.0,$30=0,$31=0,$32=.0,$33=0,$34=0,$35=.0,$36=.0,$37=0,$38=0,$39=.0,$40=0,$41=0,$42=0,$43=0,$44=0,$45=.0,$46=.0,$47=0;
 var $48=0,$49=0,$50=0,$51=.0,$53=0,$54=0,$55=0,$56=0,$57=0,$58=.0,$59=.0,$60=0,$61=0,$62=.0,$63=0,$64=0,$65=0,$66=0,$67=0,$68=.0;
 var $69=.0,$71=0,$72=0,$73=.0,$74=.0,$75=0,$76=0,$77=0,$78=0,$79=0,$80=.0,$81=.0,$83=0,$84=0,$85=0,$86=0,$87=.0,$89=0,$90=0,$91=0;
 var $92=0,$93=0,$94=.0,$95=.0,$96=0,$97=0,$98=.0,$99=0,$100=0,$101=0,$102=0,$103=0,$104=.0,$105=.0,$107=0,$108=0,$109=.0,$110=.0,$111=0,$112=0;
 var $113=0,$114=0,$115=0,$116=.0,$117=.0,$119=0,$120=0,$121=0,label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $k_028=1;
 }
 while(1) {

  $3=((HEAP32[((14960)>>2)])|0);
  $4=(($3+((($k_028)*(104))&-1)+32)|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=(($3+((($k_028)*(104))&-1)+36)|0);
  $7=((HEAP32[(($6)>>2)])|0);
  $8=(($3+((($k_028)*(104))&-1)+96)|0);
  $9=((HEAP8[($8)])|0);
  $10=(($9<<24)>>24);
  L5: do {
   switch (($10|0)) {
   case 8: {
    _gpvcoeff($k_028);
    label = 10;
    break;
   }
   case 5: {
    _pbvcoeff($k_028);
    label = 10;
    break;
   }
   case 6:case 3:case 4: {
    $17=((HEAP32[((15000)>>2)])|0);
    $18=(($17+($k_028<<3))|0);
    $19=(+(HEAPF64[(($18)>>3)]));
    $20=$19==(-10000000000.0);
    if (!($20)) {
     break L5;
    }
    _valvecoeff($k_028);
    label = 10;
    break;
   }
   case 2: {
    _pumpcoeff($k_028);
    label = 10;
    break;
   }
   case 0:case 1: {
    _pipecoeff($k_028);
    label = 10;
    break;
   }
   case 7: {
    _tcvcoeff($k_028);
    label = 10;
    break;
   }
   default: {
   }
   }
  } while(0);
  do {
   if ((label|0) == 10) {
    label = 0;
    $23=((HEAP32[((13880)>>2)])|0);
    $24=(($23+($k_028<<3))|0);
    $25=(+(HEAPF64[(($24)>>3)]));
    $26=((HEAP32[((12000)>>2)])|0);
    $27=(($26+($5<<3))|0);
    $28=(+(HEAPF64[(($27)>>3)]));
    $29=($28)-($25);
    HEAPF64[(($27)>>3)]=$29;
    $30=((HEAP32[((13880)>>2)])|0);
    $31=(($30+($k_028<<3))|0);
    $32=(+(HEAPF64[(($31)>>3)]));
    $33=((HEAP32[((12000)>>2)])|0);
    $34=(($33+($7<<3))|0);
    $35=(+(HEAPF64[(($34)>>3)]));
    $36=($32)+($35);
    HEAPF64[(($34)>>3)]=$36;
    $37=((HEAP32[((13976)>>2)])|0);
    $38=(($37+($k_028<<3))|0);
    $39=(+(HEAPF64[(($38)>>3)]));
    $40=((HEAP32[((14448)>>2)])|0);
    $41=(($40+($k_028<<2))|0);
    $42=((HEAP32[(($41)>>2)])|0);
    $43=((HEAP32[((17760)>>2)])|0);
    $44=(($43+($42<<3))|0);
    $45=(+(HEAPF64[(($44)>>3)]));
    $46=($45)-($39);
    HEAPF64[(($44)>>3)]=$46;
    $47=((HEAP32[((14432)>>2)])|0);
    $48=($5|0)>($47|0);
    $49=((HEAP32[((13976)>>2)])|0);
    $50=(($49+($k_028<<3))|0);
    $51=(+(HEAPF64[(($50)>>3)]));
    if ($48) {
     $71=((HEAP32[((15600)>>2)])|0);
     $72=(($71+($5<<3))|0);
     $73=(+(HEAPF64[(($72)>>3)]));
     $74=($51)*($73);
     $75=((HEAP32[((13832)>>2)])|0);
     $76=(($75+($7<<2))|0);
     $77=((HEAP32[(($76)>>2)])|0);
     $78=((HEAP32[((17504)>>2)])|0);
     $79=(($78+($77<<3))|0);
     $80=(+(HEAPF64[(($79)>>3)]));
     $81=($74)+($80);
     HEAPF64[(($79)>>3)]=$81;
    } else {
     $53=((HEAP32[((13832)>>2)])|0);
     $54=(($53+($5<<2))|0);
     $55=((HEAP32[(($54)>>2)])|0);
     $56=((HEAP32[((17768)>>2)])|0);
     $57=(($56+($55<<3))|0);
     $58=(+(HEAPF64[(($57)>>3)]));
     $59=($51)+($58);
     HEAPF64[(($57)>>3)]=$59;
     $60=((HEAP32[((11984)>>2)])|0);
     $61=(($60+($k_028<<3))|0);
     $62=(+(HEAPF64[(($61)>>3)]));
     $63=((HEAP32[((13832)>>2)])|0);
     $64=(($63+($5<<2))|0);
     $65=((HEAP32[(($64)>>2)])|0);
     $66=((HEAP32[((17504)>>2)])|0);
     $67=(($66+($65<<3))|0);
     $68=(+(HEAPF64[(($67)>>3)]));
     $69=($62)+($68);
     HEAPF64[(($67)>>3)]=$69;
    }
    $83=((HEAP32[((14432)>>2)])|0);
    $84=($7|0)>($83|0);
    $85=((HEAP32[((13976)>>2)])|0);
    $86=(($85+($k_028<<3))|0);
    $87=(+(HEAPF64[(($86)>>3)]));
    if ($84) {
     $107=((HEAP32[((15600)>>2)])|0);
     $108=(($107+($7<<3))|0);
     $109=(+(HEAPF64[(($108)>>3)]));
     $110=($87)*($109);
     $111=((HEAP32[((13832)>>2)])|0);
     $112=(($111+($5<<2))|0);
     $113=((HEAP32[(($112)>>2)])|0);
     $114=((HEAP32[((17504)>>2)])|0);
     $115=(($114+($113<<3))|0);
     $116=(+(HEAPF64[(($115)>>3)]));
     $117=($110)+($116);
     HEAPF64[(($115)>>3)]=$117;
     break;
    } else {
     $89=((HEAP32[((13832)>>2)])|0);
     $90=(($89+($7<<2))|0);
     $91=((HEAP32[(($90)>>2)])|0);
     $92=((HEAP32[((17768)>>2)])|0);
     $93=(($92+($91<<3))|0);
     $94=(+(HEAPF64[(($93)>>3)]));
     $95=($87)+($94);
     HEAPF64[(($93)>>3)]=$95;
     $96=((HEAP32[((11984)>>2)])|0);
     $97=(($96+($k_028<<3))|0);
     $98=(+(HEAPF64[(($97)>>3)]));
     $99=((HEAP32[((13832)>>2)])|0);
     $100=(($99+($7<<2))|0);
     $101=((HEAP32[(($100)>>2)])|0);
     $102=((HEAP32[((17504)>>2)])|0);
     $103=(($102+($101<<3))|0);
     $104=(+(HEAPF64[(($103)>>3)]));
     $105=($104)-($98);
     HEAPF64[(($103)>>3)]=$105;
     break;
    }
   }
  } while(0);
  $119=((($k_028)+(1))|0);
  $120=((HEAP32[((14424)>>2)])|0);
  $121=($119|0)>($120|0);
  if ($121) {
   break;
  } else {
   $k_028=$119;
  }
 }
 return;
}


function _emittercoeffs(){
 var $1=0,$2=0,$i_021=0,$3=0,$4=0,$5=.0,$6=0,$8=0,$9=.0,$10=0,$11=0,$12=.0,$13=0,$14=.0,$15=.0,$16=.0,$17=.0,$19=.0,$20=.0,$21=.0;
 var $22=.0,$23=.0,$24=.0,$26=.0,$27=.0,$28=.0,$29=.0,$30=.0,$31=0,$_=.0,$p_0=.0,$32=.0,$33=.0,$34=.0,$35=0,$36=0,$37=0,$38=0,$39=0,$40=.0;
 var $41=.0,$42=0,$43=0,$44=.0,$45=.0,$46=.0,$47=0,$48=0,$49=0,$50=0,$51=0,$52=.0,$53=.0,$54=0,$55=0,$56=.0,$57=.0,$59=0,$60=0,$61=0;
 var label=0;

 $1=((HEAP32[((14432)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $i_021=1;
 }
 while(1) {

  $3=((HEAP32[((14408)>>2)])|0);
  $4=(($3+((($i_021)*(72))&-1)+56)|0);
  $5=(+(HEAPF64[(($4)>>3)]));
  $6=$5==(0.0);
  if (!($6)) {
   $8=$5>(0.000001);
   $9=($8?$5:(0.000001));
   $10=((HEAP32[((17536)>>2)])|0);
   $11=(($10+($i_021<<3))|0);
   $12=(+(HEAPF64[(($11)>>3)]));
   $13=$12<(0.0);
   if ($13) {
    $19=((-.0))-($12);
    $20=(+(HEAPF64[((11000)>>3)]));
    $21=(+(Math_pow((+($19)),(+($20)))));
    $22=($9)*($21);
    $23=($20)*($22);
    $24=((-.0))-($12);
    $28=$24;$27=$22;$26=$23;
   } else {
    $14=(+(HEAPF64[((11000)>>3)]));
    $15=(+(Math_pow((+($12)),(+($14)))));
    $16=($9)*($15);
    $17=($14)*($16);
    $28=$12;$27=$16;$26=$17;
   }



   $29=($26)/($28);
   $30=(+(HEAPF64[((10984)>>3)]));
   $31=$29<$30;
   $_=($31?$30:$29);
   $p_0=((1.0))/($_);
   $32=($13?(-1.0):(1.0));
   $33=($32)*($27);
   $34=($33)*($p_0);
   $35=((HEAP32[((13832)>>2)])|0);
   $36=(($35+($i_021<<2))|0);
   $37=((HEAP32[(($36)>>2)])|0);
   $38=((HEAP32[((17768)>>2)])|0);
   $39=(($38+($37<<3))|0);
   $40=(+(HEAPF64[(($39)>>3)]));
   $41=($p_0)+($40);
   HEAPF64[(($39)>>3)]=$41;
   $42=((HEAP32[((14408)>>2)])|0);
   $43=(($42+((($i_021)*(72))&-1)+32)|0);
   $44=(+(HEAPF64[(($43)>>3)]));
   $45=($p_0)*($44);
   $46=($34)+($45);
   $47=((HEAP32[((13832)>>2)])|0);
   $48=(($47+($i_021<<2))|0);
   $49=((HEAP32[(($48)>>2)])|0);
   $50=((HEAP32[((17504)>>2)])|0);
   $51=(($50+($49<<3))|0);
   $52=(+(HEAPF64[(($51)>>3)]));
   $53=($46)+($52);
   HEAPF64[(($51)>>3)]=$53;
   $54=((HEAP32[((12000)>>2)])|0);
   $55=(($54+($i_021<<3))|0);
   $56=(+(HEAPF64[(($55)>>3)]));
   $57=($56)-($12);
   HEAPF64[(($55)>>3)]=$57;
  }
  $59=((($i_021)+(1))|0);
  $60=((HEAP32[((14432)>>2)])|0);
  $61=($59|0)>($60|0);
  if ($61) {
   break;
  } else {
   $i_021=$59;
  }
 }
 return;
}


function _nodecoeffs(){
 var $1=0,$2=0,$i_06=0,$3=0,$4=0,$5=.0,$6=0,$7=0,$8=.0,$9=.0,$10=0,$11=0,$12=.0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=.0,$19=.0;
 var $20=0,$21=0,$22=0,label=0;

 $1=((HEAP32[((14432)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $i_06=1;
 }
 while(1) {

  $3=((HEAP32[((17632)>>2)])|0);
  $4=(($3+($i_06<<3))|0);
  $5=(+(HEAPF64[(($4)>>3)]));
  $6=((HEAP32[((12000)>>2)])|0);
  $7=(($6+($i_06<<3))|0);
  $8=(+(HEAPF64[(($7)>>3)]));
  $9=($8)-($5);
  HEAPF64[(($7)>>3)]=$9;
  $10=((HEAP32[((12000)>>2)])|0);
  $11=(($10+($i_06<<3))|0);
  $12=(+(HEAPF64[(($11)>>3)]));
  $13=((HEAP32[((13832)>>2)])|0);
  $14=(($13+($i_06<<2))|0);
  $15=((HEAP32[(($14)>>2)])|0);
  $16=((HEAP32[((17504)>>2)])|0);
  $17=(($16+($15<<3))|0);
  $18=(+(HEAPF64[(($17)>>3)]));
  $19=($12)+($18);
  HEAPF64[(($17)>>3)]=$19;
  $20=((($i_06)+(1))|0);
  $21=((HEAP32[((14432)>>2)])|0);
  $22=($20|0)>($21|0);
  if ($22) {
   break;
  } else {
   $i_06=$20;
  }
 }
 return;
}


function _valvecoeffs(){
 var $1=0,$2=0,$i_013=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=.0,$9=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$23=0,$24=0;
 var $25=0,label=0;

 $1=((HEAP32[((14328)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $i_013=1;
 }
 while(1) {

  $3=((HEAP32[((12024)>>2)])|0);
  $4=(($3+($i_013<<2))|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=((HEAP32[((15000)>>2)])|0);
  $7=(($6+($5<<3))|0);
  $8=(+(HEAPF64[(($7)>>3)]));
  $9=$8==(-10000000000.0);
  do {
   if (!($9)) {
    $11=((HEAP32[((14960)>>2)])|0);
    $12=(($11+((($5)*(104))&-1)+32)|0);
    $13=((HEAP32[(($12)>>2)])|0);
    $14=(($11+((($5)*(104))&-1)+36)|0);
    $15=((HEAP32[(($14)>>2)])|0);
    $16=(($11+((($5)*(104))&-1)+96)|0);
    $17=((HEAP8[($16)])|0);
    $18=(($17<<24)>>24);
    if (((($18|0))|0)==((3)|0)) {
     _prvcoeff($5,$13,$15);
     break;
    } else if (((($18|0))|0)==((4)|0)) {
     _psvcoeff($5,$13,$15);
     break;
    } else if (((($18|0))|0)==((6)|0)) {
     _fcvcoeff($5,$13,$15);
     break;
    } else {
     break;
    }
   }
  } while(0);
  $23=((($i_013)+(1))|0);
  $24=((HEAP32[((14328)>>2)])|0);
  $25=($23|0)>($24|0);
  if ($25) {
   break;
  } else {
   $i_013=$23;
  }
 }
 return;
}


function _pipecoeff($k){
 $k=($k)|0;
 var $dfdq=0,$1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$9=0,$10=.0,$11=0,$12=0,$14=0,$15=0,$16=.0,$17=0,$19=.0,$21=.0,$22=0,$23=0;
 var $24=.0,$25=0,$26=.0,$27=0,$28=0,$30=.0,$f_0=.0,$32=.0,$33=.0,$34=.0,$35=.0,$36=0,$38=.0,$39=0,$40=0,$41=0,$42=0,$43=.0,$44=.0,$45=.0;
 var $46=0,$47=0,$49=0,$50=0,$52=.0,$53=.0,$54=.0,$55=.0,$56=.0,$57=0,$58=0,$59=0,$60=0,$61=.0,$62=0,$63=.0,$64=.0,$65=.0,$66=0,$67=0;
 var $69=.0,$70=.0,$71=.0,$72=.0,$73=0,$75=.0,$76=.0,$77=.0,$78=.0,$p_0=.0,$hml_0=.0,$80=0,$81=0,$82=.0,$83=.0,$84=0,$86=.0,$88=.0,$89=0,$90=0;
 var $91=.0,$92=.0,$93=0,$94=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $dfdq=((sp)|0);
 $1=((HEAP32[((13232)>>2)])|0);
 $2=(($1+$k)|0);
 $3=((HEAP8[($2)])|0);
 $4=(($3<<24)>>24)<3;
 if ($4) {
  $6=((HEAP32[((13976)>>2)])|0);
  $7=(($6+($k<<3))|0);
  HEAPF64[(($7)>>3)]=1.0e-8;
  $8=((HEAP32[((13880)>>2)])|0);
  $9=(($8+($k<<3))|0);
  $10=(+(HEAPF64[(($9)>>3)]));
  $11=((HEAP32[((11984)>>2)])|0);
  $12=(($11+($k<<3))|0);
  HEAPF64[(($12)>>3)]=$10;
  STACKTOP=sp;return;
 }
 $14=((HEAP32[((13880)>>2)])|0);
 $15=(($14+($k<<3))|0);
 $16=(+(HEAPF64[(($15)>>3)]));
 $17=$16<(0.0);
 if ($17) {
  $19=((-.0))-($16);
  $21=$19;
 } else {
  $21=$16;
 }

 $22=((HEAP32[((14960)>>2)])|0);
 $23=(($22+((($k)*(104))&-1)+64)|0);
 $24=(+(HEAPF64[(($23)>>3)]));
 $25=(($22+((($k)*(104))&-1)+88)|0);
 $26=(+(HEAPF64[(($25)>>3)]));
 $27=((HEAP8[(15624)])|0);
 $28=(($27<<24)>>24)==1;
 if ($28) {
  $30=(+(_DWcoeff($k,$dfdq)));
  $f_0=$30;
 } else {
  $f_0=1.0;
 }

 $32=($26)*($f_0);
 $33=($24)+($32);
 $34=($21)*($33);
 $35=(+(HEAPF64[((10984)>>3)]));
 $36=$34<$35;
 if ($36) {
  $38=((1.0))/($35);
  $39=((HEAP32[((13976)>>2)])|0);
  $40=(($39+($k<<3))|0);
  HEAPF64[(($40)>>3)]=$38;
  $41=((HEAP32[((13880)>>2)])|0);
  $42=(($41+($k<<3))|0);
  $43=(+(HEAPF64[(($42)>>3)]));
  $44=(+(HEAPF64[((11232)>>3)]));
  $45=($43)/($44);
  $46=((HEAP32[((11984)>>2)])|0);
  $47=(($46+($k<<3))|0);
  HEAPF64[(($47)>>3)]=$45;
  STACKTOP=sp;return;
 }
 $49=((HEAP8[(15624)])|0);
 $50=(($49<<24)>>24)==1;
 if ($50) {
  $52=($21)*($21);
  $53=($52)*($33);
  $54=($33)*((2.0));
  $55=($21)*($54);
  $56=((1.0))/($55);
  $57=((HEAP32[((13976)>>2)])|0);
  $58=(($57+($k<<3))|0);
  HEAPF64[(($58)>>3)]=$56;
  $59=((HEAP32[((13880)>>2)])|0);
  $60=(($59+($k<<3))|0);
  $61=(+(HEAPF64[(($60)>>3)]));
  $62=$61<(0.0);
  $63=($62?(-1.0):(1.0));
  $64=($53)*($63);
  $65=($56)*($64);
  $66=((HEAP32[((11984)>>2)])|0);
  $67=(($66+($k<<3))|0);
  HEAPF64[(($67)>>3)]=$65;
  STACKTOP=sp;return;
 }
 $69=(+(HEAPF64[((11232)>>3)]));
 $70=(+(Math_pow((+($21)),(+($69)))));
 $71=($26)*($70);
 $72=($69)*($71);
 $73=$24>(0.0);
 if ($73) {
  $75=($21)*($24);
  $76=($21)*($75);
  $77=($76)*((2.0));
  $78=($77)+($72);
  $hml_0=$76;$p_0=$78;
 } else {
  $hml_0=0.0;$p_0=$72;
 }


 $80=((HEAP32[((13880)>>2)])|0);
 $81=(($80+($k<<3))|0);
 $82=(+(HEAPF64[(($81)>>3)]));
 $83=($82)/($p_0);
 $84=$83<(0.0);
 if ($84) {
  $86=((-.0))-($83);
  $88=$86;
 } else {
  $88=$83;
 }

 $89=((HEAP32[((13976)>>2)])|0);
 $90=(($89+($k<<3))|0);
 HEAPF64[(($90)>>3)]=$88;
 $91=($71)+($hml_0);
 $92=($91)*($83);
 $93=((HEAP32[((11984)>>2)])|0);
 $94=(($93+($k<<3))|0);
 HEAPF64[(($94)>>3)]=$92;
 STACKTOP=sp;return;
}


function _pumpcoeff($k){
 $k=($k)|0;
 var $h0=0,$r=0,$1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=.0,$9=0,$11=0,$12=0,$13=0,$14=0,$15=.0,$16=0,$17=0,$19=0,$20=0,$21=.0;
 var $22=0,$24=.0,$26=.0,$27=0,$28=.0,$29=0,$30=0,$31=.0,$32=0,$34=.0,$36=.0,$_sink=.0,$38=0,$39=0,$40=0,$41=0,$42=0,$44=0,$45=0,$46=0;
 var $47=0,$48=.0,$49=.0,$50=.0,$51=.0,$52=0,$53=0,$54=.0,$55=.0,$56=0,$57=0,$58=0,$59=0,$61=0,$62=0,$63=.0,$64=.0,$65=0,$66=0,$67=.0;
 var $68=.0,$69=0,$70=.0,$71=0,$72=.0,$73=0,$74=0,$75=.0,$76=.0,$77=.0,$78=.0,$79=0,$81=.0,$82=.0,$83=.0,$84=.0,$86=.0,$87=.0,$88=0,$89=.0;
 var $90=.0,$91=0,$92=0,$93=0,$94=0,$95=.0,$96=.0,$97=0,$98=0,$99=.0,$100=.0,$101=.0,$102=.0,$103=0,$104=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $h0=((sp)|0);
 $r=(((sp)+(8))|0);
 $1=((HEAP32[((13232)>>2)])|0);
 $2=(($1+$k)|0);
 $3=((HEAP8[($2)])|0);
 $4=(($3<<24)>>24)<3;
 do {
  if (!($4)) {
   $6=((HEAP32[((15000)>>2)])|0);
   $7=(($6+($k<<3))|0);
   $8=(+(HEAPF64[(($7)>>3)]));
   $9=$8==(0.0);
   if ($9) {
    break;
   }
   $19=((HEAP32[((13880)>>2)])|0);
   $20=(($19+($k<<3))|0);
   $21=(+(HEAPF64[(($20)>>3)]));
   $22=$21<(0.0);
   if ($22) {
    $24=((-.0))-($21);
    $26=$24;
   } else {
    $26=$21;
   }

   $27=$26>=(0.000001);
   $28=($27?$26:(0.000001));
   $29=((HEAP32[((14960)>>2)])|0);
   $30=(($29+((($k)*(104))&-1)+40)|0);
   $31=(+(HEAPF64[(($30)>>3)]));
   $32=$31<(0.0);
   if ($32) {
    $36=($31)+((-0.5));
    $_sink=$36;
   } else {
    $34=($31)+((0.5));
    $_sink=$34;
   }

   $38=(~~($_sink));
   $39=((HEAP32[((13888)>>2)])|0);
   $40=(($39+($38<<7)+4)|0);
   $41=((HEAP32[(($40)>>2)])|0);
   $42=($41|0)==2;
   if ($42) {
    $44=(($39+($38<<7)+56)|0);
    $45=((HEAP32[(($44)>>2)])|0);
    $46=((HEAP32[((15000)>>2)])|0);
    $47=(($46+($k<<3))|0);
    $48=(+(HEAPF64[(($47)>>3)]));
    $49=($28)/($48);
    _curvecoeff($45,$49,$h0,$r);
    $50=(+(HEAPF64[(($h0)>>3)]));
    $51=((-.0))-($50);
    $52=((HEAP32[((13888)>>2)])|0);
    $53=(($52+($38<<7)+32)|0);
    HEAPF64[(($53)>>3)]=$51;
    $54=(+(HEAPF64[(($r)>>3)]));
    $55=((-.0))-($54);
    $56=((HEAP32[((13888)>>2)])|0);
    $57=(($56+($38<<7)+40)|0);
    HEAPF64[(($57)>>3)]=$55;
    $58=((HEAP32[((13888)>>2)])|0);
    $59=(($58+($38<<7)+48)|0);
    HEAPF64[(($59)>>3)]=1.0;
   }
   $61=((HEAP32[((15000)>>2)])|0);
   $62=(($61+($k<<3))|0);
   $63=(+(HEAPF64[(($62)>>3)]));
   $64=($63)*($63);
   $65=((HEAP32[((13888)>>2)])|0);
   $66=(($65+($38<<7)+32)|0);
   $67=(+(HEAPF64[(($66)>>3)]));
   $68=($64)*($67);
   HEAPF64[(($h0)>>3)]=$68;
   $69=(($65+($38<<7)+48)|0);
   $70=(+(HEAPF64[(($69)>>3)]));
   $71=(($65+($38<<7)+40)|0);
   $72=(+(HEAPF64[(($71)>>3)]));
   $73=((HEAP32[((15000)>>2)])|0);
   $74=(($73+($k<<3))|0);
   $75=(+(HEAPF64[(($74)>>3)]));
   $76=((2.0))-($70);
   $77=(+(Math_pow((+($75)),(+($76)))));
   $78=($72)*($77);
   HEAPF64[(($r)>>3)]=$78;
   $79=$70!=(1.0);
   if ($79) {
    $81=($70)*($78);
    $82=($70)+((-1.0));
    $83=(+(Math_pow((+($28)),(+($82)))));
    $84=($81)*($83);
    HEAPF64[(($r)>>3)]=$84;
   }
   $86=(+(HEAPF64[(($r)>>3)]));
   $87=(+(HEAPF64[((10984)>>3)]));
   $88=$86>=$87;
   $89=($88?$86:$87);
   $90=((1.0))/($89);
   $91=((HEAP32[((13976)>>2)])|0);
   $92=(($91+($k<<3))|0);
   HEAPF64[(($92)>>3)]=$90;
   $93=((HEAP32[((13880)>>2)])|0);
   $94=(($93+($k<<3))|0);
   $95=(+(HEAPF64[(($94)>>3)]));
   $96=($95)/($70);
   $97=((HEAP32[((13976)>>2)])|0);
   $98=(($97+($k<<3))|0);
   $99=(+(HEAPF64[(($98)>>3)]));
   $100=(+(HEAPF64[(($h0)>>3)]));
   $101=($99)*($100);
   $102=($96)+($101);
   $103=((HEAP32[((11984)>>2)])|0);
   $104=(($103+($k<<3))|0);
   HEAPF64[(($104)>>3)]=$102;
   STACKTOP=sp;return;
  }
 } while(0);
 $11=((HEAP32[((13976)>>2)])|0);
 $12=(($11+($k<<3))|0);
 HEAPF64[(($12)>>3)]=1.0e-8;
 $13=((HEAP32[((13880)>>2)])|0);
 $14=(($13+($k<<3))|0);
 $15=(+(HEAPF64[(($14)>>3)]));
 $16=((HEAP32[((11984)>>2)])|0);
 $17=(($16+($k<<3))|0);
 HEAPF64[(($17)>>3)]=$15;
 STACKTOP=sp;return;
}


function _pbvcoeff($k){
 $k=($k)|0;
 var $1=0,$2=0,$3=.0,$4=0,$5=0,$or_cond=0,$8=0,$9=0,$10=.0,$11=0,$12=0,$13=.0,$14=.0,$15=.0,$16=0,$19=0,$20=0,$21=0,$22=0,$23=.0;
 var $24=.0,$25=0,$26=0,label=0;

 $1=((HEAP32[((15000)>>2)])|0);
 $2=(($1+($k<<3))|0);
 $3=(+(HEAPF64[(($2)>>3)]));
 $4=$3==(-10000000000.0);
 $5=$3==(0.0);
 $or_cond=$4|$5;
 if ($or_cond) {
  _valvecoeff($k);
  return;
 }
 $8=((HEAP32[((14960)>>2)])|0);
 $9=(($8+((($k)*(104))&-1)+64)|0);
 $10=(+(HEAPF64[(($9)>>3)]));
 $11=((HEAP32[((13880)>>2)])|0);
 $12=(($11+($k<<3))|0);
 $13=(+(HEAPF64[(($12)>>3)]));
 $14=($13)*($13);
 $15=($10)*($14);
 $16=$15>$3;
 if ($16) {
  _valvecoeff($k);
  return;
 } else {
  $19=((HEAP32[((13976)>>2)])|0);
  $20=(($19+($k<<3))|0);
  HEAPF64[(($20)>>3)]=100000000.0;
  $21=((HEAP32[((15000)>>2)])|0);
  $22=(($21+($k<<3))|0);
  $23=(+(HEAPF64[(($22)>>3)]));
  $24=($23)*((100000000.0));
  $25=((HEAP32[((11984)>>2)])|0);
  $26=(($25+($k<<3))|0);
  HEAPF64[(($26)>>3)]=$24;
  return;
 }
}


function _tcvcoeff($k){
 $k=($k)|0;
 var $1=0,$2=0,$3=.0,$4=0,$5=0,$6=.0,$7=0,$9=.0,$10=0,$11=.0,$12=.0,$13=.0,$14=.0,$16=0,$17=0,label=0;

 $1=((HEAP32[((14960)>>2)])|0);
 $2=(($1+((($k)*(104))&-1)+64)|0);
 $3=(+(HEAPF64[(($2)>>3)]));
 $4=((HEAP32[((15000)>>2)])|0);
 $5=(($4+($k<<3))|0);
 $6=(+(HEAPF64[(($5)>>3)]));
 $7=$6!=(-10000000000.0);
 if ($7) {
  $9=($6)*((0.02517));
  $10=(($1+((($k)*(104))&-1)+40)|0);
  $11=(+(HEAPF64[(($10)>>3)]));
  $12=($11)*($11);
  $13=($12)*($12);
  $14=($9)/($13);
  HEAPF64[(($2)>>3)]=$14;
 }
 _valvecoeff($k);
 $16=((HEAP32[((14960)>>2)])|0);
 $17=(($16+((($k)*(104))&-1)+64)|0);
 HEAPF64[(($17)>>3)]=$3;
 return;
}


function _gpvcoeff($k){
 $k=($k)|0;
 var $h0=0,$r=0,$1=0,$2=0,$3=0,$4=0,$7=0,$8=0,$9=.0,$10=0,$12=.0,$14=.0,$15=0,$16=.0,$17=0,$18=0,$19=.0,$20=0,$22=.0,$24=.0;
 var $_sink=.0,$26=0,$27=.0,$28=.0,$29=0,$30=.0,$31=.0,$32=0,$33=0,$34=0,$35=0,$36=.0,$37=.0,$38=.0,$39=.0,$40=.0,$41=.0,$42=0,$43=0,$44=.0;
 var $45=0,$46=.0,$47=.0,$48=0,$49=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $h0=((sp)|0);
 $r=(((sp)+(8))|0);
 $1=((HEAP32[((13232)>>2)])|0);
 $2=(($1+$k)|0);
 $3=((HEAP8[($2)])|0);
 $4=(($3<<24)>>24)==2;
 if ($4) {
  _valvecoeff($k);
  STACKTOP=sp;return;
 }
 $7=((HEAP32[((13880)>>2)])|0);
 $8=(($7+($k<<3))|0);
 $9=(+(HEAPF64[(($8)>>3)]));
 $10=$9<(0.0);
 if ($10) {
  $12=((-.0))-($9);
  $14=$12;
 } else {
  $14=$9;
 }

 $15=$14>=(0.000001);
 $16=($15?$14:(0.000001));
 $17=((HEAP32[((15000)>>2)])|0);
 $18=(($17+($k<<3))|0);
 $19=(+(HEAPF64[(($18)>>3)]));
 $20=$19<(0.0);
 if ($20) {
  $24=($19)+((-0.5));
  $_sink=$24;
 } else {
  $22=($19)+((0.5));
  $_sink=$22;
 }

 $26=(~~($_sink));
 _curvecoeff($26,$16,$h0,$r);
 $27=(+(HEAPF64[(($r)>>3)]));
 $28=(+(HEAPF64[((10984)>>3)]));
 $29=$27>=$28;
 $30=($29?$27:$28);
 $31=((1.0))/($30);
 $32=((HEAP32[((13976)>>2)])|0);
 $33=(($32+($k<<3))|0);
 HEAPF64[(($33)>>3)]=$31;
 $34=((HEAP32[((13976)>>2)])|0);
 $35=(($34+($k<<3))|0);
 $36=(+(HEAPF64[(($35)>>3)]));
 $37=(+(HEAPF64[(($h0)>>3)]));
 $38=(+(HEAPF64[(($r)>>3)]));
 $39=($16)*($38);
 $40=($37)+($39);
 $41=($36)*($40);
 $42=((HEAP32[((13880)>>2)])|0);
 $43=(($42+($k<<3))|0);
 $44=(+(HEAPF64[(($43)>>3)]));
 $45=$44<(0.0);
 $46=($45?(-1.0):(1.0));
 $47=($41)*($46);
 $48=((HEAP32[((11984)>>2)])|0);
 $49=(($48+($k<<3))|0);
 HEAPF64[(($49)>>3)]=$47;
 STACKTOP=sp;return;
}


function _valvecoeff($k){
 $k=($k)|0;
 var $1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$9=0,$10=.0,$11=0,$12=0,$14=0,$15=0,$16=.0,$17=0,$19=.0,$20=0,$21=0,$22=.0,$23=.0;
 var $24=.0,$25=.0,$26=0,$p_0=.0,$27=.0,$28=0,$29=0,$30=0,$31=0,$32=.0,$33=.0,$34=0,$35=0,$37=.0,$38=.0,$39=0,$40=0,$41=0,$42=0,$43=.0;
 var $44=0,$45=0,label=0;

 $1=((HEAP32[((13232)>>2)])|0);
 $2=(($1+$k)|0);
 $3=((HEAP8[($2)])|0);
 $4=(($3<<24)>>24)<3;
 if ($4) {
  $6=((HEAP32[((13976)>>2)])|0);
  $7=(($6+($k<<3))|0);
  HEAPF64[(($7)>>3)]=1.0e-8;
  $8=((HEAP32[((13880)>>2)])|0);
  $9=(($8+($k<<3))|0);
  $10=(+(HEAPF64[(($9)>>3)]));
  $11=((HEAP32[((11984)>>2)])|0);
  $12=(($11+($k<<3))|0);
  HEAPF64[(($12)>>3)]=$10;
  return;
 }
 $14=((HEAP32[((14960)>>2)])|0);
 $15=(($14+((($k)*(104))&-1)+64)|0);
 $16=(+(HEAPF64[(($15)>>3)]));
 $17=$16>(0.0);
 if ($17) {
  $19=($16)*((2.0));
  $20=((HEAP32[((13880)>>2)])|0);
  $21=(($20+($k<<3))|0);
  $22=(+(HEAPF64[(($21)>>3)]));
  $23=(+(Math_abs((+($22)))));
  $24=($19)*($23);
  $25=(+(HEAPF64[((10984)>>3)]));
  $26=$24<$25;
  $p_0=($26?$25:$24);
  $27=((1.0))/($p_0);
  $28=((HEAP32[((13976)>>2)])|0);
  $29=(($28+($k<<3))|0);
  HEAPF64[(($29)>>3)]=$27;
  $30=((HEAP32[((13880)>>2)])|0);
  $31=(($30+($k<<3))|0);
  $32=(+(HEAPF64[(($31)>>3)]));
  $33=($32)*((0.5));
  $34=((HEAP32[((11984)>>2)])|0);
  $35=(($34+($k<<3))|0);
  HEAPF64[(($35)>>3)]=$33;
  return;
 } else {
  $37=(+(HEAPF64[((10984)>>3)]));
  $38=((1.0))/($37);
  $39=((HEAP32[((13976)>>2)])|0);
  $40=(($39+($k<<3))|0);
  HEAPF64[(($40)>>3)]=$38;
  $41=((HEAP32[((13880)>>2)])|0);
  $42=(($41+($k<<3))|0);
  $43=(+(HEAPF64[(($42)>>3)]));
  $44=((HEAP32[((11984)>>2)])|0);
  $45=(($44+($k<<3))|0);
  HEAPF64[(($45)>>3)]=$43;
  return;
 }
}


function _prvcoeff($k,$n1,$n2){
 $k=($k)|0;
 $n1=($n1)|0;
 $n2=($n2)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$13=0,$14=0,$15=.0,$16=.0,$17=.0,$18=0,$19=0,$20=0,$21=0;
 var $22=.0,$23=0,$24=0,$25=.0,$26=.0,$27=0,$28=0,$29=.0,$30=0,$31=0,$32=.0,$33=.0,$34=0,$35=0,$36=.0,$37=.0,$38=0,$39=0,$40=.0,$41=0;
 var $43=0,$44=0,$45=.0,$46=.0,$48=0,$49=0,$50=.0,$51=0,$52=0,$53=0,$54=0,$55=0,$56=.0,$57=.0,$58=0,$59=0,$60=.0,$61=0,$62=0,$63=.0;
 var $64=.0,$65=0,$66=0,$67=.0,$68=0,$69=0,$70=.0,$71=.0,$72=0,$73=0,$74=.0,$75=0,$76=0,$77=.0,$78=.0,$79=0,$80=0,$81=.0,$82=.0,$83=0;
 var $84=0,$85=.0,$86=0,$87=0,$88=.0,$89=.0,$90=0,$91=0,$92=.0,$93=.0,label=0;

 $1=((HEAP32[((13832)>>2)])|0);
 $2=(($1+($n1<<2))|0);
 $3=((HEAP32[(($2)>>2)])|0);
 $4=(($1+($n2<<2))|0);
 $5=((HEAP32[(($4)>>2)])|0);
 $6=((HEAP32[((13232)>>2)])|0);
 $7=(($6+$k)|0);
 $8=((HEAP8[($7)])|0);
 $9=(($8<<24)>>24)==4;
 if (!($9)) {
  _valvecoeff($k);
  $48=((HEAP32[((13976)>>2)])|0);
  $49=(($48+($k<<3))|0);
  $50=(+(HEAPF64[(($49)>>3)]));
  $51=((HEAP32[((14448)>>2)])|0);
  $52=(($51+($k<<2))|0);
  $53=((HEAP32[(($52)>>2)])|0);
  $54=((HEAP32[((17760)>>2)])|0);
  $55=(($54+($53<<3))|0);
  $56=(+(HEAPF64[(($55)>>3)]));
  $57=($56)-($50);
  HEAPF64[(($55)>>3)]=$57;
  $58=((HEAP32[((13976)>>2)])|0);
  $59=(($58+($k<<3))|0);
  $60=(+(HEAPF64[(($59)>>3)]));
  $61=((HEAP32[((17768)>>2)])|0);
  $62=(($61+($3<<3))|0);
  $63=(+(HEAPF64[(($62)>>3)]));
  $64=($60)+($63);
  HEAPF64[(($62)>>3)]=$64;
  $65=((HEAP32[((13976)>>2)])|0);
  $66=(($65+($k<<3))|0);
  $67=(+(HEAPF64[(($66)>>3)]));
  $68=((HEAP32[((17768)>>2)])|0);
  $69=(($68+($5<<3))|0);
  $70=(+(HEAPF64[(($69)>>3)]));
  $71=($67)+($70);
  HEAPF64[(($69)>>3)]=$71;
  $72=((HEAP32[((11984)>>2)])|0);
  $73=(($72+($k<<3))|0);
  $74=(+(HEAPF64[(($73)>>3)]));
  $75=((HEAP32[((13880)>>2)])|0);
  $76=(($75+($k<<3))|0);
  $77=(+(HEAPF64[(($76)>>3)]));
  $78=($74)-($77);
  $79=((HEAP32[((17504)>>2)])|0);
  $80=(($79+($3<<3))|0);
  $81=(+(HEAPF64[(($80)>>3)]));
  $82=($78)+($81);
  HEAPF64[(($80)>>3)]=$82;
  $83=((HEAP32[((11984)>>2)])|0);
  $84=(($83+($k<<3))|0);
  $85=(+(HEAPF64[(($84)>>3)]));
  $86=((HEAP32[((13880)>>2)])|0);
  $87=(($86+($k<<3))|0);
  $88=(+(HEAPF64[(($87)>>3)]));
  $89=($85)-($88);
  $90=((HEAP32[((17504)>>2)])|0);
  $91=(($90+($5<<3))|0);
  $92=(+(HEAPF64[(($91)>>3)]));
  $93=($92)-($89);
  HEAPF64[(($91)>>3)]=$93;
  return;
 }
 $11=((HEAP32[((15000)>>2)])|0);
 $12=((HEAP32[((14408)>>2)])|0);
 $13=(($11+($k<<3))|0);
 $14=(($12+((($n2)*(72))&-1)+32)|0);
 $15=(+(HEAPF64[(($13)>>3)]));
 $16=(+(HEAPF64[(($14)>>3)]));
 $17=($15)+($16);
 $18=((HEAP32[((13976)>>2)])|0);
 $19=(($18+($k<<3))|0);
 HEAPF64[(($19)>>3)]=0.0;
 $20=((HEAP32[((13880)>>2)])|0);
 $21=(($20+($k<<3))|0);
 $22=(+(HEAPF64[(($21)>>3)]));
 $23=((HEAP32[((12000)>>2)])|0);
 $24=(($23+($n2<<3))|0);
 $25=(+(HEAPF64[(($24)>>3)]));
 $26=($22)+($25);
 $27=((HEAP32[((11984)>>2)])|0);
 $28=(($27+($k<<3))|0);
 HEAPF64[(($28)>>3)]=$26;
 $29=($17)*((100000000.0));
 $30=((HEAP32[((17504)>>2)])|0);
 $31=(($30+($5<<3))|0);
 $32=(+(HEAPF64[(($31)>>3)]));
 $33=($29)+($32);
 HEAPF64[(($31)>>3)]=$33;
 $34=((HEAP32[((17768)>>2)])|0);
 $35=(($34+($5<<3))|0);
 $36=(+(HEAPF64[(($35)>>3)]));
 $37=($36)+((100000000.0));
 HEAPF64[(($35)>>3)]=$37;
 $38=((HEAP32[((12000)>>2)])|0);
 $39=(($38+($n2<<3))|0);
 $40=(+(HEAPF64[(($39)>>3)]));
 $41=$40<(0.0);
 if (!($41)) {
  return;
 }
 $43=((HEAP32[((17504)>>2)])|0);
 $44=(($43+($3<<3))|0);
 $45=(+(HEAPF64[(($44)>>3)]));
 $46=($40)+($45);
 HEAPF64[(($44)>>3)]=$46;
 return;
}


function _psvcoeff($k,$n1,$n2){
 $k=($k)|0;
 $n1=($n1)|0;
 $n2=($n2)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$13=0,$14=0,$15=.0,$16=.0,$17=.0,$18=0,$19=0,$20=0,$21=0;
 var $22=.0,$23=0,$24=0,$25=.0,$26=.0,$27=0,$28=0,$29=.0,$30=0,$31=0,$32=.0,$33=.0,$34=0,$35=0,$36=.0,$37=.0,$38=0,$39=0,$40=.0,$41=0;
 var $43=0,$44=0,$45=.0,$46=.0,$48=0,$49=0,$50=.0,$51=0,$52=0,$53=0,$54=0,$55=0,$56=.0,$57=.0,$58=0,$59=0,$60=.0,$61=0,$62=0,$63=.0;
 var $64=.0,$65=0,$66=0,$67=.0,$68=0,$69=0,$70=.0,$71=.0,$72=0,$73=0,$74=.0,$75=0,$76=0,$77=.0,$78=.0,$79=0,$80=0,$81=.0,$82=.0,$83=0;
 var $84=0,$85=.0,$86=0,$87=0,$88=.0,$89=.0,$90=0,$91=0,$92=.0,$93=.0,label=0;

 $1=((HEAP32[((13832)>>2)])|0);
 $2=(($1+($n1<<2))|0);
 $3=((HEAP32[(($2)>>2)])|0);
 $4=(($1+($n2<<2))|0);
 $5=((HEAP32[(($4)>>2)])|0);
 $6=((HEAP32[((13232)>>2)])|0);
 $7=(($6+$k)|0);
 $8=((HEAP8[($7)])|0);
 $9=(($8<<24)>>24)==4;
 if (!($9)) {
  _valvecoeff($k);
  $48=((HEAP32[((13976)>>2)])|0);
  $49=(($48+($k<<3))|0);
  $50=(+(HEAPF64[(($49)>>3)]));
  $51=((HEAP32[((14448)>>2)])|0);
  $52=(($51+($k<<2))|0);
  $53=((HEAP32[(($52)>>2)])|0);
  $54=((HEAP32[((17760)>>2)])|0);
  $55=(($54+($53<<3))|0);
  $56=(+(HEAPF64[(($55)>>3)]));
  $57=($56)-($50);
  HEAPF64[(($55)>>3)]=$57;
  $58=((HEAP32[((13976)>>2)])|0);
  $59=(($58+($k<<3))|0);
  $60=(+(HEAPF64[(($59)>>3)]));
  $61=((HEAP32[((17768)>>2)])|0);
  $62=(($61+($3<<3))|0);
  $63=(+(HEAPF64[(($62)>>3)]));
  $64=($60)+($63);
  HEAPF64[(($62)>>3)]=$64;
  $65=((HEAP32[((13976)>>2)])|0);
  $66=(($65+($k<<3))|0);
  $67=(+(HEAPF64[(($66)>>3)]));
  $68=((HEAP32[((17768)>>2)])|0);
  $69=(($68+($5<<3))|0);
  $70=(+(HEAPF64[(($69)>>3)]));
  $71=($67)+($70);
  HEAPF64[(($69)>>3)]=$71;
  $72=((HEAP32[((11984)>>2)])|0);
  $73=(($72+($k<<3))|0);
  $74=(+(HEAPF64[(($73)>>3)]));
  $75=((HEAP32[((13880)>>2)])|0);
  $76=(($75+($k<<3))|0);
  $77=(+(HEAPF64[(($76)>>3)]));
  $78=($74)-($77);
  $79=((HEAP32[((17504)>>2)])|0);
  $80=(($79+($3<<3))|0);
  $81=(+(HEAPF64[(($80)>>3)]));
  $82=($78)+($81);
  HEAPF64[(($80)>>3)]=$82;
  $83=((HEAP32[((11984)>>2)])|0);
  $84=(($83+($k<<3))|0);
  $85=(+(HEAPF64[(($84)>>3)]));
  $86=((HEAP32[((13880)>>2)])|0);
  $87=(($86+($k<<3))|0);
  $88=(+(HEAPF64[(($87)>>3)]));
  $89=($85)-($88);
  $90=((HEAP32[((17504)>>2)])|0);
  $91=(($90+($5<<3))|0);
  $92=(+(HEAPF64[(($91)>>3)]));
  $93=($92)-($89);
  HEAPF64[(($91)>>3)]=$93;
  return;
 }
 $11=((HEAP32[((15000)>>2)])|0);
 $12=((HEAP32[((14408)>>2)])|0);
 $13=(($11+($k<<3))|0);
 $14=(($12+((($n1)*(72))&-1)+32)|0);
 $15=(+(HEAPF64[(($13)>>3)]));
 $16=(+(HEAPF64[(($14)>>3)]));
 $17=($15)+($16);
 $18=((HEAP32[((13976)>>2)])|0);
 $19=(($18+($k<<3))|0);
 HEAPF64[(($19)>>3)]=0.0;
 $20=((HEAP32[((13880)>>2)])|0);
 $21=(($20+($k<<3))|0);
 $22=(+(HEAPF64[(($21)>>3)]));
 $23=((HEAP32[((12000)>>2)])|0);
 $24=(($23+($n1<<3))|0);
 $25=(+(HEAPF64[(($24)>>3)]));
 $26=($22)-($25);
 $27=((HEAP32[((11984)>>2)])|0);
 $28=(($27+($k<<3))|0);
 HEAPF64[(($28)>>3)]=$26;
 $29=($17)*((100000000.0));
 $30=((HEAP32[((17504)>>2)])|0);
 $31=(($30+($3<<3))|0);
 $32=(+(HEAPF64[(($31)>>3)]));
 $33=($29)+($32);
 HEAPF64[(($31)>>3)]=$33;
 $34=((HEAP32[((17768)>>2)])|0);
 $35=(($34+($3<<3))|0);
 $36=(+(HEAPF64[(($35)>>3)]));
 $37=($36)+((100000000.0));
 HEAPF64[(($35)>>3)]=$37;
 $38=((HEAP32[((12000)>>2)])|0);
 $39=(($38+($n1<<3))|0);
 $40=(+(HEAPF64[(($39)>>3)]));
 $41=$40>(0.0);
 if (!($41)) {
  return;
 }
 $43=((HEAP32[((17504)>>2)])|0);
 $44=(($43+($5<<3))|0);
 $45=(+(HEAPF64[(($44)>>3)]));
 $46=($40)+($45);
 HEAPF64[(($44)>>3)]=$46;
 return;
}


function _fcvcoeff($k,$n1,$n2){
 $k=($k)|0;
 $n1=($n1)|0;
 $n2=($n2)|0;
 var $1=0,$2=0,$3=.0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$14=0,$15=0,$16=.0,$17=.0,$18=0,$19=0,$20=.0,$21=.0;
 var $22=0,$23=0,$24=.0,$25=.0,$26=0,$27=0,$28=.0,$29=.0,$30=0,$31=0,$32=0,$33=0,$34=.0,$35=0,$36=0,$37=0,$38=0,$39=0,$40=.0,$41=.0;
 var $42=0,$43=0,$44=.0,$45=0,$46=0,$47=.0,$48=.0,$49=0,$50=0,$51=.0,$52=0,$53=0,$54=.0,$55=.0,$56=0,$57=0,$58=.0,$59=.0,$60=0,$61=0;
 var $63=0,$64=0,$65=.0,$66=0,$67=0,$68=0,$69=0,$70=0,$71=.0,$72=.0,$73=0,$74=0,$75=.0,$76=0,$77=0,$78=.0,$79=.0,$80=0,$81=0,$82=.0;
 var $83=0,$84=0,$85=.0,$86=.0,$87=0,$88=0,$89=.0,$90=0,$91=0,$92=.0,$93=.0,$94=0,$95=0,$96=.0,$97=.0,$98=0,$99=0,$100=.0,$101=0,$102=0;
 var $103=.0,$104=.0,$105=0,$106=0,$107=.0,$108=.0,label=0;

 $1=((HEAP32[((15000)>>2)])|0);
 $2=(($1+($k<<3))|0);
 $3=(+(HEAPF64[(($2)>>3)]));
 $4=((HEAP32[((13832)>>2)])|0);
 $5=(($4+($n1<<2))|0);
 $6=((HEAP32[(($5)>>2)])|0);
 $7=(($4+($n2<<2))|0);
 $8=((HEAP32[(($7)>>2)])|0);
 $9=((HEAP32[((13232)>>2)])|0);
 $10=(($9+$k)|0);
 $11=((HEAP8[($10)])|0);
 $12=(($11<<24)>>24)==4;
 if ($12) {
  $14=((HEAP32[((12000)>>2)])|0);
  $15=(($14+($n1<<3))|0);
  $16=(+(HEAPF64[(($15)>>3)]));
  $17=($16)-($3);
  HEAPF64[(($15)>>3)]=$17;
  $18=((HEAP32[((17504)>>2)])|0);
  $19=(($18+($6<<3))|0);
  $20=(+(HEAPF64[(($19)>>3)]));
  $21=($20)-($3);
  HEAPF64[(($19)>>3)]=$21;
  $22=((HEAP32[((12000)>>2)])|0);
  $23=(($22+($n2<<3))|0);
  $24=(+(HEAPF64[(($23)>>3)]));
  $25=($3)+($24);
  HEAPF64[(($23)>>3)]=$25;
  $26=((HEAP32[((17504)>>2)])|0);
  $27=(($26+($8<<3))|0);
  $28=(+(HEAPF64[(($27)>>3)]));
  $29=($3)+($28);
  HEAPF64[(($27)>>3)]=$29;
  $30=((HEAP32[((13976)>>2)])|0);
  $31=(($30+($k<<3))|0);
  HEAPF64[(($31)>>3)]=1.0e-8;
  $32=((HEAP32[((13976)>>2)])|0);
  $33=(($32+($k<<3))|0);
  $34=(+(HEAPF64[(($33)>>3)]));
  $35=((HEAP32[((14448)>>2)])|0);
  $36=(($35+($k<<2))|0);
  $37=((HEAP32[(($36)>>2)])|0);
  $38=((HEAP32[((17760)>>2)])|0);
  $39=(($38+($37<<3))|0);
  $40=(+(HEAPF64[(($39)>>3)]));
  $41=($40)-($34);
  HEAPF64[(($39)>>3)]=$41;
  $42=((HEAP32[((13976)>>2)])|0);
  $43=(($42+($k<<3))|0);
  $44=(+(HEAPF64[(($43)>>3)]));
  $45=((HEAP32[((17768)>>2)])|0);
  $46=(($45+($6<<3))|0);
  $47=(+(HEAPF64[(($46)>>3)]));
  $48=($44)+($47);
  HEAPF64[(($46)>>3)]=$48;
  $49=((HEAP32[((13976)>>2)])|0);
  $50=(($49+($k<<3))|0);
  $51=(+(HEAPF64[(($50)>>3)]));
  $52=((HEAP32[((17768)>>2)])|0);
  $53=(($52+($8<<3))|0);
  $54=(+(HEAPF64[(($53)>>3)]));
  $55=($51)+($54);
  HEAPF64[(($53)>>3)]=$55;
  $56=((HEAP32[((13880)>>2)])|0);
  $57=(($56+($k<<3))|0);
  $58=(+(HEAPF64[(($57)>>3)]));
  $59=($58)-($3);
  $60=((HEAP32[((11984)>>2)])|0);
  $61=(($60+($k<<3))|0);
  HEAPF64[(($61)>>3)]=$59;
  return;
 } else {
  _valvecoeff($k);
  $63=((HEAP32[((13976)>>2)])|0);
  $64=(($63+($k<<3))|0);
  $65=(+(HEAPF64[(($64)>>3)]));
  $66=((HEAP32[((14448)>>2)])|0);
  $67=(($66+($k<<2))|0);
  $68=((HEAP32[(($67)>>2)])|0);
  $69=((HEAP32[((17760)>>2)])|0);
  $70=(($69+($68<<3))|0);
  $71=(+(HEAPF64[(($70)>>3)]));
  $72=($71)-($65);
  HEAPF64[(($70)>>3)]=$72;
  $73=((HEAP32[((13976)>>2)])|0);
  $74=(($73+($k<<3))|0);
  $75=(+(HEAPF64[(($74)>>3)]));
  $76=((HEAP32[((17768)>>2)])|0);
  $77=(($76+($6<<3))|0);
  $78=(+(HEAPF64[(($77)>>3)]));
  $79=($75)+($78);
  HEAPF64[(($77)>>3)]=$79;
  $80=((HEAP32[((13976)>>2)])|0);
  $81=(($80+($k<<3))|0);
  $82=(+(HEAPF64[(($81)>>3)]));
  $83=((HEAP32[((17768)>>2)])|0);
  $84=(($83+($8<<3))|0);
  $85=(+(HEAPF64[(($84)>>3)]));
  $86=($82)+($85);
  HEAPF64[(($84)>>3)]=$86;
  $87=((HEAP32[((11984)>>2)])|0);
  $88=(($87+($k<<3))|0);
  $89=(+(HEAPF64[(($88)>>3)]));
  $90=((HEAP32[((13880)>>2)])|0);
  $91=(($90+($k<<3))|0);
  $92=(+(HEAPF64[(($91)>>3)]));
  $93=($89)-($92);
  $94=((HEAP32[((17504)>>2)])|0);
  $95=(($94+($6<<3))|0);
  $96=(+(HEAPF64[(($95)>>3)]));
  $97=($93)+($96);
  HEAPF64[(($95)>>3)]=$97;
  $98=((HEAP32[((11984)>>2)])|0);
  $99=(($98+($k<<3))|0);
  $100=(+(HEAPF64[(($99)>>3)]));
  $101=((HEAP32[((13880)>>2)])|0);
  $102=(($101+($k<<3))|0);
  $103=(+(HEAPF64[(($102)>>3)]));
  $104=($100)-($103);
  $105=((HEAP32[((17504)>>2)])|0);
  $106=(($105+($8<<3))|0);
  $107=(+(HEAPF64[(($106)>>3)]));
  $108=($107)-($104);
  HEAPF64[(($106)>>3)]=$108;
  return;
 }
}


function _DWcoeff($k,$dfdq){
 $k=($k)|0;
 $dfdq=($dfdq)|0;
 var $1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=.0,$9=0,$11=.0,$13=.0,$14=.0,$15=0,$16=0,$17=.0,$18=.0,$19=.0,$20=0,$22=.0,$23=.0,$24=0;
 var $25=.0,$26=.0,$27=.0,$28=.0,$29=.0,$30=.0,$31=.0,$32=.0,$34=0,$36=0,$37=.0,$38=.0,$39=.0,$40=.0,$41=.0,$42=.0,$43=.0,$44=.0,$45=.0,$46=.0;
 var $47=.0,$48=.0,$49=.0,$50=.0,$51=.0,$52=.0,$53=.0,$54=.0,$55=.0,$56=.0,$57=.0,$58=.0,$59=.0,$60=.0,$61=.0,$62=.0,$63=.0,$64=.0,$65=.0,$66=.0;
 var $67=.0,$68=.0,$69=.0,$71=0,$73=.0,$74=.0,$_0=.0,label=0;

 HEAPF64[(($dfdq)>>3)]=0.0;
 $1=((HEAP32[((14960)>>2)])|0);
 $2=(($1+((($k)*(104))&-1)+96)|0);
 $3=((HEAP8[($2)])|0);
 $4=(($3<<24)>>24)>1;
 if ($4) {
  $_0=1.0;

  return (+($_0));
 }
 $6=((HEAP32[((13880)>>2)])|0);
 $7=(($6+($k<<3))|0);
 $8=(+(HEAPF64[(($7)>>3)]));
 $9=$8<(0.0);
 if ($9) {
  $11=((-.0))-($8);
  $13=$11;
 } else {
  $13=$8;
 }

 $14=(+(HEAPF64[((10480)>>3)]));
 $15=((HEAP32[((14960)>>2)])|0);
 $16=(($15+((($k)*(104))&-1)+40)|0);
 $17=(+(HEAPF64[(($16)>>3)]));
 $18=($14)*($17);
 $19=($13)/($18);
 $20=$19<(3141.59265359);
 if (!($20)) {
  $22=(+(Math_pow((+($19)),0.9)));
  $23=((4.61841319859))/($22);
  $24=(($15+((($k)*(104))&-1)+56)|0);
  $25=(+(HEAPF64[(($24)>>3)]));
  $26=($17)*((3.7));
  $27=($25)/($26);
  $28=($23)+($27);
  $29=(+(Math_log($28)));
  $30=($29)*((-0.8685889638));
  $31=($30)*($30);
  $32=((1.0))/($31);
  $_0=$32;

  return (+($_0));
 }
 $34=$19>(1570.79632679);
 if ($34) {
  $36=(($15+((($k)*(104))&-1)+56)|0);
  $37=(+(HEAPF64[(($36)>>3)]));
  $38=($17)*((3.7));
  $39=($37)/($38);
  $40=($39)+((0.00328895476345));
  $41=(+(Math_log($40)));
  $42=($41)*((-0.8685889638));
  $43=($42)*($42);
  $44=((1.0))/($43);
  $45=($40)*($42);
  $46=((-0.00514214965799))/($45);
  $47=($46)+((2.0));
  $48=($44)*($47);
  $49=($19)/((1570.79632679));
  $50=($44)*((7.0));
  $51=($50)-($48);
  $52=($44)*((17.0));
  $53=((0.128))-($52);
  $54=($48)*((2.5));
  $55=($53)+($54);
  $56=($44)*((13.0));
  $57=($56)+((-0.128));
  $58=($48)+($48);
  $59=($57)-($58);
  $60=($44)*((3.0));
  $61=((0.032))-($60);
  $62=($48)*((0.5));
  $63=($61)+($62);
  $64=($49)*($63);
  $65=($59)+($64);
  $66=($49)*($65);
  $67=($55)+($66);
  $68=($49)*($67);
  $69=($51)+($68);
  $_0=$69;

  return (+($_0));
 }
 $71=$19>(6.283185307);
 if ($71) {
  $73=($18)*((50.2654824574));
  $74=($73)/($13);
  $_0=$74;

  return (+($_0));
 } else {
  HEAPF64[(($dfdq)>>3)]=0.0;
  $_0=8.0;

  return (+($_0));
 }
}


function _curvecoeff($i,$q,$h0,$r){
 $i=($i)|0;
 $q=+($q);
 $h0=($h0)|0;
 $r=($r)|0;
 var $1=.0,$2=.0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$k2_0=0,$11=0,$13=0,$14=.0,$15=0,$16=0,$17=0,$19=0,$21=0,$22=0,$_k2_0=0;
 var $k2_1=0,$24=0,$25=0,$26=.0,$27=0,$28=.0,$29=.0,$30=0,$31=.0,$32=0,$33=.0,$34=.0,$35=.0,$36=.0,$37=.0,$38=.0,$39=.0,$40=.0,$41=.0,$42=.0;
 var $43=.0,$44=.0,$45=.0,$46=.0,label=0;

 $1=(+(HEAPF64[((12096)>>3)]));
 $2=($1)*($q);
 $3=((HEAP32[((17648)>>2)])|0);
 $4=(($3+((($i)*(48))&-1)+40)|0);
 $5=((HEAP32[(($4)>>2)])|0);
 $6=(($3+((($i)*(48))&-1)+44)|0);
 $7=((HEAP32[(($6)>>2)])|0);
 $8=(($3+((($i)*(48))&-1)+36)|0);
 $9=((HEAP32[(($8)>>2)])|0);
 $k2_0=0;
 while(1) {

  $11=($k2_0|0)<($9|0);
  if (!($11)) {
   break;
  }
  $13=(($5+($k2_0<<3))|0);
  $14=(+(HEAPF64[(($13)>>3)]));
  $15=$14<$2;
  $16=((($k2_0)+(1))|0);
  if ($15) {
   $k2_0=$16;
  } else {
   break;
  }
 }
 $17=($k2_0|0)==0;
 if ($17) {
  $19=((($k2_0)+(1))|0);
  $k2_1=$19;
 } else {
  $21=($k2_0|0)==($9|0);
  $22=(($21<<31)>>31);
  $_k2_0=((($22)+($k2_0))|0);
  $k2_1=$_k2_0;
 }

 $24=((($k2_1)-(1))|0);
 $25=(($7+($k2_1<<3))|0);
 $26=(+(HEAPF64[(($25)>>3)]));
 $27=(($7+($24<<3))|0);
 $28=(+(HEAPF64[(($27)>>3)]));
 $29=($26)-($28);
 $30=(($5+($k2_1<<3))|0);
 $31=(+(HEAPF64[(($30)>>3)]));
 $32=(($5+($24<<3))|0);
 $33=(+(HEAPF64[(($32)>>3)]));
 $34=($31)-($33);
 $35=($29)/($34);
 HEAPF64[(($r)>>3)]=$35;
 $36=(+(HEAPF64[(($27)>>3)]));
 $37=(+(HEAPF64[(($32)>>3)]));
 $38=($35)*($37);
 $39=($36)-($38);
 HEAPF64[(($h0)>>3)]=$39;
 $40=(+(HEAPF64[((12056)>>3)]));
 $41=($39)/($40);
 HEAPF64[(($h0)>>3)]=$41;
 $42=(+(HEAPF64[(($r)>>3)]));
 $43=(+(HEAPF64[((12096)>>3)]));
 $44=($42)*($43);
 $45=(+(HEAPF64[((12056)>>3)]));
 $46=($44)/($45);
 HEAPF64[(($r)>>3)]=$46;
 return;
}


function _getdata(){
 var $1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$9=0,label=0;

 _setdefaults();
 _initreport();
 $1=((HEAP32[((15272)>>2)])|0);
 _rewind((($1)|0));
 $2=((_readdata())|0);
 $3=($2|0)==0;
 do {
  if ($3) {
   _adjustdata();
   _initunits();
  } else {
   $4=($2|0)>100;
   if ($4) {
    $9=$2;
   } else {
    break;
   }

   return (($9)|0);
  }
 } while(0);
 $6=((_inittanks())|0);
 $7=($6|0)==0;
 if (!($7)) {
  $9=$6;

  return (($9)|0);
 }
 _convertunits();
 $9=0;

 return (($9)|0);
}


function _setdefaults(){
 var $1=0,$2=0,$3=0,label=0;

 _memset(((((12928)|0))|0), ((((0)|0))|0), ((((79)|0))|0))|0;
 _memset(((((13008)|0))|0), ((((0)|0))|0), ((((79)|0))|0))|0;
 _memset(((((13088)|0))|0), ((((0)|0))|0), ((((79)|0))|0))|0;
 _memset(((((12664)|0))|0), ((((0)|0))|0), ((((259)|0))|0))|0;
 _memset(((((12400)|0))|0), ((((0)|0))|0), ((((259)|0))|0))|0;
 _memset(((((15304)|0))|0), ((((0)|0))|0), ((((259)|0))|0))|0;
 _memset(((((14688)|0))|0), ((((0)|0))|0), ((((259)|0))|0))|0;
 $1=((_strncpy(((17696)|0),((9360)|0),((31)|0)))|0);
 $2=((_strncpy(((17664)|0),((5224)|0),((31)|0)))|0);
 $3=((_strncpy(((17560)|0),((3760)|0),((31)|0)))|0);
 HEAP8[(15288)]=2;
 HEAP8[(13856)]=0;
 HEAP8[(15624)]=0;
 HEAP8[(12032)]=0;
 HEAP8[(15632)]=1;
 HEAP8[(13928)]=0;
 HEAP8[(12208)]=0;
 HEAP8[(12008)]=0;
 HEAPF64[((11224)>>3)]=0.0005;
 HEAPF64[((10992)>>3)]=0.0001;
 HEAPF64[((11240)>>3)]=0.001;
 HEAPF64[((11400)>>3)]=-10000000000.0;
 HEAP32[((14648)>>2)]=200;
 HEAP32[((17512)>>2)]=-1;
 HEAP32[((17544)>>2)]=0;
 HEAP32[((12216)>>2)]=0;
 HEAP32[((13904)>>2)]=0;
 HEAP32[((15584)>>2)]=3600;
 HEAP32[((13872)>>2)]=0;
 HEAP32[((13896)>>2)]=3600;
 HEAP32[((13272)>>2)]=3600;
 HEAP32[((13240)>>2)]=0;
 HEAP32[((13280)>>2)]=0;
 HEAP32[((12224)>>2)]=0;
 HEAPF64[((11416)>>3)]=1.0;
 HEAPF64[((10472)>>3)]=1.0;
 HEAPF64[((10600)>>3)]=1.0;
 HEAPF64[((11216)>>3)]=0.0;
 HEAPF64[((11208)>>3)]=0.0;
 HEAPF64[((11408)>>3)]=0.0;
 HEAPF64[((11376)>>3)]=-10000000000.0;
 HEAPF64[((10968)>>3)]=0.0;
 HEAPF64[((10480)>>3)]=-10000000000.0;
 HEAPF64[((10648)>>3)]=1.0;
 HEAP32[((17592)>>2)]=0;
 HEAP32[((17520)>>2)]=0;
 HEAPF64[((11352)>>3)]=0.0;
 HEAPF64[((11384)>>3)]=0.0;
 HEAPF64[((11336)>>3)]=75.0;
 HEAPF64[((11344)>>3)]=0.0;
 HEAPF64[((11000)>>3)]=2.0;
 HEAPF64[((11368)>>3)]=1.0;
 HEAPF64[((10984)>>3)]=1.0e-7;
 HEAP32[((17728)>>2)]=2;
 HEAP32[((14672)>>2)]=10;
 HEAPF64[((11392)>>3)]=0.0;
 return;
}


function _initreport(){
 var $i_016=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,label=0;

 _memset(((((13304)|0))|0), ((((0)|0))|0), ((((259)|0))|0))|0;
 HEAP32[((13960)>>2)]=0;
 HEAP8[(13184)]=1;
 HEAP8[(14568)]=1;
 HEAP8[(13192)]=0;
 HEAP8[(17528)]=0;
 HEAP8[(14400)]=0;
 HEAP8[(14952)]=0;
 $i_016=0;
 while(1) {

  $2=((15656+((($i_016)*(88))&-1))|0);
  $3=((11248+($i_016<<2))|0);
  $4=((HEAP32[(($3)>>2)])|0);
  $5=((_strncpy((($2)|0),(($4)|0),((31)|0)))|0);
  $6=((15656+((($i_016)*(88))&-1)+64)|0);
  HEAP8[($6)]=0;
  $7=((15656+((($i_016)*(88))&-1)+68)|0);
  HEAP32[(($7)>>2)]=2;
  $8=((15656+((($i_016)*(88))&-1)+72)|0);
  HEAPF64[(($8)>>3)]=100000000000000000000.0;
  $9=((15656+((($i_016)*(88))&-1)+80)|0);
  HEAPF64[(($9)>>3)]=-100000000000000000000.0;
  $10=((($i_016)+(1))|0);
  $11=($10|0)<21;
  if ($11) {
   $i_016=$10;
  } else {
   break;
  }
 }
 HEAP32[((16956)>>2)]=3;
 HEAP8[(15808)]=1;
 HEAP8[(15896)]=1;
 HEAP8[(15984)]=1;
 HEAP8[(16072)]=1;
 HEAP8[(16336)]=1;
 HEAP8[(16424)]=1;
 HEAP8[(16512)]=1;
 return;
}


function _adjustdata(){
 var $1=0,$2=0,$5=0,$6=0,$8=0,$10=0,$11=0,$14=0,$15=0,$16=0,$19=0,$20=0,$21=0,$24=0,$25=0,$26=0,$_pr=0,$29=0,$30=0,$33=0;
 var $34=0,$36=0,$37=0,$39=0,$40=0,$42=0,$43=0,$45=0,$46=0,$47=0,$48=0,$49=0,$50=0,$51=0,$52=.0,$53=0,$56=0,$57=0,$_off=0,$switch=0;
 var $_=0,$60=0,$61=0,$64=0,$65=0,$_31=.0,$66=.0,$67=0,$70=0,$72=.0,$74=.0,$76=.0,$77=0,$80=0,$82=.0,$84=.0,$86=0,$87=0,$_32=.0,$88=0;
 var $89=0,$90=0,$91=0,$i_042=0,$92=0,$93=0,$94=0,$95=0,$97=0,$98=.0,$99=0,$101=.0,$103=0,$104=0,$105=.0,$106=0,$108=.0,$109=0,$111=.0,$113=0;
 var $114=.0,$115=0,$117=0,$118=.0,$119=0,$121=0,$122=0,$124=.0,$_pr33=0,$126=0,$127=0,$129=.0,$130=0,$131=0,$132=.0,$133=0,$134=.0,$135=.0,$136=.0,$137=0;
 var $139=.0,$141=.0,$142=.0,$143=0,$144=0,$146=0,$147=0,$149=.0,$150=0,$151=0,$152=.0,$153=.0,$154=0,$156=0,$157=0,$159=0,$160=0,$161=0,$162=0,$163=0;
 var $i_140=0,$164=0,$165=0,$166=.0,$167=0,$169=.0,$171=0,$172=0,$173=0,$i_236=0,$174=0,$175=0,$demand_034=0,$176=0,$demand_035=0,$177=0,$178=0,$179=0,$181=0,$183=0;
 var $demand_0=0,$184=0,$185=0,$186=0,$187=0,$188=0,$189=0,label=0;

 $1=((HEAP32[((13896)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  HEAP32[((13896)>>2)]=3600;
 }
 $5=((HEAP32[((13272)>>2)])|0);
 $6=($5|0)==0;
 if ($6) {
  $8=((HEAP32[((13896)>>2)])|0);
  HEAP32[((13272)>>2)]=$8;
 }
 $10=((HEAP32[((15584)>>2)])|0);
 $11=($10|0)<1;
 if ($11) {
  HEAP32[((15584)>>2)]=3600;
 }
 $14=((HEAP32[((15584)>>2)])|0);
 $15=((HEAP32[((13896)>>2)])|0);
 $16=($14|0)>($15|0);
 if ($16) {
  HEAP32[((15584)>>2)]=$15;
 }
 $19=((HEAP32[((15584)>>2)])|0);
 $20=((HEAP32[((13272)>>2)])|0);
 $21=($19|0)>($20|0);
 if ($21) {
  HEAP32[((15584)>>2)]=$20;
 }
 $24=((HEAP32[((13280)>>2)])|0);
 $25=((HEAP32[((17544)>>2)])|0);
 $26=($24|0)>($25|0);
 if ($26) {
  HEAP32[((13280)>>2)]=0;
  $_pr=((HEAP32[((17544)>>2)])|0);
  $29=$_pr;
 } else {
  $29=$25;
 }

 $30=($29|0)==0;
 if ($30) {
  HEAP8[(13856)]=0;
 }
 $33=((HEAP32[((13872)>>2)])|0);
 $34=($33|0)==0;
 if ($34) {
  $36=((HEAP32[((15584)>>2)])|0);
  $37=(((($36|0))/(10))&-1);
  HEAP32[((13872)>>2)]=$37;
 }
 $39=((HEAP32[((13240)>>2)])|0);
 $40=($39|0)==0;
 if ($40) {
  $42=((HEAP32[((15584)>>2)])|0);
  $43=(((($42|0))/(10))&-1);
  HEAP32[((13240)>>2)]=$43;
 }
 $45=((HEAP32[((13240)>>2)])|0);
 $46=((HEAP32[((15584)>>2)])|0);
 $47=($45|0)<=($46|0);
 $48=($47?$45:$46);
 HEAP32[((13240)>>2)]=$48;
 $49=((HEAP32[((13872)>>2)])|0);
 $50=($49|0)<=($46|0);
 $51=($50?$49:$46);
 HEAP32[((13872)>>2)]=$51;
 $52=(+(HEAPF64[((11400)>>3)]));
 $53=$52==(-10000000000.0);
 if ($53) {
  HEAPF64[((11400)>>3)]=0.01;
 }
 $56=((HEAP8[(15632)])|0);
 $57=(($56<<24)>>24);
 $_off=((($57)-(5))|0);
 $switch=($_off>>>0)<((5)>>>0);
 $_=($switch&1);
 HEAP8[(12032)]=$_;
 do {
  if ($switch) {
   $60=((HEAP8[(13928)])|0);
   $61=(($60<<24)>>24)==0;
   if (!($61)) {
    break;
   }
   HEAP8[(13928)]=2;
  } else {
   HEAP8[(13928)]=0;
  }
 } while(0);
 $64=((HEAP8[(12032)])|0);
 $65=(($64<<24)>>24)==1;
 $_31=($65?(0.09290304):(1.0));
 $66=(+(HEAPF64[((10480)>>3)]));
 $67=$66==(-10000000000.0);
 do {
  if ($67) {
   HEAPF64[((10480)>>3)]=0.000011;
  } else {
   $70=$66>(0.001);
   if ($70) {
    $72=($66)*((0.000011));
    HEAPF64[((10480)>>3)]=$72;
    break;
   } else {
    $74=($66)/($_31);
    HEAPF64[((10480)>>3)]=$74;
    break;
   }
  }
 } while(0);
 $76=(+(HEAPF64[((11376)>>3)]));
 $77=$76==(-10000000000.0);
 do {
  if ($77) {
   HEAPF64[((11376)>>3)]=1.3e-8;
  } else {
   $80=$76>(0.0001);
   if ($80) {
    $82=($76)*((1.3e-8));
    HEAPF64[((11376)>>3)]=$82;
    break;
   } else {
    $84=($76)/($_31);
    HEAPF64[((11376)>>3)]=$84;
    break;
   }
  }
 } while(0);
 $86=((HEAP8[(15624)])|0);
 $87=(($86<<24)>>24)==0;
 $_32=($87?(1.852):(2.0));
 HEAPF64[((11232)>>3)]=$_32;
 $88=((HEAP32[((14424)>>2)])|0);
 $89=($88|0)<1;
 if (!($89)) {
  $i_042=1;
  while(1) {

   $92=((HEAP32[((14960)>>2)])|0);
   $93=(($92+((($i_042)*(104))&-1)+96)|0);
   $94=((HEAP8[($93)])|0);
   $95=(($94<<24)>>24)>1;
   L53: do {
    if (!($95)) {
     $97=(($92+((($i_042)*(104))&-1)+72)|0);
     $98=(+(HEAPF64[(($97)>>3)]));
     $99=$98==(-10000000000.0);
     if ($99) {
      $101=(+(HEAPF64[((11216)>>3)]));
      HEAPF64[(($97)>>3)]=$101;
     }
     $103=((HEAP32[((14960)>>2)])|0);
     $104=(($103+((($i_042)*(104))&-1)+80)|0);
     $105=(+(HEAPF64[(($104)>>3)]));
     $106=$105==(-10000000000.0);
     if (!($106)) {
      break;
     }
     $108=(+(HEAPF64[((10968)>>3)]));
     $109=$108==(0.0);
     if ($109) {
      $111=(+(HEAPF64[((11208)>>3)]));
      HEAPF64[(($104)>>3)]=$111;
      break;
     }
     $113=(($103+((($i_042)*(104))&-1)+56)|0);
     $114=(+(HEAPF64[(($113)>>3)]));
     $115=$114>(0.0);
     do {
      if ($115) {
       $117=(($103+((($i_042)*(104))&-1)+40)|0);
       $118=(+(HEAPF64[(($117)>>3)]));
       $119=$118>(0.0);
       if (!($119)) {
        break;
       }
       $121=((HEAP8[(15624)])|0);
       $122=(($121<<24)>>24)==0;
       if ($122) {
        $124=($108)/($114);
        HEAPF64[(($104)>>3)]=$124;
        $_pr33=((HEAP8[(15624)])|0);
        $126=$_pr33;
       } else {
        $126=$121;
       }

       $127=(($126<<24)>>24)==1;
       if ($127) {
        $129=(+(HEAPF64[((10968)>>3)]));
        $130=((HEAP32[((14960)>>2)])|0);
        $131=(($130+((($i_042)*(104))&-1)+56)|0);
        $132=(+(HEAPF64[(($131)>>3)]));
        $133=(($130+((($i_042)*(104))&-1)+40)|0);
        $134=(+(HEAPF64[(($133)>>3)]));
        $135=($132)/($134);
        $136=(+(Math_log($135)));
        $137=$136<(0.0);
        if ($137) {
         $139=((-.0))-($136);
         $141=$139;
        } else {
         $141=$136;
        }

        $142=($129)/($141);
        $143=((HEAP32[((14960)>>2)])|0);
        $144=(($143+((($i_042)*(104))&-1)+80)|0);
        HEAPF64[(($144)>>3)]=$142;
       }
       $146=((HEAP8[(15624)])|0);
       $147=(($146<<24)>>24)==2;
       if (!($147)) {
        break L53;
       }
       $149=(+(HEAPF64[((10968)>>3)]));
       $150=((HEAP32[((14960)>>2)])|0);
       $151=(($150+((($i_042)*(104))&-1)+56)|0);
       $152=(+(HEAPF64[(($151)>>3)]));
       $153=($149)*($152);
       $154=(($150+((($i_042)*(104))&-1)+80)|0);
       HEAPF64[(($154)>>3)]=$153;
       break L53;
      }
     } while(0);
     $156=((HEAP32[((14960)>>2)])|0);
     $157=(($156+((($i_042)*(104))&-1)+80)|0);
     HEAPF64[(($157)>>3)]=0.0;
    }
   } while(0);
   $159=((($i_042)+(1))|0);
   $160=((HEAP32[((14424)>>2)])|0);
   $161=($159|0)>($160|0);
   if ($161) {
    break;
   } else {
    $i_042=$159;
   }
  }
 }
 $90=((HEAP32[((14352)>>2)])|0);
 $91=($90|0)<1;
 if (!($91)) {
  $i_140=1;
  while(1) {

   $164=((HEAP32[((13176)>>2)])|0);
   $165=(($164+((($i_140)*(112))&-1)+64)|0);
   $166=(+(HEAPF64[(($165)>>3)]));
   $167=$166==(-10000000000.0);
   if ($167) {
    $169=(+(HEAPF64[((11216)>>3)]));
    HEAPF64[(($165)>>3)]=$169;
   }
   $171=((($i_140)+(1))|0);
   $172=((HEAP32[((14352)>>2)])|0);
   $173=($171|0)>($172|0);
   if ($173) {
    break;
   } else {
    $i_140=$171;
   }
  }
 }
 $162=((HEAP32[((14416)>>2)])|0);
 $163=($162|0)<1;
 if (!($163)) {
  $i_236=1;
  while(1) {

   $174=((HEAP32[((14408)>>2)])|0);
   $175=(($174+((($i_236)*(72))&-1)+40)|0);
   $demand_034=((HEAP32[(($175)>>2)])|0);
   $176=($demand_034|0)==0;
   if (!($176)) {
    $demand_035=$demand_034;
    while(1) {

     $177=(($demand_035+8)|0);
     $178=((HEAP32[(($177)>>2)])|0);
     $179=($178|0)==0;
     if ($179) {
      $181=((HEAP32[((17592)>>2)])|0);
      HEAP32[(($177)>>2)]=$181;
     }
     $183=(($demand_035+12)|0);
     $demand_0=((HEAP32[(($183)>>2)])|0);
     $184=($demand_0|0)==0;
     if ($184) {
      break;
     } else {
      $demand_035=$demand_0;
     }
    }
   }
   $185=((($i_236)+(1))|0);
   $186=((HEAP32[((14416)>>2)])|0);
   $187=($185|0)>($186|0);
   if ($187) {
    break;
   } else {
    $i_236=$185;
   }
  }
 }
 $188=((HEAP8[(13856)])|0);
 $189=(($188<<24)>>24)==0;
 if (!($189)) {
  return;
 }
 HEAP8[(16072)]=0;
 return;
}


function _initunits(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$9=0,$10=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$_=.0,$21=0,$qcf_1=.0,$22=0;
 var $_qcf_1=.0,$23=0,$qcf_3=.0,$24=0,$25=0,$26=.0,$28=.0,$30=.0,$32=0,$33=0,$34=0,$35=0,$36=0,$$etemp$1=0,$$etemp$0$0=0,$$etemp$0$1=0,$st$2$0=0,$st$3$1=0,$37=0,$38=0;
 var $_12=.0,$39=0,$qcf_5=.0,$40=0,$_qcf_5=.0,$41=0,$qcf_7=.0,$42=.0,$43=.0,$dcf_0=.0,$qcf_8=.0,$hcf_0=.0,$pcf_1=.0,$wcf_0=.0,$45=0,$47=0,$48=0,$strlen=0,$endptr=0,$ccf_0=.0;
 var $52=.0,$53=.0,$54=0,$55=0,$_13=.0,$_14=0,label=0;

 $1=((HEAP8[(12032)])|0);
 $2=(($1<<24)>>24)==1;
 $3=((HEAP8[(15632)])|0);
 $4=(($3<<24)>>24);
 $5=((10928+($4<<2))|0);
 $6=((HEAP32[(($5)>>2)])|0);
 $7=((_strcpy(((15776)|0),(($6)|0)))|0);
 do {
  if ($2) {
   HEAP16[((15688)>>1)]=109;
   HEAP16[((15864)>>1)]=109;
   $9=((HEAP8[(13928)])|0);
   $10=(($9<<24)>>24)==2;
   if ($10) {
    HEAP16[((15952)>>1)]=109;
   } else {
    HEAP32[((15952)>>2)]=6377579;
   }
   HEAP16[((16128)>>1)]=109;
   HEAP8[(16216)]=((HEAP8[(1480)])|0);HEAP8[(16217)]=((HEAP8[(1481)])|0);HEAP8[(16218)]=((HEAP8[(1482)])|0);
   $14=((HEAP8[(15632)])|0);
   $15=(($14<<24)>>24);
   $16=((10928+($15<<2))|0);
   $17=((HEAP32[(($16)>>2)])|0);
   $18=((_strcpy(((16304)|0),(($17)|0)))|0);
   HEAP32[((16392)>>2)]=7548781;
   HEAP8[(16480)]=((HEAP8[(224)])|0);HEAP8[(16481)]=((HEAP8[(225)])|0);HEAP8[(16482)]=((HEAP8[(226)])|0);HEAP8[(16483)]=((HEAP8[(227)])|0);HEAP8[(16484)]=((HEAP8[(228)])|0);HEAP8[(16485)]=((HEAP8[(229)])|0);HEAP8[(16486)]=((HEAP8[(230)])|0);
   HEAP8[(16920)]=0;
   HEAP8[(17008)]=((HEAP8[(10328)])|0);HEAP8[(17009)]=((HEAP8[(10329)])|0);HEAP8[(17010)]=((HEAP8[(10330)])|0);
   $19=((HEAP8[(15632)])|0);
   $20=(($19<<24)>>24)==6;
   $_=($20?(1699.0):(28.317));
   $21=(($19<<24)>>24)==7;
   $qcf_1=($21?(2.4466):$_);
   $22=(($19<<24)>>24)==8;
   $_qcf_1=($22?(101.94):$qcf_1);
   $23=(($19<<24)>>24)==9;
   $qcf_3=($23?(2446.6):$_qcf_1);
   $24=((HEAP8[(13928)])|0);
   $25=(($24<<24)>>24)==2;
   $26=(+(HEAPF64[((10648)>>3)]));
   if ($25) {
    $28=($26)*((0.3048));
    $wcf_0=0.7457;$pcf_1=$28;$hcf_0=0.3048;$qcf_8=$qcf_3;$dcf_0=304.8;
    break;
   } else {
    $30=($26)*((2.9876035));
    $wcf_0=0.7457;$pcf_1=$30;$hcf_0=0.3048;$qcf_8=$qcf_3;$dcf_0=304.8;
    break;
   }
  } else {
   HEAP8[(15688)]=((HEAP8[(10096)])|0);HEAP8[(15689)]=((HEAP8[(10097)])|0);HEAP8[(15690)]=((HEAP8[(10098)])|0);
   HEAP8[(15864)]=((HEAP8[(10096)])|0);HEAP8[(15865)]=((HEAP8[(10097)])|0);HEAP8[(15866)]=((HEAP8[(10098)])|0);
   HEAP32[((15952)>>2)]=6910832;
   HEAP8[(16128)]=((HEAP8[(10096)])|0);HEAP8[(16129)]=((HEAP8[(10097)])|0);HEAP8[(16130)]=((HEAP8[(10098)])|0);
   HEAP8[(16216)]=((HEAP8[(9608)])|0);HEAP8[(16217)]=((HEAP8[(9609)])|0);HEAP8[(16218)]=((HEAP8[(9610)])|0);
   $32=((HEAP8[(15632)])|0);
   $33=(($32<<24)>>24);
   $34=((10928+($33<<2))|0);
   $35=((HEAP32[(($34)>>2)])|0);
   $36=((_strcpy(((16304)|0),(($35)|0)))|0);
   HEAP32[((16392)>>2)]=7565414;
   $$etemp$1=16480;
   $$etemp$0$0=808464687;
   $$etemp$0$1=7628336;
   $st$2$0=(($$etemp$1)|0);
   HEAP32[(($st$2$0)>>2)]=$$etemp$0$0;
   $st$3$1=(($$etemp$1+4)|0);
   HEAP32[(($st$3$1)>>2)]=$$etemp$0$1;
   HEAP8[(16920)]=0;
   HEAP8[(17008)]=((HEAP8[(8392)])|0);HEAP8[(17009)]=((HEAP8[(8393)])|0);HEAP8[(17010)]=((HEAP8[(8394)])|0);
   $37=((HEAP8[(15632)])|0);
   $38=(($37<<24)>>24)==1;
   $_12=($38?(448.831):(1.0));
   $39=(($37<<24)>>24)==2;
   $qcf_5=($39?(0.64632):$_12);
   $40=(($37<<24)>>24)==3;
   $_qcf_5=($40?(0.5382):$qcf_5);
   $41=(($37<<24)>>24)==4;
   $qcf_7=($41?(1.9837):$_qcf_5);
   $42=(+(HEAPF64[((10648)>>3)]));
   $43=($42)*((0.4333));
   $wcf_0=1.0;$pcf_1=$43;$hcf_0=1.0;$qcf_8=$qcf_7;$dcf_0=12.0;
  }
 } while(0);





 HEAP8[(16040)]=0;
 $45=((HEAP8[(13856)])|0);
 if ((((($45<<24)>>24))|0)==((2)|0)) {
  HEAP32[((16040)>>2)]=7565928;
  $ccf_0=1.0;
 } else if ((((($45<<24)>>24))|0)==((3)|0)) {
  HEAP8[(16040)]=((HEAP8[(6600)])|0);HEAP8[(16041)]=((HEAP8[(6601)])|0);HEAP8[(16042)]=((HEAP8[(6602)])|0);HEAP8[(16043)]=((HEAP8[(6603)])|0);HEAP8[(16044)]=((HEAP8[(6604)])|0);HEAP8[(16045)]=((HEAP8[(6605)])|0);HEAP8[(16046)]=((HEAP8[(6606)])|0);
  $ccf_0=1.0;
 } else if ((((($45<<24)>>24))|0)==((1)|0)) {
  $47=((_strncpy(((16040)|0),((17664)|0),((31)|0)))|0);
  $48=((_strncpy(((16832)|0),((17664)|0),((31)|0)))|0);
  $strlen=((_strlen(((16832)|0)))|0);
  $endptr=((16832+$strlen)|0);
  HEAP8[($endptr)]=((HEAP8[(8024)])|0);HEAP8[((($endptr)+(1))|0)]=((HEAP8[(8025)])|0);HEAP8[((($endptr)+(2))|0)]=((HEAP8[(8026)])|0);HEAP8[((($endptr)+(3))|0)]=((HEAP8[(8027)])|0);HEAP8[((($endptr)+(4))|0)]=((HEAP8[(8028)])|0);
  $ccf_0=0.03531447540346788;
 } else {
  $ccf_0=1.0;
 }

 HEAPF64[((12048)>>3)]=$qcf_8;
 HEAPF64[((12040)>>3)]=$hcf_0;
 HEAPF64[((12056)>>3)]=$hcf_0;
 HEAPF64[((12064)>>3)]=$pcf_1;
 HEAPF64[((12072)>>3)]=$ccf_0;
 HEAPF64[((12080)>>3)]=$hcf_0;
 HEAPF64[((12088)>>3)]=$dcf_0;
 HEAPF64[((12096)>>3)]=$qcf_8;
 HEAPF64[((12104)>>3)]=$hcf_0;
 HEAPF64[((12112)>>3)]=$hcf_0;
 HEAPF64[((12120)>>3)]=$ccf_0;
 HEAPF64[((12144)>>3)]=$ccf_0;
 HEAPF64[((12152)>>3)]=1.0;
 HEAPF64[((12160)>>3)]=$wcf_0;
 $52=($hcf_0)*($hcf_0);
 $53=($hcf_0)*($52);
 HEAPF64[((12176)>>3)]=$53;
 $54=((HEAP32[((15584)>>2)])|0);
 $55=($54|0)<1800;
 $_13=($55?(0.016666666666666666):(0.0002777777777777778));
 $_14=($55?7235949:7565928);
 HEAPF64[((12168)>>3)]=$_13;
 HEAP32[((17096)>>2)]=$_14;
 return;
}


function _inittanks(){
 var $1=0,$2=0,$errcode_043=0,$j_041=0,$n_040=0,$3=0,$4=0,$5=.0,$6=0,$8=0,$9=.0,$10=0,$11=.0,$12=0,$14=0,$15=.0,$16=0,$17=0,$or_cond=0,$levelerr_0=0;
 var $20=0,$21=0,$22=0,$23=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=.0,$31=0,$32=0,$33=.0,$34=0,$36=0,$37=.0,$38=0,$39=.0,$40=0,$n_1=0;
 var $42=0,$n_139=0,$43=0,$44=0,$45=0,$46=0,$47=0,$48=0,$51=0,$52=0,$53=0,$54=0,$55=0,$56=0,$57=0,$58=0,$59=0,$60=.0,$61=.0,$62=0;
 var $63=0,$64=0,$65=0,$66=0,$67=0,$68=0,$69=0,$70=0,$71=0,$72=0,$73=.0,$74=.0,$75=0,$76=0,$77=0,$78=0,$79=0,$80=0,$81=0,$82=0;
 var $83=0,$84=0,$85=0,$86=.0,$87=.0,$88=0,$89=0,$90=0,$91=0,$92=0,$93=0,$94=.0,$95=.0,$96=.0,$97=0,$98=0,$99=0,$100=.0,$101=.0,$102=.0;
 var $103=.0,$104=.0,$105=.0,$106=.0,$107=0,$108=0,$n_2=0,$errcode_1=0,$110=0,$111=0,$112=0,$errcode_0_lcssa=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=((HEAP32[((14352)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  $errcode_0_lcssa=0;

  STACKTOP=sp;return (($errcode_0_lcssa)|0);
 } else {
  $n_040=0;$j_041=1;$errcode_043=0;
 }
 while(1) {



  $3=((HEAP32[((13176)>>2)])|0);
  $4=(($3+((($j_041)*(112))&-1)+8)|0);
  $5=(+(HEAPF64[(($4)>>3)]));
  $6=$5==(0.0);
  L5: do {
   if ($6) {
    $errcode_1=$errcode_043;$n_2=$n_040;
   } else {
    $8=(($3+((($j_041)*(112))&-1)+32)|0);
    $9=(+(HEAPF64[(($8)>>3)]));
    $10=(($3+((($j_041)*(112))&-1)+24)|0);
    $11=(+(HEAPF64[(($10)>>3)]));
    $12=$9>$11;
    if ($12) {
     label = 5;
    } else {
     $14=(($3+((($j_041)*(112))&-1)+16)|0);
     $15=(+(HEAPF64[(($14)>>3)]));
     $16=$15>$11;
     $17=$9<$15;
     $or_cond=$16|$17;
     if ($or_cond) {
      label = 5;
     } else {
      $levelerr_0=0;
     }
    }
    if ((label|0) == 5) {
     label = 0;
     $levelerr_0=1;
    }

    $20=((HEAP32[((13176)>>2)])|0);
    $21=(($20+((($j_041)*(112))&-1)+92)|0);
    $22=((HEAP32[(($21)>>2)])|0);
    $23=($22|0)>0;
    do {
     if ($23) {
      $25=((HEAP32[((17648)>>2)])|0);
      $26=(($25+((($22)*(48))&-1)+36)|0);
      $27=((HEAP32[(($26)>>2)])|0);
      $28=((($27)-(1))|0);
      $29=(($20+((($j_041)*(112))&-1)+16)|0);
      $30=(+(HEAPF64[(($29)>>3)]));
      $31=(($25+((($22)*(48))&-1)+40)|0);
      $32=((HEAP32[(($31)>>2)])|0);
      $33=(+(HEAPF64[(($32)>>3)]));
      $34=$30<$33;
      if ($34) {
       $n_139=$28;
       break;
      }
      $36=(($20+((($j_041)*(112))&-1)+24)|0);
      $37=(+(HEAPF64[(($36)>>3)]));
      $38=(($32+($28<<3))|0);
      $39=(+(HEAPF64[(($38)>>3)]));
      $40=$37>$39;
      if ($40) {
       $n_139=$28;
      } else {
       $n_1=$28;
       label = 9;
      }
     } else {
      $n_1=$n_040;
      label = 9;
     }
    } while(0);
    do {
     if ((label|0) == 9) {
      label = 0;

      $42=($levelerr_0|0)==0;
      if (!($42)) {
       $n_139=$n_1;
       break;
      }
      if (!($23)) {
       $errcode_1=$errcode_043;$n_2=$n_1;
       break L5;
      }
      $51=((HEAP32[((17648)>>2)])|0);
      $52=(($51+((($22)*(48))&-1)+36)|0);
      $53=((HEAP32[(($52)>>2)])|0);
      $54=(($51+((($22)*(48))&-1)+40)|0);
      $55=((HEAP32[(($54)>>2)])|0);
      $56=(($51+((($22)*(48))&-1)+44)|0);
      $57=((HEAP32[(($56)>>2)])|0);
      $58=((HEAP32[((13176)>>2)])|0);
      $59=(($58+((($j_041)*(112))&-1)+16)|0);
      $60=(+(HEAPF64[(($59)>>3)]));
      $61=(+(_interp($53,$55,$57,$60)));
      $62=((HEAP32[((13176)>>2)])|0);
      $63=(($62+((($j_041)*(112))&-1)+40)|0);
      HEAPF64[(($63)>>3)]=$61;
      $64=((HEAP32[((17648)>>2)])|0);
      $65=(($64+((($22)*(48))&-1)+36)|0);
      $66=((HEAP32[(($65)>>2)])|0);
      $67=(($64+((($22)*(48))&-1)+40)|0);
      $68=((HEAP32[(($67)>>2)])|0);
      $69=(($64+((($22)*(48))&-1)+44)|0);
      $70=((HEAP32[(($69)>>2)])|0);
      $71=((HEAP32[((13176)>>2)])|0);
      $72=(($71+((($j_041)*(112))&-1)+24)|0);
      $73=(+(HEAPF64[(($72)>>3)]));
      $74=(+(_interp($66,$68,$70,$73)));
      $75=((HEAP32[((13176)>>2)])|0);
      $76=(($75+((($j_041)*(112))&-1)+48)|0);
      HEAPF64[(($76)>>3)]=$74;
      $77=((HEAP32[((17648)>>2)])|0);
      $78=(($77+((($22)*(48))&-1)+36)|0);
      $79=((HEAP32[(($78)>>2)])|0);
      $80=(($77+((($22)*(48))&-1)+40)|0);
      $81=((HEAP32[(($80)>>2)])|0);
      $82=(($77+((($22)*(48))&-1)+44)|0);
      $83=((HEAP32[(($82)>>2)])|0);
      $84=((HEAP32[((13176)>>2)])|0);
      $85=(($84+((($j_041)*(112))&-1)+32)|0);
      $86=(+(HEAPF64[(($85)>>3)]));
      $87=(+(_interp($79,$81,$83,$86)));
      $88=((HEAP32[((13176)>>2)])|0);
      $89=(($88+((($j_041)*(112))&-1)+56)|0);
      HEAPF64[(($89)>>3)]=$87;
      $90=((HEAP32[((17648)>>2)])|0);
      $91=(($90+((($22)*(48))&-1)+44)|0);
      $92=((HEAP32[(($91)>>2)])|0);
      $93=(($92+($n_1<<3))|0);
      $94=(+(HEAPF64[(($93)>>3)]));
      $95=(+(HEAPF64[(($92)>>3)]));
      $96=($94)-($95);
      $97=(($90+((($22)*(48))&-1)+40)|0);
      $98=((HEAP32[(($97)>>2)])|0);
      $99=(($98+($n_1<<3))|0);
      $100=(+(HEAPF64[(($99)>>3)]));
      $101=(+(HEAPF64[(($98)>>3)]));
      $102=($100)-($101);
      $103=($96)/($102);
      $104=($103)*((4.0));
      $105=($104)/((3.141592654));
      $106=(+(Math_sqrt($105)));
      $107=((HEAP32[((13176)>>2)])|0);
      $108=(($107+((($j_041)*(112))&-1)+8)|0);
      HEAPF64[(($108)>>3)]=$106;
      $errcode_1=$errcode_043;$n_2=$n_1;
      break L5;
     }
    } while(0);

    $43=((HEAP32[((13176)>>2)])|0);
    $44=(($43+((($j_041)*(112))&-1))|0);
    $45=((HEAP32[(($44)>>2)])|0);
    $46=((HEAP32[((14408)>>2)])|0);
    $47=(($46+((($45)*(72))&-1))|0);
    $48=((_sprintf(((14488)|0),((3136)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$47,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    _writeline(14488);
    $errcode_1=200;$n_2=$n_139;
   }
  } while(0);


  $110=((($j_041)+(1))|0);
  $111=((HEAP32[((14352)>>2)])|0);
  $112=($110|0)>($111|0);
  if ($112) {
   $errcode_0_lcssa=$errcode_1;
   break;
  } else {
   $n_040=$n_2;$j_041=$110;$errcode_043=$errcode_1;
  }
 }

 STACKTOP=sp;return (($errcode_0_lcssa)|0);
}


function _convertunits(){
 var $1=0,$2=0,$3=0,$4=0,$i_0110=0,$5=.0,$6=0,$7=0,$8=.0,$9=.0,$10=.0,$11=0,$12=0,$13=.0,$14=.0,$15=0,$16=0,$17=0,$i_1107=0,$18=0;
 var $19=0,$demand_0101=0,$20=0,$demand_0102=0,$21=.0,$22=0,$23=.0,$24=.0,$25=0,$demand_0=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=.0,$32=.0,$33=.0,$34=.0,$35=.0;
 var $36=0,$37=0,$38=0,$i_298=0,$39=0,$40=0,$41=.0,$42=0,$44=.0,$45=.0,$46=.0,$48=0,$49=0,$50=0,$j_095=0,$51=0,$52=0,$53=0,$54=0,$55=0;
 var $56=.0,$57=0,$58=.0,$59=.0,$60=.0,$61=.0,$62=0,$63=0,$64=.0,$65=0,$66=0,$67=.0,$68=.0,$69=.0,$70=.0,$71=0,$72=0,$73=.0,$74=0,$75=0;
 var $76=.0,$77=.0,$78=.0,$79=.0,$80=0,$81=0,$82=.0,$83=.0,$84=.0,$85=.0,$86=.0,$87=.0,$88=.0,$89=0,$90=0,$91=.0,$92=.0,$93=.0,$94=0,$95=0;
 var $96=.0,$97=.0,$98=.0,$99=0,$100=0,$101=.0,$102=.0,$103=0,$104=0,$105=.0,$106=.0,$107=0,$108=0,$109=.0,$110=0,$111=0,$112=0,$113=.0,$114=0,$115=0;
 var $116=0,$117=0,$118=.0,$119=0,$120=.0,$121=.0,$122=0,$123=0,$124=0,$125=.0,$126=.0,$127=.0,$128=.0,$129=.0,$130=.0,$131=.0,$132=.0,$133=.0,$134=.0,$135=0;
 var $136=0,$137=0,$138=0,$k_090=0,$139=0,$140=0,$141=0,$142=0,$144=0,$145=0,$147=.0,$148=.0,$149=0,$150=.0,$151=.0,$153=.0,$154=0,$155=0,$156=.0,$157=.0;
 var $158=.0,$159=0,$160=0,$161=.0,$162=.0,$163=0,$164=0,$165=.0,$166=.0,$167=0,$168=.0,$169=.0,$170=.0,$171=.0,$172=0,$173=0,$174=.0,$175=.0,$176=0,$177=0;
 var $178=.0,$179=.0,$181=0,$183=0,$184=.0,$185=0,$187=.0,$189=.0,$_sink=.0,$191=0,$192=0,$193=0,$194=0,$196=0,$197=0,$199=.0,$200=0,$201=.0,$202=.0,$204=.0;
 var $205=0,$206=.0,$207=.0,$208=.0,$209=0,$210=0,$211=.0,$212=.0,$213=.0,$214=.0,$215=0,$216=.0,$217=.0,$219=.0,$220=0,$221=0,$222=.0,$223=.0,$224=.0,$225=0;
 var $226=0,$227=.0,$228=.0,$229=.0,$230=0,$231=0,$232=.0,$233=.0,$235=.0,$236=0,$237=.0,$238=.0,$239=0,$240=0,$241=.0,$242=.0,$243=0,$244=.0,$245=.0,$246=.0;
 var $247=.0,$248=0,$249=0,$250=.0,$251=0,$253=0,$254=0,$255=0,$257=.0,$258=.0,$260=.0,$261=0,$262=0,$263=.0,$264=.0,$266=0,$267=0,$268=0,$i_388=0,$269=0;
 var $270=0,$271=0,$272=0,$274=0,$275=0,$276=0,$278=0,$279=0,$280=0,$281=0,$282=.0,$283=0,$284=.0,$286=.0,$287=.0,$288=.0,$290=.0,$291=.0,$292=.0,$294=0;
 var $295=0,$296=.0,$297=0,$299=0,$300=0,$301=0,$302=0,$304=.0,$305=0,$306=0,$307=.0,$308=.0,$310=.0,$311=.0,$313=0,$314=0,$315=0,label=0;

 $1=((HEAP32[((14416)>>2)])|0);
 $2=($1|0)<1;
 if (!($2)) {
  $i_0110=1;
  while(1) {

   $5=(+(HEAPF64[((12040)>>3)]));
   $6=((HEAP32[((14408)>>2)])|0);
   $7=(($6+((($i_0110)*(72))&-1)+32)|0);
   $8=(+(HEAPF64[(($7)>>3)]));
   $9=($8)/($5);
   HEAPF64[(($7)>>3)]=$9;
   $10=(+(HEAPF64[((12072)>>3)]));
   $11=((HEAP32[((14408)>>2)])|0);
   $12=(($11+((($i_0110)*(72))&-1)+48)|0);
   $13=(+(HEAPF64[(($12)>>3)]));
   $14=($13)/($10);
   HEAPF64[(($12)>>3)]=$14;
   $15=((($i_0110)+(1))|0);
   $16=((HEAP32[((14416)>>2)])|0);
   $17=($15|0)>($16|0);
   if ($17) {
    break;
   } else {
    $i_0110=$15;
   }
  }
 }
 $3=((HEAP32[((14432)>>2)])|0);
 $4=($3|0)<1;
 if ($4) {
  $30=$3;
 } else {
  $i_1107=1;
  while(1) {

   $18=((HEAP32[((14408)>>2)])|0);
   $19=(($18+((($i_1107)*(72))&-1)+40)|0);
   $demand_0101=((HEAP32[(($19)>>2)])|0);
   $20=($demand_0101|0)==0;
   if (!($20)) {
    $demand_0102=$demand_0101;
    while(1) {

     $21=(+(HEAPF64[((12048)>>3)]));
     $22=(($demand_0102)|0);
     $23=(+(HEAPF64[(($22)>>3)]));
     $24=($23)/($21);
     HEAPF64[(($22)>>3)]=$24;
     $25=(($demand_0102+12)|0);
     $demand_0=((HEAP32[(($25)>>2)])|0);
     $26=($demand_0|0)==0;
     if ($26) {
      break;
     } else {
      $demand_0102=$demand_0;
     }
    }
   }
   $27=((($i_1107)+(1))|0);
   $28=((HEAP32[((14432)>>2)])|0);
   $29=($27|0)>($28|0);
   if ($29) {
    $30=$28;
    break;
   } else {
    $i_1107=$27;
   }
  }
 }

 $31=(+(HEAPF64[((12096)>>3)]));
 $32=(+(HEAPF64[((11000)>>3)]));
 $33=(+(Math_pow((+($31)),(+($32)))));
 $34=(+(HEAPF64[((12064)>>3)]));
 $35=($33)/($34);
 $36=($30|0)<1;
 if (!($36)) {
  $i_298=1;
  while(1) {

   $39=((HEAP32[((14408)>>2)])|0);
   $40=(($39+((($i_298)*(72))&-1)+56)|0);
   $41=(+(HEAPF64[(($40)>>3)]));
   $42=$41>(0.0);
   if ($42) {
    $44=(+(HEAPF64[((11000)>>3)]));
    $45=(+(Math_pow((+($41)),(+($44)))));
    $46=($35)/($45);
    HEAPF64[(($40)>>3)]=$46;
   }
   $48=((($i_298)+(1))|0);
   $49=((HEAP32[((14432)>>2)])|0);
   $50=($48|0)>($49|0);
   if ($50) {
    break;
   } else {
    $i_298=$48;
   }
  }
 }
 $37=((HEAP32[((14352)>>2)])|0);
 $38=($37|0)<1;
 if (!($38)) {
  $j_095=1;
  while(1) {

   $51=((HEAP32[((13176)>>2)])|0);
   $52=(($51+((($j_095)*(112))&-1))|0);
   $53=((HEAP32[(($52)>>2)])|0);
   $54=((HEAP32[((14408)>>2)])|0);
   $55=(($54+((($53)*(72))&-1)+32)|0);
   $56=(+(HEAPF64[(($55)>>3)]));
   $57=(($51+((($j_095)*(112))&-1)+32)|0);
   $58=(+(HEAPF64[(($57)>>3)]));
   $59=(+(HEAPF64[((12040)>>3)]));
   $60=($58)/($59);
   $61=($56)+($60);
   HEAPF64[(($57)>>3)]=$61;
   $62=((HEAP32[((14408)>>2)])|0);
   $63=(($62+((($53)*(72))&-1)+32)|0);
   $64=(+(HEAPF64[(($63)>>3)]));
   $65=((HEAP32[((13176)>>2)])|0);
   $66=(($65+((($j_095)*(112))&-1)+16)|0);
   $67=(+(HEAPF64[(($66)>>3)]));
   $68=(+(HEAPF64[((12040)>>3)]));
   $69=($67)/($68);
   $70=($64)+($69);
   HEAPF64[(($66)>>3)]=$70;
   $71=((HEAP32[((14408)>>2)])|0);
   $72=(($71+((($53)*(72))&-1)+32)|0);
   $73=(+(HEAPF64[(($72)>>3)]));
   $74=((HEAP32[((13176)>>2)])|0);
   $75=(($74+((($j_095)*(112))&-1)+24)|0);
   $76=(+(HEAPF64[(($75)>>3)]));
   $77=(+(HEAPF64[((12040)>>3)]));
   $78=($76)/($77);
   $79=($73)+($78);
   HEAPF64[(($75)>>3)]=$79;
   $80=((HEAP32[((13176)>>2)])|0);
   $81=(($80+((($j_095)*(112))&-1)+8)|0);
   $82=(+(HEAPF64[(($81)>>3)]));
   $83=(+(HEAPF64[((12040)>>3)]));
   $84=($82)/($83);
   $85=($84)*($84);
   $86=($85)*((3.141592654));
   $87=($86)*((0.25));
   HEAPF64[(($81)>>3)]=$87;
   $88=(+(HEAPF64[((12176)>>3)]));
   $89=((HEAP32[((13176)>>2)])|0);
   $90=(($89+((($j_095)*(112))&-1)+56)|0);
   $91=(+(HEAPF64[(($90)>>3)]));
   $92=($91)/($88);
   HEAPF64[(($90)>>3)]=$92;
   $93=(+(HEAPF64[((12176)>>3)]));
   $94=((HEAP32[((13176)>>2)])|0);
   $95=(($94+((($j_095)*(112))&-1)+40)|0);
   $96=(+(HEAPF64[(($95)>>3)]));
   $97=($96)/($93);
   HEAPF64[(($95)>>3)]=$97;
   $98=(+(HEAPF64[((12176)>>3)]));
   $99=((HEAP32[((13176)>>2)])|0);
   $100=(($99+((($j_095)*(112))&-1)+48)|0);
   $101=(+(HEAPF64[(($100)>>3)]));
   $102=($101)/($98);
   HEAPF64[(($100)>>3)]=$102;
   $103=((HEAP32[((13176)>>2)])|0);
   $104=(($103+((($j_095)*(112))&-1)+64)|0);
   $105=(+(HEAPF64[(($104)>>3)]));
   $106=($105)/((86400.0));
   HEAPF64[(($104)>>3)]=$106;
   $107=((HEAP32[((13176)>>2)])|0);
   $108=(($107+((($j_095)*(112))&-1)+56)|0);
   $109=(+(HEAPF64[(($108)>>3)]));
   $110=(($107+((($j_095)*(112))&-1)+72)|0);
   HEAPF64[(($110)>>3)]=$109;
   $111=((HEAP32[((14408)>>2)])|0);
   $112=(($111+((($53)*(72))&-1)+48)|0);
   $113=(+(HEAPF64[(($112)>>3)]));
   $114=((HEAP32[((13176)>>2)])|0);
   $115=(($114+((($j_095)*(112))&-1)+80)|0);
   HEAPF64[(($115)>>3)]=$113;
   $116=((HEAP32[((13176)>>2)])|0);
   $117=(($116+((($j_095)*(112))&-1)+48)|0);
   $118=(+(HEAPF64[(($117)>>3)]));
   $119=(($116+((($j_095)*(112))&-1)+104)|0);
   $120=(+(HEAPF64[(($119)>>3)]));
   $121=($118)*($120);
   HEAPF64[(($119)>>3)]=$121;
   $122=((($j_095)+(1))|0);
   $123=((HEAP32[((14352)>>2)])|0);
   $124=($122|0)>($123|0);
   if ($124) {
    break;
   } else {
    $j_095=$122;
   }
  }
 }
 $125=(+(HEAPF64[((12072)>>3)]));
 $126=(+(HEAPF64[((11408)>>3)]));
 $127=($126)/($125);
 HEAPF64[((11408)>>3)]=$127;
 $128=(+(HEAPF64[((12072)>>3)]));
 $129=(+(HEAPF64[((11400)>>3)]));
 $130=($129)/($128);
 HEAPF64[((11400)>>3)]=$130;
 $131=(+(HEAPF64[((11216)>>3)]));
 $132=($131)/((86400.0));
 HEAPF64[((11216)>>3)]=$132;
 $133=(+(HEAPF64[((11208)>>3)]));
 $134=($133)/((86400.0));
 HEAPF64[((11208)>>3)]=$134;
 $135=((HEAP32[((14424)>>2)])|0);
 $136=($135|0)<1;
 if (!($136)) {
  $k_090=1;
  while(1) {

   $139=((HEAP32[((14960)>>2)])|0);
   $140=(($139+((($k_090)*(104))&-1)+96)|0);
   $141=((HEAP8[($140)])|0);
   $142=(($141<<24)>>24)<2;
   do {
    if ($142) {
     $144=((HEAP8[(15624)])|0);
     $145=(($144<<24)>>24)==1;
     if ($145) {
      $147=(+(HEAPF64[((12040)>>3)]));
      $148=($147)*((1000.0));
      $149=(($139+((($k_090)*(104))&-1)+56)|0);
      $150=(+(HEAPF64[(($149)>>3)]));
      $151=($150)/($148);
      HEAPF64[(($149)>>3)]=$151;
     }
     $153=(+(HEAPF64[((12088)>>3)]));
     $154=((HEAP32[((14960)>>2)])|0);
     $155=(($154+((($k_090)*(104))&-1)+40)|0);
     $156=(+(HEAPF64[(($155)>>3)]));
     $157=($156)/($153);
     HEAPF64[(($155)>>3)]=$157;
     $158=(+(HEAPF64[((12080)>>3)]));
     $159=((HEAP32[((14960)>>2)])|0);
     $160=(($159+((($k_090)*(104))&-1)+48)|0);
     $161=(+(HEAPF64[(($160)>>3)]));
     $162=($161)/($158);
     HEAPF64[(($160)>>3)]=$162;
     $163=((HEAP32[((14960)>>2)])|0);
     $164=(($163+((($k_090)*(104))&-1)+64)|0);
     $165=(+(HEAPF64[(($164)>>3)]));
     $166=($165)*((0.02517));
     $167=(($163+((($k_090)*(104))&-1)+40)|0);
     $168=(+(HEAPF64[(($167)>>3)]));
     $169=($168)*($168);
     $170=($166)/($169);
     $171=($170)/($169);
     HEAPF64[(($164)>>3)]=$171;
     $172=((HEAP32[((14960)>>2)])|0);
     $173=(($172+((($k_090)*(104))&-1)+72)|0);
     $174=(+(HEAPF64[(($173)>>3)]));
     $175=($174)/((86400.0));
     HEAPF64[(($173)>>3)]=$175;
     $176=((HEAP32[((14960)>>2)])|0);
     $177=(($176+((($k_090)*(104))&-1)+80)|0);
     $178=(+(HEAPF64[(($177)>>3)]));
     $179=($178)/((86400.0));
     HEAPF64[(($177)>>3)]=$179;
    } else {
     $181=(($141<<24)>>24)==2;
     if (!($181)) {
      $235=(+(HEAPF64[((12088)>>3)]));
      $236=(($139+((($k_090)*(104))&-1)+40)|0);
      $237=(+(HEAPF64[(($236)>>3)]));
      $238=($237)/($235);
      HEAPF64[(($236)>>3)]=$238;
      $239=((HEAP32[((14960)>>2)])|0);
      $240=(($239+((($k_090)*(104))&-1)+64)|0);
      $241=(+(HEAPF64[(($240)>>3)]));
      $242=($241)*((0.02517));
      $243=(($239+((($k_090)*(104))&-1)+40)|0);
      $244=(+(HEAPF64[(($243)>>3)]));
      $245=($244)*($244);
      $246=($242)/($245);
      $247=($246)/($245);
      HEAPF64[(($240)>>3)]=$247;
      $248=((HEAP32[((14960)>>2)])|0);
      $249=(($248+((($k_090)*(104))&-1)+56)|0);
      $250=(+(HEAPF64[(($249)>>3)]));
      $251=$250!=(-10000000000.0);
      if (!($251)) {
       break;
      }
      $253=(($248+((($k_090)*(104))&-1)+96)|0);
      $254=((HEAP8[($253)])|0);
      $255=(($254<<24)>>24);
      if (((($255|0))|0)==((6)|0)) {
       $257=(+(HEAPF64[((12096)>>3)]));
       $258=($250)/($257);
       HEAPF64[(($249)>>3)]=$258;
       break;
      } else if (((($255|0))|0)==((3)|0)|((($255|0))|0)==((4)|0)|((($255|0))|0)==((5)|0)) {
       $260=(+(HEAPF64[((12064)>>3)]));
       $261=((HEAP32[((14960)>>2)])|0);
       $262=(($261+((($k_090)*(104))&-1)+56)|0);
       $263=(+(HEAPF64[(($262)>>3)]));
       $264=($263)/($260);
       HEAPF64[(($262)>>3)]=$264;
       break;
      } else {
       break;
      }
     }
     $183=(($139+((($k_090)*(104))&-1)+40)|0);
     $184=(+(HEAPF64[(($183)>>3)]));
     $185=$184<(0.0);
     if ($185) {
      $189=($184)+((-0.5));
      $_sink=$189;
     } else {
      $187=($184)+((0.5));
      $_sink=$187;
     }

     $191=(~~($_sink));
     $192=((HEAP32[((13888)>>2)])|0);
     $193=(($192+($191<<7)+4)|0);
     $194=((HEAP32[(($193)>>2)])|0);
     if (((($194|0))|0)==((0)|0)) {
      $196=((HEAP8[(12032)])|0);
      $197=(($196<<24)>>24)==1;
      if (!($197)) {
       break;
      }
      $199=(+(HEAPF64[((12160)>>3)]));
      $200=(($192+($191<<7)+40)|0);
      $201=(+(HEAPF64[(($200)>>3)]));
      $202=($201)/($199);
      HEAPF64[(($200)>>3)]=$202;
      break;
     } else if (((($194|0))|0)==((1)|0)) {
      $204=(+(HEAPF64[((12056)>>3)]));
      $205=(($192+($191<<7)+32)|0);
      $206=(+(HEAPF64[(($205)>>3)]));
      $207=($206)/($204);
      HEAPF64[(($205)>>3)]=$207;
      $208=(+(HEAPF64[((12096)>>3)]));
      $209=((HEAP32[((13888)>>2)])|0);
      $210=(($209+($191<<7)+48)|0);
      $211=(+(HEAPF64[(($210)>>3)]));
      $212=(+(Math_pow((+($208)),(+($211)))));
      $213=(+(HEAPF64[((12056)>>3)]));
      $214=($212)/($213);
      $215=(($209+($191<<7)+40)|0);
      $216=(+(HEAPF64[(($215)>>3)]));
      $217=($214)*($216);
      HEAPF64[(($215)>>3)]=$217;
     }
     $219=(+(HEAPF64[((12096)>>3)]));
     $220=((HEAP32[((13888)>>2)])|0);
     $221=(($220+($191<<7)+8)|0);
     $222=(+(HEAPF64[(($221)>>3)]));
     $223=($222)/($219);
     HEAPF64[(($221)>>3)]=$223;
     $224=(+(HEAPF64[((12096)>>3)]));
     $225=((HEAP32[((13888)>>2)])|0);
     $226=(($225+($191<<7)+16)|0);
     $227=(+(HEAPF64[(($226)>>3)]));
     $228=($227)/($224);
     HEAPF64[(($226)>>3)]=$228;
     $229=(+(HEAPF64[((12056)>>3)]));
     $230=((HEAP32[((13888)>>2)])|0);
     $231=(($230+($191<<7)+24)|0);
     $232=(+(HEAPF64[(($231)>>3)]));
     $233=($232)/($229);
     HEAPF64[(($231)>>3)]=$233;
    }
   } while(0);
   _resistance($k_090);
   $266=((($k_090)+(1))|0);
   $267=((HEAP32[((14424)>>2)])|0);
   $268=($266|0)>($267|0);
   if ($268) {
    break;
   } else {
    $k_090=$266;
   }
  }
 }
 $137=((HEAP32[((14464)>>2)])|0);
 $138=($137|0)<1;
 if ($138) {
  return;
 } else {
  $i_388=1;
 }
 while(1) {

  $269=((HEAP32[((17656)>>2)])|0);
  $270=(($269+((($i_388)*(40))&-1))|0);
  $271=((HEAP32[(($270)>>2)])|0);
  $272=($271|0)==0;
  do {
   if (!($272)) {
    $274=(($269+((($i_388)*(40))&-1)+4)|0);
    $275=((HEAP32[(($274)>>2)])|0);
    $276=($275|0)>0;
    do {
     if ($276) {
      $278=((HEAP32[((14432)>>2)])|0);
      $279=($275|0)>($278|0);
      $280=((HEAP32[((14408)>>2)])|0);
      $281=(($280+((($275)*(72))&-1)+32)|0);
      $282=(+(HEAPF64[(($281)>>3)]));
      $283=(($269+((($i_388)*(40))&-1)+16)|0);
      $284=(+(HEAPF64[(($283)>>3)]));
      if ($279) {
       $286=(+(HEAPF64[((12040)>>3)]));
       $287=($284)/($286);
       $288=($282)+($287);
       HEAPF64[(($283)>>3)]=$288;
       break;
      } else {
       $290=(+(HEAPF64[((12064)>>3)]));
       $291=($284)/($290);
       $292=($282)+($291);
       HEAPF64[(($283)>>3)]=$292;
       break;
      }
     }
    } while(0);
    $294=((HEAP32[((17656)>>2)])|0);
    $295=(($294+((($i_388)*(40))&-1)+24)|0);
    $296=(+(HEAPF64[(($295)>>3)]));
    $297=$296!=(-10000000000.0);
    if (!($297)) {
     break;
    }
    $299=((HEAP32[((14960)>>2)])|0);
    $300=(($299+((($271)*(104))&-1)+96)|0);
    $301=((HEAP8[($300)])|0);
    $302=(($301<<24)>>24);
    if (((($302|0))|0)==((3)|0)|((($302|0))|0)==((4)|0)|((($302|0))|0)==((5)|0)) {
     $304=(+(HEAPF64[((12064)>>3)]));
     $305=((HEAP32[((17656)>>2)])|0);
     $306=(($305+((($i_388)*(40))&-1)+24)|0);
     $307=(+(HEAPF64[(($306)>>3)]));
     $308=($307)/($304);
     HEAPF64[(($306)>>3)]=$308;
     break;
    } else if (((($302|0))|0)==((6)|0)) {
     $310=(+(HEAPF64[((12096)>>3)]));
     $311=($296)/($310);
     HEAPF64[(($295)>>3)]=$311;
     break;
    } else {
     break;
    }
   }
  } while(0);
  $313=((($i_388)+(1))|0);
  $314=((HEAP32[((14464)>>2)])|0);
  $315=($313|0)>($314|0);
  if ($315) {
   break;
  } else {
   $i_388=$313;
  }
 }
 return;
}


function _netsize(){
 var $line=0,$1=0,$2=0,$sect_0_ph=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$12=0,$14=0,$15=0,$17=0,$20=0,$21=0,$23=0,$24=0;
 var $26=0,$27=0,$29=0,$30=0,$32=0,$33=0,$35=0,$36=0,$39=0,$41=0,$errcode_1=0,$43=0,$errcode_2=0,$44=0,$45=0,$46=0,$47=0,$48=0,$49=0,$50=0;
 var $51=0,$52=0,$53=0,$56=0,$58=0,$59=0,$61=0,$62=0,$_errcode_2=0,$errcode_3=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+256)|0;
 $line=((sp)|0);
 HEAP32[((14640)>>2)]=0;
 HEAP32[((14584)>>2)]=0;
 HEAP32[((14608)>>2)]=0;
 HEAP32[((14600)>>2)]=0;
 HEAP32[((14576)>>2)]=0;
 HEAP32[((14664)>>2)]=0;
 HEAP32[((14592)>>2)]=0;
 HEAP32[((14656)>>2)]=0;
 HEAP32[((14616)>>2)]=-1;
 $1=((_addpattern(11488))|0);
 $2=(($line)|0);
 $sect_0_ph=-1;
 L1: while(1) {

  $3=((HEAP32[((15272)>>2)])|0);
  $4=((_fgets((($2)|0),((255)|0),(($3)|0)))|0);
  $5=($4|0)==0;
  if ($5) {
   $errcode_2=0;
   break;
  }
  L3: while(1) {
   $6=((_strtok((($2)|0),((9160)|0)))|0);
   $7=($6|0)==0;
   L5: do {
    if (!($7)) {
     $12=((HEAP8[($6)])|0);
     if ((((($12<<24)>>24))|0)==((91)|0)) {
      $14=((_findmatch($6,10656))|0);
      $15=($14|0)>-1;
      if ($15) {
       break L3;
      } else {
       break;
      }
     } else if ((((($12<<24)>>24))|0)==((59)|0)) {
      break;
     }
     switch (($sect_0_ph|0)) {
     case 1: {
      $20=((HEAP32[((14640)>>2)])|0);
      $21=((($20)+(1))|0);
      HEAP32[((14640)>>2)]=$21;
      break L5;
     }
     case 5: {
      $29=((HEAP32[((14600)>>2)])|0);
      $30=((($29)+(1))|0);
      HEAP32[((14600)>>2)]=$30;
      break L5;
     }
     case 4: {
      $26=((HEAP32[((14608)>>2)])|0);
      $27=((($26)+(1))|0);
      HEAP32[((14608)>>2)]=$27;
      break L5;
     }
     case 7: {
      $35=((HEAP32[((14664)>>2)])|0);
      $36=((($35)+(1))|0);
      HEAP32[((14664)>>2)]=$36;
      break L5;
     }
     case 8: {
      _addrule($6);
      break L5;
     }
     case 12: {
      $39=((_addpattern($6))|0);
      $errcode_1=$39;
      break;
     }
     case 2:case 3: {
      $23=((HEAP32[((14584)>>2)])|0);
      $24=((($23)+(1))|0);
      HEAP32[((14584)>>2)]=$24;
      break L5;
     }
     case 6: {
      $32=((HEAP32[((14576)>>2)])|0);
      $33=((($32)+(1))|0);
      HEAP32[((14576)>>2)]=$33;
      break L5;
     }
     case 13: {
      $41=((_addcurve($6))|0);
      $errcode_1=$41;
      break;
     }
     default: {
      break L5;
     }
     }

     $43=($errcode_1|0)==0;
     if (!($43)) {
      $errcode_2=$errcode_1;
      break L1;
     }
    }
   } while(0);
   $8=((HEAP32[((15272)>>2)])|0);
   $9=((_fgets((($2)|0),((255)|0),(($8)|0)))|0);
   $10=($9|0)==0;
   if ($10) {
    $errcode_2=0;
    break L1;
   }
  }
  $17=($14|0)==28;
  if ($17) {
   $errcode_2=0;
   break;
  } else {
   $sect_0_ph=$14;
  }
 }

 $44=((HEAP32[((14640)>>2)])|0);
 $45=((HEAP32[((14584)>>2)])|0);
 $46=((($45)+($44))|0);
 HEAP32[((14624)>>2)]=$46;
 $47=((HEAP32[((14608)>>2)])|0);
 $48=((HEAP32[((14600)>>2)])|0);
 $49=((($48)+($47))|0);
 $50=((HEAP32[((14576)>>2)])|0);
 $51=((($49)+($50))|0);
 HEAP32[((14632)>>2)]=$51;
 $52=((HEAP32[((14616)>>2)])|0);
 $53=($52|0)<1;
 if ($53) {
  HEAP32[((14616)>>2)]=1;
 }
 $56=($errcode_2|0)==0;
 if (!($56)) {
  $errcode_3=$errcode_2;

  STACKTOP=sp;return (($errcode_3)|0);
 }
 $58=((HEAP32[((14640)>>2)])|0);
 $59=($58|0)<1;
 if ($59) {
  $errcode_3=223;

  STACKTOP=sp;return (($errcode_3)|0);
 } else {
  $61=((HEAP32[((14584)>>2)])|0);
  $62=($61|0)==0;
  $_errcode_2=($62?224:$errcode_2);
  STACKTOP=sp;return (($_errcode_2)|0);
 }
}


function _addpattern($id){
 $id=($id)|0;
 var $1=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$12=0,$13=0,$14=0,$15=0,$17=0,$18=0,$19=0,$20=0,$21=0,$22=0,$23=0,$24=0;
 var $25=0,$26=0,$27=0,$28=0,$_0=0,label=0;

 $1=((HEAP32[((13952)>>2)])|0);
 $2=($1|0)==0;
 do {
  if (!($2)) {
   $4=(($1+4)|0);
   $5=((_strcmp((($id)|0),(($4)|0)))|0);
   $6=($5|0)==0;
   if ($6) {
    $_0=0;
   } else {
    break;
   }

   return (($_0)|0);
  }
 } while(0);
 $8=((HEAP32[((13952)>>2)])|0);
 $9=((_findID($id,$8))|0);
 $10=($9|0)==0;
 if (!($10)) {
  $_0=0;

  return (($_0)|0);
 }
 $12=((HEAP32[((14616)>>2)])|0);
 $13=((($12)+(1))|0);
 HEAP32[((14616)>>2)]=$13;
 $14=((_malloc(48))|0);
 $15=($14|0)==0;
 if ($15) {
  $_0=101;

  return (($_0)|0);
 }
 $17=$14;
 $18=((HEAP32[((14616)>>2)])|0);
 $19=$14;
 HEAP32[(($19)>>2)]=$18;
 $20=(($14+4)|0);
 $21=((_strncpy((($20)|0),(($id)|0),((31)|0)))|0);
 $22=(($14+36)|0);
 $23=$22;
 HEAP32[(($23)>>2)]=0;
 $24=(($14+40)|0);
 $25=$24;
 HEAP32[(($25)>>2)]=0;
 $26=((HEAP32[((13952)>>2)])|0);
 $27=(($14+44)|0);
 $28=$27;
 HEAP32[(($28)>>2)]=$26;
 HEAP32[((13952)>>2)]=$17;
 $_0=0;

 return (($_0)|0);
}


function _findmatch($line,$keyword){
 $line=($line)|0;
 $keyword=($keyword)|0;
 var $i_0=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$_0=0,label=0;

 $i_0=0;
 while(1) {

  $2=(($keyword+($i_0<<2))|0);
  $3=((HEAP32[(($2)>>2)])|0);
  $4=($3|0)==0;
  if ($4) {
   $_0=-1;
   label = 4;
   break;
  }
  $6=((_match($line,$3))|0);
  $7=($6|0)==0;
  $8=((($i_0)+(1))|0);
  if ($7) {
   $i_0=$8;
  } else {
   $_0=$i_0;
   label = 4;
   break;
  }
 }
 if ((label|0) == 4) {

  return (($_0)|0);
 }
  return 0;
}


function _addcurve($id){
 $id=($id)|0;
 var $1=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$12=0,$13=0,$14=0,$15=0,$17=0,$18=0,$19=0,$20=0,$21=0,$22=0,$23=0,$24=0;
 var $25=0,$26=0,$27=0,$28=0,$_0=0,label=0;

 $1=((HEAP32[((17640)>>2)])|0);
 $2=($1|0)==0;
 do {
  if (!($2)) {
   $4=(($1+4)|0);
   $5=((_strcmp((($id)|0),(($4)|0)))|0);
   $6=($5|0)==0;
   if ($6) {
    $_0=0;
   } else {
    break;
   }

   return (($_0)|0);
  }
 } while(0);
 $8=((HEAP32[((17640)>>2)])|0);
 $9=((_findID($id,$8))|0);
 $10=($9|0)==0;
 if (!($10)) {
  $_0=0;

  return (($_0)|0);
 }
 $12=((HEAP32[((14656)>>2)])|0);
 $13=((($12)+(1))|0);
 HEAP32[((14656)>>2)]=$13;
 $14=((_malloc(48))|0);
 $15=($14|0)==0;
 if ($15) {
  $_0=101;

  return (($_0)|0);
 }
 $17=$14;
 $18=((HEAP32[((14656)>>2)])|0);
 $19=$14;
 HEAP32[(($19)>>2)]=$18;
 $20=(($14+4)|0);
 $21=((_strncpy((($20)|0),(($id)|0),((31)|0)))|0);
 $22=(($14+36)|0);
 $23=$22;
 HEAP32[(($23)>>2)]=0;
 $24=(($14+40)|0);
 $25=$24;
 HEAP32[(($25)>>2)]=0;
 $26=((HEAP32[((17640)>>2)])|0);
 $27=(($14+44)|0);
 $28=$27;
 HEAP32[(($28)>>2)]=$26;
 HEAP32[((17640)>>2)]=$17;
 $_0=0;

 return (($_0)|0);
}


function _readdata(){
 var $line=0,$wline=0,$1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$9=0,$sect_0_ph=0,$errsum_0_ph=0,$errsum_0_ph20=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0;
 var $17=0,$18=0,$20=0,$21=0,$22=0,$24=0,$25=0,$27=0,$28=0,$29=0,$errsum_1=0,$31=0,$32=0,$33=0,$35=0,$36=0,$38=0,$40=0,$42=0,$43=0;
 var $45=0,$errsum_2=0,$47=0,$errsum_3=0,$48=0,$_=0,$errcode_0=0,$50=0,$52=0,$53=0,$55=0,$56=0,$57=0,$58=0,$60=0,$errcode_4=0,$61=0,$62=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+512)|0;
 $line=((sp)|0);
 $wline=(((sp)+(256))|0);
 $1=((_calloc(40,8))|0);
 $2=$1;
 HEAP32[((12000)>>2)]=$2;
 $3=($1|0)==0;
 $4=($3?101:0);
 if ($3) {
  $errcode_0=$4;
 } else {
  HEAP32[((14344)>>2)]=0;
  HEAP32[((14416)>>2)]=0;
  HEAP32[((14432)>>2)]=0;
  HEAP32[((14352)>>2)]=0;
  HEAP32[((14424)>>2)]=0;
  HEAP32[((14376)>>2)]=0;
  HEAP32[((14368)>>2)]=0;
  HEAP32[((14328)>>2)]=0;
  HEAP32[((14464)>>2)]=0;
  HEAP32[((14360)>>2)]=0;
  $6=((HEAP32[((14656)>>2)])|0);
  HEAP32[((14456)>>2)]=$6;
  $7=((HEAP32[((14616)>>2)])|0);
  HEAP32[((14392)>>2)]=$7;
  HEAP32[((13912)>>2)]=0;
  HEAP32[((13920)>>2)]=0;
  $8=(($line)|0);
  $9=(($wline)|0);
  $errsum_0_ph=0;$sect_0_ph=-1;
  L3: while(1) {


   $errsum_0_ph20=$errsum_0_ph;
   while(1) {

    $10=((HEAP32[((15272)>>2)])|0);
    $11=((_fgets((($8)|0),((255)|0),(($10)|0)))|0);
    $12=($11|0)==0;
    if ($12) {
     $errsum_3=$errsum_0_ph20;
     break L3;
    }
    while(1) {
     $13=((_strcpy((($9)|0),(($8)|0)))|0);
     $14=((_gettokens($9))|0);
     HEAP32[((14336)>>2)]=$14;
     $15=($14|0)==0;
     if (!($15)) {
      $20=((HEAP32[((12232)>>2)])|0);
      $21=((HEAP8[($20)])|0);
      $22=(($21<<24)>>24)==59;
      if (!($22)) {
       break;
      }
     }
     $16=((HEAP32[((15272)>>2)])|0);
     $17=((_fgets((($8)|0),((255)|0),(($16)|0)))|0);
     $18=($17|0)==0;
     if ($18) {
      $errsum_3=$errsum_0_ph20;
      break L3;
     }
    }
    $24=((_strlen((($8)|0)))|0);
    $25=($24>>>0)>((254)>>>0);
    if ($25) {
     $27=((HEAP32[((10656)>>2)])|0);
     $28=((_sprintf(((14488)|0),((5072)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$27,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     _writeline(14488);
     _writeline($8);
     $29=((($errsum_0_ph20)+(1))|0);
     $errsum_1=$29;
    } else {
     $errsum_1=$errsum_0_ph20;
    }

    $31=((HEAP32[((12232)>>2)])|0);
    $32=((HEAP8[($31)])|0);
    $33=(($32<<24)>>24)==91;
    if ($33) {
     break;
    }
    $42=((_newline($sect_0_ph,$8))|0);
    $43=($42|0)>0;
    if ($43) {
     _inperrmsg($42,$sect_0_ph,$8);
     $45=((($errsum_1)+(1))|0);
     $errsum_2=$45;
    } else {
     $errsum_2=$errsum_1;
    }

    $47=($errsum_2|0)==10;
    if ($47) {
     $errsum_3=10;
     break L3;
    } else {
     $errsum_0_ph20=$errsum_2;
    }
   }
   $35=((_findmatch($31,10656))|0);
   $36=($35|0)>-1;
   if (!($36)) {
    label = 13;
    break;
   }
   $38=($35|0)==28;
   if ($38) {
    $errsum_3=$errsum_1;
    break;
   } else {
    $errsum_0_ph=$errsum_1;$sect_0_ph=$35;
   }
  }
  if ((label|0) == 13) {
   _inperrmsg(201,$sect_0_ph,$8);
   $40=((($errsum_1)+(1))|0);
   $errsum_3=$40;
  }

  $48=($errsum_3|0)>0;
  $_=($48?200:$4);
  $errcode_0=$_;
 }

 $50=($errcode_0|0)==0;
 if (!($50)) {
  $errcode_4=$errcode_0;

  $61=((HEAP32[((12000)>>2)])|0);
  $62=$61;
  _free($62);
  STACKTOP=sp;return (($errcode_4)|0);
 }
 $52=((_unlinked())|0);
 $53=($52|0)==0;
 if (!($53)) {
  $errcode_4=$52;

  $61=((HEAP32[((12000)>>2)])|0);
  $62=$61;
  _free($62);
  STACKTOP=sp;return (($errcode_4)|0);
 }
 $55=((_getpatterns())|0);
 $56=($55|0)==0;
 if (!($56)) {
  $errcode_4=$55;

  $61=((HEAP32[((12000)>>2)])|0);
  $62=$61;
  _free($62);
  STACKTOP=sp;return (($errcode_4)|0);
 }
 $57=((_getcurves())|0);
 $58=($57|0)==0;
 if (!($58)) {
  $errcode_4=$57;

  $61=((HEAP32[((12000)>>2)])|0);
  $62=$61;
  _free($62);
  STACKTOP=sp;return (($errcode_4)|0);
 }
 $60=((_getpumpparams())|0);
 $errcode_4=$60;

 $61=((HEAP32[((12000)>>2)])|0);
 $62=$61;
 _free($62);
 STACKTOP=sp;return (($errcode_4)|0);
}


function _gettokens($s){
 $s=($s)|0;
 var $1=0,$2=0,$5=0,$len_0_ph=0,$n_1_ph=0,$_0_ph=0,$6=0,$len_0=0,$_0=0,$8=0,$or_cond=0,$10=0,$_neg20=0,$11=0,$12=0,$13=0,$15=0,$16=0,$18=0,$19=0;
 var $m_0=0,$_1=0,$21=0,$22=0,$23=0,$24=0,$25=0,label=0;

 _memset(((((12232)|0))|0), ((((0)|0))|0), ((((160)|0))|0))|0;
 $1=((_strchr((($s)|0),((59)|0)))|0);
 $2=($1|0)==0;
 if (!($2)) {
  HEAP8[($1)]=0;
 }
 $5=((_strlen((($s)|0)))|0);
 $_0_ph=$s;$n_1_ph=0;$len_0_ph=$5;
 L4: while(1) {



  $6=($n_1_ph|0)<40;
  $_0=$_0_ph;$len_0=$len_0_ph;
  while(1) {


   $8=($len_0|0)>0;
   $or_cond=$8&$6;
   if (!($or_cond)) {
    break L4;
   }
   $10=((_strcspn((($_0)|0),((9160)|0)))|0);
   $_neg20=((($len_0)-(1))|0);
   $11=((($_neg20)-($10))|0);
   $12=($10|0)==0;
   $13=(($_0+1)|0);
   if ($12) {
    $_0=$13;$len_0=$11;
   } else {
    break;
   }
  }
  $15=((HEAP8[($_0)])|0);
  $16=(($15<<24)>>24)==34;
  if ($16) {
   $18=(($_0+1)|0);
   $19=((_strcspn((($18)|0),((1416)|0)))|0);
   $_1=$18;$m_0=$19;
  } else {
   $_1=$_0;$m_0=$10;
  }


  $21=(($_1+$m_0)|0);
  HEAP8[($21)]=0;
  $22=((12232+($n_1_ph<<2))|0);
  HEAP32[(($22)>>2)]=$_1;
  $23=((($n_1_ph)+(1))|0);
  $24=((($m_0)+(1))|0);
  $25=(($_1+$24)|0);
  $_0_ph=$25;$n_1_ph=$23;$len_0_ph=$11;
 }
 return (($n_1_ph)|0);
}


function _inperrmsg($err,$sect,$line){
 $err=($err)|0;
 $sect=($sect)|0;
 $line=($line)|0;
 var $fmt=0,$id=0,$1=0,$3=0,$5=0,$6=0,$8=0,$9=0,$11=0,$12=0,$15=0,$17=0,$19=0,$21=0,$23=0,$25=0,$27=0,$29=0,$31=0,$33=0;
 var $35=0,$37=0,$39=0,$40=0,$42=0,$43=0,$45=0,$47=0,$49=0,$51=0,$53=0,$55=0,$57=0,$58=0,$59=0,$60=0,$61=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+160)|0;
 $fmt=((sp)|0);
 $id=(((sp)+(80))|0);
 $1=($sect|0)==7;
 do {
  if (((($sect|0))|0)==((20)|0)|((($sect|0))|0)==((7)|0)) {
   $3=(($id)|0);
   HEAP8[($3)]=0;
  } else {
   $5=($sect|0)==17;
   $6=(($id)|0);
   if ($5) {
    $8=((HEAP32[((12236)>>2)])|0);
    $9=((_strcpy((($6)|0),(($8)|0)))|0);
    break;
   } else {
    $11=((HEAP32[((12232)>>2)])|0);
    $12=((_strcpy((($6)|0),(($11)|0)))|0);
    break;
   }
  }
 } while(0);
 switch (($err|0)) {
 case 204: {
  $21=(($fmt)|0);
  (_memcpy((($21)|0), ((7184)|0), 49)|0);
  break;
 }
 case 201: {
  $15=(($fmt)|0);
  (_memcpy((($15)|0), ((8536)|0), 65)|0);
  break;
 }
 case 202: {
  $17=(($fmt)|0);
  (_memcpy((($17)|0), ((8336)|0), 55)|0);
  break;
 }
 case 203: {
  $19=(($fmt)|0);
  (_memcpy((($19)|0), ((7952)|0), 49)|0);
  break;
 }
 case 205: {
  $23=(($fmt)|0);
  (_memcpy((($23)|0), ((6480)|0), 57)|0);
  break;
 }
 case 206: {
  $25=(($fmt)|0);
  (_memcpy((($25)|0), ((5824)|0), 50)|0);
  break;
 }
 case 207: {
  $27=(($fmt)|0);
  (_memcpy((($27)|0), ((5488)|0), 49)|0);
  break;
 }
 case 208: {
  $29=(($fmt)|0);
  (_memcpy((($29)|0), ((5360)|0), 53)|0);
  break;
 }
 case 209: {
  $31=(($fmt)|0);
  (_memcpy((($31)|0), ((5240)|0), 47)|0);
  break;
 }
 case 210: {
  $33=(($fmt)|0);
  (_memcpy((($33)|0), ((5008)|0), 53)|0);
  break;
 }
 case 211: {
  $35=(($fmt)|0);
  (_memcpy((($35)|0), ((4880)|0), 47)|0);
  break;
 }
 case 212: {
  $37=(($fmt)|0);
  (_memcpy((($37)|0), ((4688)|0), 50)|0);
  break;
 }
 case 213: {
  $39=(($id)|0);
  HEAP8[($39)]=0;
  $40=(($fmt)|0);
  (_memcpy((($40)|0), ((4536)|0), 55)|0);
  break;
 }
 case 214: {
  $42=(($id)|0);
  HEAP8[($42)]=0;
  $43=(($fmt)|0);
  (_memcpy((($43)|0), ((5072)|0), 78)|0);
  break;
 }
 case 215: {
  $45=(($fmt)|0);
  (_memcpy((($45)|0), ((4416)|0), 42)|0);
  break;
 }
 case 216: {
  $47=(($fmt)|0);
  (_memcpy((($47)|0), ((4280)|0), 58)|0);
  break;
 }
 case 217: {
  $49=(($fmt)|0);
  (_memcpy((($49)|0), ((4152)|0), 46)|0);
  break;
 }
 case 219: {
  $51=(($fmt)|0);
  (_memcpy((($51)|0), ((4024)|0), 54)|0);
  break;
 }
 case 220: {
  $53=(($fmt)|0);
  (_memcpy((($53)|0), ((3880)|0), 61)|0);
  break;
 }
 case 222: {
  $55=(($fmt)|0);
  (_memcpy((($55)|0), ((3776)|0), 53)|0);
  break;
 }
 default: {
  STACKTOP=sp;return;
 }
 }
 $57=(($fmt)|0);
 $58=((10816+($sect<<2))|0);
 $59=((HEAP32[(($58)>>2)])|0);
 $60=(($id)|0);
 $61=((_sprintf(((14488)|0),(($57)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$59,HEAP32[(((tempVarArgs)+(8))>>2)]=$60,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline(14488);
 do {
  if (!($1)) {
   if (((($err|0))|0)==((213)|0)|((($err|0))|0)==((201)|0)) {
    break;
   }
   _writeline(11488);
   STACKTOP=sp;return;
  }
 } while(0);
 _writeline($line);
 STACKTOP=sp;return;
}


function _newline($sect,$line){
 $sect=($sect)|0;
 $line=($line)|0;
 var $2=0,$3=0,$5=0,$6=0,$7=0,$8=0,$9=0,$12=0,$13=0,$14=0,$15=0,$16=0,$18=0,$20=0,$22=0,$24=0,$26=0,$28=0,$30=0,$32=0;
 var $34=0,$36=0,$38=0,$40=0,$42=0,$44=0,$46=0,$48=0,$50=0,$52=0,$54=0,$56=0,$_0=0,label=0;

 L1: do {
  switch (($sect|0)) {
  case 12: {
   $28=((_patterndata())|0);
   $_0=$28;
   break;
  }
  case 6: {
   $26=((_valvedata())|0);
   $_0=$26;
   break;
  }
  case 13: {
   $30=((_curvedata())|0);
   $_0=$30;
   break;
  }
  case 1: {
   $18=((_juncdata())|0);
   $_0=$18;
   break;
  }
  case 9: {
   $32=((_demanddata())|0);
   $_0=$32;
   break;
  }
  case 4: {
   $22=((_pipedata())|0);
   $_0=$22;
   break;
  }
  case 5: {
   $24=((_pumpdata())|0);
   $_0=$24;
   break;
  }
  case 7: {
   $34=((_controldata())|0);
   $_0=$34;
   break;
  }
  case 2:case 3: {
   $20=((_tankdata())|0);
   $_0=$20;
   break;
  }
  case 0: {
   $2=((HEAP32[((14344)>>2)])|0);
   $3=($2|0)<3;
   if (!($3)) {
    $_0=0;
    break L1;
   }
   $5=((_strlen((($line)|0)))|0);
   $6=((($5)-(1))|0);
   $7=(($line+$6)|0);
   $8=((HEAP8[($7)])|0);
   $9=(($8<<24)>>24)==10;
   if ($9) {
    HEAP8[($7)]=32;
   }
   $12=((HEAP32[((14344)>>2)])|0);
   $13=((12928+((($12)*(80))&-1))|0);
   $14=((_strncpy((($13)|0),(($line)|0),((79)|0)))|0);
   $15=((HEAP32[((14344)>>2)])|0);
   $16=((($15)+(1))|0);
   HEAP32[((14344)>>2)]=$16;
   $_0=0;
   break;
  }
  case 8: {
   $36=((_ruledata())|0);
   $_0=$36;
   break;
  }
  case 10: {
   $38=((_sourcedata())|0);
   $_0=$38;
   break;
  }
  case 11: {
   $40=((_emitterdata())|0);
   $_0=$40;
   break;
  }
  case 14: {
   $42=((_qualdata())|0);
   $_0=$42;
   break;
  }
  case 15: {
   $44=((_statusdata())|0);
   $_0=$44;
   break;
  }
  case 17: {
   $46=((_energydata())|0);
   $_0=$46;
   break;
  }
  case 18: {
   $48=((_reactdata())|0);
   $_0=$48;
   break;
  }
  case 19: {
   $50=((_mixingdata())|0);
   $_0=$50;
   break;
  }
  case 20: {
   $52=((_reportdata())|0);
   $_0=$52;
   break;
  }
  case 21: {
   $54=((_timedata())|0);
   $_0=$54;
   break;
  }
  case 22: {
   $56=((_optiondata())|0);
   $_0=$56;
   break;
  }
  case 16:case 23:case 25:case 27:case 24:case 26: {
   $_0=0;
   break;
  }
  default: {
   $_0=201;
  }
  }
 } while(0);

 return (($_0)|0);
}


function _unlinked(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$i_018=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$21=0;
 var $22=0,$23=0,$24=0,$25=0,$i_1=0,$err_0=0,$26=0,$27=0,$29=0,$30=0,$31=0,$33=0,$34=0,$35=0,$36=0,$err_1=0,$38=0,$39=0,$err_2=0,$41=0;
 var $_=0,$errcode_0=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=((HEAP32[((14416)>>2)])|0);
 $2=((($1)+(1))|0);
 $3=((_calloc($2,1))|0);
 $4=($3|0)==0;
 $5=($4?101:0);
 if ($4) {
  $errcode_0=$5;

  _free($3);
  STACKTOP=sp;return (($errcode_0)|0);
 }
 $7=((HEAP32[((14416)>>2)])|0);
 $8=((($7)+(1))|0);
 _memset((((($3)|0))|0), ((((0)|0))|0), (((($8)|0))|0))|0;
 $9=((HEAP32[((14424)>>2)])|0);
 $10=($9|0)<1;
 if ($10) {
  $err_0=0;$i_1=1;
 } else {
  $11=((HEAP32[((14960)>>2)])|0);
  $12=((HEAP32[((14424)>>2)])|0);
  $i_018=1;
  while(1) {

   $14=(($11+((($i_018)*(104))&-1)+32)|0);
   $15=((HEAP32[(($14)>>2)])|0);
   $16=(($3+$15)|0);
   $17=((HEAP8[($16)])|0);
   $18=((($17)+(1))&255);
   HEAP8[($16)]=$18;
   $19=(($11+((($i_018)*(104))&-1)+36)|0);
   $20=((HEAP32[(($19)>>2)])|0);
   $21=(($3+$20)|0);
   $22=((HEAP8[($21)])|0);
   $23=((($22)+(1))&255);
   HEAP8[($21)]=$23;
   $24=((($i_018)+(1))|0);
   $25=($24|0)>($12|0);
   if ($25) {
    $err_0=0;$i_1=1;
    break;
   } else {
    $i_018=$24;
   }
  }
 }
 while(1) {


  $26=((HEAP32[((14432)>>2)])|0);
  $27=($i_1|0)>($26|0);
  if ($27) {
   $err_2=$err_0;
   break;
  }
  $29=(($3+$i_1)|0);
  $30=((HEAP8[($29)])|0);
  $31=(($30<<24)>>24)==0;
  if ($31) {
   $33=((($err_0)+(1))|0);
   $34=((HEAP32[((14408)>>2)])|0);
   $35=(($34+((($i_1)*(72))&-1))|0);
   $36=((_sprintf(((14488)|0),((2304)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$35,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   _writeline(14488);
   $err_1=$33;
  } else {
   $err_1=$err_0;
  }

  $38=($err_1|0)>9;
  $39=((($i_1)+(1))|0);
  if ($38) {
   $err_2=$err_1;
   break;
  } else {
   $err_0=$err_1;$i_1=$39;
  }
 }

 $41=($err_2|0)>0;
 $_=($41?200:$5);
 $errcode_0=$_;

 _free($3);
 STACKTOP=sp;return (($errcode_0)|0);
}


function _getpatterns(){
 var $pat_028=0,$1=0,$pat_029=0,$2=0,$3=0,$4=0,$5=0,$6=0,$9=0,$10=0,$11=0,$or_cond=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$22=0;
 var $23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$32=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0,$j_027_in=0,$f_026=0,$j_027=0,$41=0;
 var $42=.0,$43=0,$44=0,$45=0,$46=0,$47=0,$48=0,$49=0,$50=0,$or_cond23=0,$51=0,$pat_0=0,$52=0,$_0=0,label=0;

 $pat_028=((HEAP32[((13952)>>2)])|0);
 $1=($pat_028|0)==0;
 if ($1) {
  $_0=0;

  return (($_0)|0);
 } else {
  $pat_029=$pat_028;
 }
 L3: while(1) {

  $2=(($pat_029)|0);
  $3=((HEAP32[(($2)>>2)])|0);
  $4=(($pat_029+4)|0);
  $5=((_strcmp((($4)|0),((17560)|0)))|0);
  $6=($5|0)==0;
  if ($6) {
   HEAP32[((17592)>>2)]=$3;
  }
  $9=($3|0)<0;
  $10=((HEAP32[((14616)>>2)])|0);
  $11=($3|0)>($10|0);
  $or_cond=$9|$11;
  do {
   if (!($or_cond)) {
    $13=((HEAP32[((13944)>>2)])|0);
    $14=(($13+((($3)*(40))&-1))|0);
    $15=((_strcpy((($14)|0),(($4)|0)))|0);
    $16=((HEAP32[((13944)>>2)])|0);
    $17=(($16+((($3)*(40))&-1)+32)|0);
    $18=((HEAP32[(($17)>>2)])|0);
    $19=($18|0)==0;
    if ($19) {
     HEAP32[(($17)>>2)]=1;
    }
    $22=((HEAP32[((13944)>>2)])|0);
    $23=(($22+((($3)*(40))&-1)+32)|0);
    $24=((HEAP32[(($23)>>2)])|0);
    $25=((_calloc($24,8))|0);
    $26=$25;
    $27=((HEAP32[((13944)>>2)])|0);
    $28=(($27+((($3)*(40))&-1)+36)|0);
    HEAP32[(($28)>>2)]=$26;
    $29=((HEAP32[((13944)>>2)])|0);
    $30=(($29+((($3)*(40))&-1)+36)|0);
    $31=((HEAP32[(($30)>>2)])|0);
    $32=($31|0)==0;
    if ($32) {
     $_0=101;
     label = 13;
     break L3;
    }
    $34=(($pat_029+36)|0);
    $35=((HEAP32[(($34)>>2)])|0);
    $36=(($29+((($3)*(40))&-1)+32)|0);
    $37=((HEAP32[(($36)>>2)])|0);
    $38=($35|0)==0;
    if ($38) {
     HEAPF64[(($31)>>3)]=1.0;
     break;
    }
    $39=($37|0)>0;
    if ($39) {
     $f_026=$35;$j_027_in=$37;
    } else {
     break;
    }
    while(1) {


     $j_027=((($j_027_in)-(1))|0);
     $41=(($f_026)|0);
     $42=(+(HEAPF64[(($41)>>3)]));
     $43=((HEAP32[((13944)>>2)])|0);
     $44=(($43+((($3)*(40))&-1)+36)|0);
     $45=((HEAP32[(($44)>>2)])|0);
     $46=(($45+($j_027<<3))|0);
     HEAPF64[(($46)>>3)]=$42;
     $47=(($f_026+8)|0);
     $48=((HEAP32[(($47)>>2)])|0);
     $49=($48|0)!=0;
     $50=($j_027|0)>0;
     $or_cond23=$49&$50;
     if ($or_cond23) {
      $f_026=$48;$j_027_in=$j_027;
     } else {
      break;
     }
    }
   }
  } while(0);
  $51=(($pat_029+44)|0);
  $pat_0=((HEAP32[(($51)>>2)])|0);
  $52=($pat_0|0)==0;
  if ($52) {
   $_0=0;
   label = 13;
   break;
  } else {
   $pat_029=$pat_0;
  }
 }
 if ((label|0) == 13) {

  return (($_0)|0);
 }
  return 0;
}


function _getcurves(){
 var $c_044=0,$1=0,$c_045=0,$2=0,$3=0,$4=0,$5=0,$6=0,$or_cond=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$17=0,$19=0,$20=0;
 var $21=0,$22=0,$23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$32=0,$33=0,$35=0,$36=0,$37=0,$39=0,$40=0,$41=0,$42=0;
 var $43=0,$fy_033=0,$notlhs35=0,$notrhs36=0,$or_cond31_not37=0,$44=0,$or_cond3238=0,$j_042_in=0,$fy_041=0,$fx_040=0,$x_039=.0,$j_042=0,$45=0,$46=.0,$47=0,$49=0,$51=0,$52=0,$53=0,$54=0;
 var $55=0,$56=0,$57=0,$58=.0,$59=0,$60=0,$61=0,$62=0,$63=0,$fy_0=0,$notlhs=0,$notrhs=0,$or_cond31_not=0,$64=0,$or_cond32=0,$65=0,$c_0=0,$66=0,$_0=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $c_044=((HEAP32[((17640)>>2)])|0);
 $1=($c_044|0)==0;
 if ($1) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 } else {
  $c_045=$c_044;
 }
 L3: while(1) {

  $2=(($c_045)|0);
  $3=((HEAP32[(($2)>>2)])|0);
  $4=($3|0)<1;
  $5=((HEAP32[((14656)>>2)])|0);
  $6=($3|0)>($5|0);
  $or_cond=$4|$6;
  do {
   if (!($or_cond)) {
    $8=((HEAP32[((17648)>>2)])|0);
    $9=(($8+((($3)*(48))&-1))|0);
    $10=(($c_045+4)|0);
    $11=((_strcpy((($9)|0),(($10)|0)))|0);
    $12=((HEAP32[((17648)>>2)])|0);
    $13=(($12+((($3)*(48))&-1)+36)|0);
    $14=((HEAP32[(($13)>>2)])|0);
    $15=($14|0)<1;
    if ($15) {
     label = 4;
     break L3;
    }
    $19=((_calloc($14,8))|0);
    $20=$19;
    $21=((HEAP32[((17648)>>2)])|0);
    $22=(($21+((($3)*(48))&-1)+40)|0);
    HEAP32[(($22)>>2)]=$20;
    $23=((HEAP32[((17648)>>2)])|0);
    $24=(($23+((($3)*(48))&-1)+36)|0);
    $25=((HEAP32[(($24)>>2)])|0);
    $26=((_calloc($25,8))|0);
    $27=$26;
    $28=((HEAP32[((17648)>>2)])|0);
    $29=(($28+((($3)*(48))&-1)+44)|0);
    HEAP32[(($29)>>2)]=$27;
    $30=((HEAP32[((17648)>>2)])|0);
    $31=(($30+((($3)*(48))&-1)+40)|0);
    $32=((HEAP32[(($31)>>2)])|0);
    $33=($32|0)==0;
    if ($33) {
     $_0=101;
     label = 12;
     break L3;
    }
    $35=(($30+((($3)*(48))&-1)+44)|0);
    $36=((HEAP32[(($35)>>2)])|0);
    $37=($36|0)==0;
    if ($37) {
     $_0=101;
     label = 12;
     break L3;
    }
    $39=(($c_045+36)|0);
    $40=((HEAP32[(($39)>>2)])|0);
    $41=(($c_045+40)|0);
    $42=(($30+((($3)*(48))&-1)+36)|0);
    $43=((HEAP32[(($42)>>2)])|0);
    $fy_033=((HEAP32[(($41)>>2)])|0);
    $notlhs35=($40|0)!=0;
    $notrhs36=($fy_033|0)!=0;
    $or_cond31_not37=$notrhs36&$notlhs35;
    $44=($43|0)>0;
    $or_cond3238=$or_cond31_not37&$44;
    if ($or_cond3238) {
     $x_039=10000000000.0;$fx_040=$40;$fy_041=$fy_033;$j_042_in=$43;
    } else {
     break;
    }
    while(1) {




     $j_042=((($j_042_in)-(1))|0);
     $45=(($fx_040)|0);
     $46=(+(HEAPF64[(($45)>>3)]));
     $47=$46<$x_039;
     if (!($47)) {
      label = 9;
      break L3;
     }
     $51=((HEAP32[((17648)>>2)])|0);
     $52=(($51+((($3)*(48))&-1)+40)|0);
     $53=((HEAP32[(($52)>>2)])|0);
     $54=(($53+($j_042<<3))|0);
     HEAPF64[(($54)>>3)]=$46;
     $55=(($fx_040+8)|0);
     $56=((HEAP32[(($55)>>2)])|0);
     $57=(($fy_041)|0);
     $58=(+(HEAPF64[(($57)>>3)]));
     $59=((HEAP32[((17648)>>2)])|0);
     $60=(($59+((($3)*(48))&-1)+44)|0);
     $61=((HEAP32[(($60)>>2)])|0);
     $62=(($61+($j_042<<3))|0);
     HEAPF64[(($62)>>3)]=$58;
     $63=(($fy_041+8)|0);
     $fy_0=((HEAP32[(($63)>>2)])|0);
     $notlhs=($56|0)!=0;
     $notrhs=($fy_0|0)!=0;
     $or_cond31_not=$notrhs&$notlhs;
     $64=($j_042|0)>0;
     $or_cond32=$or_cond31_not&$64;
     if ($or_cond32) {
      $x_039=$46;$fx_040=$56;$fy_041=$fy_0;$j_042_in=$j_042;
     } else {
      break;
     }
    }
   }
  } while(0);
  $65=(($c_045+44)|0);
  $c_0=((HEAP32[(($65)>>2)])|0);
  $66=($c_0|0)==0;
  if ($66) {
   $_0=0;
   label = 12;
   break;
  } else {
   $c_045=$c_0;
  }
 }
 if ((label|0) == 4) {
  $17=((_sprintf(((14488)|0),((1840)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$10,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline(14488);
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 else if ((label|0) == 9) {
  $49=((_sprintf(((14488)|0),((1840)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$10,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline(14488);
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 else if ((label|0) == 12) {

  STACKTOP=sp;return (($_0)|0);
 }
  return 0;
}


function _getpumpparams(){
 var $a=0,$b=0,$c=0,$1=0,$2=0,$q2_064=.0,$q1_063=.0,$h2_062=.0,$h1_061=.0,$h0_060=.0,$n_059=0,$j_058=0,$i_055=0,$3=0,$4=0,$5=0,$6=0,$7=0,$9=0,$10=0;
 var $11=0,$12=.0,$13=.0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$21=0,$22=0,$23=0,$25=0,$26=0,$27=0,$29=0,$30=0,$31=0,$33=0;
 var $34=0,$35=0,$37=0,$38=0,$39=0,$40=.0,$41=0,$42=0,$43=.0,$44=.0,$45=.0,$47=0,$48=0,$49=.0,$50=0,$52=0,$53=0,$54=0,$55=.0,$56=0;
 var $57=0,$58=0,$59=.0,$60=0,$61=.0,$62=0,$63=.0,$64=0,$65=.0,$67=0,$68=0,$h0_1=.0,$h1_1=.0,$h2_1=.0,$q1_1=.0,$q2_1=.0,$70=0,$71=0,$72=0,$73=0;
 var $75=0,$76=0,$78=0,$79=0,$80=0,$82=.0,$83=.0,$84=0,$85=0,$86=.0,$87=.0,$88=0,$89=0,$90=.0,$91=0,$92=0,$93=0,$94=0,$95=.0,$96=.0;
 var $97=.0,$98=.0,$99=.0,$100=.0,$101=.0,$102=0,$103=0,$104=0,$105=0,$j_1=0,$n_1=0,$h0_2=.0,$h1_2=.0,$h2_2=.0,$q1_2=.0,$q2_2=.0,$107=0,$108=0,$109=0,$110=0;
 var $111=0,$112=0,$m_0=0,$114=0,$116=0,$117=0,$118=.0,$119=0,$120=0,$121=.0,$122=0,$123=0,$125=0,$126=0,$127=0,$129=0,$130=0,$131=0,$132=0,$133=0;
 var $134=.0,$135=0,$136=0,$137=0,$138=0,$139=0,$140=.0,$141=0,$142=0,$143=.0,$144=.0,$145=.0,$146=0,$147=0,$148=0,$149=0,$150=.0,$151=0,$152=0,$j_2=0;
 var $n_2=0,$h0_3=.0,$h1_3=.0,$h2_3=.0,$q1_3=.0,$q2_3=.0,$154=0,$155=0,$156=0,$_0=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+24)|0;
 $a=((sp)|0);
 $b=(((sp)+(8))|0);
 $c=(((sp)+(16))|0);
 $1=((HEAP32[((14368)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 } else {
  $i_055=1;$j_058=0;$n_059=0;$h0_060=0.0;$h1_061=0.0;$h2_062=0.0;$q1_063=0.0;$q2_064=0.0;
 }
 L3: while(1) {








  $3=((HEAP32[((13888)>>2)])|0);
  $4=(($3+($i_055<<7))|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=(($3+($i_055<<7)+4)|0);
  $7=((HEAP32[(($6)>>2)])|0);
  do {
   if (((($7|0))|0)==((0)|0)) {
    $9=(($3+($i_055<<7)+32)|0);
    HEAPF64[(($9)>>3)]=0.0;
    $10=((HEAP32[((14960)>>2)])|0);
    $11=(($10+((($5)*(104))&-1)+64)|0);
    $12=(+(HEAPF64[(($11)>>3)]));
    $13=($12)*((-8.814));
    $14=((HEAP32[((13888)>>2)])|0);
    $15=(($14+($i_055<<7)+40)|0);
    HEAPF64[(($15)>>3)]=$13;
    $16=((HEAP32[((13888)>>2)])|0);
    $17=(($16+($i_055<<7)+48)|0);
    HEAPF64[(($17)>>3)]=-1.0;
    $18=((HEAP32[((13888)>>2)])|0);
    $19=(($18+($i_055<<7)+24)|0);
    HEAPF64[(($19)>>3)]=10000000000.0;
    $20=((HEAP32[((13888)>>2)])|0);
    $21=(($20+($i_055<<7)+16)|0);
    HEAPF64[(($21)>>3)]=10000000000.0;
    $22=((HEAP32[((13888)>>2)])|0);
    $23=(($22+($i_055<<7)+8)|0);
    HEAPF64[(($23)>>3)]=1.0;
    $q2_3=$q2_064;$q1_3=$q1_063;$h2_3=$h2_062;$h1_3=$h1_061;$h0_3=$h0_060;$n_2=$n_059;$j_2=$j_058;
   } else if (((($7|0))|0)==((3)|0)) {
    $25=(($3+($i_055<<7)+56)|0);
    $26=((HEAP32[(($25)>>2)])|0);
    $27=($26|0)==0;
    if ($27) {
     label = 5;
     break L3;
    }
    $33=((HEAP32[((17648)>>2)])|0);
    $34=(($33+((($26)*(48))&-1)+36)|0);
    $35=((HEAP32[(($34)>>2)])|0);
    do {
     if (((($35|0))|0)==((3)|0)) {
      $47=(($33+((($26)*(48))&-1)+40)|0);
      $48=((HEAP32[(($47)>>2)])|0);
      $49=(+(HEAPF64[(($48)>>3)]));
      $50=$49==(0.0);
      if (!($50)) {
       label = 10;
       break;
      }
      HEAP32[(($6)>>2)]=1;
      $52=((HEAP32[((17648)>>2)])|0);
      $53=(($52+((($26)*(48))&-1)+44)|0);
      $54=((HEAP32[(($53)>>2)])|0);
      $55=(+(HEAPF64[(($54)>>3)]));
      $56=(($52+((($26)*(48))&-1)+40)|0);
      $57=((HEAP32[(($56)>>2)])|0);
      $58=(($57+8)|0);
      $59=(+(HEAPF64[(($58)>>3)]));
      $60=(($54+8)|0);
      $61=(+(HEAPF64[(($60)>>3)]));
      $62=(($57+16)|0);
      $63=(+(HEAPF64[(($62)>>3)]));
      $64=(($54+16)|0);
      $65=(+(HEAPF64[(($64)>>3)]));
      $q2_1=$63;$q1_1=$59;$h2_1=$65;$h1_1=$61;$h0_1=$55;
     } else if (((($35|0))|0)==((1)|0)) {
      HEAP32[(($6)>>2)]=1;
      $37=((HEAP32[((17648)>>2)])|0);
      $38=(($37+((($26)*(48))&-1)+40)|0);
      $39=((HEAP32[(($38)>>2)])|0);
      $40=(+(HEAPF64[(($39)>>3)]));
      $41=(($37+((($26)*(48))&-1)+44)|0);
      $42=((HEAP32[(($41)>>2)])|0);
      $43=(+(HEAPF64[(($42)>>3)]));
      $44=($43)*((1.33334));
      $45=($40)*((2.0));
      $q2_1=$45;$q1_1=$40;$h2_1=0.0;$h1_1=$43;$h0_1=$44;
     } else {
      label = 10;
     }
    } while(0);
    if ((label|0) == 10) {
     label = 0;
     $67=((HEAP32[((13888)>>2)])|0);
     $68=(($67+($i_055<<7)+4)|0);
     HEAP32[(($68)>>2)]=2;
     $q2_1=$q2_064;$q1_1=$q1_063;$h2_1=$h2_062;$h1_1=$h1_061;$h0_1=$h0_060;
    }





    $70=((HEAP32[((13888)>>2)])|0);
    $71=(($70+($i_055<<7)+4)|0);
    $72=((HEAP32[(($71)>>2)])|0);
    $73=($72|0)==1;
    if (!($73)) {
     $q2_2=$q2_1;$q1_2=$q1_1;$h2_2=$h2_1;$h1_2=$h1_1;$h0_2=$h0_1;$n_1=$35;$j_1=$26;
     label = 15;
     break;
    }
    $75=((_powercurve($h0_1,$h1_1,$h2_1,$q1_1,$q2_1,$a,$b,$c))|0);
    $76=($75|0)==0;
    if ($76) {
     label = 13;
     break L3;
    }
    $82=(+(HEAPF64[(($a)>>3)]));
    $83=((-.0))-($82);
    $84=((HEAP32[((13888)>>2)])|0);
    $85=(($84+($i_055<<7)+32)|0);
    HEAPF64[(($85)>>3)]=$83;
    $86=(+(HEAPF64[(($b)>>3)]));
    $87=((-.0))-($86);
    $88=((HEAP32[((13888)>>2)])|0);
    $89=(($88+($i_055<<7)+40)|0);
    HEAPF64[(($89)>>3)]=$87;
    $90=(+(HEAPF64[(($c)>>3)]));
    $91=((HEAP32[((13888)>>2)])|0);
    $92=(($91+($i_055<<7)+48)|0);
    HEAPF64[(($92)>>3)]=$90;
    $93=((HEAP32[((13888)>>2)])|0);
    $94=(($93+($i_055<<7)+8)|0);
    HEAPF64[(($94)>>3)]=$q1_1;
    $95=(+(HEAPF64[(($a)>>3)]));
    $96=((-.0))-($95);
    $97=(+(HEAPF64[(($b)>>3)]));
    $98=($96)/($97);
    $99=(+(HEAPF64[(($c)>>3)]));
    $100=((1.0))/($99);
    $101=(+(Math_pow((+($98)),(+($100)))));
    $102=((HEAP32[((13888)>>2)])|0);
    $103=(($102+($i_055<<7)+16)|0);
    HEAPF64[(($103)>>3)]=$101;
    $104=((HEAP32[((13888)>>2)])|0);
    $105=(($104+($i_055<<7)+24)|0);
    HEAPF64[(($105)>>3)]=$h0_1;
    $q2_2=$q2_1;$q1_2=$q1_1;$h2_2=$h2_1;$h1_2=$h1_1;$h0_2=$h0_1;$n_1=$35;$j_1=$26;
    label = 15;
   } else {
    $q2_2=$q2_064;$q1_2=$q1_063;$h2_2=$h2_062;$h1_2=$h1_061;$h0_2=$h0_060;$n_1=$n_059;$j_1=$j_058;
    label = 15;
   }
  } while(0);
  do {
   if ((label|0) == 15) {
    label = 0;







    $107=((HEAP32[((13888)>>2)])|0);
    $108=(($107+($i_055<<7)+4)|0);
    $109=((HEAP32[(($108)>>2)])|0);
    $110=($109|0)==2;
    if (!($110)) {
     $q2_3=$q2_2;$q1_3=$q1_2;$h2_3=$h2_2;$h1_3=$h1_2;$h0_3=$h0_2;$n_2=$n_1;$j_2=$j_1;
     break;
    }
    $111=((HEAP32[((17648)>>2)])|0);
    $112=(($111+((($j_1)*(48))&-1)+44)|0);
    $m_0=1;
    while(1) {

     $114=($m_0|0)<($n_1|0);
     if (!($114)) {
      break;
     }
     $116=((HEAP32[(($112)>>2)])|0);
     $117=(($116+($m_0<<3))|0);
     $118=(+(HEAPF64[(($117)>>3)]));
     $119=((($m_0)-(1))|0);
     $120=(($116+($119<<3))|0);
     $121=(+(HEAPF64[(($120)>>3)]));
     $122=$118<$121;
     $123=((($m_0)+(1))|0);
     if ($122) {
      $m_0=$123;
     } else {
      label = 19;
      break L3;
     }
    }
    $129=((($n_1)-(1))|0);
    $130=((HEAP32[((17648)>>2)])|0);
    $131=(($130+((($j_1)*(48))&-1)+40)|0);
    $132=((HEAP32[(($131)>>2)])|0);
    $133=(($132+($129<<3))|0);
    $134=(+(HEAPF64[(($133)>>3)]));
    $135=((HEAP32[((13888)>>2)])|0);
    $136=(($135+($i_055<<7)+16)|0);
    HEAPF64[(($136)>>3)]=$134;
    $137=((HEAP32[((17648)>>2)])|0);
    $138=(($137+((($j_1)*(48))&-1)+40)|0);
    $139=((HEAP32[(($138)>>2)])|0);
    $140=(+(HEAPF64[(($139)>>3)]));
    $141=((HEAP32[((13888)>>2)])|0);
    $142=(($141+($i_055<<7)+16)|0);
    $143=(+(HEAPF64[(($142)>>3)]));
    $144=($140)+($143);
    $145=($144)*((0.5));
    $146=(($141+($i_055<<7)+8)|0);
    HEAPF64[(($146)>>3)]=$145;
    $147=((HEAP32[((17648)>>2)])|0);
    $148=(($147+((($j_1)*(48))&-1)+44)|0);
    $149=((HEAP32[(($148)>>2)])|0);
    $150=(+(HEAPF64[(($149)>>3)]));
    $151=((HEAP32[((13888)>>2)])|0);
    $152=(($151+($i_055<<7)+24)|0);
    HEAPF64[(($152)>>3)]=$150;
    $q2_3=$q2_2;$q1_3=$q1_2;$h2_3=$h2_2;$h1_3=$h1_2;$h0_3=$h0_2;$n_2=$n_1;$j_2=$j_1;
   }
  } while(0);







  $154=((($i_055)+(1))|0);
  $155=((HEAP32[((14368)>>2)])|0);
  $156=($154|0)>($155|0);
  if ($156) {
   $_0=0;
   label = 22;
   break;
  } else {
   $i_055=$154;$j_058=$j_2;$n_059=$n_2;$h0_060=$h0_3;$h1_061=$h1_3;$h2_062=$h2_3;$q1_063=$q1_3;$q2_064=$q2_3;
  }
 }
 if ((label|0) == 5) {
  $29=((HEAP32[((14960)>>2)])|0);
  $30=(($29+((($5)*(104))&-1))|0);
  $31=((_sprintf(((14488)|0),((3680)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$30,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline(14488);
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 else if ((label|0) == 13) {
  $78=((HEAP32[((14960)>>2)])|0);
  $79=(($78+((($5)*(104))&-1))|0);
  $80=((_sprintf(((14488)|0),((3064)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$79,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline(14488);
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 else if ((label|0) == 19) {
  $125=((HEAP32[((14960)>>2)])|0);
  $126=(($125+((($5)*(104))&-1))|0);
  $127=((_sprintf(((14488)|0),((3064)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$126,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline(14488);
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 else if ((label|0) == 22) {

  STACKTOP=sp;return (($_0)|0);
 }
  return 0;
}


function _addnodeID($n,$id){
 $n=($n)|0;
 $id=($id)|0;
 var $1=0,$2=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$_0=0,label=0;

 $1=((_findnode($id))|0);
 $2=($1|0)==0;
 if (!($2)) {
  $_0=0;

  return (($_0)|0);
 }
 $4=((HEAP32[((14408)>>2)])|0);
 $5=(($4+((($n)*(72))&-1))|0);
 $6=((_strncpy((($5)|0),(($id)|0),((31)|0)))|0);
 $7=((HEAP32[((14440)>>2)])|0);
 $8=((HEAP32[((14408)>>2)])|0);
 $9=(($8+((($n)*(72))&-1))|0);
 $10=((_HTinsert($7,$9,$n))|0);
 $_0=1;

 return (($_0)|0);
}


function _addlinkID($n,$id){
 $n=($n)|0;
 $id=($id)|0;
 var $1=0,$2=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$_0=0,label=0;

 $1=((_findlink($id))|0);
 $2=($1|0)==0;
 if (!($2)) {
  $_0=0;

  return (($_0)|0);
 }
 $4=((HEAP32[((14960)>>2)])|0);
 $5=(($4+((($n)*(104))&-1))|0);
 $6=((_strncpy((($5)|0),(($id)|0),((31)|0)))|0);
 $7=((HEAP32[((14976)>>2)])|0);
 $8=((HEAP32[((14960)>>2)])|0);
 $9=(($8+((($n)*(104))&-1))|0);
 $10=((_HTinsert($7,$9,$n))|0);
 $_0=1;

 return (($_0)|0);
}


function _findID($id,$list){
 $id=($id)|0;
 $list=($list)|0;
 var $1=0,$item_05=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$_0=0,label=0;

 $1=($list|0)==0;
 L1: do {
  if ($1) {
   $_0=0;
  } else {
   $item_05=$list;
   while(1) {

    $2=(($item_05+4)|0);
    $3=((_strcmp((($2)|0),(($id)|0)))|0);
    $4=($3|0)==0;
    if ($4) {
     $_0=$item_05;
     break L1;
    }
    $6=(($item_05+44)|0);
    $7=((HEAP32[(($6)>>2)])|0);
    $8=($7|0)==0;
    if ($8) {
     $_0=0;
     break;
    } else {
     $item_05=$7;
    }
   }
  }
 } while(0);

 return (($_0)|0);
}


function _match($str,$substr){
 $str=($str)|0;
 $substr=($substr)|0;
 var $1=0,$2=0,$i_0=0,$3=0,$4=0,$cond=0,$5=0,$6=0,$7=0,$8=0,$j_031=0,$i_130=0,$9=0,$10=0,$11=0,$13=0,$_off=0,$14=0,$15=0,$16=0;
 var $17=0,$18=0,$_off29=0,$19=0,$20=0,$21=0,$22=0,$24=0,$25=0,$26=0,$27=0,$28=0,$_0=0,label=0;

 $1=((HEAP8[($substr)])|0);
 $2=(($1<<24)>>24)==0;
 if ($2) {
  $_0=0;

  return (($_0)|0);
 } else {
  $i_0=0;
 }
 while(1) {

  $3=(($str+$i_0)|0);
  $4=((HEAP8[($3)])|0);
  $cond=(($4<<24)>>24)==32;
  $5=((($i_0)+(1))|0);
  if ($cond) {
   $i_0=$5;
  } else {
   break;
  }
 }
 $6=((HEAP8[($substr)])|0);
 $7=(($6<<24)>>24)==0;
 if ($7) {
  $_0=1;

  return (($_0)|0);
 } else {
  $i_130=$i_0;$j_031=0;$8=$substr;
 }
 while(1) {



  $9=(($str+$i_130)|0);
  $10=((HEAP8[($9)])|0);
  $11=(($10<<24)>>24)==0;
  if ($11) {
   $_0=0;
   label = 7;
   break;
  }
  $13=(($10<<24)>>24);
  $_off=((($10)-(97))&255);
  $14=((($_off&255))>>>0)<((26)>>>0);
  $15=$13&-33;
  $16=($14?$15:$13);
  $17=((HEAP8[($8)])|0);
  $18=(($17<<24)>>24);
  $_off29=((($17)-(97))&255);
  $19=((($_off29&255))>>>0)<((26)>>>0);
  $20=$18&-33;
  $21=($19?$20:$18);
  $22=($16|0)==($21|0);
  if (!($22)) {
   $_0=0;
   label = 7;
   break;
  }
  $24=((($i_130)+(1))|0);
  $25=((($j_031)+(1))|0);
  $26=(($substr+$25)|0);
  $27=((HEAP8[($26)])|0);
  $28=(($27<<24)>>24)==0;
  if ($28) {
   $_0=1;
   label = 7;
   break;
  } else {
   $i_130=$24;$j_031=$25;$8=$26;
  }
 }
 if ((label|0) == 7) {

  return (($_0)|0);
 }
  return 0;
}


function _hour($time,$units){
 $time=($time)|0;
 $units=($units)|0;
 var $y=0,$y22=0,$1=0,$2=0,$s_020=0,$n_119=0,$3=0,$4=0,$5=0,$7=0,$8=0,$9=0,$10=0,$or_cond=0,$11=0,$strlenfirst=0,$13=0,$15=0,$16=.0,$18=0;
 var $19=0,$21=0,$22=.0,$23=.0,$25=0,$26=0,$28=0,$29=.0,$30=.0,$32=0,$33=0,$35=0,$36=.0,$38=0,$39=0,$41=0,$42=.0,$43=.0,$45=0,$47=0;
 var $48=.0,$49=0,$50=.0,$51=.0,$52=.0,$53=0,$54=.0,$55=.0,$56=.0,$57=0,$58=0,$60=0,$61=.0,$63=0,$64=0,$66=0,$67=.0,$68=0,$70=0,$72=.0;
 var $74=0,$75=0,$77=0,$78=.0,$79=0,$81=0,$83=.0,$_0=.0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+24)|0;
 $y=((sp)|0);
 $y22=$y;
 _memset((((($y22)|0))|0), ((((0)|0))|0), ((((24)|0))|0))|0;
 $1=((_strtok((($time)|0),((752)|0)))|0);
 $2=($1|0)==0;
 L1: do {
  if ($2) {
   label = 17;
  } else {
   $n_119=0;$s_020=$1;
   while(1) {


    $3=(($y+($n_119<<3))|0);
    $4=((_getfloat($s_020,$3))|0);
    $5=($4|0)==0;
    if ($5) {
     $_0=-1.0;
     break L1;
    }
    $7=((_strtok(((0)|0),((752)|0)))|0);
    $8=((($n_119)+(1))|0);
    $9=($7|0)!=0;
    $10=($8|0)<4;
    $or_cond=$9&$10;
    if ($or_cond) {
     $n_119=$8;$s_020=$7;
    } else {
     break;
    }
   }
   $11=($n_119|0)==0;
   do {
    if ($11) {
     $strlenfirst=((HEAP8[($units)])|0);
     $13=(($strlenfirst<<24)>>24)==0;
     if ($13) {
      $15=(($y)|0);
      $16=(+(HEAPF64[(($15)>>3)]));
      $_0=$16;
      break L1;
     }
     $18=((_match($units,216))|0);
     $19=($18|0)==0;
     if (!($19)) {
      $21=(($y)|0);
      $22=(+(HEAPF64[(($21)>>3)]));
      $23=($22)/((3600.0));
      $_0=$23;
      break L1;
     }
     $25=((_match($units,10320))|0);
     $26=($25|0)==0;
     if (!($26)) {
      $28=(($y)|0);
      $29=(+(HEAPF64[(($28)>>3)]));
      $30=($29)/((60.0));
      $_0=$30;
      break L1;
     }
     $32=((_match($units,10088))|0);
     $33=($32|0)==0;
     if (!($33)) {
      $35=(($y)|0);
      $36=(+(HEAPF64[(($35)>>3)]));
      $_0=$36;
      break L1;
     }
     $38=((_match($units,9872))|0);
     $39=($38|0)==0;
     if ($39) {
      break;
     }
     $41=(($y)|0);
     $42=(+(HEAPF64[(($41)>>3)]));
     $43=($42)*((24.0));
     $_0=$43;
     break L1;
    }
   } while(0);
   $45=($n_119|0)>0;
   if (!($45)) {
    label = 17;
    break;
   }
   $47=(($y)|0);
   $48=(+(HEAPF64[(($47)>>3)]));
   $49=(($y+8)|0);
   $50=(+(HEAPF64[(($49)>>3)]));
   $51=($50)/((60.0));
   $52=($48)+($51);
   $53=(($y+16)|0);
   $54=(+(HEAPF64[(($53)>>3)]));
   $55=($54)/((3600.0));
   $56=($52)+($55);
   HEAPF64[(($47)>>3)]=$56;
   label = 17;
  }
 } while(0);
 do {
  if ((label|0) == 17) {
   $57=((HEAP8[($units)])|0);
   $58=(($57<<24)>>24)==0;
   if ($58) {
    $60=(($y)|0);
    $61=(+(HEAPF64[(($60)>>3)]));
    $_0=$61;
    break;
   }
   $63=((_match($units,9600))|0);
   $64=($63|0)==0;
   if (!($64)) {
    $66=(($y)|0);
    $67=(+(HEAPF64[(($66)>>3)]));
    $68=$67<(13.0);
    if (!($68)) {
     $_0=-1.0;
     break;
    }
    $70=$67<(12.0);
    if ($70) {
     $_0=$67;
     break;
    }
    $72=($67)+((-12.0));
    $_0=$72;
    break;
   }
   $74=((_match($units,8944))|0);
   $75=($74|0)==0;
   if ($75) {
    $_0=-1.0;
    break;
   }
   $77=(($y)|0);
   $78=(+(HEAPF64[(($77)>>3)]));
   $79=$78<(13.0);
   if (!($79)) {
    $_0=-1.0;
    break;
   }
   $81=$78<(12.0);
   if (!($81)) {
    $_0=$78;
    break;
   }
   $83=($78)+((12.0));
   $_0=$83;
  }
 } while(0);

 STACKTOP=sp;return (+($_0));
}


function _getfloat($s,$y){
 $s=($s)|0;
 $y=($y)|0;
 var $endptr=0,$1=.0,$2=0,$3=0,$not_=0,$_=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $endptr=((sp)|0);
 $1=(+(_strtod($s,$endptr)));
 HEAPF64[(($y)>>3)]=$1;
 $2=((HEAP32[(($endptr)>>2)])|0);
 $3=((HEAP8[($2)])|0);
 $not_=(($3<<24)>>24)<1;
 $_=($not_&1);
 STACKTOP=sp;return (($_)|0);
}


function _juncdata(){
 var $el=0,$y=0,$1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$14=0,$16=0,$17=0,$18=0,$20=0,$22=0,$23=0;
 var $24=0,$26=0,$28=0,$29=0,$30=0,$31=0,$33=0,$34=0,$p_0=0,$35=.0,$36=0,$37=0,$38=0,$39=0,$40=0,$41=0,$42=0,$43=0,$44=0,$45=0;
 var $46=0,$47=0,$48=0,$49=0,$50=0,$52=0,$53=0,$55=0,$56=.0,$57=0,$58=0,$59=0,$60=0,$61=0,$62=0,$63=0,$64=0,$65=0,$66=0,$67=0;
 var $68=0,$69=.0,$70=0,$71=0,$72=0,$74=0,$75=0,$76=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $el=((sp)|0);
 $y=(((sp)+(8))|0);
 HEAPF64[(($y)>>3)]=0.0;
 $1=((HEAP32[((14336)>>2)])|0);
 $2=((HEAP32[((14416)>>2)])|0);
 $3=((HEAP32[((14624)>>2)])|0);
 $4=($2|0)==($3|0);
 if ($4) {
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 $6=((HEAP32[((14432)>>2)])|0);
 $7=((($6)+(1))|0);
 HEAP32[((14432)>>2)]=$7;
 $8=((HEAP32[((14416)>>2)])|0);
 $9=((($8)+(1))|0);
 HEAP32[((14416)>>2)]=$9;
 $10=((HEAP32[((12232)>>2)])|0);
 $11=((_addnodeID($7,$10))|0);
 $12=($11|0)==0;
 if ($12) {
  $_0=215;

  STACKTOP=sp;return (($_0)|0);
 }
 $14=($1|0)<2;
 if ($14) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $16=((HEAP32[((12236)>>2)])|0);
 $17=((_getfloat($16,$el))|0);
 $18=($17|0)==0;
 if ($18) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $20=($1|0)>2;
 do {
  if ($20) {
   $22=((HEAP32[((12240)>>2)])|0);
   $23=((_getfloat($22,$y))|0);
   $24=($23|0)==0;
   if ($24) {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   }
   $26=($1|0)>3;
   if (!($26)) {
    $p_0=0;
    break;
   }
   $28=((HEAP32[((12244)>>2)])|0);
   $29=((HEAP32[((13952)>>2)])|0);
   $30=((_findID($28,$29))|0);
   $31=($30|0)==0;
   if ($31) {
    $_0=205;

    STACKTOP=sp;return (($_0)|0);
   } else {
    $33=(($30)|0);
    $34=((HEAP32[(($33)>>2)])|0);
    $p_0=$34;
    break;
   }
  } else {
   $p_0=0;
  }
 } while(0);

 $35=(+(HEAPF64[(($el)>>3)]));
 $36=((HEAP32[((14432)>>2)])|0);
 $37=((HEAP32[((14408)>>2)])|0);
 $38=(($37+((($36)*(72))&-1)+32)|0);
 HEAPF64[(($38)>>3)]=$35;
 $39=((HEAP32[((14432)>>2)])|0);
 $40=((HEAP32[((14408)>>2)])|0);
 $41=(($40+((($39)*(72))&-1)+48)|0);
 HEAPF64[(($41)>>3)]=0.0;
 $42=((HEAP32[((14432)>>2)])|0);
 $43=((HEAP32[((14408)>>2)])|0);
 $44=(($43+((($42)*(72))&-1)+44)|0);
 HEAP32[(($44)>>2)]=0;
 $45=((HEAP32[((14432)>>2)])|0);
 $46=((HEAP32[((14408)>>2)])|0);
 $47=(($46+((($45)*(72))&-1)+56)|0);
 HEAPF64[(($47)>>3)]=0.0;
 $48=((HEAP32[((14432)>>2)])|0);
 $49=((HEAP32[((14408)>>2)])|0);
 $50=(($49+((($48)*(72))&-1)+64)|0);
 HEAP8[($50)]=0;
 if (!($20)) {
  $74=((HEAP32[((14432)>>2)])|0);
  $75=((HEAP32[((17632)>>2)])|0);
  $76=(($75+($74<<3))|0);
  HEAPF64[(($76)>>3)]=-10000000000.0;
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $52=((_malloc(16))|0);
 $53=($52|0)==0;
 if ($53) {
  $_0=101;

  STACKTOP=sp;return (($_0)|0);
 }
 $55=$52;
 $56=(+(HEAPF64[(($y)>>3)]));
 $57=$52;
 HEAPF64[(($57)>>3)]=$56;
 $58=(($52+8)|0);
 $59=$58;
 HEAP32[(($59)>>2)]=$p_0;
 $60=((HEAP32[((14432)>>2)])|0);
 $61=((HEAP32[((14408)>>2)])|0);
 $62=(($61+((($60)*(72))&-1)+40)|0);
 $63=((HEAP32[(($62)>>2)])|0);
 $64=(($52+12)|0);
 $65=$64;
 HEAP32[(($65)>>2)]=$63;
 $66=((HEAP32[((14432)>>2)])|0);
 $67=((HEAP32[((14408)>>2)])|0);
 $68=(($67+((($66)*(72))&-1)+40)|0);
 HEAP32[(($68)>>2)]=$55;
 $69=(+(HEAPF64[(($y)>>3)]));
 $70=((HEAP32[((14432)>>2)])|0);
 $71=((HEAP32[((17632)>>2)])|0);
 $72=(($71+($70<<3))|0);
 HEAPF64[(($72)>>3)]=$69;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _tankdata(){
 var $el=0,$initlevel=0,$minlevel=0,$maxlevel=0,$minvol=0,$diam=0,$1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0;
 var $17=0,$19=0,$21=0,$22=0,$23=0,$25=0,$27=0,$29=0,$30=0,$31=0,$32=0,$34=0,$35=0,$37=0,$39=0,$40=0,$41=0,$43=0,$44=0,$45=0;
 var $47=0,$48=0,$49=0,$51=0,$52=0,$53=0,$54=.0,$55=0,$or_cond=0,$57=0,$59=0,$60=0,$61=0,$63=0,$65=0,$66=0,$67=0,$68=0,$70=0,$71=0;
 var $p_0=0,$vcurve_0=0,$72=0,$73=0,$74=.0,$75=0,$76=0,$77=0,$78=0,$79=0,$80=0,$81=0,$82=0,$83=0,$84=0,$85=0,$86=.0,$87=0,$88=0,$89=0;
 var $90=.0,$91=0,$92=0,$93=0,$94=.0,$95=0,$96=0,$97=0,$98=.0,$99=0,$100=0,$101=0,$102=0,$103=0,$104=0,$105=0,$106=0,$107=0,$108=.0,$109=.0;
 var $110=.0,$111=.0,$112=.0,$113=.0,$114=0,$115=0,$116=0,$117=.0,$118=0,$120=0,$121=0,$122=0,$124=0,$125=0,$126=0,$127=.0,$128=.0,$129=.0,$130=.0,$131=.0;
 var $132=.0,$133=0,$134=0,$135=0,$136=0,$137=.0,$138=.0,$139=.0,$140=.0,$141=.0,$142=.0,$143=0,$144=0,$145=0,$146=0,$147=0,$148=0,$149=0,$150=0,$151=0;
 var $152=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+48)|0;
 $el=((sp)|0);
 $initlevel=(((sp)+(8))|0);
 $minlevel=(((sp)+(16))|0);
 $maxlevel=(((sp)+(24))|0);
 $minvol=(((sp)+(32))|0);
 $diam=(((sp)+(40))|0);
 HEAPF64[(($el)>>3)]=0.0;
 HEAPF64[(($initlevel)>>3)]=0.0;
 HEAPF64[(($minlevel)>>3)]=0.0;
 HEAPF64[(($maxlevel)>>3)]=0.0;
 HEAPF64[(($minvol)>>3)]=0.0;
 HEAPF64[(($diam)>>3)]=0.0;
 $1=((HEAP32[((14336)>>2)])|0);
 $2=((HEAP32[((14352)>>2)])|0);
 $3=((HEAP32[((14584)>>2)])|0);
 $4=($2|0)==($3|0);
 if ($4) {
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 $6=((HEAP32[((14416)>>2)])|0);
 $7=((HEAP32[((14624)>>2)])|0);
 $8=($6|0)==($7|0);
 if ($8) {
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 $10=((($2)+(1))|0);
 HEAP32[((14352)>>2)]=$10;
 $11=((HEAP32[((14416)>>2)])|0);
 $12=((($11)+(1))|0);
 HEAP32[((14416)>>2)]=$12;
 $13=((HEAP32[((14640)>>2)])|0);
 $14=((($13)+($10))|0);
 $15=((HEAP32[((12232)>>2)])|0);
 $16=((_addnodeID($14,$15))|0);
 $17=($16|0)==0;
 if ($17) {
  $_0=215;

  STACKTOP=sp;return (($_0)|0);
 }
 $19=($1|0)<2;
 if ($19) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $21=((HEAP32[((12236)>>2)])|0);
 $22=((_getfloat($21,$el))|0);
 $23=($22|0)==0;
 if ($23) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $25=($1|0)<4;
 do {
  if ($25) {
   $27=($1|0)==3;
   if (!($27)) {
    $vcurve_0=0;$p_0=0;
    break;
   }
   $29=((HEAP32[((12240)>>2)])|0);
   $30=((HEAP32[((13952)>>2)])|0);
   $31=((_findID($29,$30))|0);
   $32=($31|0)==0;
   if ($32) {
    $_0=205;

    STACKTOP=sp;return (($_0)|0);
   } else {
    $34=(($31)|0);
    $35=((HEAP32[(($34)>>2)])|0);
    $vcurve_0=0;$p_0=$35;
    break;
   }
  } else {
   $37=($1|0)<6;
   if ($37) {
    $_0=201;

    STACKTOP=sp;return (($_0)|0);
   }
   $39=((HEAP32[((12240)>>2)])|0);
   $40=((_getfloat($39,$initlevel))|0);
   $41=($40|0)==0;
   if ($41) {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   }
   $43=((HEAP32[((12244)>>2)])|0);
   $44=((_getfloat($43,$minlevel))|0);
   $45=($44|0)==0;
   if ($45) {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   }
   $47=((HEAP32[((12248)>>2)])|0);
   $48=((_getfloat($47,$maxlevel))|0);
   $49=($48|0)==0;
   if ($49) {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   }
   $51=((HEAP32[((12252)>>2)])|0);
   $52=((_getfloat($51,$diam))|0);
   $53=($52|0)==0;
   $54=(+(HEAPF64[(($diam)>>3)]));
   $55=$54<(0.0);
   $or_cond=$53|$55;
   if ($or_cond) {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   }
   $57=($1|0)>6;
   if (!($57)) {
    $vcurve_0=0;$p_0=0;
    break;
   }
   $59=((HEAP32[((12256)>>2)])|0);
   $60=((_getfloat($59,$minvol))|0);
   $61=($60|0)==0;
   if ($61) {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   }
   $63=($1|0)==8;
   if (!($63)) {
    $vcurve_0=0;$p_0=0;
    break;
   }
   $65=((HEAP32[((12260)>>2)])|0);
   $66=((HEAP32[((17640)>>2)])|0);
   $67=((_findID($65,$66))|0);
   $68=($67|0)==0;
   if ($68) {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   } else {
    $70=(($67)|0);
    $71=((HEAP32[(($70)>>2)])|0);
    $vcurve_0=$71;$p_0=0;
    break;
   }
  }
 } while(0);


 $72=((HEAP32[((14408)>>2)])|0);
 $73=(($72+((($14)*(72))&-1)+64)|0);
 HEAP8[($73)]=0;
 $74=(+(HEAPF64[(($el)>>3)]));
 $75=((HEAP32[((14408)>>2)])|0);
 $76=(($75+((($14)*(72))&-1)+32)|0);
 HEAPF64[(($76)>>3)]=$74;
 $77=((HEAP32[((14408)>>2)])|0);
 $78=(($77+((($14)*(72))&-1)+48)|0);
 HEAPF64[(($78)>>3)]=0.0;
 $79=((HEAP32[((14408)>>2)])|0);
 $80=(($79+((($14)*(72))&-1)+44)|0);
 HEAP32[(($80)>>2)]=0;
 $81=((HEAP32[((14408)>>2)])|0);
 $82=(($81+((($14)*(72))&-1)+56)|0);
 HEAPF64[(($82)>>3)]=0.0;
 $83=((HEAP32[((14352)>>2)])|0);
 $84=((HEAP32[((13176)>>2)])|0);
 $85=(($84+((($83)*(112))&-1))|0);
 HEAP32[(($85)>>2)]=$14;
 $86=(+(HEAPF64[(($initlevel)>>3)]));
 $87=((HEAP32[((14352)>>2)])|0);
 $88=((HEAP32[((13176)>>2)])|0);
 $89=(($88+((($87)*(112))&-1)+32)|0);
 HEAPF64[(($89)>>3)]=$86;
 $90=(+(HEAPF64[(($minlevel)>>3)]));
 $91=((HEAP32[((14352)>>2)])|0);
 $92=((HEAP32[((13176)>>2)])|0);
 $93=(($92+((($91)*(112))&-1)+16)|0);
 HEAPF64[(($93)>>3)]=$90;
 $94=(+(HEAPF64[(($maxlevel)>>3)]));
 $95=((HEAP32[((14352)>>2)])|0);
 $96=((HEAP32[((13176)>>2)])|0);
 $97=(($96+((($95)*(112))&-1)+24)|0);
 HEAPF64[(($97)>>3)]=$94;
 $98=(+(HEAPF64[(($diam)>>3)]));
 $99=((HEAP32[((14352)>>2)])|0);
 $100=((HEAP32[((13176)>>2)])|0);
 $101=(($100+((($99)*(112))&-1)+8)|0);
 HEAPF64[(($101)>>3)]=$98;
 $102=((HEAP32[((14352)>>2)])|0);
 $103=((HEAP32[((13176)>>2)])|0);
 $104=(($103+((($102)*(112))&-1)+88)|0);
 HEAP32[(($104)>>2)]=$p_0;
 $105=((HEAP32[((14352)>>2)])|0);
 $106=((HEAP32[((13176)>>2)])|0);
 $107=(($106+((($105)*(112))&-1)+64)|0);
 HEAPF64[(($107)>>3)]=-10000000000.0;
 $108=(+(HEAPF64[(($diam)>>3)]));
 $109=($108)*($108);
 $110=($109)*((3.141592654));
 $111=($110)*((0.25));
 $112=(+(HEAPF64[(($minlevel)>>3)]));
 $113=($112)*($111);
 $114=((HEAP32[((14352)>>2)])|0);
 $115=((HEAP32[((13176)>>2)])|0);
 $116=(($115+((($114)*(112))&-1)+40)|0);
 HEAPF64[(($116)>>3)]=$113;
 $117=(+(HEAPF64[(($minvol)>>3)]));
 $118=$117>(0.0);
 if ($118) {
  $120=((HEAP32[((14352)>>2)])|0);
  $121=((HEAP32[((13176)>>2)])|0);
  $122=(($121+((($120)*(112))&-1)+40)|0);
  HEAPF64[(($122)>>3)]=$117;
 }
 $124=((HEAP32[((14352)>>2)])|0);
 $125=((HEAP32[((13176)>>2)])|0);
 $126=(($125+((($124)*(112))&-1)+40)|0);
 $127=(+(HEAPF64[(($126)>>3)]));
 $128=(+(HEAPF64[(($initlevel)>>3)]));
 $129=(+(HEAPF64[(($minlevel)>>3)]));
 $130=($128)-($129);
 $131=($111)*($130);
 $132=($127)+($131);
 $133=(($125+((($124)*(112))&-1)+56)|0);
 HEAPF64[(($133)>>3)]=$132;
 $134=((HEAP32[((14352)>>2)])|0);
 $135=((HEAP32[((13176)>>2)])|0);
 $136=(($135+((($134)*(112))&-1)+40)|0);
 $137=(+(HEAPF64[(($136)>>3)]));
 $138=(+(HEAPF64[(($maxlevel)>>3)]));
 $139=(+(HEAPF64[(($minlevel)>>3)]));
 $140=($138)-($139);
 $141=($111)*($140);
 $142=($137)+($141);
 $143=(($135+((($134)*(112))&-1)+48)|0);
 HEAPF64[(($143)>>3)]=$142;
 $144=((HEAP32[((14352)>>2)])|0);
 $145=((HEAP32[((13176)>>2)])|0);
 $146=(($145+((($144)*(112))&-1)+92)|0);
 HEAP32[(($146)>>2)]=$vcurve_0;
 $147=((HEAP32[((14352)>>2)])|0);
 $148=((HEAP32[((13176)>>2)])|0);
 $149=(($148+((($147)*(112))&-1)+96)|0);
 HEAP8[($149)]=0;
 $150=((HEAP32[((14352)>>2)])|0);
 $151=((HEAP32[((13176)>>2)])|0);
 $152=(($151+((($150)*(112))&-1)+104)|0);
 HEAPF64[(($152)>>3)]=1.0;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _pipedata(){
 var $length=0,$diam=0,$rcoeff=0,$lcoeff=0,$1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$14=0,$16=0,$17=0,$18=0,$20=0;
 var $21=0,$22=0,$24=0,$26=0,$27=0,$28=0,$30=0,$31=0,$32=0,$34=0,$35=0,$36=0,$38=.0,$39=0,$41=.0,$42=0,$44=.0,$45=0,$47=0,$49=0;
 var $50=0,$51=0,$53=0,$54=0,$55=0,$57=0,$58=0,$59=0,$61=0,$62=0,$63=0,$status_0=0,$65=0,$67=0,$68=0,$69=0,$71=0,$72=0,$73=0,$75=0;
 var $76=0,$77=0,$79=0,$80=0,$81=0,$type_1=0,$status_1=0,$82=.0,$83=0,$85=0,$86=0,$87=0,$88=0,$89=0,$90=0,$91=.0,$92=0,$93=0,$94=0,$95=.0;
 var $96=0,$97=0,$98=0,$99=.0,$100=0,$101=0,$102=0,$103=.0,$104=0,$105=0,$106=0,$107=0,$108=0,$109=0,$110=0,$111=0,$112=0,$113=0,$114=0,$115=0;
 var $116=0,$117=0,$118=0,$119=0,$120=0,$121=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+32)|0;
 $length=((sp)|0);
 $diam=(((sp)+(8))|0);
 $rcoeff=(((sp)+(16))|0);
 $lcoeff=(((sp)+(24))|0);
 HEAPF64[(($lcoeff)>>3)]=0.0;
 $1=((HEAP32[((14336)>>2)])|0);
 $2=((HEAP32[((14424)>>2)])|0);
 $3=((HEAP32[((14632)>>2)])|0);
 $4=($2|0)==($3|0);
 if ($4) {
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 $6=((HEAP32[((14376)>>2)])|0);
 $7=((($6)+(1))|0);
 HEAP32[((14376)>>2)]=$7;
 $8=((HEAP32[((14424)>>2)])|0);
 $9=((($8)+(1))|0);
 HEAP32[((14424)>>2)]=$9;
 $10=((HEAP32[((12232)>>2)])|0);
 $11=((_addlinkID($9,$10))|0);
 $12=($11|0)==0;
 if ($12) {
  $_0=215;

  STACKTOP=sp;return (($_0)|0);
 }
 $14=($1|0)<6;
 if ($14) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $16=((HEAP32[((12236)>>2)])|0);
 $17=((_findnode($16))|0);
 $18=($17|0)==0;
 if ($18) {
  $_0=203;

  STACKTOP=sp;return (($_0)|0);
 }
 $20=((HEAP32[((12240)>>2)])|0);
 $21=((_findnode($20))|0);
 $22=($21|0)==0;
 if ($22) {
  $_0=203;

  STACKTOP=sp;return (($_0)|0);
 }
 $24=($17|0)==($21|0);
 if ($24) {
  $_0=222;

  STACKTOP=sp;return (($_0)|0);
 }
 $26=((HEAP32[((12244)>>2)])|0);
 $27=((_getfloat($26,$length))|0);
 $28=($27|0)==0;
 if ($28) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $30=((HEAP32[((12248)>>2)])|0);
 $31=((_getfloat($30,$diam))|0);
 $32=($31|0)==0;
 if ($32) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $34=((HEAP32[((12252)>>2)])|0);
 $35=((_getfloat($34,$rcoeff))|0);
 $36=($35|0)==0;
 if ($36) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $38=(+(HEAPF64[(($length)>>3)]));
 $39=$38>(0.0);
 if (!($39)) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $41=(+(HEAPF64[(($diam)>>3)]));
 $42=$41>(0.0);
 if (!($42)) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $44=(+(HEAPF64[(($rcoeff)>>3)]));
 $45=$44>(0.0);
 if (!($45)) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $47=($1|0)==7;
 do {
  if ($47) {
   $49=((HEAP32[((12256)>>2)])|0);
   $50=((_match($49,3216))|0);
   $51=($50|0)==0;
   if (!($51)) {
    $status_1=3;$type_1=0;
    break;
   }
   $53=((HEAP32[((12256)>>2)])|0);
   $54=((_match($53,8984))|0);
   $55=($54|0)==0;
   if (!($55)) {
    $status_0=2;
    label = 18;
    break;
   }
   $57=((HEAP32[((12256)>>2)])|0);
   $58=((_match($57,5064))|0);
   $59=($58|0)==0;
   if (!($59)) {
    $status_0=3;
    label = 18;
    break;
   }
   $61=((HEAP32[((12256)>>2)])|0);
   $62=((_getfloat($61,$lcoeff))|0);
   $63=($62|0)==0;
   if ($63) {
    $_0=202;
   } else {
    $status_0=3;
    label = 18;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  } else {
   $status_0=3;
   label = 18;
  }
 } while(0);
 do {
  if ((label|0) == 18) {

   $65=($1|0)==8;
   if (!($65)) {
    $status_1=$status_0;$type_1=1;
    break;
   }
   $67=((HEAP32[((12256)>>2)])|0);
   $68=((_getfloat($67,$lcoeff))|0);
   $69=($68|0)==0;
   if ($69) {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   }
   $71=((HEAP32[((12260)>>2)])|0);
   $72=((_match($71,3216))|0);
   $73=($72|0)==0;
   if (!($73)) {
    $status_1=$status_0;$type_1=0;
    break;
   }
   $75=((HEAP32[((12260)>>2)])|0);
   $76=((_match($75,8984))|0);
   $77=($76|0)==0;
   if (!($77)) {
    $status_1=2;$type_1=1;
    break;
   }
   $79=((HEAP32[((12260)>>2)])|0);
   $80=((_match($79,5064))|0);
   $81=($80|0)==0;
   if ($81) {
    $_0=202;
   } else {
    $status_1=3;$type_1=1;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);


 $82=(+(HEAPF64[(($lcoeff)>>3)]));
 $83=$82<(0.0);
 if ($83) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $85=((HEAP32[((14424)>>2)])|0);
 $86=((HEAP32[((14960)>>2)])|0);
 $87=(($86+((($85)*(104))&-1)+32)|0);
 HEAP32[(($87)>>2)]=$17;
 $88=((HEAP32[((14424)>>2)])|0);
 $89=((HEAP32[((14960)>>2)])|0);
 $90=(($89+((($88)*(104))&-1)+36)|0);
 HEAP32[(($90)>>2)]=$21;
 $91=(+(HEAPF64[(($length)>>3)]));
 $92=((HEAP32[((14424)>>2)])|0);
 $93=((HEAP32[((14960)>>2)])|0);
 $94=(($93+((($92)*(104))&-1)+48)|0);
 HEAPF64[(($94)>>3)]=$91;
 $95=(+(HEAPF64[(($diam)>>3)]));
 $96=((HEAP32[((14424)>>2)])|0);
 $97=((HEAP32[((14960)>>2)])|0);
 $98=(($97+((($96)*(104))&-1)+40)|0);
 HEAPF64[(($98)>>3)]=$95;
 $99=(+(HEAPF64[(($rcoeff)>>3)]));
 $100=((HEAP32[((14424)>>2)])|0);
 $101=((HEAP32[((14960)>>2)])|0);
 $102=(($101+((($100)*(104))&-1)+56)|0);
 HEAPF64[(($102)>>3)]=$99;
 $103=(+(HEAPF64[(($lcoeff)>>3)]));
 $104=((HEAP32[((14424)>>2)])|0);
 $105=((HEAP32[((14960)>>2)])|0);
 $106=(($105+((($104)*(104))&-1)+64)|0);
 HEAPF64[(($106)>>3)]=$103;
 $107=((HEAP32[((14424)>>2)])|0);
 $108=((HEAP32[((14960)>>2)])|0);
 $109=(($108+((($107)*(104))&-1)+72)|0);
 HEAPF64[(($109)>>3)]=-10000000000.0;
 $110=((HEAP32[((14424)>>2)])|0);
 $111=((HEAP32[((14960)>>2)])|0);
 $112=(($111+((($110)*(104))&-1)+80)|0);
 HEAPF64[(($112)>>3)]=-10000000000.0;
 $113=((HEAP32[((14424)>>2)])|0);
 $114=((HEAP32[((14960)>>2)])|0);
 $115=(($114+((($113)*(104))&-1)+96)|0);
 HEAP8[($115)]=$type_1;
 $116=((HEAP32[((14424)>>2)])|0);
 $117=((HEAP32[((14960)>>2)])|0);
 $118=(($117+((($116)*(104))&-1)+97)|0);
 HEAP8[($118)]=$status_1;
 $119=((HEAP32[((14424)>>2)])|0);
 $120=((HEAP32[((14960)>>2)])|0);
 $121=(($120+((($119)*(104))&-1)+98)|0);
 HEAP8[($121)]=0;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _pumpdata(){
 var $y=0,$1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$17=0,$19=0,$20=0,$21=0,$23=0,$24=0;
 var $25=0,$27=0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=.0,$37=0,$38=0,$39=0,$40=0,$41=0,$42=0,$43=0,$44=0,$45=0,$46=0;
 var $47=0,$48=0,$49=0,$50=0,$51=0,$52=0,$53=0,$54=0,$55=0,$56=0,$57=0,$58=0,$59=0,$60=0,$61=0,$62=0,$63=0,$64=0,$65=0,$66=0;
 var $67=0,$68=0,$69=0,$70=0,$71=0,$72=0,$73=0,$74=0,$75=0,$76=0,$77=0,$78=0,$79=0,$80=0,$81=0,$82=0,$83=0,$84=0,$85=0,$86=0;
 var $87=0,$88=0,$89=0,$90=0,$m_024=0,$j_023=0,$91=0,$92=0,$93=0,$94=0,$95=0,$96=0,$98=0,$99=0,$100=0,$m_0_lcssa=0,$101=0,$m_119=0,$102=0,$103=0;
 var $104=0,$105=0,$106=0,$108=0,$109=0,$110=.0,$111=0,$113=0,$114=0,$115=0,$116=.0,$117=0,$118=0,$119=0,$121=0,$122=0,$123=0,$125=0,$126=0,$127=0;
 var $128=0,$129=0,$131=0,$132=0,$133=0,$134=0,$135=0,$137=0,$138=0,$139=0,$141=0,$142=0,$143=0,$144=0,$145=0,$147=0,$148=0,$149=0,$150=0,$151=0;
 var $153=0,$154=0,$155=0,$157=0,$158=0,$159=0,$160=0,$162=.0,$163=0,$165=0,$166=0,$167=0,$169=0,$170=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $y=((sp)|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $2=((HEAP32[((14424)>>2)])|0);
 $3=((HEAP32[((14632)>>2)])|0);
 $4=($2|0)==($3|0);
 if ($4) {
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 $6=((HEAP32[((14368)>>2)])|0);
 $7=((HEAP32[((14600)>>2)])|0);
 $8=($6|0)==($7|0);
 if ($8) {
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 $10=((($2)+(1))|0);
 HEAP32[((14424)>>2)]=$10;
 $11=((HEAP32[((14368)>>2)])|0);
 $12=((($11)+(1))|0);
 HEAP32[((14368)>>2)]=$12;
 $13=((HEAP32[((12232)>>2)])|0);
 $14=((_addlinkID($10,$13))|0);
 $15=($14|0)==0;
 if ($15) {
  $_0=215;

  STACKTOP=sp;return (($_0)|0);
 }
 $17=($1|0)<4;
 if ($17) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $19=((HEAP32[((12236)>>2)])|0);
 $20=((_findnode($19))|0);
 $21=($20|0)==0;
 if ($21) {
  $_0=203;

  STACKTOP=sp;return (($_0)|0);
 }
 $23=((HEAP32[((12240)>>2)])|0);
 $24=((_findnode($23))|0);
 $25=($24|0)==0;
 if ($25) {
  $_0=203;

  STACKTOP=sp;return (($_0)|0);
 }
 $27=($20|0)==($24|0);
 if ($27) {
  $_0=222;

  STACKTOP=sp;return (($_0)|0);
 }
 $29=((HEAP32[((14424)>>2)])|0);
 $30=((HEAP32[((14960)>>2)])|0);
 $31=(($30+((($29)*(104))&-1)+32)|0);
 HEAP32[(($31)>>2)]=$20;
 $32=((HEAP32[((14424)>>2)])|0);
 $33=((HEAP32[((14960)>>2)])|0);
 $34=(($33+((($32)*(104))&-1)+36)|0);
 HEAP32[(($34)>>2)]=$24;
 $35=((HEAP32[((14368)>>2)])|0);
 $36=(+((($35|0))|0));
 $37=((HEAP32[((14424)>>2)])|0);
 $38=((HEAP32[((14960)>>2)])|0);
 $39=(($38+((($37)*(104))&-1)+40)|0);
 HEAPF64[(($39)>>3)]=$36;
 $40=((HEAP32[((14424)>>2)])|0);
 $41=((HEAP32[((14960)>>2)])|0);
 $42=(($41+((($40)*(104))&-1)+48)|0);
 HEAPF64[(($42)>>3)]=0.0;
 $43=((HEAP32[((14424)>>2)])|0);
 $44=((HEAP32[((14960)>>2)])|0);
 $45=(($44+((($43)*(104))&-1)+56)|0);
 HEAPF64[(($45)>>3)]=1.0;
 $46=((HEAP32[((14424)>>2)])|0);
 $47=((HEAP32[((14960)>>2)])|0);
 $48=(($47+((($46)*(104))&-1)+64)|0);
 HEAPF64[(($48)>>3)]=0.0;
 $49=((HEAP32[((14424)>>2)])|0);
 $50=((HEAP32[((14960)>>2)])|0);
 $51=(($50+((($49)*(104))&-1)+72)|0);
 HEAPF64[(($51)>>3)]=0.0;
 $52=((HEAP32[((14424)>>2)])|0);
 $53=((HEAP32[((14960)>>2)])|0);
 $54=(($53+((($52)*(104))&-1)+80)|0);
 HEAPF64[(($54)>>3)]=0.0;
 $55=((HEAP32[((14424)>>2)])|0);
 $56=((HEAP32[((14960)>>2)])|0);
 $57=(($56+((($55)*(104))&-1)+96)|0);
 HEAP8[($57)]=2;
 $58=((HEAP32[((14424)>>2)])|0);
 $59=((HEAP32[((14960)>>2)])|0);
 $60=(($59+((($58)*(104))&-1)+97)|0);
 HEAP8[($60)]=3;
 $61=((HEAP32[((14424)>>2)])|0);
 $62=((HEAP32[((14960)>>2)])|0);
 $63=(($62+((($61)*(104))&-1)+98)|0);
 HEAP8[($63)]=0;
 $64=((HEAP32[((14424)>>2)])|0);
 $65=((HEAP32[((14368)>>2)])|0);
 $66=((HEAP32[((13888)>>2)])|0);
 $67=(($66+($65<<7))|0);
 HEAP32[(($67)>>2)]=$64;
 $68=((HEAP32[((14368)>>2)])|0);
 $69=((HEAP32[((13888)>>2)])|0);
 $70=(($69+($68<<7)+4)|0);
 HEAP32[(($70)>>2)]=3;
 $71=((HEAP32[((14368)>>2)])|0);
 $72=((HEAP32[((13888)>>2)])|0);
 $73=(($72+($71<<7)+56)|0);
 HEAP32[(($73)>>2)]=0;
 $74=((HEAP32[((14368)>>2)])|0);
 $75=((HEAP32[((13888)>>2)])|0);
 $76=(($75+($74<<7)+60)|0);
 HEAP32[(($76)>>2)]=0;
 $77=((HEAP32[((14368)>>2)])|0);
 $78=((HEAP32[((13888)>>2)])|0);
 $79=(($78+($77<<7)+64)|0);
 HEAP32[(($79)>>2)]=0;
 $80=((HEAP32[((14368)>>2)])|0);
 $81=((HEAP32[((13888)>>2)])|0);
 $82=(($81+($80<<7)+72)|0);
 HEAPF64[(($82)>>3)]=0.0;
 $83=((HEAP32[((14368)>>2)])|0);
 $84=((HEAP32[((13888)>>2)])|0);
 $85=(($84+($83<<7)+68)|0);
 HEAP32[(($85)>>2)]=0;
 $86=((HEAP32[((12244)>>2)])|0);
 $87=((HEAP32[((12000)>>2)])|0);
 $88=((_getfloat($86,$87))|0);
 $89=($88|0)==0;
 $90=($1|0)>4;
 if (!($89)) {
  L24: do {
   if ($90) {
    $j_023=4;$m_024=1;
    while(1) {


     $91=((12232+($j_023<<2))|0);
     $92=((HEAP32[(($91)>>2)])|0);
     $93=((HEAP32[((12000)>>2)])|0);
     $94=(($93+($m_024<<3))|0);
     $95=((_getfloat($92,$94))|0);
     $96=($95|0)==0;
     if ($96) {
      $_0=202;
      break;
     }
     $98=((($m_024)+(1))|0);
     $99=((($j_023)+(1))|0);
     $100=($99|0)<($1|0);
     if ($100) {
      $j_023=$99;$m_024=$98;
     } else {
      $m_0_lcssa=$98;
      break L24;
     }
    }

    STACKTOP=sp;return (($_0)|0);
   } else {
    $m_0_lcssa=1;
   }
  } while(0);

  $101=((_getpumpcurve($m_0_lcssa))|0);
  $_0=$101;

  STACKTOP=sp;return (($_0)|0);
 }
 if ($90) {
  $m_119=4;
 } else {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 L34: while(1) {

  $102=((($m_119)-(1))|0);
  $103=((12232+($102<<2))|0);
  $104=((HEAP32[(($103)>>2)])|0);
  $105=((_match($104,3664))|0);
  $106=($105|0)==0;
  do {
   if ($106) {
    $121=((HEAP32[(($103)>>2)])|0);
    $122=((_match($121,3056))|0);
    $123=($122|0)==0;
    if (!($123)) {
     $125=((12232+($m_119<<2))|0);
     $126=((HEAP32[(($125)>>2)])|0);
     $127=((HEAP32[((17640)>>2)])|0);
     $128=((_findID($126,$127))|0);
     $129=($128|0)==0;
     if ($129) {
      $_0=206;
      label = 28;
      break L34;
     }
     $131=(($128)|0);
     $132=((HEAP32[(($131)>>2)])|0);
     $133=((HEAP32[((14368)>>2)])|0);
     $134=((HEAP32[((13888)>>2)])|0);
     $135=(($134+($133<<7)+56)|0);
     HEAP32[(($135)>>2)]=$132;
     break;
    }
    $137=((HEAP32[(($103)>>2)])|0);
    $138=((_match($137,2296))|0);
    $139=($138|0)==0;
    if (!($139)) {
     $141=((12232+($m_119<<2))|0);
     $142=((HEAP32[(($141)>>2)])|0);
     $143=((HEAP32[((13952)>>2)])|0);
     $144=((_findID($142,$143))|0);
     $145=($144|0)==0;
     if ($145) {
      $_0=205;
      label = 28;
      break L34;
     }
     $147=(($144)|0);
     $148=((HEAP32[(($147)>>2)])|0);
     $149=((HEAP32[((14368)>>2)])|0);
     $150=((HEAP32[((13888)>>2)])|0);
     $151=(($150+($149<<7)+64)|0);
     HEAP32[(($151)>>2)]=$148;
     break;
    }
    $153=((HEAP32[(($103)>>2)])|0);
    $154=((_match($153,1824))|0);
    $155=($154|0)==0;
    if ($155) {
     $_0=201;
     label = 28;
     break L34;
    }
    $157=((12232+($m_119<<2))|0);
    $158=((HEAP32[(($157)>>2)])|0);
    $159=((_getfloat($158,$y))|0);
    $160=($159|0)==0;
    if ($160) {
     $_0=202;
     label = 28;
     break L34;
    }
    $162=(+(HEAPF64[(($y)>>3)]));
    $163=$162<(0.0);
    if ($163) {
     $_0=202;
     label = 28;
     break L34;
    }
    $165=((HEAP32[((14424)>>2)])|0);
    $166=((HEAP32[((14960)>>2)])|0);
    $167=(($166+((($165)*(104))&-1)+56)|0);
    HEAPF64[(($167)>>3)]=$162;
   } else {
    $108=((12232+($m_119<<2))|0);
    $109=((HEAP32[(($108)>>2)])|0);
    $110=(+(_atof($109)));
    HEAPF64[(($y)>>3)]=$110;
    $111=$110>(0.0);
    if (!($111)) {
     $_0=202;
     label = 28;
     break L34;
    }
    $113=((HEAP32[((14368)>>2)])|0);
    $114=((HEAP32[((13888)>>2)])|0);
    $115=(($114+($113<<7)+4)|0);
    HEAP32[(($115)>>2)]=0;
    $116=(+(HEAPF64[(($y)>>3)]));
    $117=((HEAP32[((14424)>>2)])|0);
    $118=((HEAP32[((14960)>>2)])|0);
    $119=(($118+((($117)*(104))&-1)+64)|0);
    HEAPF64[(($119)>>3)]=$116;
   }
  } while(0);
  $169=((($m_119)+(2))|0);
  $170=($169|0)<($1|0);
  if ($170) {
   $m_119=$169;
  } else {
   $_0=0;
   label = 28;
   break;
  }
 }
 if ((label|0) == 28) {

  STACKTOP=sp;return (($_0)|0);
 }
  return 0;
}


function _getpumpcurve($n){
 $n=($n)|0;
 var $a=0,$b=0,$c=0,$2=0,$3=.0,$4=0,$6=0,$7=0,$8=0,$9=0,$10=.0,$11=0,$12=0,$13=0,$15=0,$16=0,$17=.0,$18=.0,$19=.0,$20=.0;
 var $22=0,$24=0,$25=.0,$26=0,$27=.0,$28=0,$29=.0,$30=0,$31=.0,$32=0,$33=.0,$h0_0=.0,$h1_0=.0,$h2_0=.0,$q1_0=.0,$q2_0=.0,$35=0,$36=0,$37=0,$38=0;
 var $39=0,$41=.0,$42=.0,$43=0,$44=0,$45=0,$46=.0,$47=.0,$48=0,$49=0,$50=0,$51=.0,$52=0,$53=0,$54=0,$55=0,$56=0,$57=0,$58=.0,$59=.0;
 var $60=.0,$61=.0,$62=.0,$63=.0,$64=.0,$65=0,$66=0,$67=0,$68=0,$69=0,$70=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+24)|0;
 $a=((sp)|0);
 $b=(((sp)+(8))|0);
 $c=(((sp)+(16))|0);
 do {
  if (((($n|0))|0)==((1)|0)) {
   $2=((HEAP32[((12000)>>2)])|0);
   $3=(+(HEAPF64[(($2)>>3)]));
   $4=$3>(0.0);
   if (!($4)) {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   }
   $6=((HEAP32[((14368)>>2)])|0);
   $7=((HEAP32[((13888)>>2)])|0);
   $8=(($7+($6<<7)+4)|0);
   HEAP32[(($8)>>2)]=0;
   $9=((HEAP32[((12000)>>2)])|0);
   $10=(+(HEAPF64[(($9)>>3)]));
   $11=((HEAP32[((14424)>>2)])|0);
   $12=((HEAP32[((14960)>>2)])|0);
   $13=(($12+((($11)*(104))&-1)+64)|0);
   HEAPF64[(($13)>>3)]=$10;
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  } else if (((($n|0))|0)==((2)|0)) {
   $15=((HEAP32[((12000)>>2)])|0);
   $16=(($15+8)|0);
   $17=(+(HEAPF64[(($16)>>3)]));
   $18=(+(HEAPF64[(($15)>>3)]));
   $19=($18)*((1.33334));
   $20=($17)*((2.0));
   $q2_0=$20;$q1_0=$17;$h2_0=0.0;$h1_0=$18;$h0_0=$19;
  } else {
   $22=($n|0)>4;
   if ($22) {
    $24=((HEAP32[((12000)>>2)])|0);
    $25=(+(HEAPF64[(($24)>>3)]));
    $26=(($24+8)|0);
    $27=(+(HEAPF64[(($26)>>3)]));
    $28=(($24+16)|0);
    $29=(+(HEAPF64[(($28)>>3)]));
    $30=(($24+24)|0);
    $31=(+(HEAPF64[(($30)>>3)]));
    $32=(($24+32)|0);
    $33=(+(HEAPF64[(($32)>>3)]));
    $q2_0=$33;$q1_0=$29;$h2_0=$31;$h1_0=$27;$h0_0=$25;
    break;
   } else {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   }
  }
 } while(0);





 $35=((HEAP32[((14368)>>2)])|0);
 $36=((HEAP32[((13888)>>2)])|0);
 $37=(($36+($35<<7)+4)|0);
 HEAP32[(($37)>>2)]=1;
 $38=((_powercurve($h0_0,$h1_0,$h2_0,$q1_0,$q2_0,$a,$b,$c))|0);
 $39=($38|0)==0;
 if ($39) {
  $_0=206;

  STACKTOP=sp;return (($_0)|0);
 }
 $41=(+(HEAPF64[(($a)>>3)]));
 $42=((-.0))-($41);
 $43=((HEAP32[((14368)>>2)])|0);
 $44=((HEAP32[((13888)>>2)])|0);
 $45=(($44+($43<<7)+32)|0);
 HEAPF64[(($45)>>3)]=$42;
 $46=(+(HEAPF64[(($b)>>3)]));
 $47=((-.0))-($46);
 $48=((HEAP32[((14368)>>2)])|0);
 $49=((HEAP32[((13888)>>2)])|0);
 $50=(($49+($48<<7)+40)|0);
 HEAPF64[(($50)>>3)]=$47;
 $51=(+(HEAPF64[(($c)>>3)]));
 $52=((HEAP32[((14368)>>2)])|0);
 $53=((HEAP32[((13888)>>2)])|0);
 $54=(($53+($52<<7)+48)|0);
 HEAPF64[(($54)>>3)]=$51;
 $55=((HEAP32[((14368)>>2)])|0);
 $56=((HEAP32[((13888)>>2)])|0);
 $57=(($56+($55<<7)+8)|0);
 HEAPF64[(($57)>>3)]=$q1_0;
 $58=(+(HEAPF64[(($a)>>3)]));
 $59=((-.0))-($58);
 $60=(+(HEAPF64[(($b)>>3)]));
 $61=($59)/($60);
 $62=(+(HEAPF64[(($c)>>3)]));
 $63=((1.0))/($62);
 $64=(+(Math_pow((+($61)),(+($63)))));
 $65=((HEAP32[((14368)>>2)])|0);
 $66=((HEAP32[((13888)>>2)])|0);
 $67=(($66+($65<<7)+16)|0);
 HEAPF64[(($67)>>3)]=$64;
 $68=((HEAP32[((14368)>>2)])|0);
 $69=((HEAP32[((13888)>>2)])|0);
 $70=(($69+($68<<7)+24)|0);
 HEAPF64[(($70)>>3)]=$h0_0;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _valvedata(){
 var $diam=0,$setting=0,$lcoeff=0,$1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$17=0,$19=0,$20=0,$21=0;
 var $23=0,$24=0,$25=0,$27=0,$29=0,$30=0,$31=0,$33=0,$34=0,$35=0,$37=0,$38=0,$39=0,$41=0,$42=0,$43=0,$45=0,$46=0,$47=0,$49=0;
 var $50=0,$51=0,$type_0=0,$53=0,$54=0,$55=0,$56=.0,$57=0,$or_cond15=0,$59=0,$60=0,$61=0,$63=0,$64=0,$65=0,$67=0,$68=0,$69=.0,$71=0,$72=0;
 var $status_0=0,$74=0,$76=0,$77=0,$78=0,$80=0,$81=0,$82=0,$or_cond=0,$85=0,$86=0,$88=0,$89=0,$90=0,$91=0,$92=0,$93=0,$94=.0,$95=0,$96=0;
 var $97=0,$98=0,$99=0,$100=0,$101=.0,$102=0,$103=0,$104=0,$105=.0,$106=0,$107=0,$108=0,$109=0,$110=0,$111=0,$112=0,$113=0,$114=0,$115=0,$116=0;
 var $117=0,$118=0,$119=0,$120=0,$121=0,$122=0,$123=0,$124=0,$125=0,$126=0,$127=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+24)|0;
 $diam=((sp)|0);
 $setting=(((sp)+(8))|0);
 $lcoeff=(((sp)+(16))|0);
 HEAPF64[(($diam)>>3)]=0.0;
 HEAPF64[(($lcoeff)>>3)]=0.0;
 $1=((HEAP32[((14336)>>2)])|0);
 $2=((HEAP32[((14424)>>2)])|0);
 $3=((HEAP32[((14632)>>2)])|0);
 $4=($2|0)==($3|0);
 if ($4) {
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 $6=((HEAP32[((14328)>>2)])|0);
 $7=((HEAP32[((14576)>>2)])|0);
 $8=($6|0)==($7|0);
 if ($8) {
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 $10=((($6)+(1))|0);
 HEAP32[((14328)>>2)]=$10;
 $11=((HEAP32[((14424)>>2)])|0);
 $12=((($11)+(1))|0);
 HEAP32[((14424)>>2)]=$12;
 $13=((HEAP32[((12232)>>2)])|0);
 $14=((_addlinkID($12,$13))|0);
 $15=($14|0)==0;
 if ($15) {
  $_0=215;

  STACKTOP=sp;return (($_0)|0);
 }
 $17=($1|0)<6;
 if ($17) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $19=((HEAP32[((12236)>>2)])|0);
 $20=((_findnode($19))|0);
 $21=($20|0)==0;
 if ($21) {
  $_0=203;

  STACKTOP=sp;return (($_0)|0);
 }
 $23=((HEAP32[((12240)>>2)])|0);
 $24=((_findnode($23))|0);
 $25=($24|0)==0;
 if ($25) {
  $_0=203;

  STACKTOP=sp;return (($_0)|0);
 }
 $27=($20|0)==($24|0);
 if ($27) {
  $_0=222;

  STACKTOP=sp;return (($_0)|0);
 }
 $29=((HEAP32[((12248)>>2)])|0);
 $30=((_match($29,1400))|0);
 $31=($30|0)==0;
 do {
  if ($31) {
   $33=((HEAP32[((12248)>>2)])|0);
   $34=((_match($33,736))|0);
   $35=($34|0)==0;
   if (!($35)) {
    $type_0=4;
    break;
   }
   $37=((HEAP32[((12248)>>2)])|0);
   $38=((_match($37,200))|0);
   $39=($38|0)==0;
   if (!($39)) {
    $type_0=5;
    break;
   }
   $41=((HEAP32[((12248)>>2)])|0);
   $42=((_match($41,10304))|0);
   $43=($42|0)==0;
   if (!($43)) {
    $type_0=6;
    break;
   }
   $45=((HEAP32[((12248)>>2)])|0);
   $46=((_match($45,10072))|0);
   $47=($46|0)==0;
   if (!($47)) {
    $type_0=7;
    break;
   }
   $49=((HEAP32[((12248)>>2)])|0);
   $50=((_match($49,9856))|0);
   $51=($50|0)==0;
   if ($51) {
    $_0=201;
   } else {
    $type_0=8;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  } else {
   $type_0=3;
  }
 } while(0);

 $53=((HEAP32[((12244)>>2)])|0);
 $54=((_getfloat($53,$diam))|0);
 $55=($54|0)!=0;
 $56=(+(HEAPF64[(($diam)>>3)]));
 $57=$56>(0.0);
 $or_cond15=$55&$57;
 if (!($or_cond15)) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $59=($type_0&255);
 $60=(($type_0<<24)>>24)==8;
 $61=((HEAP32[((12252)>>2)])|0);
 do {
  if ($60) {
   $63=((HEAP32[((17640)>>2)])|0);
   $64=((_findID($61,$63))|0);
   $65=($64|0)==0;
   if ($65) {
    $_0=206;

    STACKTOP=sp;return (($_0)|0);
   } else {
    $67=(($64)|0);
    $68=((HEAP32[(($67)>>2)])|0);
    $69=(+((($68|0))|0));
    HEAPF64[(($setting)>>3)]=$69;
    $status_0=3;
    break;
   }
  } else {
   $71=((_getfloat($61,$setting))|0);
   $72=($71|0)==0;
   if ($72) {
    $_0=202;
   } else {
    $status_0=4;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);

 $74=($1|0)>6;
 do {
  if ($74) {
   $76=((HEAP32[((12256)>>2)])|0);
   $77=((_getfloat($76,$lcoeff))|0);
   $78=($77|0)==0;
   if ($78) {
    $_0=202;
   } else {
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);
 $80=((HEAP32[((14432)>>2)])|0);
 $81=($20|0)>($80|0);
 $82=($24|0)>($80|0);
 $or_cond=$81|$82;
 do {
  if ($or_cond) {
   if ((((($type_0<<24)>>24))|0)==((3)|0)|(((($type_0<<24)>>24))|0)==((4)|0)|(((($type_0<<24)>>24))|0)==((6)|0)) {
    $_0=219;
   } else {
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);
 $85=((_valvecheck($59,$20,$24))|0);
 $86=($85|0)==0;
 if ($86) {
  $_0=220;

  STACKTOP=sp;return (($_0)|0);
 }
 $88=((HEAP32[((14424)>>2)])|0);
 $89=((HEAP32[((14960)>>2)])|0);
 $90=(($89+((($88)*(104))&-1)+32)|0);
 HEAP32[(($90)>>2)]=$20;
 $91=((HEAP32[((14424)>>2)])|0);
 $92=((HEAP32[((14960)>>2)])|0);
 $93=(($92+((($91)*(104))&-1)+36)|0);
 HEAP32[(($93)>>2)]=$24;
 $94=(+(HEAPF64[(($diam)>>3)]));
 $95=((HEAP32[((14424)>>2)])|0);
 $96=((HEAP32[((14960)>>2)])|0);
 $97=(($96+((($95)*(104))&-1)+40)|0);
 HEAPF64[(($97)>>3)]=$94;
 $98=((HEAP32[((14424)>>2)])|0);
 $99=((HEAP32[((14960)>>2)])|0);
 $100=(($99+((($98)*(104))&-1)+48)|0);
 HEAPF64[(($100)>>3)]=0.0;
 $101=(+(HEAPF64[(($setting)>>3)]));
 $102=((HEAP32[((14424)>>2)])|0);
 $103=((HEAP32[((14960)>>2)])|0);
 $104=(($103+((($102)*(104))&-1)+56)|0);
 HEAPF64[(($104)>>3)]=$101;
 $105=(+(HEAPF64[(($lcoeff)>>3)]));
 $106=((HEAP32[((14424)>>2)])|0);
 $107=((HEAP32[((14960)>>2)])|0);
 $108=(($107+((($106)*(104))&-1)+64)|0);
 HEAPF64[(($108)>>3)]=$105;
 $109=((HEAP32[((14424)>>2)])|0);
 $110=((HEAP32[((14960)>>2)])|0);
 $111=(($110+((($109)*(104))&-1)+72)|0);
 HEAPF64[(($111)>>3)]=0.0;
 $112=((HEAP32[((14424)>>2)])|0);
 $113=((HEAP32[((14960)>>2)])|0);
 $114=(($113+((($112)*(104))&-1)+80)|0);
 HEAPF64[(($114)>>3)]=0.0;
 $115=((HEAP32[((14424)>>2)])|0);
 $116=((HEAP32[((14960)>>2)])|0);
 $117=(($116+((($115)*(104))&-1)+96)|0);
 HEAP8[($117)]=$type_0;
 $118=((HEAP32[((14424)>>2)])|0);
 $119=((HEAP32[((14960)>>2)])|0);
 $120=(($119+((($118)*(104))&-1)+97)|0);
 HEAP8[($120)]=$status_0;
 $121=((HEAP32[((14424)>>2)])|0);
 $122=((HEAP32[((14960)>>2)])|0);
 $123=(($122+((($121)*(104))&-1)+98)|0);
 HEAP8[($123)]=0;
 $124=((HEAP32[((14424)>>2)])|0);
 $125=((HEAP32[((14328)>>2)])|0);
 $126=((HEAP32[((12024)>>2)])|0);
 $127=(($126+($125<<2))|0);
 HEAP32[(($127)>>2)]=$124;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _valvecheck($type,$j1,$j2){
 $type=($type)|0;
 $j1=($j1)|0;
 $j2=($j2)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$k_0=0,$8=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$or_cond=0,$20=0,$21=0;
 var $or_cond42=0,$22=0,$or_cond43=0,$24=0,$or_cond44=0,$26=0,$27=0,$or_cond45=0,$28=0,$or_cond46=0,$or_cond47=0,$30=0,$or_cond48=0,$or_cond49=0,$32=0,$or_cond50=0,$34=0,$or_cond51=0,$or_cond52=0,$or_cond53=0;
 var $or_cond54=0,$or_cond55=0,$or_cond56=0,$or_cond57=0,$or_cond58=0,$38=0,$_0=0,label=0;

 $1=((HEAP32[((14328)>>2)])|0);
 $2=((HEAP32[((12024)>>2)])|0);
 $3=((HEAP32[((14960)>>2)])|0);
 $4=($type|0)==3;
 $5=($type|0)==4;
 $6=($type|0)==6;
 $k_0=1;
 while(1) {

  $8=($k_0|0)>($1|0);
  if ($8) {
   $_0=1;
   label = 13;
   break;
  }
  $10=(($2+($k_0<<2))|0);
  $11=((HEAP32[(($10)>>2)])|0);
  $12=(($3+((($11)*(104))&-1)+32)|0);
  $13=((HEAP32[(($12)>>2)])|0);
  $14=(($3+((($11)*(104))&-1)+36)|0);
  $15=((HEAP32[(($14)>>2)])|0);
  $16=(($3+((($11)*(104))&-1)+96)|0);
  $17=((HEAP8[($16)])|0);
  $18=(($17<<24)>>24)==3;
  $or_cond=$18&$4;
  if ($or_cond) {
   $20=($15|0)==($j2|0);
   $21=($15|0)==($j1|0);
   $or_cond42=$20|$21;
   $22=($13|0)==($j2|0);
   $or_cond43=$or_cond42|$22;
   if ($or_cond43) {
    $_0=0;
    label = 13;
    break;
   }
  }
  $24=(($17<<24)>>24)==4;
  $or_cond44=$24&$5;
  if ($or_cond44) {
   $26=($13|0)==($j1|0);
   $27=($13|0)==($j2|0);
   $or_cond45=$26|$27;
   $28=($15|0)==($j1|0);
   $or_cond46=$or_cond45|$28;
   if ($or_cond46) {
    $_0=0;
    label = 13;
    break;
   }
  }
  $or_cond47=$24&$4;
  $30=($13|0)==($j2|0);
  $or_cond48=$or_cond47&$30;
  if ($or_cond48) {
   $_0=0;
   label = 13;
   break;
  }
  $or_cond49=$18&$5;
  $32=($15|0)==($j1|0);
  $or_cond50=$or_cond49&$32;
  if ($or_cond50) {
   $_0=0;
   label = 13;
   break;
  }
  $34=(($17<<24)>>24)==6;
  $or_cond51=$34&$5;
  $or_cond52=$or_cond51&$32;
  if ($or_cond52) {
   $_0=0;
   label = 13;
   break;
  }
  $or_cond53=$34&$4;
  $or_cond54=$or_cond53&$30;
  if ($or_cond54) {
   $_0=0;
   label = 13;
   break;
  }
  $or_cond55=$24&$6;
  $or_cond56=$or_cond55&$30;
  if ($or_cond56) {
   $_0=0;
   label = 13;
   break;
  }
  $or_cond57=$18&$6;
  $or_cond58=$or_cond57&$32;
  $38=((($k_0)+(1))|0);
  if ($or_cond58) {
   $_0=0;
   label = 13;
   break;
  } else {
   $k_0=$38;
  }
 }
 if ((label|0) == 13) {

  return (($_0)|0);
 }
  return 0;
}


function _patterndata(){
 var $x=0,$1=0,$2=0,$3=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$13=0,$14=0,$15=0,$16=0,$p_012_ph=0,$17=0,$18=0,$i_013=0,$20=0,$21=0;
 var $22=0,$23=0,$25=0,$26=0,$27=0,$28=.0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0,$40=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $x=((sp)|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $2=((($1)-(1))|0);
 $3=($2|0)<1;
 if ($3) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $5=((HEAP32[((13912)>>2)])|0);
 $6=($5|0)==0;
 if ($6) {
  label = 4;
 } else {
  $8=((HEAP32[((12232)>>2)])|0);
  $9=(($5+4)|0);
  $10=((_strcmp((($8)|0),(($9)|0)))|0);
  $11=($10|0)==0;
  if ($11) {
   $p_012_ph=$5;
  } else {
   label = 4;
  }
 }
 do {
  if ((label|0) == 4) {
   $13=((HEAP32[((12232)>>2)])|0);
   $14=((HEAP32[((13952)>>2)])|0);
   $15=((_findID($13,$14))|0);
   $16=($15|0)==0;
   if ($16) {
    $_0=205;
   } else {
    $p_012_ph=$15;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);

 $17=($2|0)<1;
 L10: do {
  if (!($17)) {
   $18=(($p_012_ph+36)|0);
   $i_013=1;
   while(1) {

    $20=((12232+($i_013<<2))|0);
    $21=((HEAP32[(($20)>>2)])|0);
    $22=((_getfloat($21,$x))|0);
    $23=($22|0)==0;
    if ($23) {
     $_0=202;
     label = 11;
     break;
    }
    $25=((_malloc(16))|0);
    $26=($25|0)==0;
    if ($26) {
     $_0=101;
     label = 11;
     break;
    }
    $27=$25;
    $28=(+(HEAPF64[(($x)>>3)]));
    $29=$25;
    HEAPF64[(($29)>>3)]=$28;
    $30=((HEAP32[(($18)>>2)])|0);
    $31=(($25+8)|0);
    $32=$31;
    HEAP32[(($32)>>2)]=$30;
    HEAP32[(($18)>>2)]=$27;
    $33=((($i_013)+(1))|0);
    $34=($33|0)>($2|0);
    if ($34) {
     break L10;
    } else {
     $i_013=$33;
    }
   }
   if ((label|0) == 11) {

    STACKTOP=sp;return (($_0)|0);
   }
  }
 } while(0);
 $35=(($p_012_ph)|0);
 $36=((HEAP32[(($35)>>2)])|0);
 $37=((HEAP32[((13944)>>2)])|0);
 $38=(($37+((($36)*(40))&-1)+32)|0);
 $39=((HEAP32[(($38)>>2)])|0);
 $40=((($39)+($2))|0);
 HEAP32[(($38)>>2)]=$40;
 HEAP32[((13912)>>2)]=$p_012_ph;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _curvedata(){
 var $x=0,$y=0,$1=0,$2=0,$4=0,$5=0,$7=0,$8=0,$9=0,$10=0,$12=0,$13=0,$14=0,$15=0,$c_013=0,$16=0,$17=0,$18=0,$20=0,$21=0;
 var $22=0,$24=0,$25=0,$26=0,$27=0,$or_cond=0,$29=0,$30=0,$31=.0,$32=0,$33=0,$34=0,$35=0,$36=0,$37=.0,$38=0,$39=0,$40=0,$41=0,$42=0;
 var $43=0,$44=0,$45=0,$46=0,$47=0,$48=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $x=((sp)|0);
 $y=(((sp)+(8))|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $2=($1|0)<3;
 if ($2) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $4=((HEAP32[((13920)>>2)])|0);
 $5=($4|0)==0;
 if ($5) {
  label = 4;
 } else {
  $7=((HEAP32[((12232)>>2)])|0);
  $8=(($4+4)|0);
  $9=((_strcmp((($7)|0),(($8)|0)))|0);
  $10=($9|0)==0;
  if ($10) {
   $c_013=$4;
  } else {
   label = 4;
  }
 }
 do {
  if ((label|0) == 4) {
   $12=((HEAP32[((12232)>>2)])|0);
   $13=((HEAP32[((17640)>>2)])|0);
   $14=((_findID($12,$13))|0);
   $15=($14|0)==0;
   if ($15) {
    $_0=205;
   } else {
    $c_013=$14;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);

 $16=((HEAP32[((12236)>>2)])|0);
 $17=((_getfloat($16,$x))|0);
 $18=($17|0)==0;
 if ($18) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $20=((HEAP32[((12240)>>2)])|0);
 $21=((_getfloat($20,$y))|0);
 $22=($21|0)==0;
 if ($22) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $24=((_malloc(16))|0);
 $25=((_malloc(16))|0);
 $26=($24|0)==0;
 $27=($25|0)==0;
 $or_cond=$26|$27;
 if ($or_cond) {
  $_0=101;

  STACKTOP=sp;return (($_0)|0);
 }
 $29=$25;
 $30=$24;
 $31=(+(HEAPF64[(($x)>>3)]));
 $32=$24;
 HEAPF64[(($32)>>3)]=$31;
 $33=(($c_013+36)|0);
 $34=((HEAP32[(($33)>>2)])|0);
 $35=(($24+8)|0);
 $36=$35;
 HEAP32[(($36)>>2)]=$34;
 HEAP32[(($33)>>2)]=$30;
 $37=(+(HEAPF64[(($y)>>3)]));
 $38=$25;
 HEAPF64[(($38)>>3)]=$37;
 $39=(($c_013+40)|0);
 $40=((HEAP32[(($39)>>2)])|0);
 $41=(($25+8)|0);
 $42=$41;
 HEAP32[(($42)>>2)]=$40;
 HEAP32[(($39)>>2)]=$29;
 $43=(($c_013)|0);
 $44=((HEAP32[(($43)>>2)])|0);
 $45=((HEAP32[((17648)>>2)])|0);
 $46=(($45+((($44)*(48))&-1)+36)|0);
 $47=((HEAP32[(($46)>>2)])|0);
 $48=((($47)+(1))|0);
 HEAP32[(($46)>>2)]=$48;
 HEAP32[((13920)>>2)]=$c_013;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _demanddata(){
 var $y=0,$1=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$12=.0,$13=0,$16=0,$17=0,$18=0,$19=0,$20=0,$or_cond=0,$22=0,$24=0,$25=0;
 var $26=0,$27=0,$29=0,$30=0,$p_0=0,$32=0,$33=0,$34=0,$35=0,$37=0,$38=0,$39=.0,$40=0,$42=.0,$43=0,$44=0,$45=0,$46=0,$48=0,$49=0;
 var $51=0,$52=.0,$53=0,$54=0,$55=0,$56=0,$57=0,$58=0,$59=0,$60=0,$61=0,$62=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $y=((sp)|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $2=($1|0)<2;
 if ($2) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $4=((HEAP32[((12236)>>2)])|0);
 $5=((_getfloat($4,$y))|0);
 $6=($5|0)==0;
 if ($6) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $8=((HEAP32[((12232)>>2)])|0);
 $9=((_match($8,9520))|0);
 $10=($9|0)==0;
 if (!($10)) {
  $12=(+(HEAPF64[(($y)>>3)]));
  $13=$12>(0.0);
  if (!($13)) {
   $_0=202;

   STACKTOP=sp;return (($_0)|0);
  }
  HEAPF64[((11368)>>3)]=$12;
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $16=((HEAP32[((12232)>>2)])|0);
 $17=((_findnode($16))|0);
 $18=($17|0)==0;
 $19=((HEAP32[((14432)>>2)])|0);
 $20=($17|0)>($19|0);
 $or_cond=$18|$20;
 if ($or_cond) {
  $_0=208;

  STACKTOP=sp;return (($_0)|0);
 }
 $22=($1|0)>2;
 do {
  if ($22) {
   $24=((HEAP32[((12240)>>2)])|0);
   $25=((HEAP32[((13952)>>2)])|0);
   $26=((_findID($24,$25))|0);
   $27=($26|0)==0;
   if ($27) {
    $_0=205;

    STACKTOP=sp;return (($_0)|0);
   } else {
    $29=(($26)|0);
    $30=((HEAP32[(($29)>>2)])|0);
    $p_0=$30;
    break;
   }
  } else {
   $p_0=0;
  }
 } while(0);

 $32=((HEAP32[((14408)>>2)])|0);
 $33=(($32+((($17)*(72))&-1)+40)|0);
 $34=((HEAP32[(($33)>>2)])|0);
 $35=($34|0)==0;
 do {
  if (!($35)) {
   $37=((HEAP32[((17632)>>2)])|0);
   $38=(($37+($17<<3))|0);
   $39=(+(HEAPF64[(($38)>>3)]));
   $40=$39!=(-10000000000.0);
   if (!($40)) {
    break;
   }
   $42=(+(HEAPF64[(($y)>>3)]));
   $43=(($34)|0);
   HEAPF64[(($43)>>3)]=$42;
   $44=(($34+8)|0);
   HEAP32[(($44)>>2)]=$p_0;
   $45=((HEAP32[((17632)>>2)])|0);
   $46=(($45+($17<<3))|0);
   HEAPF64[(($46)>>3)]=-10000000000.0;
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);
 $48=((_malloc(16))|0);
 $49=($48|0)==0;
 if ($49) {
  $_0=101;

  STACKTOP=sp;return (($_0)|0);
 }
 $51=$48;
 $52=(+(HEAPF64[(($y)>>3)]));
 $53=$48;
 HEAPF64[(($53)>>3)]=$52;
 $54=(($48+8)|0);
 $55=$54;
 HEAP32[(($55)>>2)]=$p_0;
 $56=((HEAP32[((14408)>>2)])|0);
 $57=(($56+((($17)*(72))&-1)+40)|0);
 $58=((HEAP32[(($57)>>2)])|0);
 $59=(($48+12)|0);
 $60=$59;
 HEAP32[(($60)>>2)]=$58;
 $61=((HEAP32[((14408)>>2)])|0);
 $62=(($61+((($17)*(72))&-1)+40)|0);
 HEAP32[(($62)>>2)]=$51;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _controldata(){
 var $setting=0,$level=0,$1=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$13=0,$14=0,$15=0,$19=0,$20=0,$21=.0,$23=0,$24=0,$25=0;
 var $29=0,$30=0,$31=.0,$33=0,$35=0,$36=0,$37=0,$status_0=0,$_off=0,$switch=0,$_pr=.0,$39=0,$41=0,$42=.0,$43=0,$_=0,$status_1=0,$44=0,$45=0,$46=0;
 var $48=0,$49=0,$50=0,$52=0,$54=0,$55=0,$56=0,$58=0,$59=0,$60=0,$62=0,$63=0,$64=0,$i_0=0,$type_0=0,$66=0,$68=0,$69=.0,$71=0,$72=0;
 var $73=.0,$time_1=.0,$75=0,$77=0,$78=0,$79=0,$time_2=.0,$80=0,$81=0,$82=0,$83=0,$85=0,$86=0,$87=0,$88=0,$89=0,$90=0,$91=0,$92=0,$93=0;
 var $94=0,$95=0,$96=.0,$97=0,$98=0,$99=0,$100=.0,$101=0,$102=0,$103=0,$104=0,$105=0,$107=0,$108=0,$109=0,$110=0,$111=0,$113=.0,$114=0,$115=0;
 var $116=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $setting=((sp)|0);
 $level=(((sp)+(8))|0);
 HEAPF64[(($setting)>>3)]=-10000000000.0;
 HEAPF64[(($level)>>3)]=0.0;
 $1=((HEAP32[((14336)>>2)])|0);
 $2=($1|0)<6;
 if ($2) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $4=((HEAP32[((12236)>>2)])|0);
 $5=((_findlink($4))|0);
 $6=($5|0)==0;
 if ($6) {
  $_0=204;

  STACKTOP=sp;return (($_0)|0);
 }
 $8=((HEAP32[((14960)>>2)])|0);
 $9=(($8+((($5)*(104))&-1)+96)|0);
 $10=((HEAP8[($9)])|0);
 $11=(($10<<24)>>24)==0;
 if ($11) {
  $_0=207;

  STACKTOP=sp;return (($_0)|0);
 }
 $13=((HEAP32[((12240)>>2)])|0);
 $14=((_match($13,5064))|0);
 $15=($14|0)==0;
 do {
  if ($15) {
   $23=((HEAP32[((12240)>>2)])|0);
   $24=((_match($23,8984))|0);
   $25=($24|0)==0;
   if (!($25)) {
    if ((((($10<<24)>>24))|0)==((8)|0)) {
     $29=((HEAP32[((14960)>>2)])|0);
     $30=(($29+((($5)*(104))&-1)+56)|0);
     $31=(+(HEAPF64[(($30)>>3)]));
     HEAPF64[(($setting)>>3)]=$31;
     $status_1=2;
     break;
    } else if ((((($10<<24)>>24))|0)==((2)|0)) {
     HEAPF64[(($setting)>>3)]=0.0;
     $42=0.0;
     label = 17;
     break;
    } else {
     $status_0=2;
     label = 14;
     break;
    }
   }
   $33=(($10<<24)>>24)==8;
   if ($33) {
    $_0=206;

    STACKTOP=sp;return (($_0)|0);
   }
   $35=((HEAP32[((12240)>>2)])|0);
   $36=((_getfloat($35,$setting))|0);
   $37=($36|0)==0;
   if ($37) {
    $_0=202;
   } else {
    $status_0=4;
    label = 14;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  } else {
   if ((((($10<<24)>>24))|0)==((2)|0)) {
    HEAPF64[(($setting)>>3)]=1.0;
    $42=1.0;
    label = 17;
    break;
   } else if ((((($10<<24)>>24))|0)==((8)|0)) {
    $19=((HEAP32[((14960)>>2)])|0);
    $20=(($19+((($5)*(104))&-1)+56)|0);
    $21=(+(HEAPF64[(($20)>>3)]));
    HEAPF64[(($setting)>>3)]=$21;
    $status_1=3;
    break;
   } else {
    $status_0=3;
    label = 14;
    break;
   }
  }
 } while(0);
 do {
  if ((label|0) == 14) {

   $_off=((($10)-(1))&255);
   $switch=((($_off&255))>>>0)<((2)>>>0);
   if (!($switch)) {
    $status_1=$status_0;
    break;
   }
   $_pr=(+(HEAPF64[(($setting)>>3)]));
   $39=$_pr!=(-10000000000.0);
   if (!($39)) {
    $status_1=$status_0;
    break;
   }
   $41=$_pr<(0.0);
   if ($41) {
    $_0=202;
   } else {
    $42=$_pr;
    label = 17;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);
 if ((label|0) == 17) {

  $43=$42==(0.0);
  $_=($43?2:3);
  $status_1=$_;
 }

 $44=((HEAP32[((12248)>>2)])|0);
 $45=((_match($44,8936))|0);
 $46=($45|0)==0;
 do {
  if ($46) {
   $48=((HEAP32[((12248)>>2)])|0);
   $49=((_match($48,8520))|0);
   $50=($49|0)==0;
   if (!($50)) {
    $type_0=3;$i_0=0;
    break;
   }
   $52=($1|0)<8;
   if ($52) {
    $_0=201;

    STACKTOP=sp;return (($_0)|0);
   }
   $54=((HEAP32[((12252)>>2)])|0);
   $55=((_findnode($54))|0);
   $56=($55|0)==0;
   if ($56) {
    $_0=203;

    STACKTOP=sp;return (($_0)|0);
   }
   $58=((HEAP32[((12256)>>2)])|0);
   $59=((_match($58,8328))|0);
   $60=($59|0)==0;
   if (!($60)) {
    $type_0=0;$i_0=$55;
    break;
   }
   $62=((HEAP32[((12256)>>2)])|0);
   $63=((_match($62,7944))|0);
   $64=($63|0)==0;
   if ($64) {
    $_0=201;
   } else {
    $type_0=1;$i_0=$55;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  } else {
   $type_0=2;$i_0=0;
  }
 } while(0);


 $66=($type_0&255);
 do {
  if (((($66|0))|0)==((0)|0)|((($66|0))|0)==((1)|0)) {
   $77=((HEAP32[((12260)>>2)])|0);
   $78=((_getfloat($77,$level))|0);
   $79=($78|0)==0;
   if ($79) {
    $_0=202;
   } else {
    $time_2=0.0;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  } else if (((($66|0))|0)==((2)|0)|((($66|0))|0)==((3)|0)) {
   if (((($1|0))|0)==((6)|0)) {
    $68=((HEAP32[((12252)>>2)])|0);
    $69=(+(_hour($68,11496)));
    $time_1=$69;
   } else if (((($1|0))|0)==((7)|0)) {
    $71=((HEAP32[((12252)>>2)])|0);
    $72=((HEAP32[((12256)>>2)])|0);
    $73=(+(_hour($71,$72)));
    $time_1=$73;
   } else {
    $time_2=0.0;
    break;
   }

   $75=$time_1<(0.0);
   if ($75) {
    $_0=201;
   } else {
    $time_2=$time_1;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  } else {
   $time_2=0.0;
  }
 } while(0);

 $80=((HEAP32[((14464)>>2)])|0);
 $81=((($80)+(1))|0);
 HEAP32[((14464)>>2)]=$81;
 $82=((HEAP32[((14664)>>2)])|0);
 $83=($81|0)>($82|0);
 if ($83) {
  $_0=200;

  STACKTOP=sp;return (($_0)|0);
 }
 $85=((HEAP32[((17656)>>2)])|0);
 $86=(($85+((($81)*(40))&-1))|0);
 HEAP32[(($86)>>2)]=$5;
 $87=((HEAP32[((14464)>>2)])|0);
 $88=((HEAP32[((17656)>>2)])|0);
 $89=(($88+((($87)*(40))&-1)+4)|0);
 HEAP32[(($89)>>2)]=$i_0;
 $90=((HEAP32[((14464)>>2)])|0);
 $91=((HEAP32[((17656)>>2)])|0);
 $92=(($91+((($90)*(40))&-1)+33)|0);
 HEAP8[($92)]=$type_0;
 $93=((HEAP32[((14464)>>2)])|0);
 $94=((HEAP32[((17656)>>2)])|0);
 $95=(($94+((($93)*(40))&-1)+32)|0);
 HEAP8[($95)]=$status_1;
 $96=(+(HEAPF64[(($setting)>>3)]));
 $97=((HEAP32[((14464)>>2)])|0);
 $98=((HEAP32[((17656)>>2)])|0);
 $99=(($98+((($97)*(40))&-1)+24)|0);
 HEAPF64[(($99)>>3)]=$96;
 $100=($time_2)*((3600.0));
 $101=(~~($100));
 $102=((HEAP32[((14464)>>2)])|0);
 $103=((HEAP32[((17656)>>2)])|0);
 $104=(($103+((($102)*(40))&-1)+8)|0);
 HEAP32[(($104)>>2)]=$101;
 $105=(($type_0<<24)>>24)==3;
 if ($105) {
  $107=((HEAP32[((14464)>>2)])|0);
  $108=((HEAP32[((17656)>>2)])|0);
  $109=(($108+((($107)*(40))&-1)+8)|0);
  $110=((HEAP32[(($109)>>2)])|0);
  $111=(((($110|0))%(86400))&-1);
  HEAP32[(($109)>>2)]=$111;
 }
 $113=(+(HEAPF64[(($level)>>3)]));
 $114=((HEAP32[((14464)>>2)])|0);
 $115=((HEAP32[((17656)>>2)])|0);
 $116=(($115+((($114)*(40))&-1)+16)|0);
 HEAPF64[(($116)>>3)]=$113;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _sourcedata(){
 var $c0=0,$1=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$12=0,$13=0,$14=0,$16=0,$17=0,$18=0,$20=0,$21=0,$22=0,$_=0,$_11=0;
 var $type_0=0,$i_0=0,$24=0,$25=0,$26=0,$27=0,$29=0,$30=0,$32=0,$33=0,$strlenfirst=0,$34=0,$36=0,$37=0,$39=0,$40=0,$41=0,$43=0,$44=0,$p_0=0;
 var $46=0,$47=0,$49=0,$50=.0,$51=0,$52=0,$53=0,$54=0,$55=0,$56=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $c0=((sp)|0);
 HEAPF64[(($c0)>>3)]=0.0;
 $1=((HEAP32[((14336)>>2)])|0);
 $2=($1|0)<2;
 if ($2) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $4=((HEAP32[((12232)>>2)])|0);
 $5=((_findnode($4))|0);
 $6=($5|0)==0;
 if ($6) {
  $_0=203;

  STACKTOP=sp;return (($_0)|0);
 }
 $8=((HEAP32[((12236)>>2)])|0);
 $9=((_match($8,6472))|0);
 $10=($9|0)==0;
 do {
  if ($10) {
   $12=((HEAP32[((12236)>>2)])|0);
   $13=((_match($12,5816))|0);
   $14=($13|0)==0;
   if (!($14)) {
    $i_0=2;$type_0=1;
    break;
   }
   $16=((HEAP32[((12236)>>2)])|0);
   $17=((_match($16,5472))|0);
   $18=($17|0)==0;
   if (!($18)) {
    $i_0=2;$type_0=2;
    break;
   }
   $20=((HEAP32[((12236)>>2)])|0);
   $21=((_match($20,5344))|0);
   $22=($21|0)==0;
   $_=($22?0:3);
   $_11=($22?1:2);
   $i_0=$_11;$type_0=$_;
  } else {
   $i_0=2;$type_0=0;
  }
 } while(0);


 $24=((12232+($i_0<<2))|0);
 $25=((HEAP32[(($24)>>2)])|0);
 $26=((_getfloat($25,$c0))|0);
 $27=($26|0)==0;
 if ($27) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $29=((($i_0)+(1))|0);
 $30=($1|0)>($29|0);
 do {
  if ($30) {
   $32=((12232+($29<<2))|0);
   $33=((HEAP32[(($32)>>2)])|0);
   $strlenfirst=((HEAP8[($33)])|0);
   $34=(($strlenfirst<<24)>>24)==0;
   if ($34) {
    $p_0=0;
    break;
   }
   $36=((_strcmp((($33)|0),((5232)|0)))|0);
   $37=($36|0)==0;
   if ($37) {
    $p_0=0;
    break;
   }
   $39=((HEAP32[((13952)>>2)])|0);
   $40=((_findID($33,$39))|0);
   $41=($40|0)==0;
   if ($41) {
    $_0=205;

    STACKTOP=sp;return (($_0)|0);
   } else {
    $43=(($40)|0);
    $44=((HEAP32[(($43)>>2)])|0);
    $p_0=$44;
    break;
   }
  } else {
   $p_0=0;
  }
 } while(0);

 $46=((_malloc(32))|0);
 $47=($46|0)==0;
 if ($47) {
  $_0=101;

  STACKTOP=sp;return (($_0)|0);
 }
 $49=$46;
 $50=(+(HEAPF64[(($c0)>>3)]));
 $51=$46;
 HEAPF64[(($51)>>3)]=$50;
 $52=(($46+8)|0);
 $53=$52;
 HEAP32[(($53)>>2)]=$p_0;
 $54=(($46+24)|0);
 HEAP8[($54)]=$type_0;
 $55=((HEAP32[((14408)>>2)])|0);
 $56=(($55+((($5)*(72))&-1)+44)|0);
 HEAP32[(($56)>>2)]=$49;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _emitterdata(){
 var $k=0,$1=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$11=0,$12=0,$13=0,$15=.0,$16=0,$18=0,$19=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $k=((sp)|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $2=($1|0)<2;
 do {
  if ($2) {
   $_0=201;
  } else {
   $4=((HEAP32[((12232)>>2)])|0);
   $5=((_findnode($4))|0);
   $6=($5|0)==0;
   if ($6) {
    $_0=203;
    break;
   }
   $8=((HEAP32[((14432)>>2)])|0);
   $9=($5|0)>($8|0);
   if ($9) {
    $_0=209;
    break;
   }
   $11=((HEAP32[((12236)>>2)])|0);
   $12=((_getfloat($11,$k))|0);
   $13=($12|0)==0;
   if ($13) {
    $_0=202;
    break;
   }
   $15=(+(HEAPF64[(($k)>>3)]));
   $16=$15<(0.0);
   if ($16) {
    $_0=202;
    break;
   }
   $18=((HEAP32[((14408)>>2)])|0);
   $19=(($18+((($5)*(72))&-1)+56)|0);
   HEAPF64[(($19)>>3)]=$15;
   $_0=0;
  }
 } while(0);

 STACKTOP=sp;return (($_0)|0);
}


function _qualdata(){
 var $c0=0,$1=0,$2=0,$4=0,$5=0,$7=0,$9=0,$10=0,$11=0,$13=0,$14=0,$15=0,$17=.0,$18=0,$19=0,$21=0,$22=0,$23=0,$25=0,$26=0;
 var $27=0,$28=0,$29=0,$31=0,$32=0,$33=0,$34=0,$35=0,$j_012=0,$36=0,$37=0,$38=0,$39=0,$40=0,$or_cond=0,$42=.0,$43=0,$45=0,$46=0,$47=0;
 var $j_115=0,$48=0,$49=0,$50=0,$51=0,$52=0,$54=0,$55=0,$56=0,$58=.0,$59=0,$61=0,$62=0,$63=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $c0=((sp)|0);
 $1=((HEAP32[((14416)>>2)])|0);
 $2=($1|0)==0;
 if ($2) {
  $_0=208;

  STACKTOP=sp;return (($_0)|0);
 }
 $4=((HEAP32[((14336)>>2)])|0);
 $5=($4|0)<2;
 if ($5) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $7=($4|0)==2;
 if ($7) {
  $9=((HEAP32[((12232)>>2)])|0);
  $10=((_findnode($9))|0);
  $11=($10|0)==0;
  if ($11) {
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  }
  $13=((HEAP32[((12236)>>2)])|0);
  $14=((_getfloat($13,$c0))|0);
  $15=($14|0)==0;
  if ($15) {
   $_0=209;

   STACKTOP=sp;return (($_0)|0);
  }
  $17=(+(HEAPF64[(($c0)>>3)]));
  $18=((HEAP32[((14408)>>2)])|0);
  $19=(($18+((($10)*(72))&-1)+48)|0);
  HEAPF64[(($19)>>3)]=$17;
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $21=((HEAP32[((12240)>>2)])|0);
 $22=((_getfloat($21,$c0))|0);
 $23=($22|0)==0;
 if ($23) {
  $_0=209;

  STACKTOP=sp;return (($_0)|0);
 }
 $25=((HEAP32[((12232)>>2)])|0);
 $26=((_atoi((($25)|0)))|0);
 $27=($26|0)>0;
 do {
  if ($27) {
   $31=((HEAP32[((12236)>>2)])|0);
   $32=((_atoi((($31)|0)))|0);
   $33=($32|0)>0;
   if (!($33)) {
    break;
   }
   $34=((HEAP32[((14416)>>2)])|0);
   $35=($34|0)<1;
   if ($35) {
    $_0=0;

    STACKTOP=sp;return (($_0)|0);
   } else {
    $j_012=1;
   }
   while(1) {

    $36=((HEAP32[((14408)>>2)])|0);
    $37=(($36+((($j_012)*(72))&-1))|0);
    $38=((_atoi((($37)|0)))|0);
    $39=($38|0)<($26|0);
    $40=($38|0)>($32|0);
    $or_cond=$39|$40;
    if (!($or_cond)) {
     $42=(+(HEAPF64[(($c0)>>3)]));
     $43=(($36+((($j_012)*(72))&-1)+48)|0);
     HEAPF64[(($43)>>3)]=$42;
    }
    $45=((($j_012)+(1))|0);
    $46=((HEAP32[((14416)>>2)])|0);
    $47=($45|0)>($46|0);
    if ($47) {
     $_0=0;
     break;
    } else {
     $j_012=$45;
    }
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);
 $28=((HEAP32[((14416)>>2)])|0);
 $29=($28|0)<1;
 if ($29) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 } else {
  $j_115=1;
 }
 while(1) {

  $48=((HEAP32[((12232)>>2)])|0);
  $49=((HEAP32[((14408)>>2)])|0);
  $50=(($49+((($j_115)*(72))&-1))|0);
  $51=((_strcmp((($48)|0),(($50)|0)))|0);
  $52=($51|0)<1;
  do {
   if ($52) {
    $54=((HEAP32[((12236)>>2)])|0);
    $55=((_strcmp((($54)|0),(($50)|0)))|0);
    $56=($55|0)>-1;
    if (!($56)) {
     break;
    }
    $58=(+(HEAPF64[(($c0)>>3)]));
    $59=(($49+((($j_115)*(72))&-1)+48)|0);
    HEAPF64[(($59)>>3)]=$58;
   }
  } while(0);
  $61=((($j_115)+(1))|0);
  $62=((HEAP32[((14416)>>2)])|0);
  $63=($61|0)>($62|0);
  if ($63) {
   $_0=0;
   break;
  } else {
   $j_115=$61;
  }
 }

 STACKTOP=sp;return (($_0)|0);
}


function _reactdata(){
 var $y=0,$1=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$12=0,$14=0,$15=0,$16=0,$18=.0,$20=0,$21=0,$22=0,$24=.0,$26=0;
 var $27=0,$28=0,$30=.0,$31=0,$34=0,$37=0,$38=0,$39=0,$41=0,$42=0,$43=0,$44=0,$45=0,$47=.0,$49=0,$50=0,$51=0,$53=0,$54=0,$55=0;
 var $56=0,$57=0,$59=.0,$61=0,$62=0,$63=0,$65=0,$66=0,$67=0,$68=0,$69=0,$71=0,$72=0,$73=0,$75=.0,$77=0,$78=0,$79=0,$81=.0,$83=0;
 var $84=0,$85=0,$87=0,$88=0,$89=0,$91=0,$92=0,$93=0,$item_0=0,$95=0,$96=0,$97=0,$98=0,$99=0,$100=0,$101=0,$102=0,$103=0,$106=0,$107=0;
 var $109=0,$110=0,$111=0,$113=.0,$114=0,$115=0,$116=0,$118=0,$119=0,$121=0,$122=0,$123=0,$125=0,$j_036=0,$126=0,$127=0,$j_037=0,$128=0,$129=0,$130=0;
 var $131=0,$132=0,$or_cond=0,$j_0=0,$133=0,$134=0,$136=.0,$137=0,$138=0,$139=0,$140=0,$142=0,$j_140=0,$143=0,$144=0,$j_141=0,$145=0,$146=0,$147=0,$148=0;
 var $149=0,$j_1=0,$150=0,$151=0,$153=0,$154=0,$155=0,$157=.0,$158=0,$159=0,$160=0,$161=0,$164=0,$165=0,$167=0,$168=0,$170=0,$171=0,$173=0,$174=.0;
 var $175=0,$177=0,$179=0,$181=0,$182=0,$183=0,$184=0,$185=0,$187=0,$188=0,$189=0,$190=0,$191=0,$192=0,$j_244=0,$194=0,$195=0,$196=0,$197=0,$198=0;
 var $or_cond35=0,$200=.0,$202=0,$204=0,$206=0,$207=0,$208=0,$j_348=0,$210=0,$211=0,$212=0,$213=0,$214=0,$216=0,$217=0,$218=0,$220=.0,$222=0,$224=0,$226=0;
 var $227=0,$228=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $y=((sp)|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $2=($1|0)<3;
 if ($2) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $4=((HEAP32[((12232)>>2)])|0);
 $5=((_match($4,5000))|0);
 $6=($5|0)==0;
 if (!($6)) {
  $8=((($1)-(1))|0);
  $9=((12232+($8<<2))|0);
  $10=((HEAP32[(($9)>>2)])|0);
  $11=((_getfloat($10,$y))|0);
  $12=($11|0)==0;
  if ($12) {
   $_0=213;

   STACKTOP=sp;return (($_0)|0);
  }
  $14=((HEAP32[((12236)>>2)])|0);
  $15=((_match($14,4872))|0);
  $16=($15|0)==0;
  if (!($16)) {
   $18=(+(HEAPF64[(($y)>>3)]));
   HEAPF64[((11416)>>3)]=$18;
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  }
  $20=((HEAP32[((12236)>>2)])|0);
  $21=((_match($20,4680))|0);
  $22=($21|0)==0;
  if (!($22)) {
   $24=(+(HEAPF64[(($y)>>3)]));
   HEAPF64[((10600)>>3)]=$24;
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  }
  $26=((HEAP32[((12236)>>2)])|0);
  $27=((_match($26,4528))|0);
  $28=($27|0)==0;
  if ($28) {
   $_0=213;

   STACKTOP=sp;return (($_0)|0);
  }
  $30=(+(HEAPF64[(($y)>>3)]));
  $31=$30==(0.0);
  if ($31) {
   HEAPF64[((10472)>>3)]=0.0;
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  }
  $34=$30==(1.0);
  if (!($34)) {
   $_0=213;

   STACKTOP=sp;return (($_0)|0);
  }
  HEAPF64[((10472)>>3)]=1.0;
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $37=((HEAP32[((12232)>>2)])|0);
 $38=((_match($37,4408))|0);
 $39=($38|0)==0;
 if (!($39)) {
  $41=((($1)-(1))|0);
  $42=((12232+($41<<2))|0);
  $43=((HEAP32[(($42)>>2)])|0);
  $44=((_getfloat($43,$y))|0);
  $45=($44|0)==0;
  if ($45) {
   $_0=213;

   STACKTOP=sp;return (($_0)|0);
  }
  $47=(+(HEAPF64[(($y)>>3)]));
  HEAPF64[((10968)>>3)]=$47;
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $49=((HEAP32[((12232)>>2)])|0);
 $50=((_match($49,4272))|0);
 $51=($50|0)==0;
 if (!($51)) {
  $53=((($1)-(1))|0);
  $54=((12232+($53<<2))|0);
  $55=((HEAP32[(($54)>>2)])|0);
  $56=((_getfloat($55,$y))|0);
  $57=($56|0)==0;
  if ($57) {
   $_0=213;

   STACKTOP=sp;return (($_0)|0);
  }
  $59=(+(HEAPF64[(($y)>>3)]));
  HEAPF64[((11408)>>3)]=$59;
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $61=((HEAP32[((12232)>>2)])|0);
 $62=((_match($61,4144))|0);
 $63=($62|0)==0;
 if (!($63)) {
  $65=((($1)-(1))|0);
  $66=((12232+($65<<2))|0);
  $67=((HEAP32[(($66)>>2)])|0);
  $68=((_getfloat($67,$y))|0);
  $69=($68|0)==0;
  if ($69) {
   $_0=213;

   STACKTOP=sp;return (($_0)|0);
  }
  $71=((HEAP32[((12236)>>2)])|0);
  $72=((_match($71,4872))|0);
  $73=($72|0)==0;
  if (!($73)) {
   $75=(+(HEAPF64[(($y)>>3)]));
   HEAPF64[((11216)>>3)]=$75;
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  }
  $77=((HEAP32[((12236)>>2)])|0);
  $78=((_match($77,4528))|0);
  $79=($78|0)==0;
  if ($79) {
   $_0=201;

   STACKTOP=sp;return (($_0)|0);
  }
  $81=(+(HEAPF64[(($y)>>3)]));
  HEAPF64[((11208)>>3)]=$81;
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $83=((HEAP32[((12232)>>2)])|0);
 $84=((_match($83,4872))|0);
 $85=($84|0)==0;
 do {
  if ($85) {
   $87=((HEAP32[((12232)>>2)])|0);
   $88=((_match($87,4528))|0);
   $89=($88|0)==0;
   if (!($89)) {
    $item_0=2;
    break;
   }
   $91=((HEAP32[((12232)>>2)])|0);
   $92=((_match($91,4680))|0);
   $93=($92|0)==0;
   if ($93) {
    $_0=201;
   } else {
    $item_0=3;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  } else {
   $item_0=1;
  }
 } while(0);

 $95=((HEAP32[((12232)>>2)])|0);
 $96=((HEAP32[((12236)>>2)])|0);
 $97=((_strcpy((($95)|0),(($96)|0)))|0);
 $98=($item_0|0)==3;
 $99=((($1)-(1))|0);
 $100=((12232+($99<<2))|0);
 $101=((HEAP32[(($100)>>2)])|0);
 $102=((_getfloat($101,$y))|0);
 $103=($102|0)!=0;
 if ($98) {
  if (!($103)) {
   $_0=209;

   STACKTOP=sp;return (($_0)|0);
  }
  $106=($1|0)==3;
  $107=((HEAP32[((12236)>>2)])|0);
  if ($106) {
   $109=((_findnode($107))|0);
   $110=((HEAP32[((14432)>>2)])|0);
   $111=($109|0)>($110|0);
   if (!($111)) {
    $_0=0;

    STACKTOP=sp;return (($_0)|0);
   }
   $113=(+(HEAPF64[(($y)>>3)]));
   $114=((($109)-($110))|0);
   $115=((HEAP32[((13176)>>2)])|0);
   $116=(($115+((($114)*(112))&-1)+64)|0);
   HEAPF64[(($116)>>3)]=$113;
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  }
  $118=((_atoi((($107)|0)))|0);
  $119=($118|0)>0;
  do {
   if ($119) {
    $121=((HEAP32[((12240)>>2)])|0);
    $122=((_atoi((($121)|0)))|0);
    $123=($122|0)>0;
    if (!($123)) {
     break;
    }
    $125=((HEAP32[((14432)>>2)])|0);
    $j_036=((($125)+(1))|0);
    $126=((HEAP32[((14416)>>2)])|0);
    $127=($j_036|0)>($126|0);
    if ($127) {
     $_0=0;

     STACKTOP=sp;return (($_0)|0);
    } else {
     $j_037=$j_036;
    }
    while(1) {

     $128=((HEAP32[((14408)>>2)])|0);
     $129=(($128+((($j_037)*(72))&-1))|0);
     $130=((_atoi((($129)|0)))|0);
     $131=($130|0)<($118|0);
     $132=($130|0)>($122|0);
     $or_cond=$131|$132;
     if (!($or_cond)) {
      $136=(+(HEAPF64[(($y)>>3)]));
      $137=((HEAP32[((14432)>>2)])|0);
      $138=((($j_037)-($137))|0);
      $139=((HEAP32[((13176)>>2)])|0);
      $140=(($139+((($138)*(112))&-1)+64)|0);
      HEAPF64[(($140)>>3)]=$136;
     }
     $j_0=((($j_037)+(1))|0);
     $133=((HEAP32[((14416)>>2)])|0);
     $134=($j_0|0)>($133|0);
     if ($134) {
      $_0=0;
      break;
     } else {
      $j_037=$j_0;
     }
    }

    STACKTOP=sp;return (($_0)|0);
   }
  } while(0);
  $142=((HEAP32[((14432)>>2)])|0);
  $j_140=((($142)+(1))|0);
  $143=((HEAP32[((14416)>>2)])|0);
  $144=($j_140|0)>($143|0);
  if ($144) {
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  } else {
   $j_141=$j_140;
  }
  while(1) {

   $145=((HEAP32[((12236)>>2)])|0);
   $146=((HEAP32[((14408)>>2)])|0);
   $147=(($146+((($j_141)*(72))&-1))|0);
   $148=((_strcmp((($145)|0),(($147)|0)))|0);
   $149=($148|0)<1;
   do {
    if ($149) {
     $153=((HEAP32[((12240)>>2)])|0);
     $154=((_strcmp((($153)|0),(($147)|0)))|0);
     $155=($154|0)>-1;
     if (!($155)) {
      break;
     }
     $157=(+(HEAPF64[(($y)>>3)]));
     $158=((HEAP32[((14432)>>2)])|0);
     $159=((($j_141)-($158))|0);
     $160=((HEAP32[((13176)>>2)])|0);
     $161=(($160+((($159)*(112))&-1)+64)|0);
     HEAPF64[(($161)>>3)]=$157;
    }
   } while(0);
   $j_1=((($j_141)+(1))|0);
   $150=((HEAP32[((14416)>>2)])|0);
   $151=($j_1|0)>($150|0);
   if ($151) {
    $_0=0;
    break;
   } else {
    $j_141=$j_1;
   }
  }

  STACKTOP=sp;return (($_0)|0);
 }
 if (!($103)) {
  $_0=211;

  STACKTOP=sp;return (($_0)|0);
 }
 $164=((HEAP32[((14424)>>2)])|0);
 $165=($164|0)==0;
 if ($165) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $167=($1|0)==3;
 $168=((HEAP32[((12236)>>2)])|0);
 if ($167) {
  $170=((_findlink($168))|0);
  $171=($170|0)==0;
  if ($171) {
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  }
  $173=($item_0|0)==1;
  $174=(+(HEAPF64[(($y)>>3)]));
  $175=((HEAP32[((14960)>>2)])|0);
  if ($173) {
   $177=(($175+((($170)*(104))&-1)+72)|0);
   HEAPF64[(($177)>>3)]=$174;
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  } else {
   $179=(($175+((($170)*(104))&-1)+80)|0);
   HEAPF64[(($179)>>3)]=$174;
   $_0=0;

   STACKTOP=sp;return (($_0)|0);
  }
 }
 $181=((_atoi((($168)|0)))|0);
 $182=($181|0)>0;
 do {
  if ($182) {
   $187=((HEAP32[((12240)>>2)])|0);
   $188=((_atoi((($187)|0)))|0);
   $189=($188|0)>0;
   if (!($189)) {
    break;
   }
   $190=((HEAP32[((14424)>>2)])|0);
   $191=($190|0)<1;
   if ($191) {
    $_0=0;

    STACKTOP=sp;return (($_0)|0);
   }
   $192=($item_0|0)==1;
   $j_244=1;
   while(1) {

    $194=((HEAP32[((14960)>>2)])|0);
    $195=(($194+((($j_244)*(104))&-1))|0);
    $196=((_atoi((($195)|0)))|0);
    $197=($196|0)<($181|0);
    $198=($196|0)>($188|0);
    $or_cond35=$197|$198;
    do {
     if (!($or_cond35)) {
      $200=(+(HEAPF64[(($y)>>3)]));
      if ($192) {
       $202=(($194+((($j_244)*(104))&-1)+72)|0);
       HEAPF64[(($202)>>3)]=$200;
       break;
      } else {
       $204=(($194+((($j_244)*(104))&-1)+80)|0);
       HEAPF64[(($204)>>3)]=$200;
       break;
      }
     }
    } while(0);
    $206=((($j_244)+(1))|0);
    $207=((HEAP32[((14424)>>2)])|0);
    $208=($206|0)>($207|0);
    if ($208) {
     $_0=0;
     break;
    } else {
     $j_244=$206;
    }
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);
 $183=((HEAP32[((14424)>>2)])|0);
 $184=($183|0)<1;
 if ($184) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $185=($item_0|0)==1;
 $j_348=1;
 while(1) {

  $210=((HEAP32[((12236)>>2)])|0);
  $211=((HEAP32[((14960)>>2)])|0);
  $212=(($211+((($j_348)*(104))&-1))|0);
  $213=((_strcmp((($210)|0),(($212)|0)))|0);
  $214=($213|0)<1;
  do {
   if ($214) {
    $216=((HEAP32[((12240)>>2)])|0);
    $217=((_strcmp((($216)|0),(($212)|0)))|0);
    $218=($217|0)>-1;
    if (!($218)) {
     break;
    }
    $220=(+(HEAPF64[(($y)>>3)]));
    if ($185) {
     $222=(($211+((($j_348)*(104))&-1)+72)|0);
     HEAPF64[(($222)>>3)]=$220;
     break;
    } else {
     $224=(($211+((($j_348)*(104))&-1)+80)|0);
     HEAPF64[(($224)>>3)]=$220;
     break;
    }
   }
  } while(0);
  $226=((($j_348)+(1))|0);
  $227=((HEAP32[((14424)>>2)])|0);
  $228=($226|0)>($227|0);
  if ($228) {
   $_0=0;
   break;
  } else {
   $j_348=$226;
  }
 }

 STACKTOP=sp;return (($_0)|0);
}


function _mixingdata(){
 var $v=0,$1=0,$2=0,$4=0,$5=0,$7=0,$8=0,$9=0,$10=0,$12=0,$13=0,$14=0,$16=0,$17=0,$or_cond=0,$19=0,$20=0,$21=0,$_pr=.0,$23=0;
 var $25=0,$26=0,$27=0,$28=0,$29=.0,$30=0,$32=0,$33=0,$34=.0,$35=0,$36=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $v=((sp)|0);
 $1=((HEAP32[((14416)>>2)])|0);
 $2=($1|0)==0;
 L1: do {
  if ($2) {
   $_0=208;
  } else {
   $4=((HEAP32[((14336)>>2)])|0);
   $5=($4|0)<2;
   if ($5) {
    $_0=0;
    break;
   }
   $7=((HEAP32[((12232)>>2)])|0);
   $8=((_findnode($7))|0);
   $9=((HEAP32[((14432)>>2)])|0);
   $10=($8|0)>($9|0);
   if (!($10)) {
    $_0=0;
    break;
   }
   $12=((HEAP32[((12236)>>2)])|0);
   $13=((_findmatch($12,11112))|0);
   $14=($13|0)<0;
   if ($14) {
    $_0=201;
    break;
   }
   HEAPF64[(($v)>>3)]=1.0;
   $16=($13|0)==1;
   $17=($4|0)==3;
   $or_cond=$16&$17;
   do {
    if ($or_cond) {
     $19=((HEAP32[((12240)>>2)])|0);
     $20=((_getfloat($19,$v))|0);
     $21=($20|0)==0;
     if ($21) {
      $_0=209;
      break L1;
     }
     $_pr=(+(HEAPF64[(($v)>>3)]));
     $23=$_pr==(0.0);
     if (!($23)) {
      break;
     }
     HEAPF64[(($v)>>3)]=1.0;
    }
   } while(0);
   $25=((HEAP32[((14432)>>2)])|0);
   $26=((($8)-($25))|0);
   $27=((HEAP32[((13176)>>2)])|0);
   $28=(($27+((($26)*(112))&-1)+8)|0);
   $29=(+(HEAPF64[(($28)>>3)]));
   $30=$29==(0.0);
   if ($30) {
    $_0=0;
    break;
   }
   $32=(($13)&255);
   $33=(($27+((($26)*(112))&-1)+96)|0);
   HEAP8[($33)]=$32;
   $34=(+(HEAPF64[(($v)>>3)]));
   $35=((HEAP32[((13176)>>2)])|0);
   $36=(($35+((($26)*(112))&-1)+104)|0);
   HEAPF64[(($36)>>3)]=$34;
   $_0=0;
  }
 } while(0);

 STACKTOP=sp;return (($_0)|0);
}


function _statusdata(){
 var $y=0,$1=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$13=0,$14=0,$15=0,$17=0,$18=0,$19=0,$status_0=0,$21=.0,$22=0,$24=0;
 var $25=0,$27=0,$28=0,$30=0,$31=0,$32=0,$34=0,$36=.0,$38=0,$39=0,$40=0,$41=0,$43=0,$44=0,$45=0,$46=0,$47=0,$j_020=0,$48=0,$49=0;
 var $50=0,$51=0,$52=0,$or_cond=0,$54=.0,$56=0,$57=0,$58=0,$j_123=0,$59=0,$60=0,$61=0,$62=0,$63=0,$65=0,$66=0,$67=0,$69=.0,$71=0,$72=0;
 var $73=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $y=((sp)|0);
 HEAPF64[(($y)>>3)]=0.0;
 $1=((HEAP32[((14424)>>2)])|0);
 $2=($1|0)==0;
 L1: do {
  if ($2) {
   $_0=210;
  } else {
   $4=((HEAP32[((14336)>>2)])|0);
   $5=((($4)-(1))|0);
   $6=($5|0)<1;
   if ($6) {
    $_0=201;
    break;
   }
   $8=((12232+($5<<2))|0);
   $9=((HEAP32[(($8)>>2)])|0);
   $10=((_match($9,5064))|0);
   $11=($10|0)==0;
   do {
    if ($11) {
     $13=((HEAP32[(($8)>>2)])|0);
     $14=((_match($13,8984))|0);
     $15=($14|0)==0;
     if (!($15)) {
      $status_0=2;
      break;
     }
     $17=((HEAP32[(($8)>>2)])|0);
     $18=((_getfloat($17,$y))|0);
     $19=($18|0)==0;
     if ($19) {
      $_0=211;
      break L1;
     } else {
      $status_0=4;
     }
    } else {
     $status_0=3;
    }
   } while(0);

   $21=(+(HEAPF64[(($y)>>3)]));
   $22=$21<(0.0);
   if ($22) {
    $_0=211;
    break;
   }
   $24=($5|0)==1;
   $25=((HEAP32[((12232)>>2)])|0);
   if ($24) {
    $27=((_findlink($25))|0);
    $28=($27|0)==0;
    if ($28) {
     $_0=0;
     break;
    }
    $30=((HEAP32[((14960)>>2)])|0);
    $31=(($30+((($27)*(104))&-1)+96)|0);
    $32=((HEAP8[($31)])|0);
    if ((((($32<<24)>>24))|0)==((8)|0)) {
     $34=(($status_0<<24)>>24)==4;
     if ($34) {
      $_0=211;
      break;
     }
    } else if ((((($32<<24)>>24))|0)==((0)|0)) {
     $_0=211;
     break;
    }
    $36=(+(HEAPF64[(($y)>>3)]));
    _changestatus($27,$status_0,$36);
    $_0=0;
    break;
   }
   $38=((_atoi((($25)|0)))|0);
   $39=($38|0)>0;
   do {
    if ($39) {
     $43=((HEAP32[((12236)>>2)])|0);
     $44=((_atoi((($43)|0)))|0);
     $45=($44|0)>0;
     if (!($45)) {
      break;
     }
     $46=((HEAP32[((14424)>>2)])|0);
     $47=($46|0)<1;
     if ($47) {
      $_0=0;
      break L1;
     } else {
      $j_020=1;
     }
     while(1) {

      $48=((HEAP32[((14960)>>2)])|0);
      $49=(($48+((($j_020)*(104))&-1))|0);
      $50=((_atoi((($49)|0)))|0);
      $51=($50|0)<($38|0);
      $52=($50|0)>($44|0);
      $or_cond=$51|$52;
      if (!($or_cond)) {
       $54=(+(HEAPF64[(($y)>>3)]));
       _changestatus($j_020,$status_0,$54);
      }
      $56=((($j_020)+(1))|0);
      $57=((HEAP32[((14424)>>2)])|0);
      $58=($56|0)>($57|0);
      if ($58) {
       $_0=0;
       break L1;
      } else {
       $j_020=$56;
      }
     }
    }
   } while(0);
   $40=((HEAP32[((14424)>>2)])|0);
   $41=($40|0)<1;
   if ($41) {
    $_0=0;
    break;
   } else {
    $j_123=1;
   }
   while(1) {

    $59=((HEAP32[((12232)>>2)])|0);
    $60=((HEAP32[((14960)>>2)])|0);
    $61=(($60+((($j_123)*(104))&-1))|0);
    $62=((_strcmp((($59)|0),(($61)|0)))|0);
    $63=($62|0)<1;
    do {
     if ($63) {
      $65=((HEAP32[((12236)>>2)])|0);
      $66=((_strcmp((($65)|0),(($61)|0)))|0);
      $67=($66|0)>-1;
      if (!($67)) {
       break;
      }
      $69=(+(HEAPF64[(($y)>>3)]));
      _changestatus($j_123,$status_0,$69);
     }
    } while(0);
    $71=((($j_123)+(1))|0);
    $72=((HEAP32[((14424)>>2)])|0);
    $73=($71|0)>($72|0);
    if ($73) {
     $_0=0;
     break;
    } else {
     $j_123=$71;
    }
   }
  }
 } while(0);

 STACKTOP=sp;return (($_0)|0);
}


function _changestatus($j,$status,$y){
 $j=($j)|0;
 $status=($status)|0;
 $y=+($y);
 var $1=0,$2=0,$3=0,$5=0,$7=0,$8=0,$11=0,$12=0,$15=0,$_0=0,$17=0,$18=0,$20=0,$22=0,$23=0,$24=0,$25=0,$27=0,$28=0,label=0;

 $1=((HEAP32[((14960)>>2)])|0);
 $2=(($1+((($j)*(104))&-1)+96)|0);
 $3=((HEAP8[($2)])|0);
 if ((((($3<<24)>>24))|0)==((2)|0)) {
  do {
   if ((((($status<<24)>>24))|0)==((4)|0)) {
    $11=(($1+((($j)*(104))&-1)+56)|0);
    HEAPF64[(($11)>>3)]=$y;
    $12=$y==(0.0);
    if (!($12)) {
     $_0=3;
     break;
    }
    $_0=2;
   } else if ((((($status<<24)>>24))|0)==((3)|0)) {
    $15=(($1+((($j)*(104))&-1)+56)|0);
    HEAPF64[(($15)>>3)]=1.0;
    $_0=3;
   } else {
    $_0=$status;
   }
  } while(0);

  $17=((HEAP32[((14960)>>2)])|0);
  $18=(($17+((($j)*(104))&-1)+97)|0);
  HEAP8[($18)]=$_0;
  return;
 } else if ((((($3<<24)>>24))|0)==((1)|0)|(((($3<<24)>>24))|0)==((8)|0)) {
  $5=(($status<<24)>>24)==4;
  if ($5) {
   return;
  }
  $7=((HEAP32[((14960)>>2)])|0);
  $8=(($7+((($j)*(104))&-1)+97)|0);
  HEAP8[($8)]=$status;
  return;
 } else {
  $20=(($3<<24)>>24)>2;
  if (!($20)) {
   return;
  }
  $22=(($1+((($j)*(104))&-1)+56)|0);
  HEAPF64[(($22)>>3)]=$y;
  $23=((HEAP32[((14960)>>2)])|0);
  $24=(($23+((($j)*(104))&-1)+97)|0);
  HEAP8[($24)]=$status;
  $25=(($status<<24)>>24)==4;
  if ($25) {
   return;
  }
  $27=((HEAP32[((14960)>>2)])|0);
  $28=(($27+((($j)*(104))&-1)+56)|0);
  HEAPF64[(($28)>>3)]=-10000000000.0;
  return;
 }
}


function _energydata(){
 var $y=0,$1=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$12=.0,$14=0,$15=0,$16=0,$18=0,$19=0,$20=0,$21=0,$or_cond=0,$23=0,$24=0;
 var $25=0,$27=0,$28=0,$29=0,$30=0,$32=0,$33=.0,$34=0,$36=.0,$38=.0,$_sink=.0,$40=0,$j_0=0,$42=0,$43=0,$44=0,$45=0,$46=0,$48=0,$49=0;
 var $50=0,$51=0,$52=0,$53=0,$_=0,$56=.0,$59=0,$60=0,$62=0,$63=0,$64=0,$66=0,$67=0,$68=0,$69=0,$70=0,$71=0,$72=0,$_17=0,$75=0;
 var $76=0,$79=0,$80=0,$82=0,$83=0,$84=0,$86=0,$87=0,$88=0,$89=0,$91=0,$92=0,$94=.0,$95=0,$98=0,$99=0,$100=0,$102=0,$103=0,$104=0;
 var $105=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $y=((sp)|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $2=($1|0)<3;
 do {
  if ($2) {
   $_0=201;
  } else {
   $4=((HEAP32[((12232)>>2)])|0);
   $5=((_match($4,4016))|0);
   $6=($5|0)==0;
   if (!($6)) {
    $8=((HEAP32[((12240)>>2)])|0);
    $9=((_getfloat($8,$y))|0);
    $10=($9|0)==0;
    if ($10) {
     $_0=213;
     break;
    }
    $12=(+(HEAPF64[(($y)>>3)]));
    HEAPF64[((11384)>>3)]=$12;
    $_0=0;
    break;
   }
   $14=((HEAP32[((12232)>>2)])|0);
   $15=((_match($14,4144))|0);
   $16=($15|0)==0;
   if ($16) {
    $18=((HEAP32[((12232)>>2)])|0);
    $19=((_match($18,3872))|0);
    $20=($19|0)==0;
    $21=($1|0)<4;
    $or_cond=$20|$21;
    if ($or_cond) {
     $_0=201;
     break;
    }
    $23=((HEAP32[((12236)>>2)])|0);
    $24=((_findlink($23))|0);
    $25=($24|0)==0;
    if ($25) {
     $_0=216;
     break;
    }
    $27=((HEAP32[((14960)>>2)])|0);
    $28=(($27+((($24)*(104))&-1)+96)|0);
    $29=((HEAP8[($28)])|0);
    $30=(($29<<24)>>24)==2;
    if (!($30)) {
     $_0=216;
     break;
    }
    $32=(($27+((($24)*(104))&-1)+40)|0);
    $33=(+(HEAPF64[(($32)>>3)]));
    $34=$33<(0.0);
    if ($34) {
     $38=($33)+((-0.5));
     $_sink=$38;
    } else {
     $36=($33)+((0.5));
     $_sink=$36;
    }

    $40=(~~($_sink));
    $j_0=$40;
   } else {
    $j_0=0;
   }

   $42=((($1)-(2))|0);
   $43=((12232+($42<<2))|0);
   $44=((HEAP32[(($43)>>2)])|0);
   $45=((_match($44,3768))|0);
   $46=($45|0)==0;
   if (!($46)) {
    $48=((($1)-(1))|0);
    $49=((12232+($48<<2))|0);
    $50=((HEAP32[(($49)>>2)])|0);
    $51=((_getfloat($50,$y))|0);
    $52=($51|0)==0;
    $53=($j_0|0)==0;
    if ($52) {
     $_=($53?213:217);
     $_0=$_;
     break;
    }
    $56=(+(HEAPF64[(($y)>>3)]));
    if ($53) {
     HEAPF64[((11352)>>3)]=$56;
     $_0=0;
     break;
    } else {
     $59=((HEAP32[((13888)>>2)])|0);
     $60=(($59+($j_0<<7)+72)|0);
     HEAPF64[(($60)>>3)]=$56;
     $_0=0;
     break;
    }
   }
   $62=((HEAP32[(($43)>>2)])|0);
   $63=((_match($62,2296))|0);
   $64=($63|0)==0;
   if (!($64)) {
    $66=((($1)-(1))|0);
    $67=((12232+($66<<2))|0);
    $68=((HEAP32[(($67)>>2)])|0);
    $69=((HEAP32[((13952)>>2)])|0);
    $70=((_findID($68,$69))|0);
    $71=($70|0)==0;
    $72=($j_0|0)==0;
    if ($71) {
     $_17=($72?213:217);
     $_0=$_17;
     break;
    }
    $75=(($70)|0);
    $76=((HEAP32[(($75)>>2)])|0);
    if ($72) {
     HEAP32[((17520)>>2)]=$76;
     $_0=0;
     break;
    } else {
     $79=((HEAP32[((13888)>>2)])|0);
     $80=(($79+($j_0<<7)+68)|0);
     HEAP32[(($80)>>2)]=$76;
     $_0=0;
     break;
    }
   }
   $82=((HEAP32[(($43)>>2)])|0);
   $83=((_match($82,3656))|0);
   $84=($83|0)==0;
   if ($84) {
    $_0=201;
    break;
   }
   $86=($j_0|0)==0;
   $87=((($1)-(1))|0);
   $88=((12232+($87<<2))|0);
   $89=((HEAP32[(($88)>>2)])|0);
   if (!($86)) {
    $98=((HEAP32[((17640)>>2)])|0);
    $99=((_findID($89,$98))|0);
    $100=($99|0)==0;
    if ($100) {
     $_0=217;
     break;
    }
    $102=(($99)|0);
    $103=((HEAP32[(($102)>>2)])|0);
    $104=((HEAP32[((13888)>>2)])|0);
    $105=(($104+($j_0<<7)+60)|0);
    HEAP32[(($105)>>2)]=$103;
    $_0=0;
    break;
   }
   $91=((_getfloat($89,$y))|0);
   $92=($91|0)==0;
   if ($92) {
    $_0=213;
    break;
   }
   $94=(+(HEAPF64[(($y)>>3)]));
   $95=$94>(0.0);
   if (!($95)) {
    $_0=213;
    break;
   }
   HEAPF64[((11336)>>3)]=$94;
   $_0=0;
  }
 } while(0);

 STACKTOP=sp;return (($_0)|0);
}


function _reportdata(){
 var $y=0,$1=0,$2=0,$3=0,$5=0,$6=0,$7=0,$9=0,$10=0,$11=0,$12=0,$14=.0,$15=0,$16=0,$or_cond=0,$18=0,$20=0,$21=0,$22=0,$24=0;
 var $25=0,$26=0,$27=0,$30=0,$31=0,$32=0,$35=0,$36=0,$37=0,$40=0,$41=0,$42=0,$44=0,$45=0,$46=0,$47=0,$50=0,$51=0,$52=0,$55=0;
 var $56=0,$57=0,$59=0,$60=0,$61=0,$62=0,$65=0,$66=0,$67=0,$70=0,$71=0,$72=0,$74=0,$75=0,$76=0,$77=0,$80=0,$81=0,$82=0,$85=0;
 var $86=0,$87=0,$89=0,$90=0,$91=0,$92=0,$95=0,$96=0,$97=0,$100=0,$101=0,$102=0,$i_039=0,$103=0,$104=0,$105=0,$106=0,$108=0,$109=0,$110=0;
 var $111=0,$113=0,$114=0,$115=0,$117=0,$118=0,$119=0,$120=0,$123=0,$124=0,$125=0,$128=0,$129=0,$130=0,$i_136=0,$131=0,$132=0,$133=0,$134=0,$136=0;
 var $137=0,$138=0,$139=0,$141=0,$142=0,$143=0,$145=0,$146=0,$147=0,$149=0,$i_23335=0,$150=0,$151=0,$153=0,$154=0,$155=0,$157=0,$159=0,$160=0,$161=0;
 var $163=0,$165=0,$166=0,$168=0,$169=0,$170=0,$172=0,$173=0,$174=0,$176=0,$177=0,$178=0,$j_0=0,$180=0,$181=0,$182=0,$184=0,$186=0,$187=.0,$188=0;
 var $190=.0,$192=.0,$_sink=.0,$194=0,$195=0,$197=.0,$198=0,$200=0,$201=0,$202=0,$204=0,$205=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $y=((sp)|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $2=((($1)-(1))|0);
 $3=($2|0)<1;
 L1: do {
  if ($3) {
   $_0=201;
  } else {
   $5=((HEAP32[((12232)>>2)])|0);
   $6=((_match($5,3608))|0);
   $7=($6|0)==0;
   if (!($7)) {
    $9=((12232+($2<<2))|0);
    $10=((HEAP32[(($9)>>2)])|0);
    $11=((_getfloat($10,$y))|0);
    $12=($11|0)==0;
    if ($12) {
     $_0=213;
     break;
    }
    $14=(+(HEAPF64[(($y)>>3)]));
    $15=$14<(0.0);
    $16=$14>(255.0);
    $or_cond=$15|$16;
    if ($or_cond) {
     $_0=213;
     break;
    }
    $18=(~~($14));
    HEAP32[((13960)>>2)]=$18;
    $_0=0;
    break;
   }
   $20=((HEAP32[((12232)>>2)])|0);
   $21=((_match($20,3560))|0);
   $22=($21|0)==0;
   if (!($22)) {
    $24=((12232+($2<<2))|0);
    $25=((HEAP32[(($24)>>2)])|0);
    $26=((_match($25,3512))|0);
    $27=($26|0)==0;
    if (!($27)) {
     HEAP8[(13192)]=0;
    }
    $30=((HEAP32[(($24)>>2)])|0);
    $31=((_match($30,3472))|0);
    $32=($31|0)==0;
    if (!($32)) {
     HEAP8[(13192)]=1;
    }
    $35=((HEAP32[(($24)>>2)])|0);
    $36=((_match($35,3432))|0);
    $37=($36|0)==0;
    if ($37) {
     $_0=0;
     break;
    }
    HEAP8[(13192)]=2;
    $_0=0;
    break;
   }
   $40=((HEAP32[((12232)>>2)])|0);
   $41=((_match($40,3376))|0);
   $42=($41|0)==0;
   if (!($42)) {
    $44=((12232+($2<<2))|0);
    $45=((HEAP32[(($44)>>2)])|0);
    $46=((_match($45,3512))|0);
    $47=($46|0)==0;
    if (!($47)) {
     HEAP8[(13184)]=0;
    }
    $50=((HEAP32[(($44)>>2)])|0);
    $51=((_match($50,3472))|0);
    $52=($51|0)==0;
    if ($52) {
     $_0=0;
     break;
    }
    HEAP8[(13184)]=1;
    $_0=0;
    break;
   }
   $55=((HEAP32[((12232)>>2)])|0);
   $56=((_match($55,3304))|0);
   $57=($56|0)==0;
   if (!($57)) {
    $59=((12232+($2<<2))|0);
    $60=((HEAP32[(($59)>>2)])|0);
    $61=((_match($60,3512))|0);
    $62=($61|0)==0;
    if (!($62)) {
     HEAP8[(14568)]=0;
    }
    $65=((HEAP32[(($59)>>2)])|0);
    $66=((_match($65,3472))|0);
    $67=($66|0)==0;
    if ($67) {
     $_0=0;
     break;
    }
    HEAP8[(14568)]=1;
    $_0=0;
    break;
   }
   $70=((HEAP32[((12232)>>2)])|0);
   $71=((_match($70,3256))|0);
   $72=($71|0)==0;
   if (!($72)) {
    $74=((12232+($2<<2))|0);
    $75=((HEAP32[(($74)>>2)])|0);
    $76=((_match($75,3512))|0);
    $77=($76|0)==0;
    if (!($77)) {
     HEAP8[(17528)]=0;
    }
    $80=((HEAP32[(($74)>>2)])|0);
    $81=((_match($80,3472))|0);
    $82=($81|0)==0;
    if ($82) {
     $_0=0;
     break;
    }
    HEAP8[(17528)]=1;
    $_0=0;
    break;
   }
   $85=((HEAP32[((12232)>>2)])|0);
   $86=((_match($85,3200))|0);
   $87=($86|0)==0;
   if (!($87)) {
    $89=((12232+($2<<2))|0);
    $90=((HEAP32[(($89)>>2)])|0);
    $91=((_match($90,3048))|0);
    $92=($91|0)==0;
    if (!($92)) {
     HEAP8[(14400)]=0;
     $_0=0;
     break;
    }
    $95=((HEAP32[(($89)>>2)])|0);
    $96=((_match($95,2944))|0);
    $97=($96|0)==0;
    if (!($97)) {
     HEAP8[(14400)]=1;
     $_0=0;
     break;
    }
    $100=((HEAP32[((14416)>>2)])|0);
    $101=($100|0)==0;
    if ($101) {
     $_0=208;
     break;
    }
    $102=($2|0)<1;
    if (!($102)) {
     $i_039=1;
     while(1) {

      $103=((12232+($i_039<<2))|0);
      $104=((HEAP32[(($103)>>2)])|0);
      $105=((_findnode($104))|0);
      $106=($105|0)==0;
      if ($106) {
       $_0=208;
       break L1;
      }
      $108=((HEAP32[((14408)>>2)])|0);
      $109=(($108+((($105)*(72))&-1)+64)|0);
      HEAP8[($109)]=1;
      $110=((($i_039)+(1))|0);
      $111=($110|0)>($2|0);
      if ($111) {
       break;
      } else {
       $i_039=$110;
      }
     }
    }
    HEAP8[(14400)]=2;
    $_0=0;
    break;
   }
   $113=((HEAP32[((12232)>>2)])|0);
   $114=((_match($113,2824))|0);
   $115=($114|0)==0;
   if (!($115)) {
    $117=((12232+($2<<2))|0);
    $118=((HEAP32[(($117)>>2)])|0);
    $119=((_match($118,3048))|0);
    $120=($119|0)==0;
    if (!($120)) {
     HEAP8[(14952)]=0;
     $_0=0;
     break;
    }
    $123=((HEAP32[(($117)>>2)])|0);
    $124=((_match($123,2944))|0);
    $125=($124|0)==0;
    if (!($125)) {
     HEAP8[(14952)]=1;
     $_0=0;
     break;
    }
    $128=((HEAP32[((14424)>>2)])|0);
    $129=($128|0)==0;
    if ($129) {
     $_0=210;
     break;
    }
    $130=($2|0)<1;
    if (!($130)) {
     $i_136=1;
     while(1) {

      $131=((12232+($i_136<<2))|0);
      $132=((HEAP32[(($131)>>2)])|0);
      $133=((_findlink($132))|0);
      $134=($133|0)==0;
      if ($134) {
       $_0=210;
       break L1;
      }
      $136=((HEAP32[((14960)>>2)])|0);
      $137=(($136+((($133)*(104))&-1)+98)|0);
      HEAP8[($137)]=1;
      $138=((($i_136)+(1))|0);
      $139=($138|0)>($2|0);
      if ($139) {
       break;
      } else {
       $i_136=$138;
      }
     }
    }
    HEAP8[(14952)]=2;
    $_0=0;
    break;
   }
   $141=((HEAP32[((12232)>>2)])|0);
   $142=((_strcomp($141,2720))|0);
   $143=($142|0)==0;
   do {
    if ($143) {
     $145=((HEAP32[((12232)>>2)])|0);
     $146=((_findmatch($145,11248))|0);
     $147=($146|0)>-1;
     if ($147) {
      $149=($146|0)>14;
      if ($149) {
       $_0=201;
       break L1;
      } else {
       $i_23335=$146;
       break;
      }
     }
     $200=((HEAP32[((12232)>>2)])|0);
     $201=((_match($200,2544))|0);
     $202=($201|0)==0;
     if ($202) {
      $_0=201;
      break L1;
     }
     $204=((HEAP32[((12236)>>2)])|0);
     $205=((_strncpy(((13304)|0),(($204)|0),((259)|0)))|0);
     $_0=0;
     break L1;
    } else {
     $i_23335=9;
    }
   } while(0);

   $150=((HEAP32[((14336)>>2)])|0);
   $151=($150|0)==1;
   do {
    if (!($151)) {
     $153=((HEAP32[((12236)>>2)])|0);
     $154=((_match($153,3472))|0);
     $155=($154|0)==0;
     if (!($155)) {
      break;
     }
     $159=((HEAP32[((12236)>>2)])|0);
     $160=((_match($159,3512))|0);
     $161=($160|0)==0;
     if (!($161)) {
      $163=((15656+((($i_23335)*(88))&-1)+64)|0);
      HEAP8[($163)]=0;
      $_0=0;
      break L1;
     }
     $165=((HEAP32[((14336)>>2)])|0);
     $166=($165|0)<3;
     if ($166) {
      $_0=201;
      break L1;
     }
     $168=((HEAP32[((12236)>>2)])|0);
     $169=((_match($168,8328))|0);
     $170=($169|0)==0;
     do {
      if ($170) {
       $172=((HEAP32[((12236)>>2)])|0);
       $173=((_match($172,7944))|0);
       $174=($173|0)==0;
       if (!($174)) {
        $j_0=1;
        break;
       }
       $176=((HEAP32[((12236)>>2)])|0);
       $177=((_match($176,2624))|0);
       $178=($177|0)==0;
       if ($178) {
        $_0=201;
        break L1;
       } else {
        $j_0=2;
       }
      } else {
       $j_0=0;
      }
     } while(0);

     $180=((HEAP32[((12240)>>2)])|0);
     $181=((_getfloat($180,$y))|0);
     $182=($181|0)==0;
     if ($182) {
      $_0=201;
      break L1;
     }
     $184=($j_0|0)==2;
     if (!($184)) {
      $197=(+(HEAPF64[(($y)>>3)]));
      $198=((15656+((($i_23335)*(88))&-1)+72+($j_0<<3))|0);
      HEAPF64[(($198)>>3)]=$197;
      $_0=0;
      break L1;
     }
     $186=((15656+((($i_23335)*(88))&-1)+64)|0);
     HEAP8[($186)]=1;
     $187=(+(HEAPF64[(($y)>>3)]));
     $188=$187<(0.0);
     if ($188) {
      $192=($187)+((-0.5));
      $_sink=$192;
     } else {
      $190=($187)+((0.5));
      $_sink=$190;
     }

     $194=(~~($_sink));
     $195=((15656+((($i_23335)*(88))&-1)+68)|0);
     HEAP32[(($195)>>2)]=$194;
     $_0=0;
     break L1;
    }
   } while(0);
   $157=((15656+((($i_23335)*(88))&-1)+64)|0);
   HEAP8[($157)]=1;
   $_0=0;
  }
 } while(0);

 STACKTOP=sp;return (($_0)|0);
}


function _timedata(){
 var $y=0,$1=0,$2=0,$3=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$15=0,$16=0,$17=0,$20=0,$21=0,$22=0,$25=0,$26=0,$27=0;
 var $30=0,$31=0,$32=0,$35=0,$36=0,$37=0,$40=0,$41=0,$43=0,$44=.0,$45=0,$47=0,$48=0,$49=0,$50=0,$51=.0,$52=0,$54=.0,$55=.0,$56=0;
 var $57=0,$58=0,$59=0,$62=0,$63=0,$64=0,$67=0,$68=0,$69=0,$72=0,$73=0,$74=0,$77=0,$78=0,$79=0,$81=0,$82=0,$83=0,$85=0,$86=0;
 var $87=0,$90=0,$91=0,$92=0,$95=0,$96=0,$97=0,$99=0,$100=0,$101=0,$104=0,$105=0,$106=0,$109=0,$110=0,$111=0,$113=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $y=((sp)|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $2=((($1)-(1))|0);
 $3=($2|0)<1;
 L1: do {
  if ($3) {
   $_0=201;
  } else {
   $5=((HEAP32[((12232)>>2)])|0);
   $6=((_match($5,2456))|0);
   $7=($6|0)==0;
   $8=((12232+($2<<2))|0);
   $9=((HEAP32[(($8)>>2)])|0);
   if (!($7)) {
    $11=((_match($9,3048))|0);
    $12=($11|0)==0;
    if (!($12)) {
     HEAP8[(12208)]=0;
     $_0=0;
     break;
    }
    $15=((HEAP32[(($8)>>2)])|0);
    $16=((_match($15,3512))|0);
    $17=($16|0)==0;
    if (!($17)) {
     HEAP8[(12208)]=0;
     $_0=0;
     break;
    }
    $20=((HEAP32[(($8)>>2)])|0);
    $21=((_match($20,2424))|0);
    $22=($21|0)==0;
    if (!($22)) {
     HEAP8[(12208)]=1;
     $_0=0;
     break;
    }
    $25=((HEAP32[(($8)>>2)])|0);
    $26=((_match($25,2408))|0);
    $27=($26|0)==0;
    if (!($27)) {
     HEAP8[(12208)]=2;
     $_0=0;
     break;
    }
    $30=((HEAP32[(($8)>>2)])|0);
    $31=((_match($30,2376))|0);
    $32=($31|0)==0;
    if (!($32)) {
     HEAP8[(12208)]=3;
     $_0=0;
     break;
    }
    $35=((HEAP32[(($8)>>2)])|0);
    $36=((_match($35,2288))|0);
    $37=($36|0)==0;
    if ($37) {
     $_0=201;
     break;
    }
    HEAP8[(12208)]=4;
    $_0=0;
    break;
   }
   $40=((_getfloat($9,$y))|0);
   $41=($40|0)==0;
   do {
    if ($41) {
     $43=((HEAP32[(($8)>>2)])|0);
     $44=(+(_hour($43,11496)));
     HEAPF64[(($y)>>3)]=$44;
     $45=$44<(0.0);
     if (!($45)) {
      break;
     }
     $47=((($1)-(2))|0);
     $48=((12232+($47<<2))|0);
     $49=((HEAP32[(($48)>>2)])|0);
     $50=((HEAP32[(($8)>>2)])|0);
     $51=(+(_hour($49,$50)));
     HEAPF64[(($y)>>3)]=$51;
     $52=$51<(0.0);
     if ($52) {
      $_0=213;
      break L1;
     }
    }
   } while(0);
   $54=(+(HEAPF64[(($y)>>3)]));
   $55=($54)*((3600.0));
   $56=(~~($55));
   $57=((HEAP32[((12232)>>2)])|0);
   $58=((_match($57,2264))|0);
   $59=($58|0)==0;
   if (!($59)) {
    HEAP32[((17544)>>2)]=$56;
    $_0=0;
    break;
   }
   $62=((HEAP32[((12232)>>2)])|0);
   $63=((_match($62,2240))|0);
   $64=($63|0)==0;
   if (!($64)) {
    HEAP32[((15584)>>2)]=$56;
    $_0=0;
    break;
   }
   $67=((HEAP32[((12232)>>2)])|0);
   $68=((_match($67,2216))|0);
   $69=($68|0)==0;
   if (!($69)) {
    HEAP32[((13872)>>2)]=$56;
    $_0=0;
    break;
   }
   $72=((HEAP32[((12232)>>2)])|0);
   $73=((_match($72,2192))|0);
   $74=($73|0)==0;
   if (!($74)) {
    HEAP32[((13240)>>2)]=$56;
    $_0=0;
    break;
   }
   $77=((HEAP32[((12232)>>2)])|0);
   $78=((_match($77,2120))|0);
   $79=($78|0)==0;
   if (!($79)) {
    $_0=0;
    break;
   }
   $81=((HEAP32[((12232)>>2)])|0);
   $82=((_match($81,2296))|0);
   $83=($82|0)==0;
   if (!($83)) {
    $85=((HEAP32[((12236)>>2)])|0);
    $86=((_match($85,8936))|0);
    $87=($86|0)==0;
    if (!($87)) {
     HEAP32[((13896)>>2)]=$56;
     $_0=0;
     break;
    }
    $90=((HEAP32[((12236)>>2)])|0);
    $91=((_match($90,2008))|0);
    $92=($91|0)==0;
    if ($92) {
     $_0=201;
     break;
    }
    HEAP32[((13904)>>2)]=$56;
    $_0=0;
    break;
   }
   $95=((HEAP32[((12232)>>2)])|0);
   $96=((_match($95,1976))|0);
   $97=($96|0)==0;
   if ($97) {
    $109=((HEAP32[((12232)>>2)])|0);
    $110=((_match($109,2008))|0);
    $111=($110|0)==0;
    if ($111) {
     $_0=201;
     break;
    }
    $113=(((($56|0))%(86400))&-1);
    HEAP32[((12216)>>2)]=$113;
    $_0=0;
    break;
   }
   $99=((HEAP32[((12236)>>2)])|0);
   $100=((_match($99,8936))|0);
   $101=($100|0)==0;
   if (!($101)) {
    HEAP32[((13272)>>2)]=$56;
    $_0=0;
    break;
   }
   $104=((HEAP32[((12236)>>2)])|0);
   $105=((_match($104,2008))|0);
   $106=($105|0)==0;
   if ($106) {
    $_0=201;
    break;
   }
   HEAP32[((13280)>>2)]=$56;
   $_0=0;
  }
 } while(0);

 STACKTOP=sp;return (($_0)|0);
}


function _optiondata(){
 var $1=0,$2=0,$3=0,$4=0,$6=0,$_0=0,label=0;

 $1=((HEAP32[((14336)>>2)])|0);
 $2=((($1)-(1))|0);
 $3=((_optionchoice($2))|0);
 $4=($3|0)>-1;
 if ($4) {
  $_0=$3;

  return (($_0)|0);
 }
 $6=((_optionvalue($2))|0);
 $_0=$6;

 return (($_0)|0);
}


function _optionchoice($n){
 $n=($n)|0;
 var $1=0,$3=0,$4=0,$5=0,$7=0,$9=0,$10=0,$11=0,$14=0,$15=0,$16=0,$19=0,$20=0,$21=0,$24=0,$25=0,$26=0,$29=0,$30=0,$31=0;
 var $34=0,$35=0,$36=0,$39=0,$40=0,$41=0,$44=0,$45=0,$46=0,$49=0,$50=0,$51=0,$54=0,$55=0,$56=0,$59=0,$60=0,$61=0,$64=0,$65=0;
 var $66=0,$68=0,$70=0,$71=0,$72=0,$75=0,$76=0,$77=0,$80=0,$81=0,$82=0,$85=0,$86=0,$87=0,$89=0,$91=0,$92=0,$93=0,$96=0,$97=0;
 var $98=0,$101=0,$102=0,$103=0,$106=0,$107=0,$108=0,$110=0,$112=0,$113=0,$114=0,$116=0,$117=0,$118=0,$storemerge=0,$120=0,$121=0,$123=0,$124=0,$125=0;
 var $127=0,$129=0,$130=0,$131=0,$134=0,$135=0,$136=0,$139=0,$140=0,$141=0,$144=0,$145=0,$146=0,$148=0,$149=0,$150=0,$152=0,$153=0,$_pr=0,$155=0;
 var $157=0,$158=0,$160=0,$161=0,$162=0,$163=0,$164=0,$165=0,$167=0,$168=0,$169=0,$_pr14=0,$171=0,$172=0,$174=0,$175=0,$177=0,$178=0,$179=0,$181=0;
 var $183=0,$184=0,$186=0,$187=0,$188=0,$190=0,$191=0,$192=0,$194=0,$196=0,$197=0,$198=0,$201=0,$202=0,$203=0,$205=0,$207=0,$208=0,$211=0,$212=0;
 var $213=0,$215=0,$217=0,$218=0,$_0=0,label=0;

 $1=($n|0)<0;
 if ($1) {
  $_0=201;

  return (($_0)|0);
 }
 $3=((HEAP32[((12232)>>2)])|0);
 $4=((_match($3,1952))|0);
 $5=($4|0)==0;
 if (!($5)) {
  $7=($n|0)<1;
  if ($7) {
   $_0=0;

   return (($_0)|0);
  }
  $9=((HEAP32[((12236)>>2)])|0);
  $10=((_match($9,1920))|0);
  $11=($10|0)==0;
  if (!($11)) {
   HEAP8[(15632)]=0;
   $_0=0;

   return (($_0)|0);
  }
  $14=((HEAP32[((12236)>>2)])|0);
  $15=((_match($14,1816))|0);
  $16=($15|0)==0;
  if (!($16)) {
   HEAP8[(15632)]=1;
   $_0=0;

   return (($_0)|0);
  }
  $19=((HEAP32[((12236)>>2)])|0);
  $20=((_match($19,1792))|0);
  $21=($20|0)==0;
  if (!($21)) {
   HEAP8[(15632)]=4;
   $_0=0;

   return (($_0)|0);
  }
  $24=((HEAP32[((12236)>>2)])|0);
  $25=((_match($24,1760))|0);
  $26=($25|0)==0;
  if (!($26)) {
   HEAP8[(15632)]=2;
   $_0=0;

   return (($_0)|0);
  }
  $29=((HEAP32[((12236)>>2)])|0);
  $30=((_match($29,1712))|0);
  $31=($30|0)==0;
  if (!($31)) {
   HEAP8[(15632)]=3;
   $_0=0;

   return (($_0)|0);
  }
  $34=((HEAP32[((12236)>>2)])|0);
  $35=((_match($34,1664))|0);
  $36=($35|0)==0;
  if (!($36)) {
   HEAP8[(15632)]=5;
   $_0=0;

   return (($_0)|0);
  }
  $39=((HEAP32[((12236)>>2)])|0);
  $40=((_match($39,1624))|0);
  $41=($40|0)==0;
  if (!($41)) {
   HEAP8[(15632)]=6;
   $_0=0;

   return (($_0)|0);
  }
  $44=((HEAP32[((12236)>>2)])|0);
  $45=((_match($44,1592))|0);
  $46=($45|0)==0;
  if (!($46)) {
   HEAP8[(15632)]=8;
   $_0=0;

   return (($_0)|0);
  }
  $49=((HEAP32[((12236)>>2)])|0);
  $50=((_match($49,1552))|0);
  $51=($50|0)==0;
  if (!($51)) {
   HEAP8[(15632)]=9;
   $_0=0;

   return (($_0)|0);
  }
  $54=((HEAP32[((12236)>>2)])|0);
  $55=((_match($54,1528))|0);
  $56=($55|0)==0;
  if (!($56)) {
   HEAP8[(15632)]=7;
   $_0=0;

   return (($_0)|0);
  }
  $59=((HEAP32[((12236)>>2)])|0);
  $60=((_match($59,1488))|0);
  $61=($60|0)==0;
  if ($61) {
   $_0=201;

   return (($_0)|0);
  }
  HEAP8[(15632)]=5;
  $_0=0;

  return (($_0)|0);
 }
 $64=((HEAP32[((12232)>>2)])|0);
 $65=((_match($64,1392))|0);
 $66=($65|0)==0;
 if (!($66)) {
  $68=($n|0)<1;
  if ($68) {
   $_0=0;

   return (($_0)|0);
  }
  $70=((HEAP32[((12236)>>2)])|0);
  $71=((_match($70,1328))|0);
  $72=($71|0)==0;
  if (!($72)) {
   HEAP8[(13928)]=0;
   $_0=0;

   return (($_0)|0);
  }
  $75=((HEAP32[((12236)>>2)])|0);
  $76=((_match($75,1216))|0);
  $77=($76|0)==0;
  if (!($77)) {
   HEAP8[(13928)]=1;
   $_0=0;

   return (($_0)|0);
  }
  $80=((HEAP32[((12236)>>2)])|0);
  $81=((_match($80,1152))|0);
  $82=($81|0)==0;
  if ($82) {
   $_0=201;

   return (($_0)|0);
  }
  HEAP8[(13928)]=2;
  $_0=0;

  return (($_0)|0);
 }
 $85=((HEAP32[((12232)>>2)])|0);
 $86=((_match($85,2720))|0);
 $87=($86|0)==0;
 if (!($87)) {
  $89=($n|0)<1;
  if ($89) {
   $_0=0;

   return (($_0)|0);
  }
  $91=((HEAP32[((12236)>>2)])|0);
  $92=((_match($91,1096))|0);
  $93=($92|0)==0;
  if (!($93)) {
   HEAP8[(15624)]=0;
   $_0=0;

   return (($_0)|0);
  }
  $96=((HEAP32[((12236)>>2)])|0);
  $97=((_match($96,1048))|0);
  $98=($97|0)==0;
  if (!($98)) {
   HEAP8[(15624)]=1;
   $_0=0;

   return (($_0)|0);
  }
  $101=((HEAP32[((12236)>>2)])|0);
  $102=((_match($101,952))|0);
  $103=($102|0)==0;
  if ($103) {
   $_0=201;

   return (($_0)|0);
  }
  HEAP8[(15624)]=2;
  $_0=0;

  return (($_0)|0);
 }
 $106=((HEAP32[((12232)>>2)])|0);
 $107=((_match($106,2240))|0);
 $108=($107|0)==0;
 if (!($108)) {
  $110=($n|0)<2;
  if ($110) {
   $_0=0;

   return (($_0)|0);
  }
  $112=((HEAP32[((12236)>>2)])|0);
  $113=((_match($112,896))|0);
  $114=($113|0)==0;
  do {
   if ($114) {
    $116=((HEAP32[((12236)>>2)])|0);
    $117=((_match($116,848))|0);
    $118=($117|0)==0;
    if ($118) {
     $_0=201;
    } else {
     $storemerge=1;
     break;
    }

    return (($_0)|0);
   } else {
    $storemerge=0;
   }
  } while(0);

  HEAP8[(15288)]=$storemerge;
  $120=((HEAP32[((12240)>>2)])|0);
  $121=((_strncpy(((15304)|0),(($120)|0),((259)|0)))|0);
  $_0=0;

  return (($_0)|0);
 }
 $123=((HEAP32[((12232)>>2)])|0);
 $124=((_match($123,2216))|0);
 $125=($124|0)==0;
 if (!($125)) {
  $127=($n|0)<1;
  if ($127) {
   $_0=0;

   return (($_0)|0);
  }
  $129=((HEAP32[((12236)>>2)])|0);
  $130=((_match($129,3048))|0);
  $131=($130|0)==0;
  do {
   if ($131) {
    $134=((HEAP32[((12236)>>2)])|0);
    $135=((_match($134,800))|0);
    $136=($135|0)==0;
    if (!($136)) {
     HEAP8[(13856)]=1;
     label = 63;
     break;
    }
    $139=((HEAP32[((12236)>>2)])|0);
    $140=((_match($139,728))|0);
    $141=($140|0)==0;
    if (!($141)) {
     HEAP8[(13856)]=2;
     label = 63;
     break;
    }
    $144=((HEAP32[((12236)>>2)])|0);
    $145=((_match($144,688))|0);
    $146=($145|0)==0;
    if ($146) {
     HEAP8[(13856)]=1;
     $148=((HEAP32[((12236)>>2)])|0);
     $149=((_strncpy(((17696)|0),(($148)|0),((31)|0)))|0);
     $150=($n|0)>1;
     if ($150) {
      $152=((HEAP32[((12240)>>2)])|0);
      $153=((_strncpy(((17664)|0),(($152)|0),((31)|0)))|0);
     }
     $_pr=((HEAP8[(13856)])|0);
     $155=(($_pr<<24)>>24)==3;
     if (!($155)) {
      $171=$_pr;
      break;
     }
    } else {
     HEAP8[(13856)]=3;
    }
    $157=((HEAP32[((12232)>>2)])|0);
    HEAP8[($157)]=0;
    $158=($n|0)<2;
    if ($158) {
     $_0=212;

     return (($_0)|0);
    }
    $160=((HEAP32[((12232)>>2)])|0);
    $161=((HEAP32[((12240)>>2)])|0);
    $162=((_strcpy((($160)|0),(($161)|0)))|0);
    $163=((HEAP32[((12240)>>2)])|0);
    $164=((_findnode($163))|0);
    HEAP32[((12224)>>2)]=$164;
    $165=($164|0)==0;
    if ($165) {
     $_0=212;

     return (($_0)|0);
    } else {
     $167=((_strncpy(((17696)|0),((584)|0),((31)|0)))|0);
     $168=((HEAP32[((12240)>>2)])|0);
     $169=((_strncpy(((17664)|0),(($168)|0),((31)|0)))|0);
     label = 63;
     break;
    }
   } else {
    HEAP8[(13856)]=0;
    label = 63;
   }
  } while(0);
  if ((label|0) == 63) {
   $_pr14=((HEAP8[(13856)])|0);
   $171=$_pr14;
  }

  $172=(($171<<24)>>24)==2;
  if (!($172)) {
   $_0=0;

   return (($_0)|0);
  }
  $174=((_strncpy(((17696)|0),((728)|0),((31)|0)))|0);
  $175=((_strncpy(((17664)|0),((520)|0),((31)|0)))|0);
  $_0=0;

  return (($_0)|0);
 }
 $177=((HEAP32[((12232)>>2)])|0);
 $178=((_match($177,448))|0);
 $179=($178|0)==0;
 if (!($179)) {
  $181=($n|0)<1;
  if ($181) {
   $_0=0;

   return (($_0)|0);
  }
  $183=((HEAP32[((12236)>>2)])|0);
  $184=((_strncpy(((14688)|0),(($183)|0),((259)|0)))|0);
  $_0=0;

  return (($_0)|0);
 }
 $186=((HEAP32[((12232)>>2)])|0);
 $187=((_match($186,384))|0);
 $188=($187|0)==0;
 if (!($188)) {
  $_0=0;

  return (($_0)|0);
 }
 $190=((HEAP32[((12232)>>2)])|0);
 $191=((_match($190,328))|0);
 $192=($191|0)==0;
 if ($192) {
  $211=((HEAP32[((12232)>>2)])|0);
  $212=((_match($211,2296))|0);
  $213=($212|0)==0;
  if ($213) {
   $_0=-1;

   return (($_0)|0);
  }
  $215=($n|0)<1;
  if ($215) {
   $_0=0;

   return (($_0)|0);
  }
  $217=((HEAP32[((12236)>>2)])|0);
  $218=((_strncpy(((17560)|0),(($217)|0),((31)|0)))|0);
  $_0=0;

  return (($_0)|0);
 }
 $194=($n|0)<1;
 if ($194) {
  $_0=0;

  return (($_0)|0);
 }
 $196=((HEAP32[((12236)>>2)])|0);
 $197=((_match($196,280))|0);
 $198=($197|0)==0;
 if (!($198)) {
  HEAP32[((17512)>>2)]=-1;
  $_0=0;

  return (($_0)|0);
 }
 $201=((HEAP32[((12236)>>2)])|0);
 $202=((_match($201,248))|0);
 $203=($202|0)==0;
 if ($203) {
  $_0=201;

  return (($_0)|0);
 }
 $205=($n|0)>1;
 if ($205) {
  $207=((HEAP32[((12240)>>2)])|0);
  $208=((_atoi((($207)|0)))|0);
  HEAP32[((17512)>>2)]=$208;
  $_0=0;

  return (($_0)|0);
 } else {
  HEAP32[((17512)>>2)]=0;
  $_0=0;

  return (($_0)|0);
 }
}


function _optionvalue($n){
 $n=($n)|0;
 var $y=0,$1=0,$2=0,$3=0,$5=0,$6=0,$7=0,$9=0,$10=0,$11=0,$13=0,$14=0,$15=0,$nvalue_0=0,$18=0,$20=0,$21=0,$22=0,$23=0,$25=0;
 var $26=0,$27=0,$29=.0,$30=0,$33=0,$34=0,$35=0,$37=.0,$38=0,$41=0,$42=0,$43=0,$44=.0,$47=0,$49=0,$50=0,$51=0,$53=.0,$55=0,$56=0;
 var $57=0,$59=.0,$61=0,$62=0,$63=0,$65=.0,$66=0,$68=0,$69=0,$70=0,$72=.0,$73=0,$74=.0,$75=0,$76=.0,$78=0,$79=0,$80=0,$82=.0,$84=0;
 var $85=0,$86=0,$88=.0,$90=0,$91=0,$92=0,$94=.0,$95=0,$98=0,$99=0,$100=0,$102=.0,$103=0,$105=0,$106=0,$107=0,$109=.0,$110=0,$112=0,$113=0;
 var $114=0,$116=.0,$117=.0,$119=0,$120=0,$121=0,$123=.0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $y=((sp)|0);
 $1=((HEAP32[((12232)>>2)])|0);
 $2=((_match($1,232))|0);
 $3=($2|0)==0;
 do {
  if ($3) {
   $5=((HEAP32[((12232)>>2)])|0);
   $6=((_match($5,192))|0);
   $7=($6|0)==0;
   do {
    if ($7) {
     $9=((HEAP32[((12232)>>2)])|0);
     $10=((_match($9,176))|0);
     $11=($10|0)==0;
     if (!($11)) {
      label = 5;
      break;
     }
     $13=((HEAP32[((12232)>>2)])|0);
     $14=((_match($13,112))|0);
     $15=($14|0)==0;
     if ($15) {
      $nvalue_0=1;
     } else {
      label = 5;
     }
    } else {
     label = 5;
    }
   } while(0);
   if ((label|0) == 5) {
    $nvalue_0=2;
   }

   $18=($nvalue_0|0)>($n|0);
   if ($18) {
    $_0=0;
    break;
   }
   $20=((12232+($nvalue_0<<2))|0);
   $21=((HEAP32[(($20)>>2)])|0);
   $22=((_getfloat($21,$y))|0);
   $23=($22|0)==0;
   if ($23) {
    $_0=213;
    break;
   }
   $25=((HEAP32[((12232)>>2)])|0);
   $26=((_match($25,88))|0);
   $27=($26|0)==0;
   if (!($27)) {
    $29=(+(HEAPF64[(($y)>>3)]));
    $30=$29<(0.0);
    if ($30) {
     $_0=213;
     break;
    }
    HEAPF64[((11400)>>3)]=$29;
    $_0=0;
    break;
   }
   $33=((HEAP32[((12232)>>2)])|0);
   $34=((_match($33,72))|0);
   $35=($34|0)==0;
   if (!($35)) {
    $37=(+(HEAPF64[(($y)>>3)]));
    $38=$37<(0.0);
    if ($38) {
     $_0=213;
     break;
    }
    HEAPF64[((11376)>>3)]=$37;
    $_0=0;
    break;
   }
   $41=((HEAP32[((12232)>>2)])|0);
   $42=((_match($41,48))|0);
   $43=($42|0)==0;
   $44=(+(HEAPF64[(($y)>>3)]));
   if (!($43)) {
    HEAPF64[((11392)>>3)]=$44;
    $_0=0;
    break;
   }
   $47=$44>(0.0);
   if (!($47)) {
    $_0=213;
    break;
   }
   $49=((HEAP32[((12232)>>2)])|0);
   $50=((_match($49,10384))|0);
   $51=($50|0)==0;
   if (!($51)) {
    $53=(+(HEAPF64[(($y)>>3)]));
    HEAPF64[((10480)>>3)]=$53;
    $_0=0;
    break;
   }
   $55=((HEAP32[((12232)>>2)])|0);
   $56=((_match($55,192))|0);
   $57=($56|0)==0;
   if (!($57)) {
    $59=(+(HEAPF64[(($y)>>3)]));
    HEAPF64[((10648)>>3)]=$59;
    $_0=0;
    break;
   }
   $61=((HEAP32[((12232)>>2)])|0);
   $62=((_match($61,10368))|0);
   $63=($62|0)==0;
   if (!($63)) {
    $65=(+(HEAPF64[(($y)>>3)]));
    $66=(~~($65));
    HEAP32[((14648)>>2)]=$66;
    $_0=0;
    break;
   }
   $68=((HEAP32[((12232)>>2)])|0);
   $69=((_match($68,10352))|0);
   $70=($69|0)==0;
   if (!($70)) {
    $72=(+(HEAPF64[(($y)>>3)]));
    $73=$72>=(0.00001);
    $74=($73?$72:(0.00001));
    $75=$74<=(0.1);
    $76=($75?$74:(0.1));
    HEAPF64[(($y)>>3)]=$76;
    HEAPF64[((11240)>>3)]=$76;
    $_0=0;
    break;
   }
   $78=((HEAP32[((12232)>>2)])|0);
   $79=((_match($78,10336))|0);
   $80=($79|0)==0;
   if (!($80)) {
    $82=(+(HEAPF64[(($y)>>3)]));
    HEAPF64[((11224)>>3)]=$82;
    $_0=0;
    break;
   }
   $84=((HEAP32[((12232)>>2)])|0);
   $85=((_match($84,10296))|0);
   $86=($85|0)==0;
   if (!($86)) {
    $88=(+(HEAPF64[(($y)>>3)]));
    HEAPF64[((10992)>>3)]=$88;
    $_0=0;
    break;
   }
   $90=((HEAP32[((12232)>>2)])|0);
   $91=((_match($90,10280))|0);
   $92=($91|0)==0;
   if (!($92)) {
    $94=(+(HEAPF64[(($y)>>3)]));
    $95=$94<(1.0);
    if (!($95)) {
     $_0=213;
     break;
    }
    HEAPF64[((10984)>>3)]=$94;
    $_0=0;
    break;
   }
   $98=((HEAP32[((12232)>>2)])|0);
   $99=((_match($98,10200))|0);
   $100=($99|0)==0;
   if (!($100)) {
    $102=(+(HEAPF64[(($y)>>3)]));
    $103=(~~($102));
    HEAP32[((17728)>>2)]=$103;
    $_0=0;
    break;
   }
   $105=((HEAP32[((12232)>>2)])|0);
   $106=((_match($105,10168))|0);
   $107=($106|0)==0;
   if (!($107)) {
    $109=(+(HEAPF64[(($y)>>3)]));
    $110=(~~($109));
    HEAP32[((14672)>>2)]=$110;
    $_0=0;
    break;
   }
   $112=((HEAP32[((12232)>>2)])|0);
   $113=((_match($112,176))|0);
   $114=($113|0)==0;
   if (!($114)) {
    $116=(+(HEAPF64[(($y)>>3)]));
    $117=((1.0))/($116);
    HEAPF64[((11000)>>3)]=$117;
    $_0=0;
    break;
   }
   $119=((HEAP32[((12232)>>2)])|0);
   $120=((_match($119,112))|0);
   $121=($120|0)==0;
   if ($121) {
    $_0=201;
    break;
   }
   $123=(+(HEAPF64[(($y)>>3)]));
   HEAPF64[((11368)>>3)]=$123;
   $_0=0;
  } else {
   $_0=0;
  }
 } while(0);

 STACKTOP=sp;return (($_0)|0);
}


function _powercurve($h0,$h1,$h2,$q1,$q2,$a,$b,$c){
 $h0=+($h0);
 $h1=+($h1);
 $h2=+($h2);
 $q1=+($q1);
 $q2=+($q2);
 $a=($a)|0;
 $b=($b)|0;
 $c=($c)|0;
 var $1=0,$3=.0,$4=0,$6=.0,$7=0,$8=0,$or_cond=0,$10=.0,$11=0,$13=.0,$14=.0,$15=.0,$16=.0,$17=.0,$18=.0,$19=0,$20=0,$or_cond25=0,$22=.0,$23=.0;
 var $24=.0,$25=0,$_=0,$_0=0,label=0;

 $1=$h0<(0.000001);
 if ($1) {
  $_0=0;

  return (($_0)|0);
 }
 $3=($h0)-($h1);
 $4=$3<(0.000001);
 if ($4) {
  $_0=0;

  return (($_0)|0);
 }
 $6=($h1)-($h2);
 $7=$6<(0.000001);
 $8=$q1<(0.000001);
 $or_cond=$7|$8;
 if ($or_cond) {
  $_0=0;

  return (($_0)|0);
 }
 $10=($q2)-($q1);
 $11=$10<(0.000001);
 if ($11) {
  $_0=0;

  return (($_0)|0);
 }
 HEAPF64[(($a)>>3)]=$h0;
 $13=($h0)-($h2);
 $14=($13)/($3);
 $15=(+(Math_log($14)));
 $16=($q2)/($q1);
 $17=(+(Math_log($16)));
 $18=($15)/($17);
 HEAPF64[(($c)>>3)]=$18;
 $19=$18<=(0.0);
 $20=$18>(20.0);
 $or_cond25=$19|$20;
 if ($or_cond25) {
  $_0=0;

  return (($_0)|0);
 }
 $22=((-.0))-($3);
 $23=(+(Math_pow((+($q1)),(+($18)))));
 $24=($22)/($23);
 HEAPF64[(($b)>>3)]=$24;
 $25=$24<(0.0);
 $_=($25&1);
 $_0=$_;

 return (($_0)|0);
}


function _AllocInit(){
 var $1=0,$2=0,$3=0,$5=0,$6=0,$7=0,$8=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$_0=0,label=0;

 $1=((_malloc(8))|0);
 $2=$1;
 HEAP32[((11440)>>2)]=$2;
 $3=($1|0)==0;
 if ($3) {
  $_0=0;

  return (($_0)|0);
 }
 $5=((_AllocHdr())|0);
 $6=((HEAP32[((11440)>>2)])|0);
 $7=(($6)|0);
 HEAP32[(($7)>>2)]=$5;
 $8=($5|0)==0;
 if ($8) {
  $_0=0;

  return (($_0)|0);
 }
 $10=((HEAP32[((11440)>>2)])|0);
 $11=(($10)|0);
 $12=((HEAP32[(($11)>>2)])|0);
 $13=(($10+4)|0);
 HEAP32[(($13)>>2)]=$12;
 $14=((HEAP32[((11440)>>2)])|0);
 $15=$14;
 $_0=$15;

 return (($_0)|0);
}


function _AllocHdr(){
 var $1=0,$2=0,$3=0,$4=0,$or_cond=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$_0=0,label=0;

 $1=((_malloc(64000))|0);
 $2=((_malloc(16))|0);
 $3=($2|0)==0;
 $4=($1|0)==0;
 $or_cond=$3|$4;
 if ($or_cond) {
  $_0=0;

  return (($_0)|0);
 }
 $6=$2;
 $7=(($2+4)|0);
 $8=$7;
 HEAP32[(($8)>>2)]=$1;
 $9=(($2+8)|0);
 $10=$9;
 HEAP32[(($10)>>2)]=$1;
 $11=$2;
 HEAP32[(($11)>>2)]=0;
 $12=(($1+64000)|0);
 $13=(($2+12)|0);
 $14=$13;
 HEAP32[(($14)>>2)]=$12;
 $_0=$6;

 return (($_0)|0);
}


function _Alloc($size){
 $size=($size)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$13=0,$14=0,$15=0,$17=0,$18=0,$19=0,$20=0,$21=0,$22=0;
 var $24=0,$25=0,$27=0,$28=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$_0=0,label=0;

 $1=((HEAP32[((11440)>>2)])|0);
 $2=(($1+4)|0);
 $3=((HEAP32[(($2)>>2)])|0);
 $4=((($size)+(3))|0);
 $5=$4&-4;
 $6=(($3+8)|0);
 $7=((HEAP32[(($6)>>2)])|0);
 $8=(($7+$5)|0);
 HEAP32[(($6)>>2)]=$8;
 $9=(($3+12)|0);
 $10=((HEAP32[(($9)>>2)])|0);
 $11=($8>>>0)<($10>>>0);
 if ($11) {
  $_0=$7;

  return (($_0)|0);
 }
 $13=(($3)|0);
 $14=((HEAP32[(($13)>>2)])|0);
 $15=($14|0)==0;
 do {
  if ($15) {
   $24=((_AllocHdr())|0);
   HEAP32[(($13)>>2)]=$24;
   $25=($24|0)==0;
   if ($25) {
    $_0=0;

    return (($_0)|0);
   } else {
    $27=((HEAP32[((11440)>>2)])|0);
    $28=(($27+4)|0);
    HEAP32[(($28)>>2)]=$24;
    break;
   }
  } else {
   $17=(($14+4)|0);
   $18=((HEAP32[(($17)>>2)])|0);
   $19=(($14+8)|0);
   HEAP32[(($19)>>2)]=$18;
   $20=((HEAP32[(($13)>>2)])|0);
   $21=((HEAP32[((11440)>>2)])|0);
   $22=(($21+4)|0);
   HEAP32[(($22)>>2)]=$20;
  }
 } while(0);
 $30=((HEAP32[((11440)>>2)])|0);
 $31=(($30+4)|0);
 $32=((HEAP32[(($31)>>2)])|0);
 $33=(($32+8)|0);
 $34=((HEAP32[(($33)>>2)])|0);
 $35=(($34+$5)|0);
 HEAP32[(($33)>>2)]=$35;
 $_0=$34;

 return (($_0)|0);
}


function _AllocSetPool($newpool){
 $newpool=($newpool)|0;
 var $1=0,$2=0,$3=0,label=0;

 $1=((HEAP32[((11440)>>2)])|0);
 $2=$1;
 $3=$newpool;
 HEAP32[((11440)>>2)]=$3;
 return (($2)|0);
}


function _AllocReset(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,label=0;

 $1=((HEAP32[((11440)>>2)])|0);
 $2=(($1)|0);
 $3=((HEAP32[(($2)>>2)])|0);
 $4=(($1+4)|0);
 HEAP32[(($4)>>2)]=$3;
 $5=((HEAP32[((11440)>>2)])|0);
 $6=(($5+4)|0);
 $7=((HEAP32[(($6)>>2)])|0);
 $8=(($7+4)|0);
 $9=((HEAP32[(($8)>>2)])|0);
 $10=(($7+8)|0);
 HEAP32[(($10)>>2)]=$9;
 return;
}


function _AllocFreePool(){
 var $1=0,$2=0,$3=0,$4=0,$hdr_04=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,label=0;

 $1=((HEAP32[((11440)>>2)])|0);
 $2=(($1)|0);
 $3=((HEAP32[(($2)>>2)])|0);
 $4=($3|0)==0;
 if (!($4)) {
  $hdr_04=$3;
  while(1) {

   $5=(($hdr_04)|0);
   $6=((HEAP32[(($5)>>2)])|0);
   $7=(($hdr_04+4)|0);
   $8=((HEAP32[(($7)>>2)])|0);
   _free($8);
   $9=$hdr_04;
   _free($9);
   $10=($6|0)==0;
   if ($10) {
    break;
   } else {
    $hdr_04=$6;
   }
  }
 }
 $11=((HEAP32[((11440)>>2)])|0);
 $12=$11;
 _free($12);
 HEAP32[((11440)>>2)]=0;
 return;
}


function _savenetdata(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$15=0,$16=0,$18=0,$19=0,$21=0,$22=0,$23=0;
 var $24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0,$40=0,$41=0,$42=0,$43=0;
 var $44=0,$45=0,$46=0,$47=0,$48=0,$49=0,$50=0,$51=0,$52=0,$53=0,$54=0,$55=0,$56=0,$57=0,$58=0,$59=0,$60=0,$61=0,$62=0,$63=0;
 var $64=0,$65=0,$66=0,$67=0,$68=0,$69=0,$70=0,$71=0,$72=0,$73=0,$74=0,$75=0,$76=0,$77=0,$78=0,$79=0,$80=0,$81=0,$82=0,$83=0;
 var $84=0,$85=0,$i_0127=0,$86=0,$87=0,$88=0,$89=0,$90=0,$91=0,$92=0,$93=0,$i_1125=0,$94=0,$95=0,$96=0,$97=0,$98=0,$99=0,$100=0,$i_2120=0;
 var $101=0,$102=0,$103=0,$104=0,$105=0,$106=0,$107=0,$_lcssa119=0,$108=0,$109=0,$110=0,$111=0,$i_3114=0,$112=0,$113=0,$114=0,$115=0,$116=0,$117=0,$118=0;
 var $_lcssa113=0,$119=0,$120=0,$121=0,$122=0,$i_4108=0,$123=0,$124=0,$125=0,$126=0,$127=0,$128=0,$129=0,$130=0,$_lcssa107=0,$131=0,$132=0,$133=0,$134=0,$i_5102=0;
 var $135=0,$136=0,$137=0,$138=0,$139=0,$140=0,$141=0,$_lcssa101=0,$142=0,$143=0,$144=0,$145=0,$i_696=0,$146=0,$147=0,$148=.0,$149=.0,$150=0,$151=0,$152=0;
 var $153=0,$_lcssa95=0,$154=0,$155=0,$156=0,$157=0,$158=0,$i_790=0,$159=0,$160=0,$161=.0,$162=.0,$163=.0,$164=.0,$165=0,$166=0,$167=0,$168=0,$_lcssa89=0,$169=0;
 var $170=0,$171=0,$172=0,$i_884=0,$173=0,$174=0,$175=.0,$176=.0,$177=.0,$178=.0,$179=0,$180=0,$181=0,$182=0,$_lcssa83=0,$183=0,$184=0,$185=0,$186=0,$i_982=0;
 var $187=0,$188=0,$189=0,$190=0,$192=0,$193=.0,$194=.0,$195=.0,$196=.0,$197=0,$199=0,$201=0,$202=0,$203=0,$_lcssa=0,$204=0,$205=0,$206=0,$207=0,$_=0;
 var $errcode_0=0,$209=0,$210=0,label=0;

 $1=((HEAP32[((14416)>>2)])|0);
 $2=((HEAP32[((14424)>>2)])|0);
 $3=($1|0)>=($2|0);
 $4=($3?$1:$2);
 $5=((($4)+(1))|0);
 $6=($5|0)<15;
 $7=($6?15:$5);
 $8=((_calloc($7,4))|0);
 $9=$8;
 $10=((_calloc($7,4))|0);
 $11=$10;
 $12=($8|0)==0;
 $13=($12?101:0);
 if ($12) {
  $18=$13;
 } else {
  $15=($10|0)==0;
  $16=($15?101:0);
  $18=$16;
 }

 $19=($18|0)==0;
 if (!($19)) {
  $errcode_0=$18;

  _free($9);
  _free($11);
  return (($errcode_0)|0);
 }
 HEAP32[(($9)>>2)]=516114521;
 $21=(($8+4)|0);
 $22=$21;
 HEAP32[(($22)>>2)]=20012;
 $23=((HEAP32[((14416)>>2)])|0);
 $24=(($8+8)|0);
 $25=$24;
 HEAP32[(($25)>>2)]=$23;
 $26=((HEAP32[((14352)>>2)])|0);
 $27=(($8+12)|0);
 $28=$27;
 HEAP32[(($28)>>2)]=$26;
 $29=((HEAP32[((14424)>>2)])|0);
 $30=(($8+16)|0);
 $31=$30;
 HEAP32[(($31)>>2)]=$29;
 $32=((HEAP32[((14368)>>2)])|0);
 $33=(($8+20)|0);
 $34=$33;
 HEAP32[(($34)>>2)]=$32;
 $35=((HEAP32[((14328)>>2)])|0);
 $36=(($8+24)|0);
 $37=$36;
 HEAP32[(($37)>>2)]=$35;
 $38=((HEAP8[(13856)])|0);
 $39=(($38<<24)>>24);
 $40=(($8+28)|0);
 $41=$40;
 HEAP32[(($41)>>2)]=$39;
 $42=((HEAP32[((12224)>>2)])|0);
 $43=(($8+32)|0);
 $44=$43;
 HEAP32[(($44)>>2)]=$42;
 $45=((HEAP8[(15632)])|0);
 $46=(($45<<24)>>24);
 $47=(($8+36)|0);
 $48=$47;
 HEAP32[(($48)>>2)]=$46;
 $49=((HEAP8[(13928)])|0);
 $50=(($49<<24)>>24);
 $51=(($8+40)|0);
 $52=$51;
 HEAP32[(($52)>>2)]=$50;
 $53=((HEAP8[(12208)])|0);
 $54=(($53<<24)>>24);
 $55=(($8+44)|0);
 $56=$55;
 HEAP32[(($56)>>2)]=$54;
 $57=((HEAP32[((13280)>>2)])|0);
 $58=(($8+48)|0);
 $59=$58;
 HEAP32[(($59)>>2)]=$57;
 $60=((HEAP32[((13272)>>2)])|0);
 $61=(($8+52)|0);
 $62=$61;
 HEAP32[(($62)>>2)]=$60;
 $63=((HEAP32[((17544)>>2)])|0);
 $64=(($8+56)|0);
 $65=$64;
 HEAP32[(($65)>>2)]=$63;
 $66=((HEAP32[((14280)>>2)])|0);
 $67=((_fwrite((($8)|0),((4)|0),((15)|0),(($66)|0)))|0);
 $68=((HEAP32[((14280)>>2)])|0);
 $69=((_fwrite(((12928)|0),((1)|0),((80)|0),(($68)|0)))|0);
 $70=((HEAP32[((14280)>>2)])|0);
 $71=((_fwrite(((13008)|0),((1)|0),((80)|0),(($70)|0)))|0);
 $72=((HEAP32[((14280)>>2)])|0);
 $73=((_fwrite(((13088)|0),((1)|0),((80)|0),(($72)|0)))|0);
 $74=((HEAP32[((14280)>>2)])|0);
 $75=((_fwrite(((15008)|0),((1)|0),((260)|0),(($74)|0)))|0);
 $76=((HEAP32[((14280)>>2)])|0);
 $77=((_fwrite(((13304)|0),((1)|0),((260)|0),(($76)|0)))|0);
 $78=((HEAP32[((14280)>>2)])|0);
 $79=((_fwrite(((17696)|0),((1)|0),((32)|0),(($78)|0)))|0);
 $80=((HEAP32[((14280)>>2)])|0);
 $81=((_fwrite(((16040)|0),((1)|0),((32)|0),(($80)|0)))|0);
 $82=((HEAP32[((14416)>>2)])|0);
 $83=($82|0)<1;
 if (!($83)) {
  $i_0127=1;
  while(1) {

   $86=((HEAP32[((14408)>>2)])|0);
   $87=(($86+((($i_0127)*(72))&-1))|0);
   $88=((HEAP32[((14280)>>2)])|0);
   $89=((_fwrite((($87)|0),((32)|0),((1)|0),(($88)|0)))|0);
   $90=((($i_0127)+(1))|0);
   $91=((HEAP32[((14416)>>2)])|0);
   $92=($90|0)>($91|0);
   if ($92) {
    break;
   } else {
    $i_0127=$90;
   }
  }
 }
 $84=((HEAP32[((14424)>>2)])|0);
 $85=($84|0)<1;
 do {
  if ($85) {
   $_lcssa119=$84;
  } else {
   $i_1125=1;
   while(1) {

    $94=((HEAP32[((14960)>>2)])|0);
    $95=(($94+((($i_1125)*(104))&-1))|0);
    $96=((HEAP32[((14280)>>2)])|0);
    $97=((_fwrite((($95)|0),((32)|0),((1)|0),(($96)|0)))|0);
    $98=((($i_1125)+(1))|0);
    $99=((HEAP32[((14424)>>2)])|0);
    $100=($98|0)>($99|0);
    if ($100) {
     break;
    } else {
     $i_1125=$98;
    }
   }
   $93=($99|0)<1;
   if ($93) {
    $_lcssa119=$99;
    break;
   } else {
    $i_2120=1;
   }
   while(1) {

    $101=((HEAP32[((14960)>>2)])|0);
    $102=(($101+((($i_2120)*(104))&-1)+32)|0);
    $103=((HEAP32[(($102)>>2)])|0);
    $104=(($9+($i_2120<<2))|0);
    HEAP32[(($104)>>2)]=$103;
    $105=((($i_2120)+(1))|0);
    $106=((HEAP32[((14424)>>2)])|0);
    $107=($105|0)>($106|0);
    if ($107) {
     $_lcssa119=$106;
     break;
    } else {
     $i_2120=$105;
    }
   }
  }
 } while(0);

 $108=((HEAP32[((14280)>>2)])|0);
 $109=((_fwrite((($21)|0),((4)|0),(($_lcssa119)|0),(($108)|0)))|0);
 $110=((HEAP32[((14424)>>2)])|0);
 $111=($110|0)<1;
 if ($111) {
  $_lcssa113=$110;
 } else {
  $i_3114=1;
  while(1) {

   $112=((HEAP32[((14960)>>2)])|0);
   $113=(($112+((($i_3114)*(104))&-1)+36)|0);
   $114=((HEAP32[(($113)>>2)])|0);
   $115=(($9+($i_3114<<2))|0);
   HEAP32[(($115)>>2)]=$114;
   $116=((($i_3114)+(1))|0);
   $117=((HEAP32[((14424)>>2)])|0);
   $118=($116|0)>($117|0);
   if ($118) {
    $_lcssa113=$117;
    break;
   } else {
    $i_3114=$116;
   }
  }
 }

 $119=((HEAP32[((14280)>>2)])|0);
 $120=((_fwrite((($21)|0),((4)|0),(($_lcssa113)|0),(($119)|0)))|0);
 $121=((HEAP32[((14424)>>2)])|0);
 $122=($121|0)<1;
 if ($122) {
  $_lcssa107=$121;
 } else {
  $i_4108=1;
  while(1) {

   $123=((HEAP32[((14960)>>2)])|0);
   $124=(($123+((($i_4108)*(104))&-1)+96)|0);
   $125=((HEAP8[($124)])|0);
   $126=(($125<<24)>>24);
   $127=(($9+($i_4108<<2))|0);
   HEAP32[(($127)>>2)]=$126;
   $128=((($i_4108)+(1))|0);
   $129=((HEAP32[((14424)>>2)])|0);
   $130=($128|0)>($129|0);
   if ($130) {
    $_lcssa107=$129;
    break;
   } else {
    $i_4108=$128;
   }
  }
 }

 $131=((HEAP32[((14280)>>2)])|0);
 $132=((_fwrite((($21)|0),((4)|0),(($_lcssa107)|0),(($131)|0)))|0);
 $133=((HEAP32[((14352)>>2)])|0);
 $134=($133|0)<1;
 if ($134) {
  $_lcssa101=$133;
 } else {
  $i_5102=1;
  while(1) {

   $135=((HEAP32[((13176)>>2)])|0);
   $136=(($135+((($i_5102)*(112))&-1))|0);
   $137=((HEAP32[(($136)>>2)])|0);
   $138=(($9+($i_5102<<2))|0);
   HEAP32[(($138)>>2)]=$137;
   $139=((($i_5102)+(1))|0);
   $140=((HEAP32[((14352)>>2)])|0);
   $141=($139|0)>($140|0);
   if ($141) {
    $_lcssa101=$140;
    break;
   } else {
    $i_5102=$139;
   }
  }
 }

 $142=((HEAP32[((14280)>>2)])|0);
 $143=((_fwrite((($21)|0),((4)|0),(($_lcssa101)|0),(($142)|0)))|0);
 $144=((HEAP32[((14352)>>2)])|0);
 $145=($144|0)<1;
 if ($145) {
  $_lcssa95=$144;
 } else {
  $i_696=1;
  while(1) {

   $146=((HEAP32[((13176)>>2)])|0);
   $147=(($146+((($i_696)*(112))&-1)+8)|0);
   $148=(+(HEAPF64[(($147)>>3)]));
   $149=$148;
   $150=(($11+($i_696<<2))|0);
   HEAPF32[(($150)>>2)]=$149;
   $151=((($i_696)+(1))|0);
   $152=((HEAP32[((14352)>>2)])|0);
   $153=($151|0)>($152|0);
   if ($153) {
    $_lcssa95=$152;
    break;
   } else {
    $i_696=$151;
   }
  }
 }

 $154=(($10+4)|0);
 $155=((HEAP32[((14280)>>2)])|0);
 $156=((_fwrite((($154)|0),((4)|0),(($_lcssa95)|0),(($155)|0)))|0);
 $157=((HEAP32[((14416)>>2)])|0);
 $158=($157|0)<1;
 if ($158) {
  $_lcssa89=$157;
 } else {
  $i_790=1;
  while(1) {

   $159=((HEAP32[((14408)>>2)])|0);
   $160=(($159+((($i_790)*(72))&-1)+32)|0);
   $161=(+(HEAPF64[(($160)>>3)]));
   $162=(+(HEAPF64[((12040)>>3)]));
   $163=($161)*($162);
   $164=$163;
   $165=(($11+($i_790<<2))|0);
   HEAPF32[(($165)>>2)]=$164;
   $166=((($i_790)+(1))|0);
   $167=((HEAP32[((14416)>>2)])|0);
   $168=($166|0)>($167|0);
   if ($168) {
    $_lcssa89=$167;
    break;
   } else {
    $i_790=$166;
   }
  }
 }

 $169=((HEAP32[((14280)>>2)])|0);
 $170=((_fwrite((($154)|0),((4)|0),(($_lcssa89)|0),(($169)|0)))|0);
 $171=((HEAP32[((14424)>>2)])|0);
 $172=($171|0)<1;
 if ($172) {
  $_lcssa83=$171;
 } else {
  $i_884=1;
  while(1) {

   $173=((HEAP32[((14960)>>2)])|0);
   $174=(($173+((($i_884)*(104))&-1)+48)|0);
   $175=(+(HEAPF64[(($174)>>3)]));
   $176=(+(HEAPF64[((12040)>>3)]));
   $177=($175)*($176);
   $178=$177;
   $179=(($11+($i_884<<2))|0);
   HEAPF32[(($179)>>2)]=$178;
   $180=((($i_884)+(1))|0);
   $181=((HEAP32[((14424)>>2)])|0);
   $182=($180|0)>($181|0);
   if ($182) {
    $_lcssa83=$181;
    break;
   } else {
    $i_884=$180;
   }
  }
 }

 $183=((HEAP32[((14280)>>2)])|0);
 $184=((_fwrite((($154)|0),((4)|0),(($_lcssa83)|0),(($183)|0)))|0);
 $185=((HEAP32[((14424)>>2)])|0);
 $186=($185|0)<1;
 if ($186) {
  $_lcssa=$185;
 } else {
  $i_982=1;
  while(1) {

   $187=((HEAP32[((14960)>>2)])|0);
   $188=(($187+((($i_982)*(104))&-1)+96)|0);
   $189=((HEAP8[($188)])|0);
   $190=(($189<<24)>>24)==2;
   if ($190) {
    $199=(($11+($i_982<<2))|0);
    HEAPF32[(($199)>>2)]=0.0;
   } else {
    $192=(($187+((($i_982)*(104))&-1)+40)|0);
    $193=(+(HEAPF64[(($192)>>3)]));
    $194=(+(HEAPF64[((12088)>>3)]));
    $195=($193)*($194);
    $196=$195;
    $197=(($11+($i_982<<2))|0);
    HEAPF32[(($197)>>2)]=$196;
   }
   $201=((($i_982)+(1))|0);
   $202=((HEAP32[((14424)>>2)])|0);
   $203=($201|0)>($202|0);
   if ($203) {
    $_lcssa=$202;
    break;
   } else {
    $i_982=$201;
   }
  }
 }

 $204=((HEAP32[((14280)>>2)])|0);
 $205=((_fwrite((($154)|0),((4)|0),(($_lcssa)|0),(($204)|0)))|0);
 $206=((HEAP32[((14424)>>2)])|0);
 $207=($205>>>0)<($206>>>0);
 $_=($207?308:$18);
 $errcode_0=$_;

 _free($9);
 _free($11);
 return (($errcode_0)|0);
}


function _savehyd($htime){
 $htime=($htime)|0;
 var $t=0,$1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$i_054=0,$16=0,$17=0,$18=.0,$19=.0;
 var $20=0,$21=0,$22=0,$23=0,$_lcssa53=0,$24=0,$25=0,$26=0,$27=0,$28=0,$i_148=0,$29=0,$30=0,$31=.0,$32=.0,$33=0,$34=0,$35=0,$36=0,$_lcssa47=0;
 var $37=0,$38=0,$39=0,$40=0,$i_242=0,$41=0,$42=0,$43=0,$44=0,$46=0,$48=0,$49=0,$50=.0,$51=.0,$52=0,$54=0,$55=0,$56=0,$_lcssa41=0,$57=0;
 var $58=0,$59=0,$60=0,$i_336=0,$61=0,$62=0,$63=0,$64=.0,$65=0,$66=0,$67=0,$68=0,$_lcssa35=0,$69=0,$70=0,$71=0,$72=0,$i_434=0,$73=0,$74=0;
 var $75=.0,$76=.0,$77=0,$78=0,$79=0,$80=0,$_lcssa=0,$81=0,$82=0,$83=0,$84=0,$_=0,$85=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $t=((sp)|0);
 $1=((HEAP32[((14416)>>2)])|0);
 $2=((HEAP32[((14424)>>2)])|0);
 $3=($1|0)>=($2|0);
 $4=($3?$1:$2);
 $5=((($4)+(1))|0);
 $6=((_calloc($5,4))|0);
 $7=$6;
 $8=($6|0)==0;
 if ($8) {
  $_0=101;

  STACKTOP=sp;return (($_0)|0);
 }
 $10=((HEAP32[(($htime)>>2)])|0);
 HEAP32[(($t)>>2)]=$10;
 $11=$t;
 $12=((HEAP32[((15568)>>2)])|0);
 $13=((_fwrite((($11)|0),((4)|0),((1)|0),(($12)|0)))|0);
 $14=((HEAP32[((14416)>>2)])|0);
 $15=($14|0)<1;
 if ($15) {
  $_lcssa53=$14;
 } else {
  $i_054=1;
  while(1) {

   $16=((HEAP32[((17632)>>2)])|0);
   $17=(($16+($i_054<<3))|0);
   $18=(+(HEAPF64[(($17)>>3)]));
   $19=$18;
   $20=(($7+($i_054<<2))|0);
   HEAPF32[(($20)>>2)]=$19;
   $21=((($i_054)+(1))|0);
   $22=((HEAP32[((14416)>>2)])|0);
   $23=($21|0)>($22|0);
   if ($23) {
    $_lcssa53=$22;
    break;
   } else {
    $i_054=$21;
   }
  }
 }

 $24=(($6+4)|0);
 $25=((HEAP32[((15568)>>2)])|0);
 $26=((_fwrite((($24)|0),((4)|0),(($_lcssa53)|0),(($25)|0)))|0);
 $27=((HEAP32[((14416)>>2)])|0);
 $28=($27|0)<1;
 if ($28) {
  $_lcssa47=$27;
 } else {
  $i_148=1;
  while(1) {

   $29=((HEAP32[((15600)>>2)])|0);
   $30=(($29+($i_148<<3))|0);
   $31=(+(HEAPF64[(($30)>>3)]));
   $32=$31;
   $33=(($7+($i_148<<2))|0);
   HEAPF32[(($33)>>2)]=$32;
   $34=((($i_148)+(1))|0);
   $35=((HEAP32[((14416)>>2)])|0);
   $36=($34|0)>($35|0);
   if ($36) {
    $_lcssa47=$35;
    break;
   } else {
    $i_148=$34;
   }
  }
 }

 $37=((HEAP32[((15568)>>2)])|0);
 $38=((_fwrite((($24)|0),((4)|0),(($_lcssa47)|0),(($37)|0)))|0);
 $39=((HEAP32[((14424)>>2)])|0);
 $40=($39|0)<1;
 if ($40) {
  $_lcssa41=$39;
 } else {
  $i_242=1;
  while(1) {

   $41=((HEAP32[((13232)>>2)])|0);
   $42=(($41+$i_242)|0);
   $43=((HEAP8[($42)])|0);
   $44=(($43<<24)>>24)<3;
   if ($44) {
    $46=(($7+($i_242<<2))|0);
    HEAPF32[(($46)>>2)]=0.0;
   } else {
    $48=((HEAP32[((13880)>>2)])|0);
    $49=(($48+($i_242<<3))|0);
    $50=(+(HEAPF64[(($49)>>3)]));
    $51=$50;
    $52=(($7+($i_242<<2))|0);
    HEAPF32[(($52)>>2)]=$51;
   }
   $54=((($i_242)+(1))|0);
   $55=((HEAP32[((14424)>>2)])|0);
   $56=($54|0)>($55|0);
   if ($56) {
    $_lcssa41=$55;
    break;
   } else {
    $i_242=$54;
   }
  }
 }

 $57=((HEAP32[((15568)>>2)])|0);
 $58=((_fwrite((($24)|0),((4)|0),(($_lcssa41)|0),(($57)|0)))|0);
 $59=((HEAP32[((14424)>>2)])|0);
 $60=($59|0)<1;
 if ($60) {
  $_lcssa35=$59;
 } else {
  $i_336=1;
  while(1) {

   $61=((HEAP32[((13232)>>2)])|0);
   $62=(($61+$i_336)|0);
   $63=((HEAP8[($62)])|0);
   $64=(+(((($63<<24)>>24))|0));
   $65=(($7+($i_336<<2))|0);
   HEAPF32[(($65)>>2)]=$64;
   $66=((($i_336)+(1))|0);
   $67=((HEAP32[((14424)>>2)])|0);
   $68=($66|0)>($67|0);
   if ($68) {
    $_lcssa35=$67;
    break;
   } else {
    $i_336=$66;
   }
  }
 }

 $69=((HEAP32[((15568)>>2)])|0);
 $70=((_fwrite((($24)|0),((4)|0),(($_lcssa35)|0),(($69)|0)))|0);
 $71=((HEAP32[((14424)>>2)])|0);
 $72=($71|0)<1;
 if ($72) {
  $_lcssa=$71;
 } else {
  $i_434=1;
  while(1) {

   $73=((HEAP32[((15000)>>2)])|0);
   $74=(($73+($i_434<<3))|0);
   $75=(+(HEAPF64[(($74)>>3)]));
   $76=$75;
   $77=(($7+($i_434<<2))|0);
   HEAPF32[(($77)>>2)]=$76;
   $78=((($i_434)+(1))|0);
   $79=((HEAP32[((14424)>>2)])|0);
   $80=($78|0)>($79|0);
   if ($80) {
    $_lcssa=$79;
    break;
   } else {
    $i_434=$78;
   }
  }
 }

 $81=((HEAP32[((15568)>>2)])|0);
 $82=((_fwrite((($24)|0),((4)|0),(($_lcssa)|0),(($81)|0)))|0);
 $83=((HEAP32[((14424)>>2)])|0);
 $84=($82>>>0)<($83>>>0);
 $_=($84?308:0);
 _free($7);
 $_0=$_;

 STACKTOP=sp;return (($_0)|0);
}


function _savehydstep($hydstep){
 $hydstep=($hydstep)|0;
 var $t=0,$1=0,$2=0,$3=0,$4=0,$5=0,$_=0,$6=0,$7=0,$9=0,$10=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $t=((sp)|0);
 $1=((HEAP32[(($hydstep)>>2)])|0);
 HEAP32[(($t)>>2)]=$1;
 $2=$t;
 $3=((HEAP32[((15568)>>2)])|0);
 $4=((_fwrite((($2)|0),((4)|0),((1)|0),(($3)|0)))|0);
 $5=($4|0)==0;
 $_=($5?308:0);
 $6=((HEAP32[(($t)>>2)])|0);
 $7=($6|0)==0;
 if (!($7)) {
  STACKTOP=sp;return (($_)|0);
 }
 $9=((HEAP32[((15568)>>2)])|0);
 $10=((_fputc(((26)|0),(($9)|0)))|0);
 STACKTOP=sp;return (($_)|0);
}


function _saveenergy(){
 var $index=0,$x=0,$1=0,$2=.0,$3=.0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$i_0=0,$18=0;
 var $19=0,$21=0,$22=0,$23=.0,$25=.0,$26=0,$27=0,$28=.0,$29=.0,$30=0,$31=0,$32=.0,$33=.0,$34=0,$35=0,$36=.0,$37=.0,$38=0,$39=0,$40=.0;
 var $41=.0,$42=0,$43=0,$44=.0,$45=.0,$46=.0,$48=.0,$49=.0,$50=0,$51=0,$53=0,$54=0,$55=.0,$56=.0,$57=.0,$58=0,$59=0,$60=.0,$61=.0,$62=.0;
 var $63=0,$64=0,$65=.0,$66=.0,$67=.0,$69=0,$70=0,$71=.0,$72=.0,$73=0,$74=0,$75=.0,$76=.0,$77=.0,$78=.0,$80=.0,$81=.0,$82=.0,$83=.0,$84=0;
 var $85=0,$86=.0,$88=.0,$90=.0,$storemerge=.0,$92=0,$93=.0,$94=.0,$95=0,$96=0,$97=0,$98=.0,$99=.0,$100=0,$101=0,$102=0,$103=.0,$104=.0,$105=0,$106=0;
 var $107=0,$108=.0,$109=.0,$110=0,$111=0,$112=0,$113=.0,$114=.0,$115=0,$116=0,$117=0,$118=.0,$119=.0,$120=0,$121=0,$122=0,$123=0,$124=0,$125=0,$126=0;
 var $127=0,$129=0,$130=0,$131=0,$132=0,$134=.0,$135=.0,$136=.0,$137=.0,$138=0,$139=0,$140=0,$141=0,$142=0,$_=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+32)|0;
 $index=((sp)|0);
 $x=(((sp)+(8))|0);
 $1=((HEAP32[((17544)>>2)])|0);
 $2=(+((($1|0))|0));
 $3=($2)/((3600.0));
 $4=$3==(0.0);
 $5=(($x)|0);
 $6=(($x+4)|0);
 $7=(($x+8)|0);
 $8=$index;
 $9=$x;
 $10=(($x)|0);
 $11=(($x+4)|0);
 $12=(($x+8)|0);
 $13=(($x+12)|0);
 $14=(($x+16)|0);
 $15=(($x+20)|0);
 $16=(($x+20)|0);
 $i_0=1;
 while(1) {

  $18=((HEAP32[((14368)>>2)])|0);
  $19=($i_0|0)>($18|0);
  if ($19) {
   label = 13;
   break;
  }
  $21=((HEAP32[((13888)>>2)])|0);
  $22=(($21+($i_0<<7)+80)|0);
  $23=(+(HEAPF64[(($22)>>3)]));
  if ($4) {
   $25=$23;
   $26=(($x)|0);
   HEAPF32[(($26)>>2)]=$25;
   $27=(($21+($i_0<<7)+88)|0);
   $28=(+(HEAPF64[(($27)>>3)]));
   $29=$28;
   $30=(($x+4)|0);
   HEAPF32[(($30)>>2)]=$29;
   $31=(($21+($i_0<<7)+96)|0);
   $32=(+(HEAPF64[(($31)>>3)]));
   $33=$32;
   $34=(($x+8)|0);
   HEAPF32[(($34)>>2)]=$33;
   $35=(($21+($i_0<<7)+104)|0);
   $36=(+(HEAPF64[(($35)>>3)]));
   $37=$36;
   $38=(($x+12)|0);
   HEAPF32[(($38)>>2)]=$37;
   $39=(($21+($i_0<<7)+112)|0);
   $40=(+(HEAPF64[(($39)>>3)]));
   $41=$40;
   $42=(($x+16)|0);
   HEAPF32[(($42)>>2)]=$41;
   $43=(($21+($i_0<<7)+120)|0);
   $44=(+(HEAPF64[(($43)>>3)]));
   $45=($44)*((24.0));
   $46=$45;
   HEAPF32[(($16)>>2)]=$46;
  } else {
   $48=($23)/($3);
   $49=$48;
   HEAPF32[(($10)>>2)]=$49;
   $50=$23>(0.0);
   $51=$11;
   _memset((((($51)|0))|0), ((((0)|0))|0), ((((16)|0))|0))|0;
   if ($50) {
    $53=((HEAP32[((13888)>>2)])|0);
    $54=(($53+($i_0<<7)+88)|0);
    $55=(+(HEAPF64[(($54)>>3)]));
    $56=($55)/($23);
    $57=$56;
    HEAPF32[(($11)>>2)]=$57;
    $58=((HEAP32[((13888)>>2)])|0);
    $59=(($58+($i_0<<7)+96)|0);
    $60=(+(HEAPF64[(($59)>>3)]));
    $61=($60)/($23);
    $62=$61;
    HEAPF32[(($12)>>2)]=$62;
    $63=((HEAP32[((13888)>>2)])|0);
    $64=(($63+($i_0<<7)+104)|0);
    $65=(+(HEAPF64[(($64)>>3)]));
    $66=($65)/($23);
    $67=$66;
    HEAPF32[(($13)>>2)]=$67;
   }
   $69=((HEAP32[((13888)>>2)])|0);
   $70=(($69+($i_0<<7)+112)|0);
   $71=(+(HEAPF64[(($70)>>3)]));
   $72=$71;
   HEAPF32[(($14)>>2)]=$72;
   $73=((HEAP32[((13888)>>2)])|0);
   $74=(($73+($i_0<<7)+120)|0);
   $75=(+(HEAPF64[(($74)>>3)]));
   $76=($75)*((24.0));
   $77=($76)/($3);
   $78=$77;
   HEAPF32[(($15)>>2)]=$78;
  }
  $80=(+(HEAPF32[(($5)>>2)]));
  $81=($80)*((100.0));
  HEAPF32[(($5)>>2)]=$81;
  $82=(+(HEAPF32[(($6)>>2)]));
  $83=($82)*((100.0));
  HEAPF32[(($6)>>2)]=$83;
  $84=((HEAP8[(12032)])|0);
  $85=(($84<<24)>>24)==1;
  $86=(+(HEAPF32[(($7)>>2)]));
  if ($85) {
   $88=($86)*((0.009809576906263828));
   $storemerge=$88;
  } else {
   $90=($86)*((37.13350296020508));
   $storemerge=$90;
  }

  HEAPF32[(($7)>>2)]=$storemerge;
  $92=(($x)|0);
  $93=(+(HEAPF32[(($92)>>2)]));
  $94=$93;
  $95=((HEAP32[((13888)>>2)])|0);
  $96=(($95+($i_0<<7)+80)|0);
  HEAPF64[(($96)>>3)]=$94;
  $97=(($x+4)|0);
  $98=(+(HEAPF32[(($97)>>2)]));
  $99=$98;
  $100=((HEAP32[((13888)>>2)])|0);
  $101=(($100+($i_0<<7)+88)|0);
  HEAPF64[(($101)>>3)]=$99;
  $102=(($x+8)|0);
  $103=(+(HEAPF32[(($102)>>2)]));
  $104=$103;
  $105=((HEAP32[((13888)>>2)])|0);
  $106=(($105+($i_0<<7)+96)|0);
  HEAPF64[(($106)>>3)]=$104;
  $107=(($x+12)|0);
  $108=(+(HEAPF32[(($107)>>2)]));
  $109=$108;
  $110=((HEAP32[((13888)>>2)])|0);
  $111=(($110+($i_0<<7)+104)|0);
  HEAPF64[(($111)>>3)]=$109;
  $112=(($x+16)|0);
  $113=(+(HEAPF32[(($112)>>2)]));
  $114=$113;
  $115=((HEAP32[((13888)>>2)])|0);
  $116=(($115+($i_0<<7)+112)|0);
  HEAPF64[(($116)>>3)]=$114;
  $117=(($x+20)|0);
  $118=(+(HEAPF32[(($117)>>2)]));
  $119=$118;
  $120=((HEAP32[((13888)>>2)])|0);
  $121=(($120+($i_0<<7)+120)|0);
  HEAPF64[(($121)>>3)]=$119;
  $122=((HEAP32[((13888)>>2)])|0);
  $123=(($122+($i_0<<7))|0);
  $124=((HEAP32[(($123)>>2)])|0);
  HEAP32[(($index)>>2)]=$124;
  $125=((HEAP32[((14280)>>2)])|0);
  $126=((_fwrite((($8)|0),((4)|0),((1)|0),(($125)|0)))|0);
  $127=($126|0)==0;
  if ($127) {
   $_0=308;
   label = 14;
   break;
  }
  $129=((HEAP32[((14280)>>2)])|0);
  $130=((_fwrite((($9)|0),((4)|0),((6)|0),(($129)|0)))|0);
  $131=($130>>>0)<((6)>>>0);
  $132=((($i_0)+(1))|0);
  if ($131) {
   $_0=308;
   label = 14;
   break;
  } else {
   $i_0=$132;
  }
 }
 if ((label|0) == 13) {
  $134=(+(HEAPF64[((11344)>>3)]));
  $135=(+(HEAPF64[((11384)>>3)]));
  $136=($134)*($135);
  HEAPF64[((11344)>>3)]=$136;
  $137=$136;
  $138=(($x)|0);
  HEAPF32[(($138)>>2)]=$137;
  $139=$x;
  $140=((HEAP32[((14280)>>2)])|0);
  $141=((_fwrite((($139)|0),((4)|0),((1)|0),(($140)|0)))|0);
  $142=($141|0)==0;
  $_=($142?308:0);
  $_0=$_;

  STACKTOP=sp;return (($_0)|0);
 }
 else if ((label|0) == 14) {

  STACKTOP=sp;return (($_0)|0);
 }
  return 0;
}


function _readhyd($hydtime){
 $hydtime=($hydtime)|0;
 var $t=0,$1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$10=0,$11=0,$12=0,$not_=0,$_=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0;
 var $19=0,$20=0,$21=0,$i_047=0,$22=0,$23=.0,$24=.0,$25=0,$26=0,$27=0,$28=0,$29=0,$result_1=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0;
 var $i_143=0,$37=0,$38=.0,$39=.0,$40=0,$41=0,$42=0,$43=0,$44=0,$result_2=0,$45=0,$46=0,$47=0,$48=0,$49=0,$50=0,$51=0,$i_239=0,$52=0,$53=.0;
 var $54=.0,$55=0,$56=0,$57=0,$58=0,$59=0,$result_3=0,$60=0,$61=0,$62=0,$63=0,$64=0,$65=0,$66=0,$i_335=0,$67=0,$68=.0,$69=0,$70=0,$71=0;
 var $72=0,$73=0,$74=0,$result_4=0,$75=0,$76=0,$77=0,$78=0,$79=0,$80=0,$81=0,$i_432=0,$82=0,$83=.0,$84=.0,$85=0,$86=0,$87=0,$88=0,$89=0;
 var $result_5=0,$90=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $t=((sp)|0);
 $1=((HEAP32[((14416)>>2)])|0);
 $2=((HEAP32[((14424)>>2)])|0);
 $3=($1|0)>=($2|0);
 $4=($3?$1:$2);
 $5=((($4)+(1))|0);
 $6=((_calloc($5,4))|0);
 $7=$6;
 $8=($6|0)==0;
 if ($8) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $10=$t;
 $11=((HEAP32[((15568)>>2)])|0);
 $12=((_fread((($10)|0),((4)|0),((1)|0),(($11)|0)))|0);
 $not_=($12|0)!=0;
 $_=($not_&1);
 $13=((HEAP32[(($t)>>2)])|0);
 HEAP32[(($hydtime)>>2)]=$13;
 $14=(($6+4)|0);
 $15=((HEAP32[((14416)>>2)])|0);
 $16=((HEAP32[((15568)>>2)])|0);
 $17=((_fread((($14)|0),((4)|0),(($15)|0),(($16)|0)))|0);
 $18=((HEAP32[((14416)>>2)])|0);
 $19=($17>>>0)<($18>>>0);
 do {
  if ($19) {
   $result_1=0;
  } else {
   $20=((HEAP32[((14416)>>2)])|0);
   $21=($20|0)<1;
   if ($21) {
    $result_1=$_;
    break;
   } else {
    $i_047=1;
   }
   while(1) {

    $22=(($7+($i_047<<2))|0);
    $23=(+(HEAPF32[(($22)>>2)]));
    $24=$23;
    $25=((HEAP32[((17632)>>2)])|0);
    $26=(($25+($i_047<<3))|0);
    HEAPF64[(($26)>>3)]=$24;
    $27=((($i_047)+(1))|0);
    $28=((HEAP32[((14416)>>2)])|0);
    $29=($27|0)>($28|0);
    if ($29) {
     $result_1=$_;
     break;
    } else {
     $i_047=$27;
    }
   }
  }
 } while(0);

 $30=((HEAP32[((14416)>>2)])|0);
 $31=((HEAP32[((15568)>>2)])|0);
 $32=((_fread((($14)|0),((4)|0),(($30)|0),(($31)|0)))|0);
 $33=((HEAP32[((14416)>>2)])|0);
 $34=($32>>>0)<($33>>>0);
 do {
  if ($34) {
   $result_2=0;
  } else {
   $35=((HEAP32[((14416)>>2)])|0);
   $36=($35|0)<1;
   if ($36) {
    $result_2=$result_1;
    break;
   } else {
    $i_143=1;
   }
   while(1) {

    $37=(($7+($i_143<<2))|0);
    $38=(+(HEAPF32[(($37)>>2)]));
    $39=$38;
    $40=((HEAP32[((15600)>>2)])|0);
    $41=(($40+($i_143<<3))|0);
    HEAPF64[(($41)>>3)]=$39;
    $42=((($i_143)+(1))|0);
    $43=((HEAP32[((14416)>>2)])|0);
    $44=($42|0)>($43|0);
    if ($44) {
     $result_2=$result_1;
     break;
    } else {
     $i_143=$42;
    }
   }
  }
 } while(0);

 $45=((HEAP32[((14424)>>2)])|0);
 $46=((HEAP32[((15568)>>2)])|0);
 $47=((_fread((($14)|0),((4)|0),(($45)|0),(($46)|0)))|0);
 $48=((HEAP32[((14424)>>2)])|0);
 $49=($47>>>0)<($48>>>0);
 do {
  if ($49) {
   $result_3=0;
  } else {
   $50=((HEAP32[((14424)>>2)])|0);
   $51=($50|0)<1;
   if ($51) {
    $result_3=$result_2;
    break;
   } else {
    $i_239=1;
   }
   while(1) {

    $52=(($7+($i_239<<2))|0);
    $53=(+(HEAPF32[(($52)>>2)]));
    $54=$53;
    $55=((HEAP32[((13880)>>2)])|0);
    $56=(($55+($i_239<<3))|0);
    HEAPF64[(($56)>>3)]=$54;
    $57=((($i_239)+(1))|0);
    $58=((HEAP32[((14424)>>2)])|0);
    $59=($57|0)>($58|0);
    if ($59) {
     $result_3=$result_2;
     break;
    } else {
     $i_239=$57;
    }
   }
  }
 } while(0);

 $60=((HEAP32[((14424)>>2)])|0);
 $61=((HEAP32[((15568)>>2)])|0);
 $62=((_fread((($14)|0),((4)|0),(($60)|0),(($61)|0)))|0);
 $63=((HEAP32[((14424)>>2)])|0);
 $64=($62>>>0)<($63>>>0);
 do {
  if ($64) {
   $result_4=0;
  } else {
   $65=((HEAP32[((14424)>>2)])|0);
   $66=($65|0)<1;
   if ($66) {
    $result_4=$result_3;
    break;
   } else {
    $i_335=1;
   }
   while(1) {

    $67=(($7+($i_335<<2))|0);
    $68=(+(HEAPF32[(($67)>>2)]));
    $69=(~~($68));
    $70=((HEAP32[((13232)>>2)])|0);
    $71=(($70+$i_335)|0);
    HEAP8[($71)]=$69;
    $72=((($i_335)+(1))|0);
    $73=((HEAP32[((14424)>>2)])|0);
    $74=($72|0)>($73|0);
    if ($74) {
     $result_4=$result_3;
     break;
    } else {
     $i_335=$72;
    }
   }
  }
 } while(0);

 $75=((HEAP32[((14424)>>2)])|0);
 $76=((HEAP32[((15568)>>2)])|0);
 $77=((_fread((($14)|0),((4)|0),(($75)|0),(($76)|0)))|0);
 $78=((HEAP32[((14424)>>2)])|0);
 $79=($77>>>0)<($78>>>0);
 do {
  if ($79) {
   $result_5=0;
  } else {
   $80=((HEAP32[((14424)>>2)])|0);
   $81=($80|0)<1;
   if ($81) {
    $result_5=$result_4;
    break;
   } else {
    $i_432=1;
   }
   while(1) {

    $82=(($7+($i_432<<2))|0);
    $83=(+(HEAPF32[(($82)>>2)]));
    $84=$83;
    $85=((HEAP32[((15000)>>2)])|0);
    $86=(($85+($i_432<<3))|0);
    HEAPF64[(($86)>>3)]=$84;
    $87=((($i_432)+(1))|0);
    $88=((HEAP32[((14424)>>2)])|0);
    $89=($87|0)>($88|0);
    if ($89) {
     $result_5=$result_4;
     break;
    } else {
     $i_432=$87;
    }
   }
  }
 } while(0);

 _free($7);
 $_0=$result_5;

 STACKTOP=sp;return (($_0)|0);
}


function _readhydstep($hydstep){
 $hydstep=($hydstep)|0;
 var $t=0,$1=0,$2=0,$3=0,$4=0,$6=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $t=((sp)|0);
 $1=$t;
 $2=((HEAP32[((15568)>>2)])|0);
 $3=((_fread((($1)|0),((4)|0),((1)|0),(($2)|0)))|0);
 $4=($3|0)==0;
 if ($4) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $6=((HEAP32[(($t)>>2)])|0);
 HEAP32[(($hydstep)>>2)]=$6;
 $_0=1;

 STACKTOP=sp;return (($_0)|0);
}


function _saveoutput(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$10=.0,$11=0,$12=0,$14=.0,$15=0,$16=0,$18=.0,$19=0,$20=0,$_0=0,$21=.0,$22=0;
 var $23=0,$25=.0,$26=0,$27=0,$28=.0,$29=0,$30=0,$32=.0,$33=0,$34=0,$35=.0,$36=0,$37=0,$39=.0,$40=0,$41=0,$43=.0,$44=0,$46=.0,$47=0;
 var $48=0,$50=.0,$51=0,$52=0,label=0;

 $1=((HEAP32[((14416)>>2)])|0);
 $2=((HEAP32[((14424)>>2)])|0);
 $3=($1|0)>=($2|0);
 $4=($3?$1:$2);
 $5=((($4)+(1))|0);
 $6=((_calloc($5,4))|0);
 $7=$6;
 $8=($6|0)==0;
 if ($8) {
  $_0=101;

  return (($_0)|0);
 }
 $10=(+(HEAPF64[((12048)>>3)]));
 $11=((_nodeoutput(1,$7,$10))|0);
 $12=($11|0)>100;
 if ($12) {
  $_0=$11;

  return (($_0)|0);
 }
 $46=(+(HEAPF64[((12056)>>3)]));
 $47=((_nodeoutput(2,$7,$46))|0);
 $48=($47|0)>100;
 if ($48) {
  $_0=$47;

  return (($_0)|0);
 }
 $50=(+(HEAPF64[((12064)>>3)]));
 $51=((_nodeoutput(3,$7,$50))|0);
 $52=($51|0)>100;
 if ($52) {
  $_0=$51;

  return (($_0)|0);
 }
 $14=(+(HEAPF64[((12072)>>3)]));
 $15=((_nodeoutput(4,$7,$14))|0);
 $16=($15|0)>100;
 if ($16) {
  $_0=$15;

  return (($_0)|0);
 }
 $18=(+(HEAPF64[((12096)>>3)]));
 $19=((_linkoutput(7,$7,$18))|0);
 $20=($19|0)>100;
 if ($20) {
  $_0=$19;

  return (($_0)|0);
 }
 $21=(+(HEAPF64[((12104)>>3)]));
 $22=((_linkoutput(8,$7,$21))|0);
 $23=($22|0)>100;
 if ($23) {
  $_0=$22;

  return (($_0)|0);
 }
 $25=(+(HEAPF64[((12112)>>3)]));
 $26=((_linkoutput(9,$7,$25))|0);
 $27=($26|0)>100;
 if ($27) {
  $_0=$26;

  return (($_0)|0);
 }
 $28=(+(HEAPF64[((12120)>>3)]));
 $29=((_linkoutput(10,$7,$28))|0);
 $30=($29|0)>100;
 if ($30) {
  $_0=$29;

  return (($_0)|0);
 }
 $32=(+(HEAPF64[((12128)>>3)]));
 $33=((_linkoutput(11,$7,$32))|0);
 $34=($33|0)>100;
 if ($34) {
  $_0=$33;

  return (($_0)|0);
 }
 $35=(+(HEAPF64[((12136)>>3)]));
 $36=((_linkoutput(12,$7,$35))|0);
 $37=($36|0)>100;
 if ($37) {
  $_0=$36;

  return (($_0)|0);
 }
 $39=(+(HEAPF64[((12144)>>3)]));
 $40=((_linkoutput(13,$7,$39))|0);
 $41=($40|0)>100;
 if ($41) {
  $_0=$40;

  return (($_0)|0);
 }
 $43=(+(HEAPF64[((12152)>>3)]));
 $44=((_linkoutput(14,$7,$43))|0);
 $_0=$44;

 return (($_0)|0);
}


function _nodeoutput($j,$x,$ucf){
 $j=($j)|0;
 $x=($x)|0;
 $ucf=+($ucf);
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$i_027=0,$9=0,$10=0,$11=.0,$12=.0,$13=.0,$14=0,$15=0,$16=0,$17=0,$i_130=0,$18=0;
 var $19=0,$20=.0,$21=.0,$22=.0,$23=0,$24=0,$25=0,$26=0,$i_234=0,$27=0,$28=0,$29=.0,$30=0,$31=0,$32=.0,$33=.0,$34=.0,$35=.0,$36=0,$37=0;
 var $38=0,$39=0,$i_338=0,$40=0,$41=0,$42=.0,$43=.0,$44=.0,$45=0,$46=0,$47=0,$48=0,$49=0,$50=0,$51=0,$52=0,$53=0,$54=0,$55=0,$_=0;
 var label=0;

 do {
  if (((($j|0))|0)==((2)|0)) {
   $5=((HEAP32[((14416)>>2)])|0);
   $6=($5|0)<1;
   if ($6) {
    break;
   } else {
    $i_130=1;
   }
   while(1) {

    $18=((HEAP32[((15600)>>2)])|0);
    $19=(($18+($i_130<<3))|0);
    $20=(+(HEAPF64[(($19)>>3)]));
    $21=($20)*($ucf);
    $22=$21;
    $23=(($x+($i_130<<2))|0);
    HEAPF32[(($23)>>2)]=$22;
    $24=((($i_130)+(1))|0);
    $25=((HEAP32[((14416)>>2)])|0);
    $26=($24|0)>($25|0);
    if ($26) {
     break;
    } else {
     $i_130=$24;
    }
   }
  } else if (((($j|0))|0)==((4)|0)) {
   $1=((HEAP32[((14416)>>2)])|0);
   $2=($1|0)<1;
   if ($2) {
    break;
   } else {
    $i_338=1;
   }
   while(1) {

    $40=((HEAP32[((17736)>>2)])|0);
    $41=(($40+($i_338<<3))|0);
    $42=(+(HEAPF64[(($41)>>3)]));
    $43=($42)*($ucf);
    $44=$43;
    $45=(($x+($i_338<<2))|0);
    HEAPF32[(($45)>>2)]=$44;
    $46=((($i_338)+(1))|0);
    $47=((HEAP32[((14416)>>2)])|0);
    $48=($46|0)>($47|0);
    if ($48) {
     break;
    } else {
     $i_338=$46;
    }
   }
  } else if (((($j|0))|0)==((3)|0)) {
   $3=((HEAP32[((14416)>>2)])|0);
   $4=($3|0)<1;
   if ($4) {
    break;
   } else {
    $i_234=1;
   }
   while(1) {

    $27=((HEAP32[((15600)>>2)])|0);
    $28=(($27+($i_234<<3))|0);
    $29=(+(HEAPF64[(($28)>>3)]));
    $30=((HEAP32[((14408)>>2)])|0);
    $31=(($30+((($i_234)*(72))&-1)+32)|0);
    $32=(+(HEAPF64[(($31)>>3)]));
    $33=($29)-($32);
    $34=($33)*($ucf);
    $35=$34;
    $36=(($x+($i_234<<2))|0);
    HEAPF32[(($36)>>2)]=$35;
    $37=((($i_234)+(1))|0);
    $38=((HEAP32[((14416)>>2)])|0);
    $39=($37|0)>($38|0);
    if ($39) {
     break;
    } else {
     $i_234=$37;
    }
   }
  } else if (((($j|0))|0)==((1)|0)) {
   $7=((HEAP32[((14416)>>2)])|0);
   $8=($7|0)<1;
   if ($8) {
    break;
   } else {
    $i_027=1;
   }
   while(1) {

    $9=((HEAP32[((17632)>>2)])|0);
    $10=(($9+($i_027<<3))|0);
    $11=(+(HEAPF64[(($10)>>3)]));
    $12=($11)*($ucf);
    $13=$12;
    $14=(($x+($i_027<<2))|0);
    HEAPF32[(($14)>>2)]=$13;
    $15=((($i_027)+(1))|0);
    $16=((HEAP32[((14416)>>2)])|0);
    $17=($15|0)>($16|0);
    if ($17) {
     break;
    } else {
     $i_027=$15;
    }
   }
  }
 } while(0);
 $49=(($x+4)|0);
 $50=$49;
 $51=((HEAP32[((14416)>>2)])|0);
 $52=((HEAP32[((12392)>>2)])|0);
 $53=((_fwrite((($50)|0),((4)|0),(($51)|0),(($52)|0)))|0);
 $54=((HEAP32[((14416)>>2)])|0);
 $55=($53>>>0)<($54>>>0);
 $_=($55?308:0);
 return (($_)|0);
}


function _linkoutput($j,$x,$ucf){
 $j=($j)|0;
 $x=($x)|0;
 $ucf=+($ucf);
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$i_093=0,$15=0,$16=0,$17=.0,$18=.0,$19=.0;
 var $20=0,$21=0,$22=0,$23=0,$i_196=0,$24=0,$25=0,$26=0,$27=0,$29=0,$31=0,$32=0,$33=.0,$34=0,$36=.0,$38=.0,$39=0,$40=0,$41=.0,$42=.0;
 var $43=.0,$44=.0,$45=.0,$46=.0,$47=.0,$48=0,$50=0,$51=0,$52=0,$i_2101=0,$53=0,$54=0,$55=0,$56=0,$58=0,$60=0,$61=0,$62=0,$63=0,$64=0;
 var $65=.0,$66=0,$67=0,$68=0,$69=.0,$70=.0,$71=0,$72=0,$73=0,$74=0,$or_cond=0,$76=.0,$h_0=.0,$78=0,$79=0,$80=0,$81=0,$83=.0,$84=0,$85=.0;
 var $86=.0,$87=.0,$88=0,$90=.0,$91=.0,$92=0,$94=0,$95=0,$96=0,$i_3106=0,$97=.0,$98=.0,$99=.0,$100=0,$101=0,$102=0,$103=0,$i_4110=0,$104=0,$105=0;
 var $106=0,$107=.0,$108=0,$109=0,$110=0,$111=0,$i_5114=0,$112=0,$113=0,$114=.0,$115=0,$117=0,$118=0,$119=0,$120=0,$122=0,$123=0,$124=.0,$125=.0,$126=0;
 var $128=.0,$129=0,$131=0,$132=0,$133=.0,$134=.0,$135=.0,$136=.0,$137=0,$139=.0,$140=.0,$141=.0,$142=0,$144=.0,$145=0,$147=0,$149=0,$151=0,$152=0,$153=0;
 var $155=0,$156=0,$157=0,$158=0,$160=0,$161=0,$162=0,$163=0,$i_6119=0,$164=0,$165=0,$166=.0,$167=.0,$168=.0,$169=0,$170=0,$171=0,$172=0,$i_7123=0,$173=0;
 var $174=0,$175=0,$176=0,$178=0,$179=0,$180=.0,$181=0,$183=.0,$185=.0,$186=0,$188=0,$189=0,$190=0,$191=0,$192=0,$193=.0,$194=0,$195=0,$196=0,$197=.0;
 var $198=.0,$199=0,$201=.0,$203=.0,$204=.0,$205=0,$206=0,$207=.0,$208=.0,$209=.0,$210=0,$211=.0,$212=.0,$213=0,$214=0,$215=.0,$216=.0,$217=.0,$218=.0,$219=0;
 var $221=0,$223=0,$224=0,$225=0,$226=0,$227=0,$228=0,$229=0,$230=0,$231=0,$232=0,$_=0,label=0;

 L1: do {
  switch (($j|0)) {
  case 7: {
   $13=((HEAP32[((14424)>>2)])|0);
   $14=($13|0)<1;
   if ($14) {
    break L1;
   } else {
    $i_093=1;
   }
   while(1) {

    $15=((HEAP32[((13880)>>2)])|0);
    $16=(($15+($i_093<<3))|0);
    $17=(+(HEAPF64[(($16)>>3)]));
    $18=($17)*($ucf);
    $19=$18;
    $20=(($x+($i_093<<2))|0);
    HEAPF32[(($20)>>2)]=$19;
    $21=((($i_093)+(1))|0);
    $22=((HEAP32[((14424)>>2)])|0);
    $23=($21|0)>($22|0);
    if ($23) {
     break;
    } else {
     $i_093=$21;
    }
   }
   break;
  }
  case 9: {
   $9=((HEAP32[((14424)>>2)])|0);
   $10=($9|0)<1;
   if ($10) {
    break L1;
   } else {
    $i_2101=1;
   }
   while(1) {

    $53=((HEAP32[((13232)>>2)])|0);
    $54=(($53+$i_2101)|0);
    $55=((HEAP8[($54)])|0);
    $56=(($55<<24)>>24)<3;
    do {
     if ($56) {
      $58=(($x+($i_2101<<2))|0);
      HEAPF32[(($58)>>2)]=0.0;
     } else {
      $60=((HEAP32[((14960)>>2)])|0);
      $61=(($60+((($i_2101)*(104))&-1)+32)|0);
      $62=((HEAP32[(($61)>>2)])|0);
      $63=((HEAP32[((15600)>>2)])|0);
      $64=(($63+($62<<3))|0);
      $65=(+(HEAPF64[(($64)>>3)]));
      $66=(($60+((($i_2101)*(104))&-1)+36)|0);
      $67=((HEAP32[(($66)>>2)])|0);
      $68=(($63+($67<<3))|0);
      $69=(+(HEAPF64[(($68)>>3)]));
      $70=($65)-($69);
      $71=(($60+((($i_2101)*(104))&-1)+96)|0);
      $72=((HEAP8[($71)])|0);
      $73=(($72<<24)>>24)!=2;
      $74=$70<(0.0);
      $or_cond=$73&$74;
      if ($or_cond) {
       $76=((-.0))-($70);
       $h_0=$76;
      } else {
       $h_0=$70;
      }

      $78=((HEAP32[((14960)>>2)])|0);
      $79=(($78+((($i_2101)*(104))&-1)+96)|0);
      $80=((HEAP8[($79)])|0);
      $81=(($80<<24)>>24)<2;
      if ($81) {
       $83=($h_0)*((1000.0));
       $84=(($78+((($i_2101)*(104))&-1)+48)|0);
       $85=(+(HEAPF64[(($84)>>3)]));
       $86=($83)/($85);
       $87=$86;
       $88=(($x+($i_2101<<2))|0);
       HEAPF32[(($88)>>2)]=$87;
       break;
      } else {
       $90=($h_0)*($ucf);
       $91=$90;
       $92=(($x+($i_2101<<2))|0);
       HEAPF32[(($92)>>2)]=$91;
       break;
      }
     }
    } while(0);
    $94=((($i_2101)+(1))|0);
    $95=((HEAP32[((14424)>>2)])|0);
    $96=($94|0)>($95|0);
    if ($96) {
     break;
    } else {
     $i_2101=$94;
    }
   }
   break;
  }
  case 8: {
   $11=((HEAP32[((14424)>>2)])|0);
   $12=($11|0)<1;
   if ($12) {
    break L1;
   } else {
    $i_196=1;
   }
   while(1) {

    $24=((HEAP32[((14960)>>2)])|0);
    $25=(($24+((($i_196)*(104))&-1)+96)|0);
    $26=((HEAP8[($25)])|0);
    $27=(($26<<24)>>24)==2;
    if ($27) {
     $29=(($x+($i_196<<2))|0);
     HEAPF32[(($29)>>2)]=0.0;
    } else {
     $31=((HEAP32[((13880)>>2)])|0);
     $32=(($31+($i_196<<3))|0);
     $33=(+(HEAPF64[(($32)>>3)]));
     $34=$33<(0.0);
     if ($34) {
      $36=((-.0))-($33);
      $38=$36;
     } else {
      $38=$33;
     }

     $39=((HEAP32[((14960)>>2)])|0);
     $40=(($39+((($i_196)*(104))&-1)+40)|0);
     $41=(+(HEAPF64[(($40)>>3)]));
     $42=($41)*($41);
     $43=($42)*((3.141592654));
     $44=($43)*((0.25));
     $45=($38)/($44);
     $46=($45)*($ucf);
     $47=$46;
     $48=(($x+($i_196<<2))|0);
     HEAPF32[(($48)>>2)]=$47;
    }
    $50=((($i_196)+(1))|0);
    $51=((HEAP32[((14424)>>2)])|0);
    $52=($50|0)>($51|0);
    if ($52) {
     break;
    } else {
     $i_196=$50;
    }
   }
   break;
  }
  case 10: {
   $7=((HEAP32[((14424)>>2)])|0);
   $8=($7|0)<1;
   if ($8) {
    break L1;
   } else {
    $i_3106=1;
   }
   while(1) {

    $97=(+(_avgqual($i_3106)));
    $98=($97)*($ucf);
    $99=$98;
    $100=(($x+($i_3106<<2))|0);
    HEAPF32[(($100)>>2)]=$99;
    $101=((($i_3106)+(1))|0);
    $102=((HEAP32[((14424)>>2)])|0);
    $103=($101|0)>($102|0);
    if ($103) {
     break;
    } else {
     $i_3106=$101;
    }
   }
   break;
  }
  case 12: {
   $3=((HEAP32[((14424)>>2)])|0);
   $4=($3|0)<1;
   if ($4) {
    break L1;
   } else {
    $i_5114=1;
   }
   while(1) {

    $112=((HEAP32[((15000)>>2)])|0);
    $113=(($112+($i_5114<<3))|0);
    $114=(+(HEAPF64[(($113)>>3)]));
    $115=$114!=(-10000000000.0);
    L34: do {
     if ($115) {
      $117=((HEAP32[((14960)>>2)])|0);
      $118=(($117+((($i_5114)*(104))&-1)+96)|0);
      $119=((HEAP8[($118)])|0);
      $120=(($119<<24)>>24);
      switch (($120|0)) {
      case 3:case 4:case 5: {
       $131=((HEAP32[((15000)>>2)])|0);
       $132=(($131+($i_5114<<3))|0);
       $133=(+(HEAPF64[(($132)>>3)]));
       $134=(+(HEAPF64[((12064)>>3)]));
       $135=($133)*($134);
       $136=$135;
       $137=(($x+($i_5114<<2))|0);
       HEAPF32[(($137)>>2)]=$136;
       break L34;
      }
      case 6: {
       $139=(+(HEAPF64[((12096)>>3)]));
       $140=($114)*($139);
       $141=$140;
       $142=(($x+($i_5114<<2))|0);
       HEAPF32[(($142)>>2)]=$141;
       break L34;
      }
      case 7: {
       $144=$114;
       $145=(($x+($i_5114<<2))|0);
       HEAPF32[(($145)>>2)]=$144;
       break L34;
      }
      case 0:case 1: {
       $122=((HEAP32[((15000)>>2)])|0);
       $123=(($122+($i_5114<<3))|0);
       $124=(+(HEAPF64[(($123)>>3)]));
       $125=$124;
       $126=(($x+($i_5114<<2))|0);
       HEAPF32[(($126)>>2)]=$125;
       break L34;
      }
      case 2: {
       $128=$114;
       $129=(($x+($i_5114<<2))|0);
       HEAPF32[(($129)>>2)]=$128;
       break L34;
      }
      default: {
       $147=(($x+($i_5114<<2))|0);
       HEAPF32[(($147)>>2)]=0.0;
       break L34;
      }
      }
     } else {
      $149=(($x+($i_5114<<2))|0);
      HEAPF32[(($149)>>2)]=0.0;
     }
    } while(0);
    $151=((($i_5114)+(1))|0);
    $152=((HEAP32[((14424)>>2)])|0);
    $153=($151|0)>($152|0);
    if ($153) {
     break;
    } else {
     $i_5114=$151;
    }
   }
   break;
  }
  case 11: {
   $5=((HEAP32[((14424)>>2)])|0);
   $6=($5|0)<1;
   if ($6) {
    break L1;
   } else {
    $i_4110=1;
   }
   while(1) {

    $104=((HEAP32[((13232)>>2)])|0);
    $105=(($104+$i_4110)|0);
    $106=((HEAP8[($105)])|0);
    $107=(+(((($106<<24)>>24))|0));
    $108=(($x+($i_4110<<2))|0);
    HEAPF32[(($108)>>2)]=$107;
    $109=((($i_4110)+(1))|0);
    $110=((HEAP32[((14424)>>2)])|0);
    $111=($109|0)>($110|0);
    if ($111) {
     break;
    } else {
     $i_4110=$109;
    }
   }
   break;
  }
  case 14: {
   $1=((HEAP32[((14424)>>2)])|0);
   $2=($1|0)<1;
   if ($2) {
    break L1;
   } else {
    $i_7123=1;
   }
   while(1) {

    $173=((HEAP32[((14960)>>2)])|0);
    $174=(($173+((($i_7123)*(104))&-1)+96)|0);
    $175=((HEAP8[($174)])|0);
    $176=(($175<<24)>>24)<2;
    do {
     if ($176) {
      $178=((HEAP32[((13880)>>2)])|0);
      $179=(($178+($i_7123<<3))|0);
      $180=(+(HEAPF64[(($179)>>3)]));
      $181=$180<(0.0);
      if ($181) {
       $183=((-.0))-($180);
       $185=$183;
      } else {
       $185=$180;
      }

      $186=$185>(0.000001);
      if (!($186)) {
       label = 47;
       break;
      }
      $188=((HEAP32[((14960)>>2)])|0);
      $189=(($188+((($i_7123)*(104))&-1)+32)|0);
      $190=((HEAP32[(($189)>>2)])|0);
      $191=((HEAP32[((15600)>>2)])|0);
      $192=(($191+($190<<3))|0);
      $193=(+(HEAPF64[(($192)>>3)]));
      $194=(($188+((($i_7123)*(104))&-1)+36)|0);
      $195=((HEAP32[(($194)>>2)])|0);
      $196=(($191+($195<<3))|0);
      $197=(+(HEAPF64[(($196)>>3)]));
      $198=($193)-($197);
      $199=$198<(0.0);
      if ($199) {
       $201=((-.0))-($198);
       $203=$201;
      } else {
       $203=$198;
      }

      $204=($203)*((39.725));
      $205=((HEAP32[((14960)>>2)])|0);
      $206=(($205+((($i_7123)*(104))&-1)+40)|0);
      $207=(+(HEAPF64[(($206)>>3)]));
      $208=(+(Math_pow((+($207)),5.0)));
      $209=($204)*($208);
      $210=(($205+((($i_7123)*(104))&-1)+48)|0);
      $211=(+(HEAPF64[(($210)>>3)]));
      $212=($209)/($211);
      $213=((HEAP32[((13880)>>2)])|0);
      $214=(($213+($i_7123<<3))|0);
      $215=(+(HEAPF64[(($214)>>3)]));
      $216=($215)*($215);
      $217=($212)/($216);
      $218=$217;
      $219=(($x+($i_7123<<2))|0);
      HEAPF32[(($219)>>2)]=$218;
     } else {
      label = 47;
     }
    } while(0);
    if ((label|0) == 47) {
     label = 0;
     $221=(($x+($i_7123<<2))|0);
     HEAPF32[(($221)>>2)]=0.0;
    }
    $223=((($i_7123)+(1))|0);
    $224=((HEAP32[((14424)>>2)])|0);
    $225=($223|0)>($224|0);
    if ($225) {
     break;
    } else {
     $i_7123=$223;
    }
   }
   break;
  }
  case 13: {
   $155=((HEAP8[(13856)])|0);
   $156=(($155<<24)>>24)==0;
   if ($156) {
    $160=$x;
    $161=((HEAP32[((14424)>>2)])|0);
    $162=$161<<2;
    $163=((($162)+(4))|0);
    _memset((((($160)|0))|0), ((((0)|0))|0), (((($163)|0))|0))|0;
    break L1;
   }
   $157=((HEAP32[((14424)>>2)])|0);
   $158=($157|0)<1;
   if ($158) {
    break L1;
   } else {
    $i_6119=1;
   }
   while(1) {

    $164=((HEAP32[((13848)>>2)])|0);
    $165=(($164+($i_6119<<3))|0);
    $166=(+(HEAPF64[(($165)>>3)]));
    $167=($166)*($ucf);
    $168=$167;
    $169=(($x+($i_6119<<2))|0);
    HEAPF32[(($169)>>2)]=$168;
    $170=((($i_6119)+(1))|0);
    $171=((HEAP32[((14424)>>2)])|0);
    $172=($170|0)>($171|0);
    if ($172) {
     break;
    } else {
     $i_6119=$170;
    }
   }
   break;
  }
  default: {
  }
  }
 } while(0);
 $226=(($x+4)|0);
 $227=$226;
 $228=((HEAP32[((14424)>>2)])|0);
 $229=((HEAP32[((12392)>>2)])|0);
 $230=((_fwrite((($227)|0),((4)|0),(($228)|0),(($229)|0)))|0);
 $231=((HEAP32[((14424)>>2)])|0);
 $232=($230>>>0)<($231>>>0);
 $_=($232?308:0);
 return (($_)|0);
}


function _savefinaloutput(){
 var $1=0,$2=0,$3=0,$4=0,$or_cond=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$15=0,$16=0,$18=0,$19=0,$21=0,$22=0,$23=0;
 var $24=0,$errcode_0=0,$26=0,$27=0,$28=0,$or_cond15=0,$30=.0,$31=.0,$32=.0,$33=.0,$34=0,$35=0,$37=0,$_0=0,label=0;

 $1=((HEAP8[(12208)])|0);
 $2=(($1<<24)>>24)!=0;
 $3=((HEAP32[((12392)>>2)])|0);
 $4=($3|0)!=0;
 $or_cond=$2&$4;
 if ($or_cond) {
  $6=((HEAP32[((14416)>>2)])|0);
  $7=((HEAP32[((14424)>>2)])|0);
  $8=($6|0)>=($7|0);
  $9=($8?$6:$7);
  $10=((($9)+(1))|0);
  $11=((_calloc($10,4))|0);
  $12=$11;
  $13=($11|0)==0;
  if ($13) {
   $_0=101;

   return (($_0)|0);
  }
  $15=((_savetimestat($12,2))|0);
  $16=($15|0)>100;
  do {
   if ($16) {
    $21=$15;
   } else {
    $18=((_savetimestat($12,3))|0);
    $19=($18|0)==0;
    if (!($19)) {
     $21=$18;
     break;
    }
    HEAP32[((14384)>>2)]=1;
    $21=0;
   }
  } while(0);

  $22=((HEAP32[((12392)>>2)])|0);
  $23=((_fclose((($22)|0)))|0);
  _free($12);
  $errcode_0=$21;
 } else {
  $errcode_0=0;
 }

 $26=((HEAP32[((14280)>>2)])|0);
 $27=($26|0)==0;
 $28=($errcode_0|0)>100;
 $or_cond15=$27|$28;
 if ($or_cond15) {
  $_0=$errcode_0;

  return (($_0)|0);
 }
 $30=(+(HEAPF64[((10464)>>3)]));
 $31=(+(HEAPF64[((10440)>>3)]));
 $32=(+(HEAPF64[((10448)>>3)]));
 $33=(+(HEAPF64[((10456)>>3)]));
 $34=((_savenetreacts($30,$31,$32,$33))|0);
 $35=($34|0)>100;
 if ($35) {
  $_0=$34;

  return (($_0)|0);
 }
 $37=((_saveepilog())|0);
 $_0=$37;

 return (($_0)|0);
}


function _savetimestat($x,$objtype){
 $x=($x)|0;
 $objtype=($objtype)|0;
 var $1=0,$2=0,$4=0,$5=0,$6=0,$7=0,$9=0,$10=0,$11=0,$12=0,$13=0,$n2_0=0,$startbyte_0=0,$skipbytes_0_in=0,$n1_0=0,$n_0=0,$skipbytes_0=0,$15=0,$16=0,$17=0;
 var $18=0,$19=0,$20=0,$21=0,$23=0,$24=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0;
 var $40=0,$41=0,$42=0,$43=0,$44=0,$45=0,$46=0,$scevgep=0,$scevgep172=0,$scevgep173=0,$47=0,$scevgep174=0,$scevgep174175=0,$scevgep176=0,$errcode_0170=0,$j_0169=0,$49=0,$50=0,$i_0124=0,$52=0;
 var $53=0,$54=0,$55=0,$56=0,$57=0,$58=0,$59=0,$60=0,$61=0,$62=0,$63=0,$64=0,$p_0127=0,$66=0,$67=0,$68=0,$69=0,$i_1125=0,$71=0,$72=.0;
 var $74=0,$or_cond123=0,$76=.0,$xx_0=.0,$79=0,$_=.0,$xx_1=.0,$81=0,$82=.0,$84=.0,$86=0,$xx_1_=.0,$87=0,$88=.0,$89=0,$90=.0,$92=0,$93=0,$94=0,$95=0;
 var $97=0,$98=0,$100=0,$101=0,$102=0,$103=0,$104=0,$i_2145=0,$105=0,$106=.0,$107=0,$108=.0,$109=.0,$110=0,$111=0,$112=0,$i_5133=0,$113=0,$114=.0,$115=0;
 var $116=.0,$117=.0,$118=0,$119=0,$120=0,$notlhs=0,$notrhs=0,$or_cond_not=0,$brmerge=0,$i_6149=0,$121=0,$122=.0,$123=0,$_122=.0,$124=0,$125=0,$126=0,$127=0,$128=0,$_errcode_0=0;
 var $i_7165=0,$130=0,$131=.0,$132=.0,$133=.0,$134=.0,$135=0,$136=0,$137=0,$138=0,$i_8161=0,$139=0,$140=.0,$141=.0,$142=.0,$143=.0,$144=0,$145=0,$146=0,$147=0;
 var $i_9157=0,$148=0,$149=.0,$150=.0,$151=.0,$152=.0,$153=0,$154=0,$155=0,$156=0,$_not=0,$brmerge177=0,$i_10153=0,$158=0,$159=.0,$160=.0,$161=.0,$162=.0,$163=0,$164=0;
 var $165=0,$166=0,$167=0,$168=0,$errcode_2=0,$169=0,$170=0,label=0;

 $1=(($objtype<<24)>>24)==2;
 $2=((HEAP32[((14416)>>2)])|0);
 if ($1) {
  $4=((($2)*(3))&-1);
  $5=((HEAP32[((14424)>>2)])|0);
  $6=$5<<3;
  $7=((($6)+($4))|0);
  $n_0=$2;$n1_0=1;$skipbytes_0_in=$7;$startbyte_0=0;$n2_0=4;
 } else {
  $9=$2<<2;
  $10=$2<<4;
  $11=((HEAP32[((14424)>>2)])|0);
  $12=((($11)*(7))&-1);
  $13=((($12)+($9))|0);
  $n_0=$11;$n1_0=7;$skipbytes_0_in=$13;$startbyte_0=$10;$n2_0=14;
 }





 $skipbytes_0=$skipbytes_0_in<<2;
 $15=((($n_0)+(1))|0);
 $16=((_calloc($15,4))|0);
 $17=$16;
 $18=((_calloc($15,4))|0);
 $19=$18;
 $20=($16|0)==0;
 $21=($20?101:0);
 if ($20) {
  $26=$21;
 } else {
  $23=($18|0)==0;
  $24=($23?101:0);
  $26=$24;
 }

 $27=($26|0)==0;
 if (!($27)) {
  $errcode_2=$26;

  _free($17);
  _free($19);
  return (($errcode_2)|0);
 }
 $28=($n1_0>>>0)>($n2_0>>>0);
 if ($28) {
  $errcode_2=0;

  _free($17);
  _free($19);
  return (($errcode_2)|0);
 }
 $29=$15<<2;
 $30=$n_0<<2;
 $31=(($x+4)|0);
 $32=$31;
 $33=($n_0|0)<1;
 $34=($n_0|0)<1;
 $35=($n_0|0)<1;
 $36=($n_0|0)<1;
 $37=($n_0|0)<1;
 $38=($n_0|0)<1;
 $39=($n_0|0)<1;
 $40=($n_0|0)<1;
 $41=($n_0|0)<1;
 $42=(($x+4)|0);
 $43=$42;
 $44=($n_0|0)<1;
 $45=(($objtype<<24)>>24)==3;
 $46=($n_0|0)<1;
 $scevgep=(($x+4)|0);
 $scevgep172=$scevgep;
 $scevgep173=(($18+4)|0);
 $47=$n_0<<2;
 $scevgep174=(($x+4)|0);
 $scevgep174175=$scevgep174;
 $scevgep176=(($16+4)|0);
 $j_0169=$n1_0;$errcode_0170=0;
 while(1) {


  $49=((HEAP8[(12208)])|0);
  $50=(($49<<24)>>24)==1;
  do {
   if ($50) {
    _memset((((($16)|0))|0), ((((0)|0))|0), (((($29)|0))|0))|0;
   } else {
    if ($46) {
     break;
    } else {
     $i_0124=1;
    }
    while(1) {

     $52=(($17+($i_0124<<2))|0);
     HEAPF32[(($52)>>2)]=10000000000.0;
     $53=(($19+($i_0124<<2))|0);
     HEAPF32[(($53)>>2)]=-10000000000.0;
     $54=((($i_0124)+(1))|0);
     $55=($54|0)>($n_0|0);
     if ($55) {
      break;
     } else {
      $i_0124=$54;
     }
    }
   }
  } while(0);
  $56=((HEAP32[((12392)>>2)])|0);
  $57=((($j_0169)-($n1_0))|0);
  $58=(Math_imul($30,$57)|0);
  $59=((($58)+($startbyte_0))|0);
  $60=((_fseek((($56)|0),(($59)|0),((0)|0)))|0);
  $61=((HEAP32[((14384)>>2)])|0);
  $62=($61|0)<1;
  if (!($62)) {
   $63=($j_0169|0)==7;
   $64=($j_0169|0)==11;
   $p_0127=1;
   while(1) {

    $66=((HEAP32[((12392)>>2)])|0);
    $67=((_fread((($43)|0),((4)|0),(($n_0)|0),(($66)|0)))|0);
    if (!($44)) {
     $68=((HEAP8[(12208)])|0);
     $69=(($68<<24)>>24)==1;
     $i_1125=1;
     while(1) {

      $71=(($x+($i_1125<<2))|0);
      $72=(+(HEAPF32[(($71)>>2)]));
      do {
       if ($45) {
        $74=$72<(0.0);
        $or_cond123=$63&$74;
        if ($or_cond123) {
         $76=((-.0))-($72);
         $xx_0=$76;
        } else {
         $xx_0=$72;
        }

        if (!($64)) {
         $xx_1=$xx_0;
         break;
        }
        $79=$xx_0<(3.0);
        $_=($79?(0.0):(1.0));
        $xx_1=$_;
       } else {
        $xx_1=$72;
       }
      } while(0);

      $81=(($17+($i_1125<<2))|0);
      $82=(+(HEAPF32[(($81)>>2)]));
      if ($69) {
       $84=($xx_1)+($82);
       HEAPF32[(($81)>>2)]=$84;
      } else {
       $86=$82>$xx_1;
       $xx_1_=($86?$xx_1:$82);
       HEAPF32[(($81)>>2)]=$xx_1_;
       $87=(($19+($i_1125<<2))|0);
       $88=(+(HEAPF32[(($87)>>2)]));
       $89=$88<$xx_1;
       $90=($89?$xx_1:$88);
       HEAPF32[(($87)>>2)]=$90;
      }
      $92=((($i_1125)+(1))|0);
      $93=($92|0)>($n_0|0);
      if ($93) {
       break;
      } else {
       $i_1125=$92;
      }
     }
    }
    $94=((HEAP32[((14384)>>2)])|0);
    $95=($p_0127|0)<($94|0);
    if ($95) {
     $97=((HEAP32[((12392)>>2)])|0);
     $98=((_fseek((($97)|0),(($skipbytes_0)|0),((1)|0)))|0);
    }
    $100=((($p_0127)+(1))|0);
    $101=((HEAP32[((14384)>>2)])|0);
    $102=($100|0)>($101|0);
    if ($102) {
     break;
    } else {
     $p_0127=$100;
    }
   }
  }
  $103=((HEAP8[(12208)])|0);
  $104=(($103<<24)>>24);
  do {
   if (((($104|0))|0)==((4)|0)) {
    if ($38) {
     break;
    } else {
     $i_5133=1;
    }
    while(1) {

     $113=(($19+($i_5133<<2))|0);
     $114=(+(HEAPF32[(($113)>>2)]));
     $115=(($17+($i_5133<<2))|0);
     $116=(+(HEAPF32[(($115)>>2)]));
     $117=($114)-($116);
     $118=(($x+($i_5133<<2))|0);
     HEAPF32[(($118)>>2)]=$117;
     $119=((($i_5133)+(1))|0);
     $120=($119|0)>($n_0|0);
     if ($120) {
      break;
     } else {
      $i_5133=$119;
     }
    }
   } else if (((($104|0))|0)==((2)|0)) {
    if ($40) {
     break;
    }
    (_memcpy((($scevgep174175)|0), (($scevgep176)|0), $47)|0);
   } else if (((($104|0))|0)==((3)|0)) {
    if ($39) {
     break;
    }
    (_memcpy((($scevgep172)|0), (($scevgep173)|0), $47)|0);
   } else if (((($104|0))|0)==((1)|0)) {
    if ($41) {
     break;
    } else {
     $i_2145=1;
    }
    while(1) {

     $105=(($17+($i_2145<<2))|0);
     $106=(+(HEAPF32[(($105)>>2)]));
     $107=((HEAP32[((14384)>>2)])|0);
     $108=(+((($107|0))|0));
     $109=($106)/($108);
     $110=(($x+($i_2145<<2))|0);
     HEAPF32[(($110)>>2)]=$109;
     $111=((($i_2145)+(1))|0);
     $112=($111|0)>($n_0|0);
     if ($112) {
      break;
     } else {
      $i_2145=$111;
     }
    }
   }
  } while(0);
  $notlhs=(($objtype<<24)>>24)!=3;
  $notrhs=($j_0169|0)!=11;
  $or_cond_not=$notrhs|$notlhs;
  $brmerge=$or_cond_not|$37;
  if (!($brmerge)) {
   $i_6149=1;
   while(1) {

    $121=(($x+($i_6149<<2))|0);
    $122=(+(HEAPF32[(($121)>>2)]));
    $123=$122<(0.5);
    $_122=($123?(2.0):(3.0));
    HEAPF32[(($121)>>2)]=$_122;
    $124=((($i_6149)+(1))|0);
    $125=($124|0)>($n_0|0);
    if ($125) {
     break;
    } else {
     $i_6149=$124;
    }
   }
  }
  $126=((HEAP32[((14280)>>2)])|0);
  $127=((_fwrite((($32)|0),((4)|0),(($n_0)|0),(($126)|0)))|0);
  $128=($127>>>0)<($n_0>>>0);
  $_errcode_0=($128?308:$errcode_0170);
  do {
   if ($1) {
    if (((($j_0169|0))|0)==((1)|0)) {
     if ($35) {
      break;
     } else {
      $i_7165=1;
     }
     while(1) {

      $130=(($x+($i_7165<<2))|0);
      $131=(+(HEAPF32[(($130)>>2)]));
      $132=$131;
      $133=(+(HEAPF64[((12048)>>3)]));
      $134=($132)/($133);
      $135=((HEAP32[((17632)>>2)])|0);
      $136=(($135+($i_7165<<3))|0);
      HEAPF64[(($136)>>3)]=$134;
      $137=((($i_7165)+(1))|0);
      $138=($137|0)>($n_0|0);
      if ($138) {
       break;
      } else {
       $i_7165=$137;
      }
     }
    } else if (((($j_0169|0))|0)==((2)|0)) {
     if ($34) {
      break;
     } else {
      $i_8161=1;
     }
     while(1) {

      $139=(($x+($i_8161<<2))|0);
      $140=(+(HEAPF32[(($139)>>2)]));
      $141=$140;
      $142=(+(HEAPF64[((12056)>>3)]));
      $143=($141)/($142);
      $144=((HEAP32[((15600)>>2)])|0);
      $145=(($144+($i_8161<<3))|0);
      HEAPF64[(($145)>>3)]=$143;
      $146=((($i_8161)+(1))|0);
      $147=($146|0)>($n_0|0);
      if ($147) {
       break;
      } else {
       $i_8161=$146;
      }
     }
    } else if (((($j_0169|0))|0)==((4)|0)) {
     if ($33) {
      break;
     } else {
      $i_9157=1;
     }
     while(1) {

      $148=(($x+($i_9157<<2))|0);
      $149=(+(HEAPF32[(($148)>>2)]));
      $150=$149;
      $151=(+(HEAPF64[((12072)>>3)]));
      $152=($150)/($151);
      $153=((HEAP32[((17736)>>2)])|0);
      $154=(($153+($i_9157<<3))|0);
      HEAPF64[(($154)>>3)]=$152;
      $155=((($i_9157)+(1))|0);
      $156=($155|0)>($n_0|0);
      if ($156) {
       break;
      } else {
       $i_9157=$155;
      }
     }
    } else {
     break;
    }
   } else {
    $_not=($j_0169|0)!=7;
    $brmerge177=$_not|$36;
    if ($brmerge177) {
     break;
    } else {
     $i_10153=1;
    }
    while(1) {

     $158=(($x+($i_10153<<2))|0);
     $159=(+(HEAPF32[(($158)>>2)]));
     $160=$159;
     $161=(+(HEAPF64[((12096)>>3)]));
     $162=($160)/($161);
     $163=((HEAP32[((13880)>>2)])|0);
     $164=(($163+($i_10153<<3))|0);
     HEAPF64[(($164)>>3)]=$162;
     $165=((($i_10153)+(1))|0);
     $166=($165|0)>($n_0|0);
     if ($166) {
      break;
     } else {
      $i_10153=$165;
     }
    }
   }
  } while(0);
  $167=((($j_0169)+(1))|0);
  $168=($167|0)>($n2_0|0);
  if ($168) {
   $errcode_2=$_errcode_0;
   break;
  } else {
   $j_0169=$167;$errcode_0170=$_errcode_0;
  }
 }

 _free($17);
 _free($19);
 return (($errcode_2)|0);
}


function _savenetreacts($wbulk,$wwall,$wtank,$wsource){
 $wbulk=+($wbulk);
 $wwall=+($wwall);
 $wtank=+($wtank);
 $wsource=+($wsource);
 var $w=0,$1=0,$2=0,$4=.0,$5=.0,$t_0=.0,$7=.0,$8=.0,$9=0,$10=.0,$11=.0,$12=0,$13=.0,$14=.0,$15=0,$16=.0,$17=.0,$18=0,$19=0,$20=0;
 var $21=0,$22=0,$_=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $w=((sp)|0);
 $1=((HEAP32[((17544)>>2)])|0);
 $2=($1|0)>0;
 if ($2) {
  $4=(+((($1|0))|0));
  $5=($4)/((3600.0));
  $t_0=$5;
 } else {
  $t_0=1.0;
 }

 $7=($wbulk)/($t_0);
 $8=$7;
 $9=(($w)|0);
 HEAPF32[(($9)>>2)]=$8;
 $10=($wwall)/($t_0);
 $11=$10;
 $12=(($w+4)|0);
 HEAPF32[(($12)>>2)]=$11;
 $13=($wtank)/($t_0);
 $14=$13;
 $15=(($w+8)|0);
 HEAPF32[(($15)>>2)]=$14;
 $16=($wsource)/($t_0);
 $17=$16;
 $18=(($w+12)|0);
 HEAPF32[(($18)>>2)]=$17;
 $19=$w;
 $20=((HEAP32[((14280)>>2)])|0);
 $21=((_fwrite((($19)|0),((4)|0),((4)|0),(($20)|0)))|0);
 $22=($21>>>0)<((4)>>>0);
 $_=($22?308:0);
 STACKTOP=sp;return (($_)|0);
}


function _saveepilog(){
 var $i=0,$1=0,$2=0,$3=0,$4=0,$5=0,$_=0,$6=0,$7=0,$8=0,$9=0,$10=0,$errcode_1=0,$11=0,$12=0,$13=0,$_errcode_1=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $i=((sp)|0);
 $1=((HEAP32[((14384)>>2)])|0);
 HEAP32[(($i)>>2)]=$1;
 $2=$i;
 $3=((HEAP32[((14280)>>2)])|0);
 $4=((_fwrite((($2)|0),((4)|0),((1)|0),(($3)|0)))|0);
 $5=($4|0)==0;
 $_=($5?308:0);
 $6=((HEAP8[(12008)])|0);
 $7=(($6<<24)>>24);
 HEAP32[(($i)>>2)]=$7;
 $8=((HEAP32[((14280)>>2)])|0);
 $9=((_fwrite((($2)|0),((4)|0),((1)|0),(($8)|0)))|0);
 $10=($9|0)==0;
 $errcode_1=($10?308:$_);
 HEAP32[(($i)>>2)]=516114521;
 $11=((HEAP32[((14280)>>2)])|0);
 $12=((_fwrite((($2)|0),((4)|0),((1)|0),(($11)|0)))|0);
 $13=($12|0)==0;
 $_errcode_1=($13?308:$errcode_1);
 STACKTOP=sp;return (($_errcode_1)|0);
}


function _openqual(){
 var $1=0,$2=0,$_=0,$3=0,$4=0,$5=0,$_sink=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$14=0,$15=0,$16=0,$18=0,$19=0,$21=0;
 var $22=0,$23=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0,$40=0,$41=0,$43=0;
 var $44=0,$45=0,$47=0,$48=0,$49=0,$51=0,$52=0,$54=0,$55=0,$56=0,$58=0,$59=0,$60=0,$61=0,$62=0,$64=0,$65=0,$66=0,$67=0,label=0;

 HEAP8[(14008)]=0;
 $1=((_AllocInit())|0);
 HEAP32[((13200)>>2)]=$1;
 $2=($1|0)==0;
 $_=($2?101:0);
 $3=((HEAP32[((14416)>>2)])|0);
 $4=((HEAP32[((14424)>>2)])|0);
 $5=($3|0)>=($4|0);
 $_sink=($5?$3:$4);
 $6=((($_sink)+(1))|0);
 $7=((_calloc($6,8))|0);
 $8=$7;
 HEAP32[((12000)>>2)]=$8;
 $9=((HEAP32[((14424)>>2)])|0);
 $10=((($9)+(1))|0);
 $11=((_calloc($10,8))|0);
 $12=$11;
 HEAP32[((13848)>>2)]=$12;
 if ($2) {
  $18=$_;
 } else {
  $14=((HEAP32[((12000)>>2)])|0);
  $15=($14|0)==0;
  $16=($15?101:0);
  $18=$16;
 }

 $19=($18|0)==101;
 if ($19) {
  $25=101;
 } else {
  $21=((HEAP32[((13848)>>2)])|0);
  $22=($21|0)==0;
  $23=($22?101:0);
  $25=$23;
 }

 $26=((HEAP32[((14424)>>2)])|0);
 $27=((HEAP32[((14352)>>2)])|0);
 $28=((($26)+(1))|0);
 $29=((($28)+($27))|0);
 $30=((_calloc($29,4))|0);
 $31=$30;
 HEAP32[((15648)>>2)]=$31;
 $32=((_calloc($29,4))|0);
 $33=$32;
 HEAP32[((14984)>>2)]=$33;
 $34=((_calloc($29,1))|0);
 HEAP32[((15640)>>2)]=$34;
 $35=((HEAP32[((14416)>>2)])|0);
 $36=((($35)+(1))|0);
 $37=((_calloc($36,8))|0);
 $38=$37;
 HEAP32[((12016)>>2)]=$38;
 $39=((_calloc($36,8))|0);
 $40=$39;
 HEAP32[((14680)>>2)]=$40;
 $41=($25|0)==101;
 if ($41) {
  $67=$25;

  return (($67)|0);
 }
 $43=((HEAP32[((15648)>>2)])|0);
 $44=($43|0)==0;
 $45=($44?101:0);
 if ($44) {
  $51=$45;
 } else {
  $47=((HEAP32[((14984)>>2)])|0);
  $48=($47|0)==0;
  $49=($48?101:0);
  $51=$49;
 }

 $52=($51|0)==101;
 if ($52) {
  $67=101;

  return (($67)|0);
 }
 $54=((HEAP32[((15640)>>2)])|0);
 $55=($54|0)==0;
 $56=($55?101:0);
 if ($55) {
  $61=$56;
 } else {
  $58=((HEAP32[((12016)>>2)])|0);
  $59=($58|0)==0;
  $60=($59?101:0);
  $61=$60;
 }

 $62=($61|0)==101;
 if ($62) {
  $67=101;

  return (($67)|0);
 }
 $64=((HEAP32[((14680)>>2)])|0);
 $65=($64|0)==0;
 $66=($65?101:0);
 $67=$66;

 return (($67)|0);
}


function _getucf($order){
 $order=+($order);
 var $1=0,$_0=.0,$2=0,$4=.0,$5=.0,$6=.0,$_04=.0,label=0;

 $1=$order<(0.0);
 $_0=($1?(0.0):$order);
 $2=$_0==(1.0);
 if ($2) {
  $_04=1.0;

  return (+($_04));
 }
 $4=($_0)+((-1.0));
 $5=(+(Math_pow(28.317,(+($4)))));
 $6=((1.0))/($5);
 $_04=$6;

 return (+($_04));
}


function _initqual(){
 var $1=0,$2=0,$3=0,$4=0,$i_023=0,$5=0,$6=0,$7=.0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$i_121=0,$14=0,$15=0,$16=0,$17=0,$18=0;
 var $19=.0,$20=0,$21=0,$22=0,$23=0,$24=0,$25=0,$i_218=0,$26=0,$27=0,$28=.0,$29=0,$30=0,$31=0,$32=0,$i_316=0,$33=0,$34=0,$35=0,$36=0;
 var $38=0,$40=0,$41=0,$42=0,$43=0,$45=0,$46=0,$47=0,$49=.0,$50=0,$52=.0,$53=.0,$storemerge=.0,$55=.0,$56=.0,$57=.0,$58=.0,$59=0,$60=0,$61=0;
 var $63=0,$64=0,$65=0,$66=0,label=0;

 $1=((HEAP32[((14416)>>2)])|0);
 $2=($1|0)<1;
 if (!($2)) {
  $i_023=1;
  while(1) {

   $5=((HEAP32[((14408)>>2)])|0);
   $6=(($5+((($i_023)*(72))&-1)+48)|0);
   $7=(+(HEAPF64[(($6)>>3)]));
   $8=((HEAP32[((17736)>>2)])|0);
   $9=(($8+($i_023<<3))|0);
   HEAPF64[(($9)>>3)]=$7;
   $10=((($i_023)+(1))|0);
   $11=((HEAP32[((14416)>>2)])|0);
   $12=($10|0)>($11|0);
   if ($12) {
    break;
   } else {
    $i_023=$10;
   }
  }
 }
 $3=((HEAP32[((14352)>>2)])|0);
 $4=($3|0)<1;
 do {
  if (!($4)) {
   $i_121=1;
   while(1) {

    $14=((HEAP32[((13176)>>2)])|0);
    $15=(($14+((($i_121)*(112))&-1))|0);
    $16=((HEAP32[(($15)>>2)])|0);
    $17=((HEAP32[((14408)>>2)])|0);
    $18=(($17+((($16)*(72))&-1)+48)|0);
    $19=(+(HEAPF64[(($18)>>3)]));
    $20=(($14+((($i_121)*(112))&-1)+80)|0);
    HEAPF64[(($20)>>3)]=$19;
    $21=((($i_121)+(1))|0);
    $22=((HEAP32[((14352)>>2)])|0);
    $23=($21|0)>($22|0);
    if ($23) {
     break;
    } else {
     $i_121=$21;
    }
   }
   $13=($22|0)<1;
   if ($13) {
    break;
   } else {
    $i_218=1;
   }
   while(1) {

    $26=((HEAP32[((13176)>>2)])|0);
    $27=(($26+((($i_218)*(112))&-1)+56)|0);
    $28=(+(HEAPF64[(($27)>>3)]));
    $29=(($26+((($i_218)*(112))&-1)+72)|0);
    HEAPF64[(($29)>>3)]=$28;
    $30=((($i_218)+(1))|0);
    $31=((HEAP32[((14352)>>2)])|0);
    $32=($30|0)>($31|0);
    if ($32) {
     break;
    } else {
     $i_218=$30;
    }
   }
  }
 } while(0);
 $24=((HEAP32[((14416)>>2)])|0);
 $25=($24|0)<1;
 if (!($25)) {
  $i_316=1;
  while(1) {

   $33=((HEAP32[((14408)>>2)])|0);
   $34=(($33+((($i_316)*(72))&-1)+44)|0);
   $35=((HEAP32[(($34)>>2)])|0);
   $36=($35|0)==0;
   if (!($36)) {
    $38=(($35+16)|0);
    HEAPF64[(($38)>>3)]=0.0;
   }
   $40=((($i_316)+(1))|0);
   $41=((HEAP32[((14416)>>2)])|0);
   $42=($40|0)>($41|0);
   if ($42) {
    break;
   } else {
    $i_316=$40;
   }
  }
 }
 HEAPF64[((11424)>>3)]=1.0;
 HEAPF64[((10568)>>3)]=1.0;
 HEAP8[(13840)]=0;
 $43=((HEAP8[(13856)])|0);
 if ((((($43<<24)>>24))|0)==((3)|0)) {
  $45=((HEAP32[((12224)>>2)])|0);
  $46=((HEAP32[((17736)>>2)])|0);
  $47=(($46+($45<<3))|0);
  HEAPF64[(($47)>>3)]=100.0;
 } else if ((((($43<<24)>>24))|0)==((0)|0)) {
  HEAPF64[((10464)>>3)]=0.0;
  HEAPF64[((10440)>>3)]=0.0;
  HEAPF64[((10448)>>3)]=0.0;
  HEAPF64[((10456)>>3)]=0.0;
  $63=((HEAP32[((15568)>>2)])|0);
  $64=((HEAP32[((15296)>>2)])|0);
  $65=((_fseek((($63)|0),(($64)|0),((0)|0)))|0);
  HEAP32[((15576)>>2)]=0;
  HEAP32[((13864)>>2)]=0;
  $66=((HEAP32[((13280)>>2)])|0);
  HEAP32[((13264)>>2)]=$66;
  HEAP32[((14384)>>2)]=0;
  return;
 }
 $49=(+(HEAPF64[((11376)>>3)]));
 $50=$49>(0.0);
 if ($50) {
  $52=(+(HEAPF64[((10480)>>3)]));
  $53=($52)/($49);
  $storemerge=$53;
 } else {
  $storemerge=0.0;
 }

 HEAPF64[((10776)>>3)]=$storemerge;
 $55=(+(HEAPF64[((11416)>>3)]));
 $56=(+(_getucf($55)));
 HEAPF64[((11424)>>3)]=$56;
 $57=(+(HEAPF64[((10600)>>3)]));
 $58=(+(_getucf($57)));
 HEAPF64[((10568)>>3)]=$58;
 $59=((_setReactflag())|0);
 HEAP8[(13840)]=$59;
 HEAP32[((15608)>>2)]=0;
 $60=((HEAP32[((13200)>>2)])|0);
 $61=((_AllocSetPool($60))|0);
 _AllocReset();
 HEAPF64[((10464)>>3)]=0.0;
 HEAPF64[((10440)>>3)]=0.0;
 HEAPF64[((10448)>>3)]=0.0;
 HEAPF64[((10456)>>3)]=0.0;
 $63=((HEAP32[((15568)>>2)])|0);
 $64=((HEAP32[((15296)>>2)])|0);
 $65=((_fseek((($63)|0),(($64)|0),((0)|0)))|0);
 HEAP32[((15576)>>2)]=0;
 HEAP32[((13864)>>2)]=0;
 $66=((HEAP32[((13280)>>2)])|0);
 HEAP32[((13264)>>2)]=$66;
 HEAP32[((14384)>>2)]=0;
 return;
}


function _setReactflag(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$7=0,$8=0,$i_010=0,$10=0,$11=0,$12=0,$14=0,$15=.0,$16=0,$18=0,$19=.0,$20=0,$22=0,$23=0,$i_1=0;
 var $25=0,$27=0,$28=.0,$29=0,$30=0,$_0=0,label=0;

 $1=((HEAP8[(13856)])|0);
 if ((((($1<<24)>>24))|0)==((3)|0)) {
  $_0=0;

  return (($_0)|0);
 } else if ((((($1<<24)>>24))|0)==((2)|0)) {
  $_0=1;

  return (($_0)|0);
 } else {
  $2=((HEAP32[((14424)>>2)])|0);
  $3=($2|0)<1;
  L3: do {
   if (!($3)) {
    $4=((HEAP32[((14960)>>2)])|0);
    $5=((HEAP32[((14424)>>2)])|0);
    $i_010=1;
    while(1) {

     $10=(($4+((($i_010)*(104))&-1)+96)|0);
     $11=((HEAP8[($10)])|0);
     $12=(($11<<24)>>24)<2;
     if ($12) {
      $14=(($4+((($i_010)*(104))&-1)+72)|0);
      $15=(+(HEAPF64[(($14)>>3)]));
      $16=$15!=(0.0);
      if ($16) {
       $_0=1;
       label = 12;
       break;
      }
      $18=(($4+((($i_010)*(104))&-1)+80)|0);
      $19=(+(HEAPF64[(($18)>>3)]));
      $20=$19!=(0.0);
      if ($20) {
       $_0=1;
       label = 12;
       break;
      }
     }
     $22=((($i_010)+(1))|0);
     $23=($22|0)>($5|0);
     if ($23) {
      break L3;
     } else {
      $i_010=$22;
     }
    }
    if ((label|0) == 12) {

     return (($_0)|0);
    }
   }
  } while(0);
  $7=((HEAP32[((14352)>>2)])|0);
  $8=((HEAP32[((13176)>>2)])|0);
  $i_1=1;
  while(1) {

   $25=($i_1|0)>($7|0);
   if ($25) {
    $_0=0;
    label = 12;
    break;
   }
   $27=(($8+((($i_1)*(112))&-1)+64)|0);
   $28=(+(HEAPF64[(($27)>>3)]));
   $29=$28!=(0.0);
   $30=((($i_1)+(1))|0);
   if ($29) {
    $_0=1;
    label = 12;
    break;
   } else {
    $i_1=$30;
   }
  }
  if ((label|0) == 12) {

   return (($_0)|0);
  }
 }
  return 0;
}


function _runqual($t){
 $t=($t)|0;
 var $hydtime=0,$hydstep=0,$1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$9=0,$errcode_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+16)|0;
 $hydtime=((sp)|0);
 $hydstep=(((sp)+(8))|0);
 $1=((HEAP32[((13864)>>2)])|0);
 HEAP32[(($t)>>2)]=$1;
 $2=((HEAP32[((13864)>>2)])|0);
 $3=((HEAP32[((15576)>>2)])|0);
 $4=($2|0)==($3|0);
 if (!($4)) {
  $errcode_0=0;

  STACKTOP=sp;return (($errcode_0)|0);
 }
 $6=((_gethyd($hydtime,$hydstep))|0);
 $7=((HEAP32[(($hydtime)>>2)])|0);
 $8=((HEAP32[(($hydstep)>>2)])|0);
 $9=((($8)+($7))|0);
 HEAP32[((15576)>>2)]=$9;
 $errcode_0=$6;

 STACKTOP=sp;return (($errcode_0)|0);
}


function _gethyd($hydtime,$hydstep){
 $hydtime=($hydtime)|0;
 $hydstep=($hydstep)|0;
 var $1=0,$2=0,$4=0,$5=0,$7=0,$8=0,$9=0,$11=0,$12=0,$14=0,$15=0,$16=0,$errcode_0=0,$18=0,$19=0,$20=0,$errcode_1=0,$22=0,$23=0,$25=0;
 var $26=0,$27=0,$29=0,$30=0,$31=0,$or_cond=0,$34=0,$35=0,$_0=0,label=0;

 $1=((_readhyd($hydtime))|0);
 $2=($1|0)==0;
 if ($2) {
  $_0=307;

  return (($_0)|0);
 }
 $4=((_readhydstep($hydstep))|0);
 $5=($4|0)==0;
 if ($5) {
  $_0=307;

  return (($_0)|0);
 }
 $7=((HEAP32[(($hydtime)>>2)])|0);
 HEAP32[((15576)>>2)]=$7;
 $8=((HEAP32[((13264)>>2)])|0);
 $9=($7|0)<($8|0);
 if ($9) {
  $errcode_1=0;
 } else {
  $11=((HEAP8[(13208)])|0);
  $12=(($11<<24)>>24)==0;
  if ($12) {
   $errcode_0=0;
  } else {
   $14=((_saveoutput())|0);
   $15=((HEAP32[((14384)>>2)])|0);
   $16=((($15)+(1))|0);
   HEAP32[((14384)>>2)]=$16;
   $errcode_0=$14;
  }

  $18=((HEAP32[((13272)>>2)])|0);
  $19=((HEAP32[((13264)>>2)])|0);
  $20=((($19)+($18))|0);
  HEAP32[((13264)>>2)]=$20;
  $errcode_1=$errcode_0;
 }

 $22=((HEAP8[(13856)])|0);
 $23=(($22<<24)>>24)==0;
 if ($23) {
  $_0=$errcode_1;

  return (($_0)|0);
 }
 $25=((HEAP32[((13864)>>2)])|0);
 $26=((HEAP32[((17544)>>2)])|0);
 $27=($25|0)<($26|0);
 if (!($27)) {
  $_0=$errcode_1;

  return (($_0)|0);
 }
 $29=((HEAP8[(13840)])|0);
 $30=(($29<<24)>>24)==0;
 $31=(($22<<24)>>24)==2;
 $or_cond=$30|$31;
 if (!($or_cond)) {
  _ratecoeffs();
 }
 $34=((HEAP32[((13864)>>2)])|0);
 $35=($34|0)==0;
 if ($35) {
  _initsegs();
  $_0=$errcode_1;

  return (($_0)|0);
 } else {
  _reorientsegs();
  $_0=$errcode_1;

  return (($_0)|0);
 }
}


function _nextqual($tstep){
 $tstep=($tstep)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$or_cond=0,$9=0,$10=0,$not_=0,$12=0,$13=0,$14=0,$15=0,$or_cond9=0,$17=0,$18=0,$20=0,$21=0,$22=0;
 var $errcode_1=0,label=0;

 HEAP32[(($tstep)>>2)]=0;
 $1=((HEAP32[((15576)>>2)])|0);
 $2=((HEAP32[((13864)>>2)])|0);
 $3=((($1)-($2))|0);
 $4=((HEAP8[(13856)])|0);
 $5=(($4<<24)>>24)!=0;
 $6=($3|0)>0;
 $or_cond=$5&$6;
 if ($or_cond) {
  _transport($3);
 }
 $9=((HEAP8[(14008)])|0);
 $10=(($9<<24)>>24)==0;
 if (!($10)) {
  $21=((HEAP32[((13864)>>2)])|0);
  $22=((($21)+($3))|0);
  HEAP32[((13864)>>2)]=$22;
  $errcode_1=101;

  return (($errcode_1)|0);
 }
 $not_=$10^1;
 HEAP32[(($tstep)>>2)]=$3;
 $12=((HEAP32[((13864)>>2)])|0);
 $13=((($12)+($3))|0);
 HEAP32[((13864)>>2)]=$13;
 $14=((HEAP8[(13208)])|0);
 $15=(($14<<24)>>24)==0;
 $or_cond9=$15|$not_;
 if ($or_cond9) {
  $errcode_1=0;

  return (($errcode_1)|0);
 }
 $17=((HEAP32[(($tstep)>>2)])|0);
 $18=($17|0)==0;
 if (!($18)) {
  $errcode_1=0;

  return (($errcode_1)|0);
 }
 $20=((_savefinaloutput())|0);
 $errcode_1=$20;

 return (($errcode_1)|0);
}


function _transport($tstep){
 $tstep=($tstep)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$or_cond12=0,$qtime_013=0,$6=0,$7=0,$8=0,$_=0,$9=0,$10=0,$11=0,$14=0,$15=0,$16=0,$or_cond=0,label=0;

 $1=((HEAP32[((13200)>>2)])|0);
 $2=((_AllocSetPool($1))|0);
 $3=((HEAP8[(14008)])|0);
 $4=(($3<<24)>>24)==0;
 $5=($tstep|0)>0;
 $or_cond12=$4&$5;
 if ($or_cond12) {
  $qtime_013=0;
 } else {
  _updatesourcenodes($tstep);
  return;
 }
 while(1) {

  $6=((HEAP32[((13872)>>2)])|0);
  $7=((($tstep)-($qtime_013))|0);
  $8=($6|0)>($7|0);
  $_=($8?$7:$6);
  $9=((($_)+($qtime_013))|0);
  $10=((HEAP8[(13840)])|0);
  $11=(($10<<24)>>24)==0;
  if (!($11)) {
   _updatesegs($_);
  }
  _accumulate($_);
  _updatenodes($_);
  _sourceinput($_);
  _release($_);
  $14=((HEAP8[(14008)])|0);
  $15=(($14<<24)>>24)==0;
  $16=($9|0)<($tstep|0);
  $or_cond=$15&$16;
  if ($or_cond) {
   $qtime_013=$9;
  } else {
   break;
  }
 }
 _updatesourcenodes($tstep);
 return;
}


function _closequal(){
 var $1=0,$2=0,$4=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,label=0;

 $1=((HEAP32[((13200)>>2)])|0);
 $2=($1|0)==0;
 if (!($2)) {
  $4=((_AllocSetPool($1))|0);
  _AllocFreePool();
 }
 $6=((HEAP32[((15648)>>2)])|0);
 _free($6);
 $8=((HEAP32[((14984)>>2)])|0);
 _free($8);
 $10=((HEAP32[((15640)>>2)])|0);
 _free($10);
 $12=((HEAP32[((12016)>>2)])|0);
 _free($12);
 $14=((HEAP32[((14680)>>2)])|0);
 _free($14);
 $16=((HEAP32[((13848)>>2)])|0);
 _free($16);
 $18=((HEAP32[((12000)>>2)])|0);
 _free($18);
 return ((0)|0);
}


function _ratecoeffs(){
 var $1=0,$2=0,$k_07=0,$3=0,$4=0,$5=.0,$6=0,$8=.0,$kw_0=.0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $k_07=1;
 }
 while(1) {

  $3=((HEAP32[((14960)>>2)])|0);
  $4=(($3+((($k_07)*(104))&-1)+80)|0);
  $5=(+(HEAPF64[(($4)>>3)]));
  $6=$5!=(0.0);
  if ($6) {
   $8=(+(_piperate($k_07)));
   $kw_0=$8;
  } else {
   $kw_0=$5;
  }

  $10=((HEAP32[((14960)>>2)])|0);
  $11=(($10+((($k_07)*(104))&-1)+88)|0);
  HEAPF64[(($11)>>3)]=$kw_0;
  $12=((HEAP32[((13848)>>2)])|0);
  $13=(($12+($k_07<<3))|0);
  HEAPF64[(($13)>>3)]=0.0;
  $14=((($k_07)+(1))|0);
  $15=((HEAP32[((14424)>>2)])|0);
  $16=($14|0)>($15|0);
  if ($16) {
   break;
  } else {
   $k_07=$14;
  }
 }
 return;
}


function _initsegs(){
 var $1=0,$2=0,$3=0,$4=0,$k_038=0,$5=0,$6=0,$7=0,$8=0,$9=.0,$10=0,$12=0,$13=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$21=0;
 var $22=0,$23=0,$25=0,$27=0,$_in=0,$29=0,$30=0,$31=0,$33=0,$34=0,$36=0,$37=0,$38=0,$c_0_in=0,$c_0=.0,$40=0,$41=0,$42=.0,$43=.0,$44=0;
 var $45=.0,$46=.0,$47=.0,$48=0,$49=0,$50=0,$j_037=0,$51=0,$52=0,$53=.0,$54=0,$56=0,$57=0,$58=0,$60=0,$61=0,$62=0,$63=.0,$64=0,$65=0;
 var $66=0,$67=0,$68=0,$69=0,$70=0,$71=0,$72=0,$73=.0,$75=0,$76=.0,$77=.0,$78=0,$79=.0,$80=0,$81=0,$82=.0,$83=.0,$86=0,$87=0,$88=0;
 var label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=($1|0)<1;
 if (!($2)) {
  $k_038=1;
  while(1) {

   $5=((HEAP32[((15640)>>2)])|0);
   $6=(($5+$k_038)|0);
   HEAP8[($6)]=43;
   $7=((HEAP32[((13880)>>2)])|0);
   $8=(($7+($k_038<<3))|0);
   $9=(+(HEAPF64[(($8)>>3)]));
   $10=$9<(0.0);
   if ($10) {
    $12=((HEAP32[((15640)>>2)])|0);
    $13=(($12+$k_038)|0);
    HEAP8[($13)]=45;
   }
   $15=((HEAP32[((14984)>>2)])|0);
   $16=(($15+($k_038<<2))|0);
   HEAP32[(($16)>>2)]=0;
   $17=((HEAP32[((15648)>>2)])|0);
   $18=(($17+($k_038<<2))|0);
   HEAP32[(($18)>>2)]=0;
   $19=((HEAP32[((15640)>>2)])|0);
   $20=(($19+$k_038)|0);
   $21=((HEAP8[($20)])|0);
   $22=(($21<<24)>>24)==43;
   $23=((HEAP32[((14960)>>2)])|0);
   if ($22) {
    $25=(($23+((($k_038)*(104))&-1)+36)|0);
    $_in=$25;
   } else {
    $27=(($23+((($k_038)*(104))&-1)+32)|0);
    $_in=$27;
   }

   $29=((HEAP32[(($_in)>>2)])|0);
   $30=((HEAP32[((14432)>>2)])|0);
   $31=($29|0)>($30|0);
   if ($31) {
    $36=((($29)-($30))|0);
    $37=((HEAP32[((13176)>>2)])|0);
    $38=(($37+((($36)*(112))&-1)+80)|0);
    $c_0_in=$38;
   } else {
    $33=((HEAP32[((17736)>>2)])|0);
    $34=(($33+($29<<3))|0);
    $c_0_in=$34;
   }

   $c_0=(+(HEAPF64[(($c_0_in)>>3)]));
   $40=((HEAP32[((14960)>>2)])|0);
   $41=(($40+((($k_038)*(104))&-1)+48)|0);
   $42=(+(HEAPF64[(($41)>>3)]));
   $43=($42)*((0.785398));
   $44=(($40+((($k_038)*(104))&-1)+40)|0);
   $45=(+(HEAPF64[(($44)>>3)]));
   $46=($45)*($45);
   $47=($43)*($46);
   _addseg($k_038,$47,$c_0);
   $48=((($k_038)+(1))|0);
   $49=((HEAP32[((14424)>>2)])|0);
   $50=($48|0)>($49|0);
   if ($50) {
    break;
   } else {
    $k_038=$48;
   }
  }
 }
 $3=((HEAP32[((14352)>>2)])|0);
 $4=($3|0)<1;
 if ($4) {
  return;
 } else {
  $j_037=1;
 }
 while(1) {

  $51=((HEAP32[((13176)>>2)])|0);
  $52=(($51+((($j_037)*(112))&-1)+8)|0);
  $53=(+(HEAPF64[(($52)>>3)]));
  $54=$53==(0.0);
  do {
   if (!($54)) {
    $56=(($51+((($j_037)*(112))&-1)+96)|0);
    $57=((HEAP8[($56)])|0);
    $58=(($57<<24)>>24)==0;
    if ($58) {
     break;
    }
    $60=((HEAP32[((14424)>>2)])|0);
    $61=((($60)+($j_037))|0);
    $62=(($51+((($j_037)*(112))&-1)+80)|0);
    $63=(+(HEAPF64[(($62)>>3)]));
    $64=((HEAP32[((14984)>>2)])|0);
    $65=(($64+($61<<2))|0);
    HEAP32[(($65)>>2)]=0;
    $66=((HEAP32[((15648)>>2)])|0);
    $67=(($66+($61<<2))|0);
    HEAP32[(($67)>>2)]=0;
    $68=((HEAP32[((13176)>>2)])|0);
    $69=(($68+((($j_037)*(112))&-1)+96)|0);
    $70=((HEAP8[($69)])|0);
    $71=(($70<<24)>>24)==1;
    $72=(($68+((($j_037)*(112))&-1)+72)|0);
    $73=(+(HEAPF64[(($72)>>3)]));
    if ($71) {
     $75=(($68+((($j_037)*(112))&-1)+104)|0);
     $76=(+(HEAPF64[(($75)>>3)]));
     $77=($73)-($76);
     $78=$77>(0.0);
     $79=($78?$77:(0.0));
     _addseg($61,$79,$63);
     $80=((HEAP32[((13176)>>2)])|0);
     $81=(($80+((($j_037)*(112))&-1)+72)|0);
     $82=(+(HEAPF64[(($81)>>3)]));
     $83=($82)-($79);
     _addseg($61,$83,$63);
     break;
    } else {
     _addseg($61,$73,$63);
     break;
    }
   }
  } while(0);
  $86=((($j_037)+(1))|0);
  $87=((HEAP32[((14352)>>2)])|0);
  $88=($86|0)>($87|0);
  if ($88) {
   break;
  } else {
   $j_037=$86;
  }
 }
 return;
}


function _reorientsegs(){
 var $1=0,$2=0,$k_017=0,$3=0,$4=0,$5=.0,$6=0,$8=0,$9=0,$10=0,$12=0,$newdir_0=0,$15=0,$16=0,$17=0,$18=0,$20=0,$21=0,$22=0,$23=0;
 var $24=0,$25=0,$26=0,$27=0,$28=0,$pseg_016=0,$seg_015=0,$29=0,$30=0,$31=0,$32=0,$33=0,$35=0,$36=0,$37=0,label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $k_017=1;
 }
 while(1) {

  $3=((HEAP32[((13880)>>2)])|0);
  $4=(($3+($k_017<<3))|0);
  $5=(+(HEAPF64[(($4)>>3)]));
  $6=$5==(0.0);
  do {
   if ($6) {
    $8=((HEAP32[((15640)>>2)])|0);
    $9=(($8+$k_017)|0);
    $10=((HEAP8[($9)])|0);
    $newdir_0=$10;
   } else {
    $12=$5<(0.0);
    if (!($12)) {
     $newdir_0=43;
     break;
    }
    $newdir_0=45;
   }
  } while(0);

  $15=((HEAP32[((15640)>>2)])|0);
  $16=(($15+$k_017)|0);
  $17=((HEAP8[($16)])|0);
  $18=(($newdir_0<<24)>>24)==(($17<<24)>>24);
  if (!($18)) {
   $20=((HEAP32[((15648)>>2)])|0);
   $21=(($20+($k_017<<2))|0);
   $22=((HEAP32[(($21)>>2)])|0);
   $23=((HEAP32[((14984)>>2)])|0);
   $24=(($23+($k_017<<2))|0);
   $25=((HEAP32[(($24)>>2)])|0);
   HEAP32[(($21)>>2)]=$25;
   $26=((HEAP32[((14984)>>2)])|0);
   $27=(($26+($k_017<<2))|0);
   HEAP32[(($27)>>2)]=$22;
   $28=($22|0)==0;
   if (!($28)) {
    $seg_015=$22;$pseg_016=0;
    while(1) {


     $29=(($seg_015+16)|0);
     $30=((HEAP32[(($29)>>2)])|0);
     HEAP32[(($29)>>2)]=$pseg_016;
     $31=($30|0)==0;
     if ($31) {
      break;
     } else {
      $pseg_016=$seg_015;$seg_015=$30;
     }
    }
   }
   $32=((HEAP32[((15640)>>2)])|0);
   $33=(($32+$k_017)|0);
   HEAP8[($33)]=$newdir_0;
  }
  $35=((($k_017)+(1))|0);
  $36=((HEAP32[((14424)>>2)])|0);
  $37=($35|0)>($36|0);
  if ($37) {
   break;
  } else {
   $k_017=$35;
  }
 }
 return;
}


function _updatesegs($dt){
 $dt=($dt)|0;
 var $1=0,$2=0,$3=.0,$k_026=0,$5=0,$6=0,$7=.0,$8=0,$10=0,$11=0,$seg_021=0,$12=0,$seg_024=0,$vsum_023=.0,$rsum_022=.0,$13=0,$14=.0,$15=0,$16=.0,$17=.0;
 var $18=0,$19=0,$21=.0,$22=0,$24=.0,$26=.0,$27=.0,$28=.0,$29=.0,$30=.0,$rsum_1=.0,$vsum_1=.0,$32=0,$seg_0=0,$33=0,$34=0,$36=.0,$37=.0,$38=.0,$39=0;
 var $40=0,$41=0,$42=0,$44=0,$45=0,$46=0,label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 }
 $3=(+((($dt|0))|0));
 $k_026=1;
 while(1) {

  $5=((HEAP32[((14960)>>2)])|0);
  $6=(($5+((($k_026)*(104))&-1)+48)|0);
  $7=(+(HEAPF64[(($6)>>3)]));
  $8=$7==(0.0);
  L6: do {
   if (!($8)) {
    $10=((HEAP32[((15648)>>2)])|0);
    $11=(($10+($k_026<<2))|0);
    $seg_021=((HEAP32[(($11)>>2)])|0);
    $12=($seg_021|0)==0;
    do {
     if (!($12)) {
      $rsum_022=0.0;$vsum_023=0.0;$seg_024=$seg_021;
      while(1) {



       $13=(($seg_024+8)|0);
       $14=(+(HEAPF64[(($13)>>3)]));
       $15=(($seg_024)|0);
       $16=(+(HEAPF64[(($15)>>3)]));
       $17=(+(_pipereact($k_026,$14,$16,$dt)));
       HEAPF64[(($13)>>3)]=$17;
       $18=((HEAP8[(13856)])|0);
       $19=(($18<<24)>>24)==1;
       if ($19) {
        $21=($17)-($14);
        $22=$21<(0.0);
        if ($22) {
         $24=((-.0))-($21);
         $26=$24;
        } else {
         $26=$21;
        }

        $27=(+(HEAPF64[(($15)>>3)]));
        $28=($26)*($27);
        $29=($rsum_022)+($28);
        $30=($vsum_023)+($27);
        $vsum_1=$30;$rsum_1=$29;
       } else {
        $vsum_1=$vsum_023;$rsum_1=$rsum_022;
       }


       $32=(($seg_024+16)|0);
       $seg_0=((HEAP32[(($32)>>2)])|0);
       $33=($seg_0|0)==0;
       if ($33) {
        break;
       } else {
        $rsum_022=$rsum_1;$vsum_023=$vsum_1;$seg_024=$seg_0;
       }
      }
      $34=$vsum_1>(0.0);
      if (!($34)) {
       break;
      }
      $36=($rsum_1)/($vsum_1);
      $37=($36)/($3);
      $38=($37)*((86400.0));
      $39=((HEAP32[((13848)>>2)])|0);
      $40=(($39+($k_026<<3))|0);
      HEAPF64[(($40)>>3)]=$38;
      break L6;
     }
    } while(0);
    $41=((HEAP32[((13848)>>2)])|0);
    $42=(($41+($k_026<<3))|0);
    HEAPF64[(($42)>>3)]=0.0;
   }
  } while(0);
  $44=((($k_026)+(1))|0);
  $45=((HEAP32[((14424)>>2)])|0);
  $46=($44|0)>($45|0);
  if ($46) {
   break;
  } else {
   $k_026=$44;
  }
 }
 return;
}


function _accumulate($dt){
 $dt=($dt)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0;
 var $k_067=0,$21=0,$22=0,$23=0,$24=0,$25=0,$27=0,$29=0,$_in53=0,$31=0,$32=0,$33=0,$34=0,$35=0,$37=0,$38=.0,$39=0,$40=0,$41=.0,$42=.0;
 var $43=0,$44=0,$45=.0,$46=.0,$48=0,$49=0,$50=0,$51=0,$52=0,$54=0,$56=0,$_in54=0,$58=0,$59=0,$60=0,$61=0,$62=0,$64=0,$65=.0,$66=0;
 var $67=0,$68=.0,$69=.0,$70=0,$71=0,$72=.0,$73=.0,$75=0,$76=0,$77=0,$78=0,$k_162=0,$79=0,$80=.0,$81=0,$83=0,$84=0,$85=.0,$86=.0,$87=0;
 var $88=0,$90=0,$91=0,$92=0,$93=0,$_lcssa61=0,$_lcssa=0,$94=0,$95=0,$96=0,$97=0,$98=0,$99=0,$100=0,$101=0,$102=0,$103=0,$104=.0,$k_256=0,$106=0;
 var $107=0,$108=0,$109=0,$110=0,$112=0,$114=0,$_in=0,$116=0,$117=0,$118=0,$119=.0,$120=0,$122=.0,$124=.0,$125=.0,$126=0,$v_055=.0,$127=0,$128=0,$129=0;
 var $130=0,$132=0,$133=.0,$134=0,$135=.0,$136=0,$137=0,$138=0,$139=0,$v_0_=.0,$140=0,$141=.0,$142=0,$143=0,$144=.0,$145=.0,$146=.0,$147=0,$148=0,$149=.0;
 var $150=.0,$151=.0,$152=0,$154=.0,$155=0,$157=0,$158=0,$159=0,$160=0,$161=0,$162=0,$163=0,$164=0,$166=0,$167=0,$169=0,$171=.0,$172=.0,$173=0,$174=0;
 var $175=0,$176=0,label=0;

 $1=((HEAP32[((12016)>>2)])|0);
 $2=$1;
 $3=((HEAP32[((14416)>>2)])|0);
 $4=$3<<3;
 $5=((($4)+(8))|0);
 _memset((((($2)|0))|0), ((((0)|0))|0), (((($5)|0))|0))|0;
 $6=((HEAP32[((14680)>>2)])|0);
 $7=$6;
 $8=((HEAP32[((14416)>>2)])|0);
 $9=$8<<3;
 $10=((($9)+(8))|0);
 _memset((((($7)|0))|0), ((((0)|0))|0), (((($10)|0))|0))|0;
 $11=((HEAP32[((12000)>>2)])|0);
 $12=$11;
 $13=((HEAP32[((14416)>>2)])|0);
 $14=$13<<3;
 $15=((($14)+(8))|0);
 _memset((((($12)|0))|0), ((((0)|0))|0), (((($15)|0))|0))|0;
 $16=((HEAP32[((14424)>>2)])|0);
 $17=($16|0)<1;
 if (!($17)) {
  $k_067=1;
  while(1) {

   $21=((HEAP32[((15640)>>2)])|0);
   $22=(($21+$k_067)|0);
   $23=((HEAP8[($22)])|0);
   $24=(($23<<24)>>24)==43;
   $25=((HEAP32[((14960)>>2)])|0);
   if ($24) {
    $27=(($25+((($k_067)*(104))&-1)+36)|0);
    $_in53=$27;
   } else {
    $29=(($25+((($k_067)*(104))&-1)+32)|0);
    $_in53=$29;
   }

   $31=((HEAP32[(($_in53)>>2)])|0);
   $32=((HEAP32[((15648)>>2)])|0);
   $33=(($32+($k_067<<2))|0);
   $34=((HEAP32[(($33)>>2)])|0);
   $35=($34|0)==0;
   if (!($35)) {
    $37=(($34+8)|0);
    $38=(+(HEAPF64[(($37)>>3)]));
    $39=((HEAP32[((14680)>>2)])|0);
    $40=(($39+($31<<3))|0);
    $41=(+(HEAPF64[(($40)>>3)]));
    $42=($38)+($41);
    HEAPF64[(($40)>>3)]=$42;
    $43=((HEAP32[((12016)>>2)])|0);
    $44=(($43+($31<<3))|0);
    $45=(+(HEAPF64[(($44)>>3)]));
    $46=($45)+((1.0));
    HEAPF64[(($44)>>3)]=$46;
   }
   $48=((HEAP32[((15640)>>2)])|0);
   $49=(($48+$k_067)|0);
   $50=((HEAP8[($49)])|0);
   $51=(($50<<24)>>24)==43;
   $52=((HEAP32[((14960)>>2)])|0);
   if ($51) {
    $54=(($52+((($k_067)*(104))&-1)+32)|0);
    $_in54=$54;
   } else {
    $56=(($52+((($k_067)*(104))&-1)+36)|0);
    $_in54=$56;
   }

   $58=((HEAP32[(($_in54)>>2)])|0);
   $59=((HEAP32[((14984)>>2)])|0);
   $60=(($59+($k_067<<2))|0);
   $61=((HEAP32[(($60)>>2)])|0);
   $62=($61|0)==0;
   if (!($62)) {
    $64=(($61+8)|0);
    $65=(+(HEAPF64[(($64)>>3)]));
    $66=((HEAP32[((14680)>>2)])|0);
    $67=(($66+($58<<3))|0);
    $68=(+(HEAPF64[(($67)>>3)]));
    $69=($65)+($68);
    HEAPF64[(($67)>>3)]=$69;
    $70=((HEAP32[((12016)>>2)])|0);
    $71=(($70+($58<<3))|0);
    $72=(+(HEAPF64[(($71)>>3)]));
    $73=($72)+((1.0));
    HEAPF64[(($71)>>3)]=$73;
   }
   $75=((($k_067)+(1))|0);
   $76=((HEAP32[((14424)>>2)])|0);
   $77=($75|0)>($76|0);
   if ($77) {
    break;
   } else {
    $k_067=$75;
   }
  }
 }
 $18=((HEAP32[((14416)>>2)])|0);
 $19=($18|0)<1;
 $20=((HEAP32[((12016)>>2)])|0);
 if ($19) {
  $_lcssa=$18;$_lcssa61=$20;
 } else {
  $k_162=1;$78=$20;
  while(1) {


   $79=(($78+($k_162<<3))|0);
   $80=(+(HEAPF64[(($79)>>3)]));
   $81=$80>(0.0);
   if ($81) {
    $83=((HEAP32[((14680)>>2)])|0);
    $84=(($83+($k_162<<3))|0);
    $85=(+(HEAPF64[(($84)>>3)]));
    $86=($85)/($80);
    $87=((HEAP32[((12000)>>2)])|0);
    $88=(($87+($k_162<<3))|0);
    HEAPF64[(($88)>>3)]=$86;
   }
   $90=((($k_162)+(1))|0);
   $91=((HEAP32[((14416)>>2)])|0);
   $92=($90|0)>($91|0);
   $93=((HEAP32[((12016)>>2)])|0);
   if ($92) {
    $_lcssa=$91;$_lcssa61=$93;
    break;
   } else {
    $k_162=$90;$78=$93;
   }
  }
 }


 $94=$_lcssa61;
 $95=$_lcssa<<3;
 $96=((($95)+(8))|0);
 _memset((((($94)|0))|0), ((((0)|0))|0), (((($96)|0))|0))|0;
 $97=((HEAP32[((14680)>>2)])|0);
 $98=$97;
 $99=((HEAP32[((14416)>>2)])|0);
 $100=$99<<3;
 $101=((($100)+(8))|0);
 _memset((((($98)|0))|0), ((((0)|0))|0), (((($101)|0))|0))|0;
 $102=((HEAP32[((14424)>>2)])|0);
 $103=($102|0)<1;
 if ($103) {
  return;
 }
 $104=(+((($dt|0))|0));
 $k_256=1;
 while(1) {

  $106=((HEAP32[((15640)>>2)])|0);
  $107=(($106+$k_256)|0);
  $108=((HEAP8[($107)])|0);
  $109=(($108<<24)>>24)==43;
  $110=((HEAP32[((14960)>>2)])|0);
  if ($109) {
   $112=(($110+((($k_256)*(104))&-1)+36)|0);
   $_in=$112;
  } else {
   $114=(($110+((($k_256)*(104))&-1)+32)|0);
   $_in=$114;
  }

  $116=((HEAP32[(($_in)>>2)])|0);
  $117=((HEAP32[((13880)>>2)])|0);
  $118=(($117+($k_256<<3))|0);
  $119=(+(HEAPF64[(($118)>>3)]));
  $120=$119<(0.0);
  if ($120) {
   $122=((-.0))-($119);
   $124=$122;
  } else {
   $124=$119;
  }

  $125=($104)*($124);
  $126=$125>(0.0);
  L38: do {
   if ($126) {
    $v_055=$125;
    while(1) {

     $127=((HEAP32[((15648)>>2)])|0);
     $128=(($127+($k_256<<2))|0);
     $129=((HEAP32[(($128)>>2)])|0);
     $130=($129|0)==0;
     if ($130) {
      break L38;
     }
     $132=(($129)|0);
     $133=(+(HEAPF64[(($132)>>3)]));
     $134=$133<=$v_055;
     $135=($134?$133:$v_055);
     $136=((HEAP32[((14984)>>2)])|0);
     $137=(($136+($k_256<<2))|0);
     $138=((HEAP32[(($137)>>2)])|0);
     $139=($129|0)==($138|0);
     $v_0_=($139?$v_055:$135);
     $140=(($129+8)|0);
     $141=(+(HEAPF64[(($140)>>3)]));
     $142=((HEAP32[((12016)>>2)])|0);
     $143=(($142+($116<<3))|0);
     $144=(+(HEAPF64[(($143)>>3)]));
     $145=($v_0_)+($144);
     HEAPF64[(($143)>>3)]=$145;
     $146=($141)*($v_0_);
     $147=((HEAP32[((14680)>>2)])|0);
     $148=(($147+($116<<3))|0);
     $149=(+(HEAPF64[(($148)>>3)]));
     $150=($146)+($149);
     HEAPF64[(($148)>>3)]=$150;
     $151=($v_055)-($v_0_);
     $152=$151<(0.0);
     do {
      if ($152) {
       label = 31;
      } else {
       $154=(+(HEAPF64[(($132)>>3)]));
       $155=$v_0_<$154;
       if ($155) {
        label = 31;
        break;
       }
       $157=(($129+16)|0);
       $158=((HEAP32[(($157)>>2)])|0);
       $159=((HEAP32[((15648)>>2)])|0);
       $160=(($159+($k_256<<2))|0);
       HEAP32[(($160)>>2)]=$158;
       $161=((HEAP32[((15648)>>2)])|0);
       $162=(($161+($k_256<<2))|0);
       $163=((HEAP32[(($162)>>2)])|0);
       $164=($163|0)==0;
       if ($164) {
        $166=((HEAP32[((14984)>>2)])|0);
        $167=(($166+($k_256<<2))|0);
        HEAP32[(($167)>>2)]=0;
       }
       $169=((HEAP32[((15608)>>2)])|0);
       HEAP32[(($157)>>2)]=$169;
       HEAP32[((15608)>>2)]=$129;
      }
     } while(0);
     if ((label|0) == 31) {
      label = 0;
      $171=(+(HEAPF64[(($132)>>3)]));
      $172=($171)-($v_0_);
      HEAPF64[(($132)>>3)]=$172;
     }
     $173=$151>(0.0);
     if ($173) {
      $v_055=$151;
     } else {
      break;
     }
    }
   }
  } while(0);
  $174=((($k_256)+(1))|0);
  $175=((HEAP32[((14424)>>2)])|0);
  $176=($174|0)>($175|0);
  if ($176) {
   break;
  } else {
   $k_256=$174;
  }
 }
 return;
}


function _updatenodes($dt){
 $dt=($dt)|0;
 var $1=0,$2=0,$3=.0,$i_011=0,$5=0,$6=0,$7=.0,$8=0,$10=.0,$11=0,$12=0,$13=.0,$14=.0,$16=0,$17=0,$18=.0,$19=0,$21=0,$22=0,$23=.0;
 var $24=.0,$25=0,$26=0,$28=0,$29=0,$30=.0,$31=0,$32=0,$34=0,$35=0,$36=0,$37=0,$38=0,$40=0,$41=0,$42=0,label=0;

 $1=((HEAP32[((14432)>>2)])|0);
 $2=($1|0)<1;
 if (!($2)) {
  $3=(+((($dt|0))|0));
  $i_011=1;
  while(1) {

   $5=((HEAP32[((17632)>>2)])|0);
   $6=(($5+($i_011<<3))|0);
   $7=(+(HEAPF64[(($6)>>3)]));
   $8=$7<(0.0);
   if ($8) {
    $10=($3)*($7);
    $11=((HEAP32[((12016)>>2)])|0);
    $12=(($11+($i_011<<3))|0);
    $13=(+(HEAPF64[(($12)>>3)]));
    $14=($13)-($10);
    HEAPF64[(($12)>>3)]=$14;
   }
   $16=((HEAP32[((12016)>>2)])|0);
   $17=(($16+($i_011<<3))|0);
   $18=(+(HEAPF64[(($17)>>3)]));
   $19=$18>(0.0);
   if ($19) {
    $21=((HEAP32[((14680)>>2)])|0);
    $22=(($21+($i_011<<3))|0);
    $23=(+(HEAPF64[(($22)>>3)]));
    $24=($23)/($18);
    $25=((HEAP32[((17736)>>2)])|0);
    $26=(($25+($i_011<<3))|0);
    HEAPF64[(($26)>>3)]=$24;
   } else {
    $28=((HEAP32[((12000)>>2)])|0);
    $29=(($28+($i_011<<3))|0);
    $30=(+(HEAPF64[(($29)>>3)]));
    $31=((HEAP32[((17736)>>2)])|0);
    $32=(($31+($i_011<<3))|0);
    HEAPF64[(($32)>>3)]=$30;
   }
   $34=((($i_011)+(1))|0);
   $35=((HEAP32[((14432)>>2)])|0);
   $36=($34|0)>($35|0);
   if ($36) {
    break;
   } else {
    $i_011=$34;
   }
  }
 }
 _updatetanks($dt);
 $37=((HEAP8[(13856)])|0);
 $38=(($37<<24)>>24)==3;
 if (!($38)) {
  return;
 }
 $40=((HEAP32[((12224)>>2)])|0);
 $41=((HEAP32[((17736)>>2)])|0);
 $42=(($41+($40<<3))|0);
 HEAPF64[(($42)>>3)]=100.0;
 return;
}


function _sourceinput($dt){
 $dt=($dt)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=.0,$11=.0,$n_041=0,$massadded_040=.0,$13=0,$14=0,$15=0,$16=0,$18=0,$19=.0,$20=0;
 var $22=0,$23=0,$24=0,$25=0,$26=.0,$28=0,$29=0,$30=.0,$31=.0,$32=.0,$volout_0=.0,$34=.0,$35=0,$37=.0,$38=0,$39=0,$40=0,$42=0,$43=0,$44=.0;
 var $45=0,$47=.0,$48=.0,$49=.0,$50=0,$51=0,$53=0,$54=0,$56=.0,$58=0,$59=0,$60=.0,$61=0,$63=.0,$64=.0,$66=.0,$massadded_1=.0,$68=.0,$69=0,$70=0;
 var $71=0,$72=.0,$73=.0,$74=0,$75=0,$76=0,$78=.0,$79=.0,$massadded_2=.0,$81=0,$82=0,$83=0,$84=0,$85=0,$86=0,$87=0,$88=0,$or_cond=0,$89=.0,$j_038=0;
 var $91=0,$92=0,$93=.0,$94=0,$96=0,$97=0,$98=0,$99=0,$100=.0,$101=0,$102=0,$103=.0,$104=.0,$105=.0,$106=0,$108=0,$109=0,$110=.0,$111=.0,$112=.0;
 var $113=.0,$115=0,$116=0,$117=0,label=0;

 $1=((HEAP32[((12000)>>2)])|0);
 $2=$1;
 $3=((HEAP32[((14416)>>2)])|0);
 $4=$3<<3;
 $5=((($4)+(8))|0);
 _memset((((($2)|0))|0), ((((0)|0))|0), (((($5)|0))|0))|0;
 $6=((HEAP8[(13856)])|0);
 $7=(($6<<24)>>24)==1;
 if (!($7)) {
  return;
 }
 $8=((HEAP32[((14416)>>2)])|0);
 $9=($8|0)<1;
 if (!($9)) {
  $10=(+((($dt|0))|0));
  $11=(+((($dt|0))|0));
  $massadded_040=0.0;$n_041=1;
  while(1) {


   $13=((HEAP32[((14408)>>2)])|0);
   $14=(($13+((($n_041)*(72))&-1)+44)|0);
   $15=((HEAP32[(($14)>>2)])|0);
   $16=($15|0)==0;
   do {
    if ($16) {
     $massadded_2=$massadded_040;
    } else {
     $18=(($15)|0);
     $19=(+(HEAPF64[(($18)>>3)]));
     $20=$19==(0.0);
     if ($20) {
      $massadded_2=$massadded_040;
      break;
     }
     $22=((HEAP32[((14432)>>2)])|0);
     $23=($n_041|0)>($22|0);
     $24=((HEAP32[((12016)>>2)])|0);
     $25=(($24+($n_041<<3))|0);
     $26=(+(HEAPF64[(($25)>>3)]));
     if ($23) {
      $28=((HEAP32[((17632)>>2)])|0);
      $29=(($28+($n_041<<3))|0);
      $30=(+(HEAPF64[(($29)>>3)]));
      $31=($10)*($30);
      $32=($26)-($31);
      $volout_0=$32;
     } else {
      $volout_0=$26;
     }

     $34=($volout_0)/($11);
     $35=$34>(0.000009999999999999999);
     if (!($35)) {
      $massadded_2=$massadded_040;
      break;
     }
     $37=(+(_sourcequal($15)));
     $38=(($15+24)|0);
     $39=((HEAP8[($38)])|0);
     $40=(($39<<24)>>24);
     do {
      if (((($40|0))|0)==((1)|0)) {
       $56=($11)*($37);
       $massadded_1=$56;
      } else if (((($40|0))|0)==((0)|0)) {
       $42=((HEAP32[((17632)>>2)])|0);
       $43=(($42+($n_041<<3))|0);
       $44=(+(HEAPF64[(($43)>>3)]));
       $45=$44<(0.0);
       if (!($45)) {
        $massadded_1=0.0;
        break;
       }
       $47=((-.0))-($37);
       $48=($44)*($47);
       $49=($11)*($48);
       $50=((HEAP32[((14432)>>2)])|0);
       $51=($n_041|0)>($50|0);
       if (!($51)) {
        $massadded_1=$49;
        break;
       }
       $53=((HEAP32[((17736)>>2)])|0);
       $54=(($53+($n_041<<3))|0);
       HEAPF64[(($54)>>3)]=0.0;
       $massadded_1=$49;
      } else if (((($40|0))|0)==((2)|0)) {
       $58=((HEAP32[((17736)>>2)])|0);
       $59=(($58+($n_041<<3))|0);
       $60=(+(HEAPF64[(($59)>>3)]));
       $61=$37>$60;
       if (!($61)) {
        $massadded_1=0.0;
        break;
       }
       $63=($37)-($60);
       $64=($volout_0)*($63);
       $massadded_1=$64;
      } else if (((($40|0))|0)==((3)|0)) {
       $66=($volout_0)*($37);
       $massadded_1=$66;
      } else {
       $massadded_1=$massadded_040;
      }
     } while(0);

     $68=($massadded_1)/($volout_0);
     $69=((HEAP32[((12000)>>2)])|0);
     $70=(($69+($n_041<<3))|0);
     HEAPF64[(($70)>>3)]=$68;
     $71=(($15+16)|0);
     $72=(+(HEAPF64[(($71)>>3)]));
     $73=($massadded_1)+($72);
     HEAPF64[(($71)>>3)]=$73;
     $74=((HEAP32[((15576)>>2)])|0);
     $75=((HEAP32[((13280)>>2)])|0);
     $76=($74|0)<($75|0);
     if ($76) {
      $massadded_2=$massadded_1;
      break;
     }
     $78=(+(HEAPF64[((10456)>>3)]));
     $79=($massadded_1)+($78);
     HEAPF64[((10456)>>3)]=$79;
     $massadded_2=$massadded_1;
    }
   } while(0);

   $81=((($n_041)+(1))|0);
   $82=((HEAP32[((14416)>>2)])|0);
   $83=($81|0)>($82|0);
   if ($83) {
    break;
   } else {
    $massadded_040=$massadded_2;$n_041=$81;
   }
  }
 }
 $84=((HEAP32[((15576)>>2)])|0);
 $85=((HEAP32[((13280)>>2)])|0);
 $86=($84|0)<($85|0);
 $87=((HEAP32[((14352)>>2)])|0);
 $88=($87|0)<1;
 $or_cond=$86|$88;
 if ($or_cond) {
  return;
 }
 $89=(+((($dt|0))|0));
 $j_038=1;
 while(1) {

  $91=((HEAP32[((13176)>>2)])|0);
  $92=(($91+((($j_038)*(112))&-1)+8)|0);
  $93=(+(HEAPF64[(($92)>>3)]));
  $94=$93==(0.0);
  do {
   if ($94) {
    $96=((HEAP32[((14432)>>2)])|0);
    $97=((($96)+($j_038))|0);
    $98=((HEAP32[((12016)>>2)])|0);
    $99=(($98+($97<<3))|0);
    $100=(+(HEAPF64[(($99)>>3)]));
    $101=((HEAP32[((17632)>>2)])|0);
    $102=(($101+($97<<3))|0);
    $103=(+(HEAPF64[(($102)>>3)]));
    $104=($89)*($103);
    $105=($100)-($104);
    $106=$105>(0.0);
    if (!($106)) {
     break;
    }
    $108=((HEAP32[((17736)>>2)])|0);
    $109=(($108+($97<<3))|0);
    $110=(+(HEAPF64[(($109)>>3)]));
    $111=($105)*($110);
    $112=(+(HEAPF64[((10456)>>3)]));
    $113=($112)+($111);
    HEAPF64[((10456)>>3)]=$113;
   }
  } while(0);
  $115=((($j_038)+(1))|0);
  $116=((HEAP32[((14352)>>2)])|0);
  $117=($115|0)>($116|0);
  if ($117) {
   break;
  } else {
   $j_038=$115;
  }
 }
 return;
}


function _release($dt){
 $dt=($dt)|0;
 var $1=0,$2=0,$3=.0,$k_027=0,$5=0,$6=0,$7=.0,$8=0,$10=0,$11=0,$12=0,$13=0,$14=0,$16=0,$18=0,$_in=0,$20=0,$21=0,$22=0,$23=.0;
 var $24=0,$26=.0,$28=.0,$29=.0,$30=0,$31=0,$32=.0,$33=0,$34=0,$35=.0,$36=.0,$37=0,$38=0,$39=0,$40=0,$42=0,$43=.0,$44=.0,$45=0,$47=.0;
 var $49=.0,$50=.0,$51=0,$53=.0,$54=0,$55=.0,$56=.0,$57=.0,$58=.0,$59=.0,$60=.0,$61=.0,$62=.0,$65=0,$66=0,$67=.0,$68=.0,$69=0,$70=.0,$71=.0;
 var $72=.0,$74=0,$75=0,$76=0,label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 }
 $3=(+((($dt|0))|0));
 $k_027=1;
 while(1) {

  $5=((HEAP32[((13880)>>2)])|0);
  $6=(($5+($k_027<<3))|0);
  $7=(+(HEAPF64[(($6)>>3)]));
  $8=$7==(0.0);
  do {
   if (!($8)) {
    $10=((HEAP32[((15640)>>2)])|0);
    $11=(($10+$k_027)|0);
    $12=((HEAP8[($11)])|0);
    $13=(($12<<24)>>24)==43;
    $14=((HEAP32[((14960)>>2)])|0);
    if ($13) {
     $16=(($14+((($k_027)*(104))&-1)+32)|0);
     $_in=$16;
    } else {
     $18=(($14+((($k_027)*(104))&-1)+36)|0);
     $_in=$18;
    }

    $20=((HEAP32[(($_in)>>2)])|0);
    $21=((HEAP32[((13880)>>2)])|0);
    $22=(($21+($k_027<<3))|0);
    $23=(+(HEAPF64[(($22)>>3)]));
    $24=$23<(0.0);
    if ($24) {
     $26=((-.0))-($23);
     $28=$26;
    } else {
     $28=$23;
    }

    $29=($3)*($28);
    $30=((HEAP32[((17736)>>2)])|0);
    $31=(($30+($20<<3))|0);
    $32=(+(HEAPF64[(($31)>>3)]));
    $33=((HEAP32[((12000)>>2)])|0);
    $34=(($33+($20<<3))|0);
    $35=(+(HEAPF64[(($34)>>3)]));
    $36=($32)+($35);
    $37=((HEAP32[((14984)>>2)])|0);
    $38=(($37+($k_027<<2))|0);
    $39=((HEAP32[(($38)>>2)])|0);
    $40=($39|0)==0;
    if ($40) {
     $65=((HEAP32[((14960)>>2)])|0);
     $66=(($65+((($k_027)*(104))&-1)+48)|0);
     $67=(+(HEAPF64[(($66)>>3)]));
     $68=($67)*((0.785398));
     $69=(($65+((($k_027)*(104))&-1)+40)|0);
     $70=(+(HEAPF64[(($69)>>3)]));
     $71=($70)*($70);
     $72=($68)*($71);
     _addseg($k_027,$72,$36);
     break;
    }
    $42=(($39+8)|0);
    $43=(+(HEAPF64[(($42)>>3)]));
    $44=($43)-($36);
    $45=$44<(0.0);
    if ($45) {
     $47=((-.0))-($44);
     $49=$47;
    } else {
     $49=$44;
    }

    $50=(+(HEAPF64[((11400)>>3)]));
    $51=$49<$50;
    if ($51) {
     $53=(+(HEAPF64[(($42)>>3)]));
     $54=(($39)|0);
     $55=(+(HEAPF64[(($54)>>3)]));
     $56=($53)*($55);
     $57=($29)*($36);
     $58=($57)+($56);
     $59=($29)+($55);
     $60=($58)/($59);
     HEAPF64[(($42)>>3)]=$60;
     $61=(+(HEAPF64[(($54)>>3)]));
     $62=($29)+($61);
     HEAPF64[(($54)>>3)]=$62;
     break;
    } else {
     _addseg($k_027,$29,$36);
     break;
    }
   }
  } while(0);
  $74=((($k_027)+(1))|0);
  $75=((HEAP32[((14424)>>2)])|0);
  $76=($74|0)>($75|0);
  if ($76) {
   break;
  } else {
   $k_027=$74;
  }
 }
 return;
}


function _updatesourcenodes($dt){
 $dt=($dt)|0;
 var $1=0,$2=0,$3=0,$4=0,$or_cond=0,$5=.0,$n_010=0,$7=0,$8=0,$9=0,$10=0,$12=0,$13=0,$14=.0,$15=0,$16=0,$17=.0,$18=.0,$19=0,$20=0;
 var $22=0,$23=0,$24=0,$25=.0,$26=0,$28=0,$29=.0,$30=0,$31=0,$33=0,$34=.0,$35=.0,$37=0,$38=0,$39=0,label=0;

 $1=((HEAP8[(13856)])|0);
 $2=(($1<<24)>>24)!=1;
 $3=((HEAP32[((14416)>>2)])|0);
 $4=($3|0)<1;
 $or_cond=$2|$4;
 if ($or_cond) {
  return;
 }
 $5=(+((($dt|0))|0));
 $n_010=1;
 while(1) {

  $7=((HEAP32[((14408)>>2)])|0);
  $8=(($7+((($n_010)*(72))&-1)+44)|0);
  $9=((HEAP32[(($8)>>2)])|0);
  $10=($9|0)==0;
  if (!($10)) {
   $12=((HEAP32[((12000)>>2)])|0);
   $13=(($12+($n_010<<3))|0);
   $14=(+(HEAPF64[(($13)>>3)]));
   $15=((HEAP32[((17736)>>2)])|0);
   $16=(($15+($n_010<<3))|0);
   $17=(+(HEAPF64[(($16)>>3)]));
   $18=($14)+($17);
   HEAPF64[(($16)>>3)]=$18;
   $19=((HEAP32[((14432)>>2)])|0);
   $20=($n_010|0)>($19|0);
   do {
    if ($20) {
     $22=((($n_010)-($19))|0);
     $23=((HEAP32[((13176)>>2)])|0);
     $24=(($23+((($22)*(112))&-1)+8)|0);
     $25=(+(HEAPF64[(($24)>>3)]));
     $26=$25>(0.0);
     if (!($26)) {
      break;
     }
     $28=(($23+((($22)*(112))&-1)+80)|0);
     $29=(+(HEAPF64[(($28)>>3)]));
     $30=((HEAP32[((17736)>>2)])|0);
     $31=(($30+($n_010<<3))|0);
     HEAPF64[(($31)>>3)]=$29;
    }
   } while(0);
   $33=(($9+16)|0);
   $34=(+(HEAPF64[(($33)>>3)]));
   $35=($34)/($5);
   HEAPF64[(($33)>>3)]=$35;
  }
  $37=((($n_010)+(1))|0);
  $38=((HEAP32[((14416)>>2)])|0);
  $39=($37|0)>($38|0);
  if ($39) {
   break;
  } else {
   $n_010=$37;
  }
 }
 return;
}


function _addseg($k,$v,$c){
 $k=($k)|0;
 $v=+($v);
 $c=+($c);
 var $1=0,$2=0,$4=0,$5=0,$7=0,$8=0,$9=0,$seg_0=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$21=0,$22=0,$23=0,$24=0,$26=0;
 var $28=0,$29=0,label=0;

 $1=((HEAP32[((15608)>>2)])|0);
 $2=($1|0)==0;
 do {
  if ($2) {
   $7=((_Alloc(24))|0);
   $8=$7;
   $9=($7|0)==0;
   if (!($9)) {
    $seg_0=$8;
    break;
   }
   HEAP8[(14008)]=1;
   return;
  } else {
   $4=(($1+16)|0);
   $5=((HEAP32[(($4)>>2)])|0);
   HEAP32[((15608)>>2)]=$5;
   $seg_0=$1;
  }
 } while(0);

 $12=(($seg_0)|0);
 HEAPF64[(($12)>>3)]=$v;
 $13=(($seg_0+8)|0);
 HEAPF64[(($13)>>3)]=$c;
 $14=(($seg_0+16)|0);
 HEAP32[(($14)>>2)]=0;
 $15=((HEAP32[((15648)>>2)])|0);
 $16=(($15+($k<<2))|0);
 $17=((HEAP32[(($16)>>2)])|0);
 $18=($17|0)==0;
 if ($18) {
  HEAP32[(($16)>>2)]=$seg_0;
 }
 $21=((HEAP32[((14984)>>2)])|0);
 $22=(($21+($k<<2))|0);
 $23=((HEAP32[(($22)>>2)])|0);
 $24=($23|0)==0;
 if (!($24)) {
  $26=(($23+16)|0);
  HEAP32[(($26)>>2)]=$seg_0;
 }
 $28=((HEAP32[((14984)>>2)])|0);
 $29=(($28+($k<<2))|0);
 HEAP32[(($29)>>2)]=$seg_0;
 return;
}


function _pipereact($k,$c,$v,$dt){
 $k=($k)|0;
 $c=+($c);
 $v=+($v);
 $dt=($dt)|0;
 var $1=0,$2=0,$4=.0,$5=.0,$6=.0,$8=0,$9=0,$10=.0,$11=.0,$12=.0,$13=.0,$14=.0,$15=0,$16=.0,$17=0,$18=.0,$19=0,$20=.0,$21=.0,$22=.0;
 var $23=.0,$24=.0,$25=0,$26=0,$27=0,$29=0,$31=.0,$33=.0,$34=.0,$35=.0,$36=.0,$37=0,$39=.0,$41=.0,$42=.0,$43=.0,$44=.0,$46=.0,$47=.0,$48=0;
 var $49=.0,$_0=.0,label=0;

 $1=((HEAP8[(13856)])|0);
 $2=(($1<<24)>>24)==2;
 if ($2) {
  $4=(+((($dt|0))|0));
  $5=($4)/((3600.0));
  $6=($5)+($c);
  $_0=$6;

  return (+($_0));
 }
 $8=((HEAP32[((14960)>>2)])|0);
 $9=(($8+((($k)*(104))&-1)+72)|0);
 $10=(+(HEAPF64[(($9)>>3)]));
 $11=(+(HEAPF64[((11416)>>3)]));
 $12=(+(_bulkrate($c,$10,$11)));
 $13=(+(HEAPF64[((11424)>>3)]));
 $14=($12)*($13);
 $15=(($8+((($k)*(104))&-1)+40)|0);
 $16=(+(HEAPF64[(($15)>>3)]));
 $17=(($8+((($k)*(104))&-1)+80)|0);
 $18=(+(HEAPF64[(($17)>>3)]));
 $19=(($8+((($k)*(104))&-1)+88)|0);
 $20=(+(HEAPF64[(($19)>>3)]));
 $21=(+(_wallrate($c,$16,$18,$20)));
 $22=(+((($dt|0))|0));
 $23=($22)*($14);
 $24=($22)*($21);
 $25=((HEAP32[((15576)>>2)])|0);
 $26=((HEAP32[((13280)>>2)])|0);
 $27=($25|0)<($26|0);
 if (!($27)) {
  $29=$23<(0.0);
  if ($29) {
   $31=((-.0))-($23);
   $33=$31;
  } else {
   $33=$23;
  }

  $34=($33)*($v);
  $35=(+(HEAPF64[((10464)>>3)]));
  $36=($35)+($34);
  HEAPF64[((10464)>>3)]=$36;
  $37=$24<(0.0);
  if ($37) {
   $39=((-.0))-($24);
   $41=$39;
  } else {
   $41=$24;
  }

  $42=($41)*($v);
  $43=(+(HEAPF64[((10440)>>3)]));
  $44=($43)+($42);
  HEAPF64[((10440)>>3)]=$44;
 }
 $46=($23)+($24);
 $47=($46)+($c);
 $48=$47<=(0.0);
 $49=($48?(0.0):$47);
 $_0=$49;

 return (+($_0));
}


function _updatetanks($dt){
 $dt=($dt)|0;
 var $1=0,$2=0,$i_012=0,$3=0,$4=0,$5=.0,$6=0,$8=0,$9=0,$10=0,$11=0,$12=.0,$13=0,$14=0,$16=0,$17=0,$18=0,$24=0,$25=0,$26=0;
 var label=0;

 $1=((HEAP32[((14352)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $i_012=1;
 }
 while(1) {

  $3=((HEAP32[((13176)>>2)])|0);
  $4=(($3+((($i_012)*(112))&-1)+8)|0);
  $5=(+(HEAPF64[(($4)>>3)]));
  $6=$5==(0.0);
  do {
   if ($6) {
    $8=(($3+((($i_012)*(112))&-1))|0);
    $9=((HEAP32[(($8)>>2)])|0);
    $10=((HEAP32[((14408)>>2)])|0);
    $11=(($10+((($9)*(72))&-1)+48)|0);
    $12=(+(HEAPF64[(($11)>>3)]));
    $13=((HEAP32[((17736)>>2)])|0);
    $14=(($13+($9<<3))|0);
    HEAPF64[(($14)>>3)]=$12;
   } else {
    $16=(($3+((($i_012)*(112))&-1)+96)|0);
    $17=((HEAP8[($16)])|0);
    $18=(($17<<24)>>24);
    if (((($18|0))|0)==((3)|0)) {
     _tankmix4($i_012,$dt);
     break;
    } else if (((($18|0))|0)==((2)|0)) {
     _tankmix3($i_012,$dt);
     break;
    } else if (((($18|0))|0)==((1)|0)) {
     _tankmix2($i_012,$dt);
     break;
    } else {
     _tankmix1($i_012,$dt);
     break;
    }
   }
  } while(0);
  $24=((($i_012)+(1))|0);
  $25=((HEAP32[((14352)>>2)])|0);
  $26=($24|0)>($25|0);
  if ($26) {
   break;
  } else {
   $i_012=$24;
  }
 }
 return;
}


function _sourcequal($source){
 $source=($source)|0;
 var $1=0,$2=.0,$3=0,$4=0,$5=0,$7=.0,$9=.0,$10=.0,$c_0=.0,$12=0,$13=0,$14=0,$16=0,$17=0,$18=0,$19=0,$20=0,$21=0,$22=0,$23=0;
 var $24=0,$25=0,$26=0,$27=0,$28=.0,$29=.0,$_0=.0,label=0;

 $1=(($source)|0);
 $2=(+(HEAPF64[(($1)>>3)]));
 $3=(($source+24)|0);
 $4=((HEAP8[($3)])|0);
 $5=(($4<<24)>>24)==1;
 if ($5) {
  $7=($2)/((60.0));
  $c_0=$7;
 } else {
  $9=(+(HEAPF64[((12072)>>3)]));
  $10=($2)/($9);
  $c_0=$10;
 }

 $12=(($source+8)|0);
 $13=((HEAP32[(($12)>>2)])|0);
 $14=($13|0)==0;
 if ($14) {
  $_0=$c_0;

  return (+($_0));
 }
 $16=((HEAP32[((13864)>>2)])|0);
 $17=((HEAP32[((13904)>>2)])|0);
 $18=((($17)+($16))|0);
 $19=((HEAP32[((13896)>>2)])|0);
 $20=(((($18|0))/(($19|0)))&-1);
 $21=((HEAP32[((13944)>>2)])|0);
 $22=(($21+((($13)*(40))&-1)+32)|0);
 $23=((HEAP32[(($22)>>2)])|0);
 $24=(((($20|0))%(($23|0)))&-1);
 $25=(($21+((($13)*(40))&-1)+36)|0);
 $26=((HEAP32[(($25)>>2)])|0);
 $27=(($26+($24<<3))|0);
 $28=(+(HEAPF64[(($27)>>3)]));
 $29=($c_0)*($28);
 $_0=$29;

 return (+($_0));
}


function _tankmix2($i,$dt){
 $i=($i)|0;
 $dt=($dt)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$or_cond=0,$12=0,$13=.0,$14=0,$15=.0,$16=0,$17=0,$18=.0,$19=.0,$20=0;
 var $21=.0,$22=0,$23=.0,$24=0,$25=0,$26=.0,$27=.0,$28=0,$29=0,$30=0,$31=0,$32=0,$33=.0,$34=.0,$35=.0,$36=0,$37=0,$38=.0,$39=0,$41=0;
 var $42=0,$43=.0,$44=.0,$cin_0=.0,$46=0,$47=0,$48=.0,$49=0,$51=.0,$52=.0,$53=.0,$54=0,$55=.0,$57=.0,$58=.0,$59=.0,$60=.0,$61=.0,$62=.0,$64=0;
 var $66=.0,$67=.0,$68=.0,$69=.0,$70=.0,$71=.0,$72=.0,$73=.0,$vt_0=.0,$75=0,$77=.0,$78=0,$80=.0,$81=0,$_=.0,$vt_1=.0,$83=.0,$84=0,$86=.0,$87=.0;
 var $88=.0,$89=.0,$90=.0,$91=.0,$92=.0,$93=.0,$94=.0,$95=.0,$96=.0,$vt_2=.0,$98=0,$100=.0,$102=.0,$104=.0,$105=0,$106=.0,$108=.0,$109=.0,$110=0,$_86=.0;
 var $111=0,$112=.0,$114=0,$115=0,$116=.0,$117=.0,$118=0,$119=0,$120=.0,$121=0,$122=.0,$123=.0,$124=0,$125=0,$126=0,$127=0,$128=.0,$129=0,$130=0,label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=((($1)+($i))|0);
 $3=((HEAP32[((14984)>>2)])|0);
 $4=(($3+($2<<2))|0);
 $5=((HEAP32[(($4)>>2)])|0);
 $6=((HEAP32[((15648)>>2)])|0);
 $7=(($6+($2<<2))|0);
 $8=((HEAP32[(($7)>>2)])|0);
 $9=($5|0)==0;
 $10=($8|0)==0;
 $or_cond=$9|$10;
 if ($or_cond) {
  return;
 }
 $12=(($5+8)|0);
 $13=(+(HEAPF64[(($12)>>3)]));
 $14=(($5)|0);
 $15=(+(HEAPF64[(($14)>>3)]));
 $16=((HEAP32[((13176)>>2)])|0);
 $17=(($16+((($i)*(112))&-1)+64)|0);
 $18=(+(HEAPF64[(($17)>>3)]));
 $19=(+(_tankreact($13,$15,$18,$dt)));
 HEAPF64[(($12)>>3)]=$19;
 $20=(($8+8)|0);
 $21=(+(HEAPF64[(($20)>>3)]));
 $22=(($8)|0);
 $23=(+(HEAPF64[(($22)>>3)]));
 $24=((HEAP32[((13176)>>2)])|0);
 $25=(($24+((($i)*(112))&-1)+64)|0);
 $26=(+(HEAPF64[(($25)>>3)]));
 $27=(+(_tankreact($21,$23,$26,$dt)));
 HEAPF64[(($20)>>3)]=$27;
 $28=((HEAP32[((13176)>>2)])|0);
 $29=(($28+((($i)*(112))&-1))|0);
 $30=((HEAP32[(($29)>>2)])|0);
 $31=((HEAP32[((17632)>>2)])|0);
 $32=(($31+($30<<3))|0);
 $33=(+(HEAPF64[(($32)>>3)]));
 $34=(+((($dt|0))|0));
 $35=($34)*($33);
 $36=((HEAP32[((12016)>>2)])|0);
 $37=(($36+($30<<3))|0);
 $38=(+(HEAPF64[(($37)>>3)]));
 $39=$38>(0.0);
 if ($39) {
  $41=((HEAP32[((14680)>>2)])|0);
  $42=(($41+($30<<3))|0);
  $43=(+(HEAPF64[(($42)>>3)]));
  $44=($43)/($38);
  $cin_0=$44;
 } else {
  $cin_0=0.0;
 }

 $46=((HEAP32[((13176)>>2)])|0);
 $47=(($46+((($i)*(112))&-1)+104)|0);
 $48=(+(HEAPF64[(($47)>>3)]));
 $49=$35>(0.0);
 do {
  if ($49) {
   $51=(+(HEAPF64[(($14)>>3)]));
   $52=($35)+($51);
   $53=($52)-($48);
   $54=$53>(0.0);
   $55=($54?$53:(0.0));
   if ($39) {
    $57=(+(HEAPF64[(($12)>>3)]));
    $58=($51)*($57);
    $59=($38)*($cin_0);
    $60=($59)+($58);
    $61=($38)+($51);
    $62=($60)/($61);
    HEAPF64[(($12)>>3)]=$62;
   }
   $64=$55>(0.0);
   if (!($64)) {
    $vt_0=$55;
    break;
   }
   $66=(+(HEAPF64[(($20)>>3)]));
   $67=(+(HEAPF64[(($22)>>3)]));
   $68=($66)*($67);
   $69=(+(HEAPF64[(($12)>>3)]));
   $70=($55)*($69);
   $71=($68)+($70);
   $72=($55)+($67);
   $73=($71)/($72);
   HEAPF64[(($20)>>3)]=$73;
   $vt_0=$55;
  } else {
   $vt_0=0.0;
  }
 } while(0);

 $75=$35<(0.0);
 do {
  if ($75) {
   $77=(+(HEAPF64[(($22)>>3)]));
   $78=$77>(0.0);
   if ($78) {
    $80=((-.0))-($35);
    $81=$77>$80;
    $_=($81?$80:$77);
    $vt_1=$_;
   } else {
    $vt_1=$vt_0;
   }

   $83=($38)+($vt_1);
   $84=$83>(0.0);
   if (!($84)) {
    $vt_2=$vt_1;
    break;
   }
   $86=(+(HEAPF64[(($12)>>3)]));
   $87=(+(HEAPF64[(($14)>>3)]));
   $88=($86)*($87);
   $89=($38)*($cin_0);
   $90=($89)+($88);
   $91=(+(HEAPF64[(($20)>>3)]));
   $92=($vt_1)*($91);
   $93=($90)+($92);
   $94=($38)+($87);
   $95=($vt_1)+($94);
   $96=($93)/($95);
   HEAPF64[(($12)>>3)]=$96;
   $vt_2=$vt_1;
  } else {
   $vt_2=$vt_0;
  }
 } while(0);

 $98=$vt_2>(0.0);
 do {
  if ($98) {
   HEAPF64[(($14)>>3)]=$48;
   $100=(+(HEAPF64[(($22)>>3)]));
   if ($49) {
    $102=($vt_2)+($100);
    HEAPF64[(($22)>>3)]=$102;
    break;
   } else {
    $104=($100)-($vt_2);
    $105=$104>(0.0);
    $106=($105?$104:(0.0));
    HEAPF64[(($22)>>3)]=$106;
    break;
   }
  } else {
   $108=(+(HEAPF64[(($14)>>3)]));
   $109=($35)+($108);
   $110=$109>$48;
   $_86=($110?$48:$109);
   $111=$_86>(0.0);
   $112=($111?$_86:(0.0));
   HEAPF64[(($14)>>3)]=$112;
   HEAPF64[(($22)>>3)]=0.0;
  }
 } while(0);
 $114=((HEAP32[((13176)>>2)])|0);
 $115=(($114+((($i)*(112))&-1)+72)|0);
 $116=(+(HEAPF64[(($115)>>3)]));
 $117=($35)+($116);
 HEAPF64[(($115)>>3)]=$117;
 $118=((HEAP32[((13176)>>2)])|0);
 $119=(($118+((($i)*(112))&-1)+72)|0);
 $120=(+(HEAPF64[(($119)>>3)]));
 $121=$120>(0.0);
 $122=($121?$120:(0.0));
 HEAPF64[(($119)>>3)]=$122;
 $123=(+(HEAPF64[(($12)>>3)]));
 $124=((HEAP32[((13176)>>2)])|0);
 $125=(($124+((($i)*(112))&-1)+80)|0);
 HEAPF64[(($125)>>3)]=$123;
 $126=((HEAP32[((13176)>>2)])|0);
 $127=(($126+((($i)*(112))&-1)+80)|0);
 $128=(+(HEAPF64[(($127)>>3)]));
 $129=((HEAP32[((17736)>>2)])|0);
 $130=(($129+($30<<3))|0);
 HEAPF64[(($130)>>3)]=$128;
 return;
}


function _tankmix3($i,$dt){
 $i=($i)|0;
 $dt=($dt)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$13=0,$14=0,$seg_070=0,$15=0,$16=.0,$17=0,$18=.0,$19=0,$20=0,$21=.0;
 var $22=.0,$23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=.0,$32=.0,$33=.0,$34=0,$35=0,$36=.0,$37=.0,$38=0,$40=0,$41=0,$42=.0;
 var $43=.0,$cin_0=.0,$45=0,$46=0,$47=.0,$48=.0,$49=0,$50=0,$51=.0,$52=0,$53=.0,$54=0,$csum_067=.0,$vsum_066=.0,$vout_065=.0,$55=0,$56=0,$57=0,$58=0,$60=0;
 var $61=.0,$62=0,$63=.0,$64=0,$65=0,$66=0,$67=0,$vout_0_=.0,$68=.0,$69=0,$70=.0,$71=.0,$72=.0,$73=.0,$74=0,$75=0,$or_cond=0,$77=0,$78=0,$79=0;
 var $81=0,$82=0,$84=.0,$85=.0,$csum_0_lcssa=.0,$vsum_0_lcssa=.0,$86=0,$88=.0,$89=0,$90=0,$91=0,$92=0,$93=0,$94=0,$95=.0,$96=0,$97=0,$99=0,$100=0,$101=.0;
 var $102=0,$103=0,$105=0,$106=0,$107=0,$108=0,$110=0,$111=.0,$112=.0,$113=0,$115=.0,$117=.0,$118=.0,$119=0,$121=0,$122=.0,$123=.0,label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=((($1)+($i))|0);
 $3=((HEAP32[((14984)>>2)])|0);
 $4=(($3+($2<<2))|0);
 $5=((HEAP32[(($4)>>2)])|0);
 $6=($5|0)==0;
 if ($6) {
  return;
 }
 $8=((HEAP32[((15648)>>2)])|0);
 $9=(($8+($2<<2))|0);
 $10=((HEAP32[(($9)>>2)])|0);
 $11=($10|0)==0;
 if ($11) {
  return;
 }
 $13=((HEAP8[(13840)])|0);
 $14=(($13<<24)>>24)==0;
 if (!($14)) {
  $seg_070=$10;
  while(1) {

   $15=(($seg_070+8)|0);
   $16=(+(HEAPF64[(($15)>>3)]));
   $17=(($seg_070)|0);
   $18=(+(HEAPF64[(($17)>>3)]));
   $19=((HEAP32[((13176)>>2)])|0);
   $20=(($19+((($i)*(112))&-1)+64)|0);
   $21=(+(HEAPF64[(($20)>>3)]));
   $22=(+(_tankreact($16,$18,$21,$dt)));
   HEAPF64[(($15)>>3)]=$22;
   $23=(($seg_070+16)|0);
   $24=((HEAP32[(($23)>>2)])|0);
   $25=($24|0)==0;
   if ($25) {
    break;
   } else {
    $seg_070=$24;
   }
  }
 }
 $26=((HEAP32[((13176)>>2)])|0);
 $27=(($26+((($i)*(112))&-1))|0);
 $28=((HEAP32[(($27)>>2)])|0);
 $29=((HEAP32[((17632)>>2)])|0);
 $30=(($29+($28<<3))|0);
 $31=(+(HEAPF64[(($30)>>3)]));
 $32=(+((($dt|0))|0));
 $33=($32)*($31);
 $34=((HEAP32[((12016)>>2)])|0);
 $35=(($34+($28<<3))|0);
 $36=(+(HEAPF64[(($35)>>3)]));
 $37=($36)-($33);
 $38=$36>(0.0);
 if ($38) {
  $40=((HEAP32[((14680)>>2)])|0);
  $41=(($40+($28<<3))|0);
  $42=(+(HEAPF64[(($41)>>3)]));
  $43=($42)/($36);
  $cin_0=$43;
 } else {
  $cin_0=0.0;
 }

 $45=((HEAP32[((13176)>>2)])|0);
 $46=(($45+((($i)*(112))&-1)+72)|0);
 $47=(+(HEAPF64[(($46)>>3)]));
 $48=($33)+($47);
 HEAPF64[(($46)>>3)]=$48;
 $49=((HEAP32[((13176)>>2)])|0);
 $50=(($49+((($i)*(112))&-1)+72)|0);
 $51=(+(HEAPF64[(($50)>>3)]));
 $52=$51>(0.0);
 $53=($52?$51:(0.0));
 HEAPF64[(($50)>>3)]=$53;
 $54=$37>(0.0);
 do {
  if ($54) {
   $vout_065=$37;$vsum_066=0.0;$csum_067=0.0;
   while(1) {



    $55=((HEAP32[((15648)>>2)])|0);
    $56=(($55+($2<<2))|0);
    $57=((HEAP32[(($56)>>2)])|0);
    $58=($57|0)==0;
    if ($58) {
     $vsum_0_lcssa=$vsum_066;$csum_0_lcssa=$csum_067;
     break;
    }
    $60=(($57)|0);
    $61=(+(HEAPF64[(($60)>>3)]));
    $62=$61<=$vout_065;
    $63=($62?$61:$vout_065);
    $64=((HEAP32[((14984)>>2)])|0);
    $65=(($64+($2<<2))|0);
    $66=((HEAP32[(($65)>>2)])|0);
    $67=($57|0)==($66|0);
    $vout_0_=($67?$vout_065:$63);
    $68=($vsum_066)+($vout_0_);
    $69=(($57+8)|0);
    $70=(+(HEAPF64[(($69)>>3)]));
    $71=($70)*($vout_0_);
    $72=($csum_067)+($71);
    $73=($vout_065)-($vout_0_);
    $74=$73<(0.0);
    $75=$vout_0_<$61;
    $or_cond=$74|$75;
    do {
     if ($or_cond) {
      $84=(+(HEAPF64[(($60)>>3)]));
      $85=($84)-($vout_0_);
      HEAPF64[(($60)>>3)]=$85;
     } else {
      $77=(($57+16)|0);
      $78=((HEAP32[(($77)>>2)])|0);
      $79=($78|0)==0;
      if ($79) {
       break;
      }
      HEAP32[(($56)>>2)]=$78;
      $81=((HEAP32[((15608)>>2)])|0);
      HEAP32[(($77)>>2)]=$81;
      HEAP32[((15608)>>2)]=$57;
     }
    } while(0);
    $82=$73>(0.0);
    if ($82) {
     $vout_065=$73;$vsum_066=$68;$csum_067=$72;
    } else {
     $vsum_0_lcssa=$68;$csum_0_lcssa=$72;
     break;
    }
   }


   $86=$vsum_0_lcssa>(0.0);
   if (!($86)) {
    label = 16;
    break;
   }
   $88=($csum_0_lcssa)/($vsum_0_lcssa);
   $89=((HEAP32[((13176)>>2)])|0);
   $90=(($89+((($i)*(112))&-1)+80)|0);
   HEAPF64[(($90)>>3)]=$88;
  } else {
   label = 16;
  }
 } while(0);
 if ((label|0) == 16) {
  $91=((HEAP32[((15648)>>2)])|0);
  $92=(($91+($2<<2))|0);
  $93=((HEAP32[(($92)>>2)])|0);
  $94=(($93+8)|0);
  $95=(+(HEAPF64[(($94)>>3)]));
  $96=((HEAP32[((13176)>>2)])|0);
  $97=(($96+((($i)*(112))&-1)+80)|0);
  HEAPF64[(($97)>>3)]=$95;
 }
 $99=((HEAP32[((13176)>>2)])|0);
 $100=(($99+((($i)*(112))&-1)+80)|0);
 $101=(+(HEAPF64[(($100)>>3)]));
 $102=((HEAP32[((17736)>>2)])|0);
 $103=(($102+($28<<3))|0);
 HEAPF64[(($103)>>3)]=$101;
 if (!($38)) {
  return;
 }
 $105=((HEAP32[((14984)>>2)])|0);
 $106=(($105+($2<<2))|0);
 $107=((HEAP32[(($106)>>2)])|0);
 $108=($107|0)==0;
 if ($108) {
  _addseg($2,$36,$cin_0);
  return;
 }
 $110=(($107+8)|0);
 $111=(+(HEAPF64[(($110)>>3)]));
 $112=($111)-($cin_0);
 $113=$112<(0.0);
 if ($113) {
  $115=((-.0))-($112);
  $117=$115;
 } else {
  $117=$112;
 }

 $118=(+(HEAPF64[((11400)>>3)]));
 $119=$117<$118;
 if ($119) {
  $121=(($107)|0);
  $122=(+(HEAPF64[(($121)>>3)]));
  $123=($36)+($122);
  HEAPF64[(($121)>>3)]=$123;
  return;
 } else {
  _addseg($2,$36,$cin_0);
  return;
 }
}


function _tankmix4($i,$dt){
 $i=($i)|0;
 $dt=($dt)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$13=0,$14=0,$15=0,$or_cond82=0,$seg_077=0,$16=0,$17=.0,$18=0,$19=.0,$20=0;
 var $21=0,$22=.0,$23=.0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$32=.0,$33=.0,$34=.0,$35=0,$36=0,$37=.0,$38=0,$40=0,$41=0;
 var $42=.0,$43=.0,$cin_0=.0,$45=0,$46=0,$47=.0,$48=.0,$49=0,$50=0,$51=.0,$52=0,$53=.0,$54=0,$55=0,$56=0,$57=0,$58=.0,$59=0,$60=0,$61=0;
 var $63=0,$64=0,$65=0,$66=0,$68=0,$69=.0,$70=.0,$71=0,$73=.0,$75=.0,$76=.0,$77=0,$79=0,$80=.0,$81=.0,$83=0,$84=0,$85=0,$86=0,$87=0;
 var $88=0,$91=0,$92=0,$93=0,$94=0,$95=.0,$96=0,$97=0,$99=0,$101=0,$102=.0,$vnet_074=.0,$csum_073=.0,$vsum_072=.0,$104=0,$105=0,$106=0,$107=0,$109=0,$110=.0;
 var $111=0,$112=.0,$113=0,$114=0,$115=0,$116=0,$vnet_0_=.0,$117=.0,$118=0,$119=.0,$120=.0,$121=.0,$122=.0,$123=0,$124=0,$or_cond=0,$126=0,$127=0,$128=0,$130=0;
 var $131=0,$133=.0,$134=.0,$csum_0_lcssa=.0,$vsum_0_lcssa=.0,$135=0,$136=0,$137=.0,$138=.0,$139=.0,$140=.0,$141=0,$142=0,$144=0,$145=0,$146=.0,$147=0,$148=0,label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=((($1)+($i))|0);
 $3=((HEAP32[((14984)>>2)])|0);
 $4=(($3+($2<<2))|0);
 $5=((HEAP32[(($4)>>2)])|0);
 $6=($5|0)==0;
 if ($6) {
  return;
 }
 $8=((HEAP32[((15648)>>2)])|0);
 $9=(($8+($2<<2))|0);
 $10=((HEAP32[(($9)>>2)])|0);
 $11=($10|0)==0;
 if ($11) {
  return;
 }
 $13=((HEAP8[(13840)])|0);
 $14=(($13<<24)>>24)==0;
 $15=($5|0)==0;
 $or_cond82=$14|$15;
 if (!($or_cond82)) {
  $seg_077=$5;
  while(1) {

   $16=(($seg_077+8)|0);
   $17=(+(HEAPF64[(($16)>>3)]));
   $18=(($seg_077)|0);
   $19=(+(HEAPF64[(($18)>>3)]));
   $20=((HEAP32[((13176)>>2)])|0);
   $21=(($20+((($i)*(112))&-1)+64)|0);
   $22=(+(HEAPF64[(($21)>>3)]));
   $23=(+(_tankreact($17,$19,$22,$dt)));
   HEAPF64[(($16)>>3)]=$23;
   $24=(($seg_077+16)|0);
   $25=((HEAP32[(($24)>>2)])|0);
   $26=($25|0)==0;
   if ($26) {
    break;
   } else {
    $seg_077=$25;
   }
  }
 }
 $27=((HEAP32[((13176)>>2)])|0);
 $28=(($27+((($i)*(112))&-1))|0);
 $29=((HEAP32[(($28)>>2)])|0);
 $30=((HEAP32[((17632)>>2)])|0);
 $31=(($30+($29<<3))|0);
 $32=(+(HEAPF64[(($31)>>3)]));
 $33=(+((($dt|0))|0));
 $34=($33)*($32);
 $35=((HEAP32[((12016)>>2)])|0);
 $36=(($35+($29<<3))|0);
 $37=(+(HEAPF64[(($36)>>3)]));
 $38=$37>(0.0);
 if ($38) {
  $40=((HEAP32[((14680)>>2)])|0);
  $41=(($40+($29<<3))|0);
  $42=(+(HEAPF64[(($41)>>3)]));
  $43=($42)/($37);
  $cin_0=$43;
 } else {
  $cin_0=0.0;
 }

 $45=((HEAP32[((13176)>>2)])|0);
 $46=(($45+((($i)*(112))&-1)+72)|0);
 $47=(+(HEAPF64[(($46)>>3)]));
 $48=($34)+($47);
 HEAPF64[(($46)>>3)]=$48;
 $49=((HEAP32[((13176)>>2)])|0);
 $50=(($49+((($i)*(112))&-1)+72)|0);
 $51=(+(HEAPF64[(($50)>>3)]));
 $52=$51>(0.0);
 $53=($52?$51:(0.0));
 HEAPF64[(($50)>>3)]=$53;
 $54=((HEAP32[((14984)>>2)])|0);
 $55=(($54+($2<<2))|0);
 $56=((HEAP32[(($55)>>2)])|0);
 $57=(($56+8)|0);
 $58=(+(HEAPF64[(($57)>>3)]));
 $59=((HEAP32[((13176)>>2)])|0);
 $60=(($59+((($i)*(112))&-1)+80)|0);
 HEAPF64[(($60)>>3)]=$58;
 $61=$34>(0.0);
 do {
  if ($61) {
   $63=((HEAP32[((14984)>>2)])|0);
   $64=(($63+($2<<2))|0);
   $65=((HEAP32[(($64)>>2)])|0);
   $66=($65|0)==0;
   do {
    if ($66) {
     _addseg($2,$34,$cin_0);
    } else {
     $68=(($65+8)|0);
     $69=(+(HEAPF64[(($68)>>3)]));
     $70=($69)-($cin_0);
     $71=$70<(0.0);
     if ($71) {
      $73=((-.0))-($70);
      $75=$73;
     } else {
      $75=$70;
     }

     $76=(+(HEAPF64[((11400)>>3)]));
     $77=$75<$76;
     if ($77) {
      $79=(($65)|0);
      $80=(+(HEAPF64[(($79)>>3)]));
      $81=($34)+($80);
      HEAPF64[(($79)>>3)]=$81;
      break;
     } else {
      $83=((HEAP32[((14984)>>2)])|0);
      $84=(($83+($2<<2))|0);
      HEAP32[(($84)>>2)]=0;
      _addseg($2,$34,$cin_0);
      $85=((HEAP32[((14984)>>2)])|0);
      $86=(($85+($2<<2))|0);
      $87=((HEAP32[(($86)>>2)])|0);
      $88=(($87+16)|0);
      HEAP32[(($88)>>2)]=$65;
      break;
     }
    }
   } while(0);
   $91=((HEAP32[((14984)>>2)])|0);
   $92=(($91+($2<<2))|0);
   $93=((HEAP32[(($92)>>2)])|0);
   $94=(($93+8)|0);
   $95=(+(HEAPF64[(($94)>>3)]));
   $96=((HEAP32[((13176)>>2)])|0);
   $97=(($96+((($i)*(112))&-1)+80)|0);
   HEAPF64[(($97)>>3)]=$95;
  } else {
   $99=$34<(0.0);
   if (!($99)) {
    break;
   }
   $101=$34<(-.0);
   L28: do {
    if ($101) {
     $102=((-.0))-($34);
     $vsum_072=0.0;$csum_073=0.0;$vnet_074=$102;
     while(1) {



      $104=((HEAP32[((14984)>>2)])|0);
      $105=(($104+($2<<2))|0);
      $106=((HEAP32[(($105)>>2)])|0);
      $107=($106|0)==0;
      if ($107) {
       $vsum_0_lcssa=$vsum_072;$csum_0_lcssa=$csum_073;
       break L28;
      }
      $109=(($106)|0);
      $110=(+(HEAPF64[(($109)>>3)]));
      $111=$110<=$vnet_074;
      $112=($111?$110:$vnet_074);
      $113=((HEAP32[((15648)>>2)])|0);
      $114=(($113+($2<<2))|0);
      $115=((HEAP32[(($114)>>2)])|0);
      $116=($106|0)==($115|0);
      $vnet_0_=($116?$vnet_074:$112);
      $117=($vsum_072)+($vnet_0_);
      $118=(($106+8)|0);
      $119=(+(HEAPF64[(($118)>>3)]));
      $120=($119)*($vnet_0_);
      $121=($csum_073)+($120);
      $122=($vnet_074)-($vnet_0_);
      $123=$122<(0.0);
      $124=$vnet_0_<$110;
      $or_cond=$123|$124;
      do {
       if ($or_cond) {
        $133=(+(HEAPF64[(($109)>>3)]));
        $134=($133)-($vnet_0_);
        HEAPF64[(($109)>>3)]=$134;
       } else {
        $126=(($106+16)|0);
        $127=((HEAP32[(($126)>>2)])|0);
        $128=($127|0)==0;
        if ($128) {
         break;
        }
        HEAP32[(($105)>>2)]=$127;
        $130=((HEAP32[((15608)>>2)])|0);
        HEAP32[(($126)>>2)]=$130;
        HEAP32[((15608)>>2)]=$106;
       }
      } while(0);
      $131=$122>(0.0);
      if ($131) {
       $vsum_072=$117;$csum_073=$121;$vnet_074=$122;
      } else {
       $vsum_0_lcssa=$117;$csum_0_lcssa=$121;
       break;
      }
     }
    } else {
     $vsum_0_lcssa=0.0;$csum_0_lcssa=0.0;
    }
   } while(0);


   $135=((HEAP32[((14680)>>2)])|0);
   $136=(($135+($29<<3))|0);
   $137=(+(HEAPF64[(($136)>>3)]));
   $138=($csum_0_lcssa)+($137);
   $139=($37)+($vsum_0_lcssa);
   $140=($138)/($139);
   $141=((HEAP32[((13176)>>2)])|0);
   $142=(($141+((($i)*(112))&-1)+80)|0);
   HEAPF64[(($142)>>3)]=$140;
  }
 } while(0);
 $144=((HEAP32[((13176)>>2)])|0);
 $145=(($144+((($i)*(112))&-1)+80)|0);
 $146=(+(HEAPF64[(($145)>>3)]));
 $147=((HEAP32[((17736)>>2)])|0);
 $148=(($147+($29<<3))|0);
 HEAPF64[(($148)>>3)]=$146;
 return;
}


function _tankmix1($i,$dt){
 $i=($i)|0;
 $dt=($dt)|0;
 var $1=0,$2=0,$3=.0,$4=0,$5=.0,$6=0,$7=.0,$8=.0,$9=0,$10=0,$11=.0,$12=0,$13=0,$14=0,$15=0,$16=.0,$17=.0,$18=.0,$19=.0,$20=0;
 var $21=0,$22=.0,$23=0,$24=0,$25=.0,$27=0,$28=0,$29=.0,$30=.0,$31=0,$32=.0,$33=.0,$34=.0,$35=.0,$36=.0,$37=.0,$39=.0,$c_0=.0,$40=0,$41=.0;
 var $42=0,$43=.0,$44=0,$45=0,$46=0,$47=0,$48=.0,$49=0,$50=0,label=0;

 $1=((HEAP32[((13176)>>2)])|0);
 $2=(($1+((($i)*(112))&-1)+80)|0);
 $3=(+(HEAPF64[(($2)>>3)]));
 $4=(($1+((($i)*(112))&-1)+72)|0);
 $5=(+(HEAPF64[(($4)>>3)]));
 $6=(($1+((($i)*(112))&-1)+64)|0);
 $7=(+(HEAPF64[(($6)>>3)]));
 $8=(+(_tankreact($3,$5,$7,$dt)));
 $9=((HEAP32[((13176)>>2)])|0);
 $10=(($9+((($i)*(112))&-1)+72)|0);
 $11=(+(HEAPF64[(($10)>>3)]));
 $12=(($9+((($i)*(112))&-1))|0);
 $13=((HEAP32[(($12)>>2)])|0);
 $14=((HEAP32[((17632)>>2)])|0);
 $15=(($14+($13<<3))|0);
 $16=(+(HEAPF64[(($15)>>3)]));
 $17=(+((($dt|0))|0));
 $18=($17)*($16);
 $19=($11)+($18);
 HEAPF64[(($10)>>3)]=$19;
 $20=((HEAP32[((12016)>>2)])|0);
 $21=(($20+($13<<3))|0);
 $22=(+(HEAPF64[(($21)>>3)]));
 $23=$22>(0.0);
 if ($23) {
  $27=((HEAP32[((14680)>>2)])|0);
  $28=(($27+($13<<3))|0);
  $29=(+(HEAPF64[(($28)>>3)]));
  $30=($29)/($22);
  $31=$8>=$30;
  $32=($31?$8:$30);
  $33=($8)*($11);
  $34=($22)*($30);
  $35=($33)+($34);
  $36=($11)+($22);
  $37=($35)/($36);
  $c_0=$37;$39=$32;
 } else {
  $24=$8>=(0.0);
  $25=($24?$8:(0.0));
  $c_0=$8;$39=$25;
 }


 $40=$c_0<=$39;
 $41=($40?$c_0:$39);
 $42=$41>=(0.0);
 $43=($42?$41:(0.0));
 $44=((HEAP32[((13176)>>2)])|0);
 $45=(($44+((($i)*(112))&-1)+80)|0);
 HEAPF64[(($45)>>3)]=$43;
 $46=((HEAP32[((13176)>>2)])|0);
 $47=(($46+((($i)*(112))&-1)+80)|0);
 $48=(+(HEAPF64[(($47)>>3)]));
 $49=((HEAP32[((17736)>>2)])|0);
 $50=(($49+($13<<3))|0);
 HEAPF64[(($50)>>3)]=$48;
 return;
}


function _tankreact($c,$v,$kb,$dt){
 $c=+($c);
 $v=+($v);
 $kb=+($kb);
 $dt=($dt)|0;
 var $1=0,$2=0,$4=0,$5=0,$7=.0,$8=.0,$9=.0,$11=.0,$12=.0,$13=.0,$14=.0,$15=.0,$16=.0,$17=0,$18=0,$19=0,$21=0,$23=.0,$25=.0,$26=.0;
 var $27=.0,$28=.0,$30=.0,$31=0,$32=.0,$_0=.0,label=0;

 $1=((HEAP8[(13840)])|0);
 $2=(($1<<24)>>24)==0;
 if ($2) {
  $_0=$c;

  return (+($_0));
 }
 $4=((HEAP8[(13856)])|0);
 $5=(($4<<24)>>24)==2;
 if ($5) {
  $7=(+((($dt|0))|0));
  $8=($7)/((3600.0));
  $9=($8)+($c);
  $_0=$9;

  return (+($_0));
 }
 $11=(+(HEAPF64[((10600)>>3)]));
 $12=(+(_bulkrate($c,$kb,$11)));
 $13=(+(HEAPF64[((10568)>>3)]));
 $14=($12)*($13);
 $15=(+((($dt|0))|0));
 $16=($15)*($14);
 $17=((HEAP32[((15576)>>2)])|0);
 $18=((HEAP32[((13280)>>2)])|0);
 $19=($17|0)<($18|0);
 if (!($19)) {
  $21=$16<(0.0);
  if ($21) {
   $23=((-.0))-($16);
   $25=$23;
  } else {
   $25=$16;
  }

  $26=($25)*($v);
  $27=(+(HEAPF64[((10448)>>3)]));
  $28=($27)+($26);
  HEAPF64[((10448)>>3)]=$28;
 }
 $30=($16)+($c);
 $31=$30<=(0.0);
 $32=($31?(0.0):$30);
 $_0=$32;

 return (+($_0));
}


function _avgqual($k){
 $k=($k)|0;
 var $1=0,$2=0,$4=0,$5=0,$seg_011=0,$6=0,$seg_014=0,$msum_013=.0,$vsum_012=.0,$7=0,$8=.0,$9=.0,$10=0,$11=.0,$12=.0,$13=.0,$14=0,$seg_0=0,$15=0,$16=0;
 var $18=.0,$19=0,$20=0,$21=0,$22=0,$23=0,$24=.0,$25=0,$26=0,$27=0,$28=.0,$29=.0,$30=.0,$_0=.0,label=0;

 $1=((HEAP8[(13856)])|0);
 $2=(($1<<24)>>24)==0;
 if ($2) {
  $_0=0.0;

  return (+($_0));
 }
 $4=((HEAP32[((15648)>>2)])|0);
 $5=(($4+($k<<2))|0);
 $seg_011=((HEAP32[(($5)>>2)])|0);
 $6=($seg_011|0)==0;
 do {
  if (!($6)) {
   $vsum_012=0.0;$msum_013=0.0;$seg_014=$seg_011;
   while(1) {



    $7=(($seg_014)|0);
    $8=(+(HEAPF64[(($7)>>3)]));
    $9=($vsum_012)+($8);
    $10=(($seg_014+8)|0);
    $11=(+(HEAPF64[(($10)>>3)]));
    $12=($8)*($11);
    $13=($msum_013)+($12);
    $14=(($seg_014+16)|0);
    $seg_0=((HEAP32[(($14)>>2)])|0);
    $15=($seg_0|0)==0;
    if ($15) {
     break;
    } else {
     $vsum_012=$9;$msum_013=$13;$seg_014=$seg_0;
    }
   }
   $16=$9>(0.0);
   if (!($16)) {
    break;
   }
   $18=($13)/($9);
   $_0=$18;

   return (+($_0));
  }
 } while(0);
 $19=((HEAP32[((14960)>>2)])|0);
 $20=(($19+((($k)*(104))&-1)+32)|0);
 $21=((HEAP32[(($20)>>2)])|0);
 $22=((HEAP32[((17736)>>2)])|0);
 $23=(($22+($21<<3))|0);
 $24=(+(HEAPF64[(($23)>>3)]));
 $25=(($19+((($k)*(104))&-1)+36)|0);
 $26=((HEAP32[(($25)>>2)])|0);
 $27=(($22+($26<<3))|0);
 $28=(+(HEAPF64[(($27)>>3)]));
 $29=($24)+($28);
 $30=($29)*((0.5));
 $_0=$30;

 return (+($_0));
}


function _piperate($k){
 $k=($k)|0;
 var $1=0,$2=0,$3=.0,$4=.0,$5=0,$7=.0,$8=0,$10=0,$11=.0,$12=.0,$13=.0,$14=.0,$15=.0,$17=.0,$18=.0,$19=.0,$20=0,$21=0,$22=.0,$23=0;
 var $25=.0,$27=.0,$28=.0,$29=.0,$30=.0,$31=.0,$32=0,$34=0,$36=.0,$37=.0,$38=.0,$39=.0,$40=.0,$42=0,$43=0,$44=.0,$45=.0,$46=.0,$47=.0,$48=.0;
 var $49=.0,$50=.0,$51=.0,$52=.0,$53=.0,$54=.0,$Sh_0=.0,$56=.0,$57=.0,$58=.0,$59=.0,$60=0,$62=0,$63=0,$64=.0,$65=.0,$66=.0,$67=.0,$68=.0,$69=.0;
 var $70=0,$72=.0,$74=.0,$75=.0,$76=.0,$_0=.0,label=0;

 $1=((HEAP32[((14960)>>2)])|0);
 $2=(($1+((($k)*(104))&-1)+40)|0);
 $3=(+(HEAPF64[(($2)>>3)]));
 $4=(+(HEAPF64[((10776)>>3)]));
 $5=$4==(0.0);
 if ($5) {
  $7=(+(HEAPF64[((10472)>>3)]));
  $8=$7==(0.0);
  if ($8) {
   $_0=10000000000.0;

   return (+($_0));
  }
  $10=(($1+((($k)*(104))&-1)+80)|0);
  $11=(+(HEAPF64[(($10)>>3)]));
  $12=((4.0))/($3);
  $13=($11)*($12);
  $14=(+(HEAPF64[((12040)>>3)]));
  $15=($13)/($14);
  $_0=$15;

  return (+($_0));
 }
 $17=($3)*((3.141592654));
 $18=($3)*($17);
 $19=($18)*((0.25));
 $20=((HEAP32[((13880)>>2)])|0);
 $21=(($20+($k<<3))|0);
 $22=(+(HEAPF64[(($21)>>3)]));
 $23=$22<(0.0);
 if ($23) {
  $25=((-.0))-($22);
  $27=$25;
 } else {
  $27=$22;
 }

 $28=($27)/($19);
 $29=($3)*($28);
 $30=(+(HEAPF64[((10480)>>3)]));
 $31=($29)/($30);
 $32=$31<(1.0);
 do {
  if ($32) {
   $Sh_0=2.0;
  } else {
   $34=$31<(2300.0);
   if ($34) {
    $42=((HEAP32[((14960)>>2)])|0);
    $43=(($42+((($k)*(104))&-1)+48)|0);
    $44=(+(HEAPF64[(($43)>>3)]));
    $45=($3)/($44);
    $46=($31)*($45);
    $47=(+(HEAPF64[((10776)>>3)]));
    $48=($46)*($47);
    $49=($48)*((0.0668));
    $50=(+(Math_pow((+($48)),0.667)));
    $51=($50)*((0.04));
    $52=($51)+((1.0));
    $53=($49)/($52);
    $54=($53)+((3.65));
    $Sh_0=$54;
    break;
   } else {
    $36=(+(Math_pow((+($31)),0.88)));
    $37=($36)*((0.0149));
    $38=(+(HEAPF64[((10776)>>3)]));
    $39=(+(Math_pow((+($38)),0.333)));
    $40=($37)*($39);
    $Sh_0=$40;
    break;
   }
  }
 } while(0);

 $56=(+(HEAPF64[((11376)>>3)]));
 $57=($Sh_0)*($56);
 $58=($57)/($3);
 $59=(+(HEAPF64[((10472)>>3)]));
 $60=$59==(0.0);
 if ($60) {
  $_0=$58;

  return (+($_0));
 }
 $62=((HEAP32[((14960)>>2)])|0);
 $63=(($62+((($k)*(104))&-1)+80)|0);
 $64=(+(HEAPF64[(($63)>>3)]));
 $65=(+(HEAPF64[((12040)>>3)]));
 $66=($64)/($65);
 $67=((4.0))/($3);
 $68=($66)*($67);
 $69=($58)*($68);
 $70=$66<(0.0);
 if ($70) {
  $72=((-.0))-($66);
  $74=$72;
 } else {
  $74=$66;
 }

 $75=($58)+($74);
 $76=($69)/($75);
 $_0=$76;

 return (+($_0));
}


function _bulkrate($c,$kb,$order){
 $c=+($c);
 $kb=+($kb);
 $order=+($order);
 var $1=0,$3=0,$4=.0,$6=0,$7=.0,$8=.0,$9=.0,$10=0,$12=.0,$14=.0,$15=0,$17=.0,$c1_0=.0,$19=.0,$21=0,$23=0,$24=.0,$25=.0,$26=.0,$27=0;
 var $28=.0,$c1_1=.0,$30=0,$32=0,$34=.0,$36=0,$37=.0,$38=.0,$39=.0,$40=.0,$_0=.0,$42=0,$_1=.0,$43=.0,label=0;

 $1=$order==(0.0);
 do {
  if ($1) {
   $_0=1.0;
  } else {
   $3=$order<(0.0);
   $4=(+(HEAPF64[((11408)>>3)]));
   if ($3) {
    $6=$kb<(0.0);
    $7=($6?(-1.0):(1.0));
    $8=($7)*($c);
    $9=($8)+($4);
    $10=$9<(0.0);
    if ($10) {
     $12=((-.0))-($9);
     $14=$12;
    } else {
     $14=$9;
    }

    $15=$14<(0.000001);
    if ($15) {
     $17=($10?(-0.000001):(0.000001));
     $c1_0=$17;
    } else {
     $c1_0=$9;
    }

    $19=($c)/($c1_0);
    $_0=$19;
    break;
   }
   $21=$4==(0.0);
   if ($21) {
    $c1_1=$c;
   } else {
    $23=$kb<(0.0);
    $24=($23?(-1.0):(1.0));
    $25=($4)-($c);
    $26=($24)*($25);
    $27=$26>(0.0);
    $28=($27?$26:(0.0));
    $c1_1=$28;
   }

   $30=$order==(1.0);
   if ($30) {
    $_0=$c1_1;
    break;
   }
   $32=$order==(2.0);
   if ($32) {
    $34=($c1_1)*($c);
    $_0=$34;
    break;
   } else {
    $36=$c<=(0.0);
    $37=($36?(0.0):$c);
    $38=($order)+((-1.0));
    $39=(+(Math_pow((+($37)),(+($38)))));
    $40=($c1_1)*($39);
    $_0=$40;
    break;
   }
  }
 } while(0);

 $42=$_0<(0.0);
 $_1=($42?(0.0):$_0);
 $43=($_1)*($kb);
 return (+($43));
}


function _wallrate($c,$d,$kw,$kf){
 $c=+($c);
 $d=+($d);
 $kw=+($kw);
 $kf=+($kf);
 var $1=0,$2=0,$or_cond=0,$4=.0,$5=0,$7=0,$8=.0,$9=.0,$10=.0,$11=.0,$12=.0,$13=.0,$14=0,$16=.0,$18=.0,$19=0,$21=.0,$23=.0,$24=0,$_0=.0;
 var $25=.0,$26=.0,$28=.0,$_016=.0,label=0;

 $1=$kw==(0.0);
 $2=$d==(0.0);
 $or_cond=$1|$2;
 if ($or_cond) {
  $_016=0.0;

  return (+($_016));
 }
 $4=(+(HEAPF64[((10472)>>3)]));
 $5=$4==(0.0);
 if (!($5)) {
  $28=($c)*($kf);
  $_016=$28;

  return (+($_016));
 }
 $7=$kw<(0.0);
 $8=($7?(-1.0):(1.0));
 $9=($8)*($c);
 $10=($9)*($kf);
 $11=(+(HEAPF64[((12040)>>3)]));
 $12=($11)*($11);
 $13=($12)*($kw);
 $14=$10<(0.0);
 if ($14) {
  $16=((-.0))-($10);
  $18=$16;
 } else {
  $18=$10;
 }

 $19=$13<(0.0);
 if ($19) {
  $21=((-.0))-($13);
  $23=$21;
 } else {
  $23=$13;
 }

 $24=$18<$23;
 $_0=($24?$10:$13);
 $25=($_0)*((4.0));
 $26=($25)/($d);
 $_016=$26;

 return (+($_016));
}


function _writereport(){
 var $1=0,$2=0,$strlenfirst_pr=0,$4=0,$5=0,$6=0,$or_cond=0,$8=0,$9=0,$12=0,$13=0,$15=0,$16=0,$18=0,$19=0,$21=0,$22=0,$25=0,$27=0,$28=0;
 var $29=0,$30=0,$33=0,$34=0,$37=0,$38=0,$41=0,$42=0,$43=0,$errcode_0=0,$45=0,$46=0,label=0;

 HEAP8[(15616)]=0;
 $1=((HEAP8[(13288)])|0);
 $2=(($1<<24)>>24)==0;
 $strlenfirst_pr=((HEAP8[(13304)])|0);
 do {
  if ($2) {
   label = 6;
  } else {
   $4=(($strlenfirst_pr<<24)>>24)==0;
   $5=((HEAP32[((13296)>>2)])|0);
   $6=($5|0)!=0;
   $or_cond=$4&$6;
   if (!($or_cond)) {
    label = 6;
    break;
   }
   _writecon(((2024)|0));
   _writecon(((13568)|0));
   $8=((HEAP8[(17528)])|0);
   $9=(($8<<24)>>24)==0;
   if (!($9)) {
    _writeenergy();
   }
   $12=((_writeresults())|0);
   $errcode_0=$12;
  }
 } while(0);
 L7: do {
  if ((label|0) == 6) {
   $13=(($strlenfirst_pr<<24)>>24)==0;
   if ($13) {
    $errcode_0=0;
    break;
   }
   $15=((_strcomp(13304,15008))|0);
   $16=($15|0)==0;
   do {
    if ($16) {
     $18=((_strcomp(13304,13568))|0);
     $19=($18|0)==0;
     if (!($19)) {
      break;
     }
     $27=((HEAP32[((13296)>>2)])|0);
     $28=((HEAP8[(13288)])|0);
     $29=((_fopen(((13304)|0),((8408)|0)))|0);
     HEAP32[((13296)>>2)]=$29;
     $30=($29|0)==0;
     if ($30) {
      HEAP32[((13296)>>2)]=$27;
      HEAP8[(13288)]=$28;
      $errcode_0=303;
      break L7;
     }
     HEAP8[(13288)]=1;
     _writecon(((2024)|0));
     _writecon(((13304)|0));
     _writelogo();
     $33=((HEAP8[(13184)])|0);
     $34=(($33<<24)>>24)==0;
     if (!($34)) {
      _writesummary();
     }
     $37=((HEAP8[(17528)])|0);
     $38=(($37<<24)>>24)==0;
     if (!($38)) {
      _writeenergy();
     }
     $41=((_writeresults())|0);
     $42=((HEAP32[((13296)>>2)])|0);
     $43=((_fclose((($42)|0)))|0);
     HEAP32[((13296)>>2)]=$27;
     HEAP8[(13288)]=$28;
     $errcode_0=$41;
     break L7;
    }
   } while(0);
   _writecon(((2024)|0));
   _writecon(((13568)|0));
   $21=((HEAP8[(17528)])|0);
   $22=(($21<<24)>>24)==0;
   if (!($22)) {
    _writeenergy();
   }
   $25=((_writeresults())|0);
   $errcode_0=$25;
  }
 } while(0);

 $45=((HEAP8[(15616)])|0);
 $46=(($45<<24)>>24)==0;
 if ($46) {
  return (($errcode_0)|0);
 }
 _errmsg(309);
 return (($errcode_0)|0);
}


function _writeenergy(){
 var $s=0,$1=0,$2=0,$4=0,$5=0,$6=0,$csum_012=.0,$j_011=0,$8=0,$9=0,$10=.0,$11=.0,$12=0,$13=0,$14=0,$17=0,$18=0,$19=0,$20=0,$21=0;
 var $22=0,$23=.0,$24=0,$25=.0,$26=0,$27=.0,$28=0,$29=.0,$30=0,$31=.0,$32=0,$33=.0,$34=0,$35=0,$36=0,$37=0,$csum_0_lcssa=.0,$38=0,$39=0,$40=.0;
 var $41=.0,$42=.0,$43=0,$44=.0,$45=.0,$46=.0,$47=.0,$48=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+256)|0;
 $s=((sp)|0);
 $1=((HEAP32[((14368)>>2)])|0);
 $2=($1|0)==0;
 if ($2) {
  STACKTOP=sp;return;
 }
 _writeline(1768);
 _writeheader(1,0);
 $4=((HEAP32[((14368)>>2)])|0);
 $5=($4|0)<1;
 if ($5) {
  $csum_0_lcssa=0.0;
 } else {
  $6=(($s)|0);
  $j_011=1;$csum_012=0.0;
  while(1) {


   $8=((HEAP32[((13888)>>2)])|0);
   $9=(($8+($j_011<<7)+120)|0);
   $10=(+(HEAPF64[(($9)>>3)]));
   $11=($csum_012)+($10);
   $12=((HEAP32[((14968)>>2)])|0);
   $13=((HEAP32[((13960)>>2)])|0);
   $14=($12|0)==($13|0);
   if ($14) {
    _writeheader(1,1);
   }
   $17=((HEAP32[((13888)>>2)])|0);
   $18=(($17+($j_011<<7))|0);
   $19=((HEAP32[(($18)>>2)])|0);
   $20=((HEAP32[((14960)>>2)])|0);
   $21=(($20+((($19)*(104))&-1))|0);
   $22=(($17+($j_011<<7)+80)|0);
   $23=(+(HEAPF64[(($22)>>3)]));
   $24=(($17+($j_011<<7)+88)|0);
   $25=(+(HEAPF64[(($24)>>3)]));
   $26=(($17+($j_011<<7)+96)|0);
   $27=(+(HEAPF64[(($26)>>3)]));
   $28=(($17+($j_011<<7)+104)|0);
   $29=(+(HEAPF64[(($28)>>3)]));
   $30=(($17+($j_011<<7)+112)|0);
   $31=(+(HEAPF64[(($30)>>3)]));
   $32=(($17+($j_011<<7)+120)|0);
   $33=(+(HEAPF64[(($32)>>3)]));
   $34=((_sprintf((($6)|0),((2896)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 56)|0,HEAP32[((tempVarArgs)>>2)]=$21,HEAPF64[(((tempVarArgs)+(8))>>3)]=$23,HEAPF64[(((tempVarArgs)+(16))>>3)]=$25,HEAPF64[(((tempVarArgs)+(24))>>3)]=$27,HEAPF64[(((tempVarArgs)+(32))>>3)]=$29,HEAPF64[(((tempVarArgs)+(40))>>3)]=$31,HEAPF64[(((tempVarArgs)+(48))>>3)]=$33,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   _writeline($6);
   $35=((($j_011)+(1))|0);
   $36=((HEAP32[((14368)>>2)])|0);
   $37=($35|0)>($36|0);
   if ($37) {
    $csum_0_lcssa=$11;
    break;
   } else {
    $j_011=$35;$csum_012=$11;
   }
  }
 }

 $38=(($s)|0);
 $39=((_fillstr($38,45,63))|0);
 _writeline($38);
 $40=(+(HEAPF64[((11344)>>3)]));
 $41=(+(HEAPF64[((11384)>>3)]));
 $42=($40)*($41);
 $43=((_sprintf((($38)|0),((2792)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=11472,HEAPF64[(((tempVarArgs)+(8))>>3)]=$42,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($38);
 $44=(+(HEAPF64[((11344)>>3)]));
 $45=(+(HEAPF64[((11384)>>3)]));
 $46=($44)*($45);
 $47=($csum_0_lcssa)+($46);
 $48=((_sprintf((($38)|0),((2688)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=11472,HEAPF64[(((tempVarArgs)+(8))>>3)]=$47,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($38);
 _writeline(1768);
 STACKTOP=sp;return;
}


function _writeresults(){
 var $1=0,$2=0,$4=0,$5=0,$6=0,$7=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$21=0,$22=0;
 var $23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0,$40=0,$41=0,$42=0;
 var $43=0,$44=0,$45=0,$46=0,$47=0,$48=0,$49=0,$50=0,$51=0,$52=0,$53=0,$55=0,$56=0,$57=0,$_sink=0,$58=0,$59=0,$60=0,$61=0,$62=0;
 var $64=0,$65=0,$66=0,$67=0,$68=0,$69=0,$70=0,$72=0,$73=0,$74=0,$75=0,$76=0,$77=0,$78=0,$79=0,$np_054=0,$80=0,$81=0,$82=0,$83=0;
 var $84=0,$85=0,$86=0,$87=0,$88=0,$89=0,$90=0,$91=0,$92=0,$93=0,$94=0,$95=0,$96=0,$97=0,$98=0,$99=0,$100=0,$101=0,$102=0,$103=0;
 var $104=0,$105=0,$106=0,$107=0,$108=0,$109=0,$110=0,$111=0,$or_cond46=0,$113=0,$114=0,$115=0,$116=0,$117=0,$118=0,$119=0,$120=0,$121=0,$122=0,$123=0;
 var $124=0,$125=0,$126=0,$127=0,$128=0,$129=0,$130=0,$131=0,$132=0,$133=0,$134=0,$135=0,$136=0,$137=0,$138=0,$139=0,$140=0,$141=0,$142=0,$143=0;
 var $144=0,$145=0,$146=0,$147=0,$148=0,$149=0,$150=0,$151=0,$152=0,$153=0,$154=0,$155=0,$156=0,$157=0,$158=0,$159=0,$160=0,$161=0,$162=0,$163=0;
 var $164=0,$165=0,$166=0,$167=0,$168=0,$169=0,$170=0,$171=0,$172=0,$173=0,$174=0,$175=0,$176=0,$or_cond48=0,$179=0,$180=0,$181=0,$182=0,$183=0,$184=0;
 var $185=0,$186=0,$187=0,$188=0,$189=0,$190=0,$191=0,$192=0,$193=0,$194=0,$195=0,$196=0,$197=0,$198=0,$199=0,$200=0,$201=0,$202=0,$203=0,$204=0;
 var $205=0,$206=0,$207=0,$208=0,$209=0,$210=0,$211=0,$212=0,$213=0,$214=0,$215=0,$_0=0,$217=0,$218=0,$220=0,$221=0,$222=0,$223=0,$224=0,$225=0;
 var $227=0,$228=0,$230=0,$231=0,$232=0,$233=0,$234=0,$235=0,$237=0,$238=0,$240=0,$241=0,$242=0,$243=0,$244=0,$245=0,$247=0,$248=0,$250=0,$251=0;
 var $252=0,$253=0,$254=0,$255=0,$257=0,$258=0,$260=0,$261=0,$262=0,$263=0,$264=0,$265=0,$267=0,$268=0,$270=0,$271=0,$272=0,$273=0,$274=0,$275=0;
 var $277=0,$278=0,label=0;

 $1=((HEAP32[((14280)>>2)])|0);
 $2=($1|0)==0;
 if ($2) {
  $_0=106;

  return (($_0)|0);
 }
 $4=((HEAP8[(14400)])|0);
 $5=((HEAP8[(14952)])|0);
 $6=$5|$4;
 $7=(($6<<24)>>24)==0;
 if ($7) {
  $_0=0;

  return (($_0)|0);
 }
 $9=((HEAP8[(15720)])|0);
 $10=(($9<<24)>>24);
 $11=((HEAP8[(15808)])|0);
 $12=(($11<<24)>>24);
 $13=((($12)+($10))|0);
 $14=((HEAP8[(15896)])|0);
 $15=(($14<<24)>>24);
 $16=((($15)+($13))|0);
 $17=((HEAP8[(15984)])|0);
 $18=(($17<<24)>>24);
 $19=((($18)+($16))|0);
 $20=((HEAP8[(16072)])|0);
 $21=(($20<<24)>>24);
 $22=((($21)+($19))|0);
 $23=((HEAP8[(16160)])|0);
 $24=(($23<<24)>>24);
 $25=((HEAP8[(16248)])|0);
 $26=(($25<<24)>>24);
 $27=((($26)+($24))|0);
 $28=((HEAP8[(16336)])|0);
 $29=(($28<<24)>>24);
 $30=((($29)+($27))|0);
 $31=((HEAP8[(16424)])|0);
 $32=(($31<<24)>>24);
 $33=((($32)+($30))|0);
 $34=((HEAP8[(16512)])|0);
 $35=(($34<<24)>>24);
 $36=((($35)+($33))|0);
 $37=((HEAP8[(16600)])|0);
 $38=(($37<<24)>>24);
 $39=((($38)+($36))|0);
 $40=((HEAP8[(16688)])|0);
 $41=(($40<<24)>>24);
 $42=((($41)+($39))|0);
 $43=((HEAP8[(16776)])|0);
 $44=(($43<<24)>>24);
 $45=((($44)+($42))|0);
 $46=((HEAP8[(16864)])|0);
 $47=(($46<<24)>>24);
 $48=((($47)+($45))|0);
 $49=((HEAP8[(16952)])|0);
 $50=(($49<<24)>>24);
 $51=((($50)+($48))|0);
 $52=$51|$22;
 $53=($52|0)==0;
 if ($53) {
  $_0=0;

  return (($_0)|0);
 }
 $55=((HEAP32[((14416)>>2)])|0);
 $56=((HEAP32[((14424)>>2)])|0);
 $57=($55|0)>=($56|0);
 $_sink=($57?$55:$56);
 $58=((($_sink)+(1))|0);
 $59=((_calloc(8,4))|0);
 $60=$59;
 $61=($59|0)==0;
 $62=($61?101:0);
 if ($61) {
  $_0=$62;

  return (($_0)|0);
 }
 $64=((_calloc($58,4))|0);
 $65=$64;
 HEAP32[(($60)>>2)]=$65;
 $66=($64|0)==0;
 $67=((_calloc($58,4))|0);
 $68=$67;
 $69=(($59+4)|0);
 $70=$69;
 HEAP32[(($70)>>2)]=$68;
 if ($66) {
  $220=101;
 } else {
  $217=($67|0)==0;
  $218=($217?101:0);
  $220=$218;
 }

 $221=((_calloc($58,4))|0);
 $222=$221;
 $223=(($59+8)|0);
 $224=$223;
 HEAP32[(($224)>>2)]=$222;
 $225=($220|0)==101;
 if ($225) {
  $230=$220;
 } else {
  $227=($221|0)==0;
  $228=($227?101:0);
  $230=$228;
 }

 $231=((_calloc($58,4))|0);
 $232=$231;
 $233=(($59+12)|0);
 $234=$233;
 HEAP32[(($234)>>2)]=$232;
 $235=($230|0)>100;
 if ($235) {
  $240=$230;
 } else {
  $237=($231|0)==0;
  $238=($237?101:0);
  $240=$238;
 }

 $241=((_calloc($58,4))|0);
 $242=$241;
 $243=(($59+16)|0);
 $244=$243;
 HEAP32[(($244)>>2)]=$242;
 $245=($240|0)>100;
 if ($245) {
  $250=$240;
 } else {
  $247=($241|0)==0;
  $248=($247?101:0);
  $250=$248;
 }

 $251=((_calloc($58,4))|0);
 $252=$251;
 $253=(($59+20)|0);
 $254=$253;
 HEAP32[(($254)>>2)]=$252;
 $255=($250|0)>100;
 if ($255) {
  $260=$250;
 } else {
  $257=($251|0)==0;
  $258=($257?101:0);
  $260=$258;
 }

 $261=((_calloc($58,4))|0);
 $262=$261;
 $263=(($59+24)|0);
 $264=$263;
 HEAP32[(($264)>>2)]=$262;
 $265=($260|0)>100;
 if ($265) {
  $270=$260;
 } else {
  $267=($261|0)==0;
  $268=($267?101:0);
  $270=$268;
 }

 $271=((_calloc($58,4))|0);
 $272=$271;
 $273=(($59+28)|0);
 $274=$273;
 HEAP32[(($274)>>2)]=$272;
 $275=($270|0)>100;
 if ($275) {
  $_0=$270;

  return (($_0)|0);
 }
 $277=($271|0)==0;
 $278=($277?101:0);
 if ($277) {
  $_0=$278;

  return (($_0)|0);
 }
 $72=((HEAP32[((14280)>>2)])|0);
 $73=((HEAP32[((13992)>>2)])|0);
 $74=((_fseek((($72)|0),(($73)|0),((0)|0)))|0);
 $75=((HEAP32[((13280)>>2)])|0);
 HEAP32[((15576)>>2)]=$75;
 $76=((HEAP32[((14384)>>2)])|0);
 $77=($76|0)<1;
 if (!($77)) {
  $78=($22|0)>0;
  $79=($51|0)>0;
  $np_054=1;
  while(1) {

   $80=((HEAP32[(($60)>>2)])|0);
   $81=(($80+4)|0);
   $82=$81;
   $83=((HEAP32[((14416)>>2)])|0);
   $84=((HEAP32[((14280)>>2)])|0);
   $85=((_fread((($82)|0),((4)|0),(($83)|0),(($84)|0)))|0);
   $86=(($59+4)|0);
   $87=$86;
   $88=((HEAP32[(($87)>>2)])|0);
   $89=(($88+4)|0);
   $90=$89;
   $91=((HEAP32[((14416)>>2)])|0);
   $92=((HEAP32[((14280)>>2)])|0);
   $93=((_fread((($90)|0),((4)|0),(($91)|0),(($92)|0)))|0);
   $94=(($59+8)|0);
   $95=$94;
   $96=((HEAP32[(($95)>>2)])|0);
   $97=(($96+4)|0);
   $98=$97;
   $99=((HEAP32[((14416)>>2)])|0);
   $100=((HEAP32[((14280)>>2)])|0);
   $101=((_fread((($98)|0),((4)|0),(($99)|0),(($100)|0)))|0);
   $102=(($59+12)|0);
   $103=$102;
   $104=((HEAP32[(($103)>>2)])|0);
   $105=(($104+4)|0);
   $106=$105;
   $107=((HEAP32[((14416)>>2)])|0);
   $108=((HEAP32[((14280)>>2)])|0);
   $109=((_fread((($106)|0),((4)|0),(($107)|0),(($108)|0)))|0);
   $110=((HEAP8[(14400)])|0);
   $111=(($110<<24)>>24)>0;
   $or_cond46=$78&$111;
   if ($or_cond46) {
    _writenodetable($60);
   }
   $113=((HEAP32[(($60)>>2)])|0);
   $114=(($113+4)|0);
   $115=$114;
   $116=((HEAP32[((14424)>>2)])|0);
   $117=((HEAP32[((14280)>>2)])|0);
   $118=((_fread((($115)|0),((4)|0),(($116)|0),(($117)|0)))|0);
   $119=(($59+4)|0);
   $120=$119;
   $121=((HEAP32[(($120)>>2)])|0);
   $122=(($121+4)|0);
   $123=$122;
   $124=((HEAP32[((14424)>>2)])|0);
   $125=((HEAP32[((14280)>>2)])|0);
   $126=((_fread((($123)|0),((4)|0),(($124)|0),(($125)|0)))|0);
   $127=(($59+8)|0);
   $128=$127;
   $129=((HEAP32[(($128)>>2)])|0);
   $130=(($129+4)|0);
   $131=$130;
   $132=((HEAP32[((14424)>>2)])|0);
   $133=((HEAP32[((14280)>>2)])|0);
   $134=((_fread((($131)|0),((4)|0),(($132)|0),(($133)|0)))|0);
   $135=(($59+12)|0);
   $136=$135;
   $137=((HEAP32[(($136)>>2)])|0);
   $138=(($137+4)|0);
   $139=$138;
   $140=((HEAP32[((14424)>>2)])|0);
   $141=((HEAP32[((14280)>>2)])|0);
   $142=((_fread((($139)|0),((4)|0),(($140)|0),(($141)|0)))|0);
   $143=(($59+16)|0);
   $144=$143;
   $145=((HEAP32[(($144)>>2)])|0);
   $146=(($145+4)|0);
   $147=$146;
   $148=((HEAP32[((14424)>>2)])|0);
   $149=((HEAP32[((14280)>>2)])|0);
   $150=((_fread((($147)|0),((4)|0),(($148)|0),(($149)|0)))|0);
   $151=(($59+20)|0);
   $152=$151;
   $153=((HEAP32[(($152)>>2)])|0);
   $154=(($153+4)|0);
   $155=$154;
   $156=((HEAP32[((14424)>>2)])|0);
   $157=((HEAP32[((14280)>>2)])|0);
   $158=((_fread((($155)|0),((4)|0),(($156)|0),(($157)|0)))|0);
   $159=(($59+24)|0);
   $160=$159;
   $161=((HEAP32[(($160)>>2)])|0);
   $162=(($161+4)|0);
   $163=$162;
   $164=((HEAP32[((14424)>>2)])|0);
   $165=((HEAP32[((14280)>>2)])|0);
   $166=((_fread((($163)|0),((4)|0),(($164)|0),(($165)|0)))|0);
   $167=(($59+28)|0);
   $168=$167;
   $169=((HEAP32[(($168)>>2)])|0);
   $170=(($169+4)|0);
   $171=$170;
   $172=((HEAP32[((14424)>>2)])|0);
   $173=((HEAP32[((14280)>>2)])|0);
   $174=((_fread((($171)|0),((4)|0),(($172)|0),(($173)|0)))|0);
   $175=((HEAP8[(14952)])|0);
   $176=(($175<<24)>>24)>0;
   $or_cond48=$79&$176;
   if ($or_cond48) {
    _writelinktable($60);
   }
   $179=((HEAP32[((13272)>>2)])|0);
   $180=((HEAP32[((15576)>>2)])|0);
   $181=((($180)+($179))|0);
   HEAP32[((15576)>>2)]=$181;
   $182=((($np_054)+(1))|0);
   $183=((HEAP32[((14384)>>2)])|0);
   $184=($182|0)>($183|0);
   if ($184) {
    break;
   } else {
    $np_054=$182;
   }
  }
 }
 $185=((HEAP32[(($60)>>2)])|0);
 _free($185);
 $187=(($59+4)|0);
 $188=$187;
 $189=((HEAP32[(($188)>>2)])|0);
 _free($189);
 $191=(($59+8)|0);
 $192=$191;
 $193=((HEAP32[(($192)>>2)])|0);
 _free($193);
 $195=(($59+12)|0);
 $196=$195;
 $197=((HEAP32[(($196)>>2)])|0);
 _free($197);
 $199=(($59+16)|0);
 $200=$199;
 $201=((HEAP32[(($200)>>2)])|0);
 _free($201);
 $203=(($59+20)|0);
 $204=$203;
 $205=((HEAP32[(($204)>>2)])|0);
 _free($205);
 $207=(($59+24)|0);
 $208=$207;
 $209=((HEAP32[(($208)>>2)])|0);
 _free($209);
 $211=(($59+28)|0);
 $212=$211;
 $213=((HEAP32[(($212)>>2)])|0);
 _free($213);
 _free($60);
 $_0=$278;

 return (($_0)|0);
}


function _writelogo(){
 var $timer=0,$1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$fputs=0,$7=0,$8=0,$9=0,$i_03=0,$10=0,$11=0,$12=0,$13=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $timer=((sp)|0);
 $1=((_time((($timer)|0)))|0);
 $2=((_ctime((($timer)|0)))|0);
 $3=((_strcpy(((17600)|0),(($2)|0)))|0);
 HEAP32[((13968)>>2)]=1;
 HEAP32[((14968)>>2)]=2;
 $4=((HEAP32[((13296)>>2)])|0);
 $5=((_fwrite(((4760)|0),((44)|0),((1)|0),(($4)|0)))|0);
 $6=((HEAP32[((13296)>>2)])|0);
 $fputs=((_fputs(((17600)|0),(($6)|0)))|0);
 $7=((HEAP32[((11136)>>2)])|0);
 $8=($7|0)==0;
 if ($8) {
  _writeline(11472);
  STACKTOP=sp;return;
 } else {
  $i_03=0;$9=$7;
 }
 while(1) {


  _writeline($9);
  $10=((($i_03)+(1))|0);
  $11=((11136+($10<<2))|0);
  $12=((HEAP32[(($11)>>2)])|0);
  $13=($12|0)==0;
  if ($13) {
   break;
  } else {
   $i_03=$10;$9=$12;
  }
 }
 _writeline(11472);
 STACKTOP=sp;return;
}


function _writesummary(){
 var $s=0,$1=0,$strlenfirst=0,$2=0,$4=0,$strlenfirst_1=0,$6=0,$7=0,$8=0,$nres_014=0,$i_113=0,$10=0,$11=.0,$12=0,$13=0,$nres_1=0,$14=0,$15=0,$nres_0_lcssa=0,$16=0;
 var $17=0,$18=0,$19=0,$20=0,$21=0,$22=0,$23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$32=.0,$33=.0,$34=.0,$35=0,$36=.0;
 var $37=0,$38=0,$39=0,$40=0,$41=0,$42=.0,$43=0,$44=0,$45=0,$46=0,$47=0,$48=0,$49=0,$or_cond11=0,$53=0,$55=0,$56=0,$57=0,$58=0,$61=0;
 var $62=0,$63=0,$64=0,$or_cond=0,$66=0,$67=.0,$68=.0,$69=.0,$70=0,$71=.0,$72=.0,$73=.0,$74=0,$76=.0,$77=0,$78=.0,$79=.0,$80=0,$81=.0,$82=.0;
 var $83=0,$84=.0,$85=0,$86=0,$87=.0,$88=.0,$89=.0,$90=0,$91=0,$92=0,$94=0,$95=0,$_pr=0,$98=0,$99=0,$102=0,$103=0,$106=0,$107=0,$_pr12=0;
 var $110=0,$111=0,$114=0,$115=0,$120=0,$strlenfirst_2=0,$122=0,$124=0,$126=0,$127=0,$128=0,$129=0,$130=0,$131=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+264)|0;
 $s=((sp)|0);
 $1=(($s)|0);
 $strlenfirst=((HEAP8[(12928)])|0);
 $2=(($strlenfirst<<24)>>24)==0;
 if (!($2)) {
  $4=((_sprintf((($1)|0),((2248)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=12928,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline($1);
 }
 $strlenfirst_1=((HEAP8[(13008)])|0);
 $6=(($strlenfirst_1<<24)>>24)==0;
 if (!($6)) {
  $120=((_sprintf((($1)|0),((2248)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=13008,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline($1);
 }
 $strlenfirst_2=((HEAP8[(13088)])|0);
 $122=(($strlenfirst_2<<24)>>24)==0;
 if (!($122)) {
  $124=((_sprintf((($1)|0),((2248)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=13088,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline($1);
 }
 _writeline(1768);
 $126=(($s)|0);
 $127=((_sprintf((($126)|0),((1224)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=15008,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $128=((HEAP32[((14432)>>2)])|0);
 $129=((_sprintf((($126)|0),((592)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$128,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $130=((HEAP32[((14352)>>2)])|0);
 $131=($130|0)<1;
 if ($131) {
  $nres_0_lcssa=0;
 } else {
  $7=((HEAP32[((13176)>>2)])|0);
  $8=((HEAP32[((14352)>>2)])|0);
  $i_113=1;$nres_014=0;
  while(1) {


   $10=(($7+((($i_113)*(112))&-1)+8)|0);
   $11=(+(HEAPF64[(($10)>>3)]));
   $12=$11==(0.0);
   $13=($12&1);
   $nres_1=((($13)+($nres_014))|0);
   $14=((($i_113)+(1))|0);
   $15=($14|0)>($8|0);
   if ($15) {
    $nres_0_lcssa=$nres_1;
    break;
   } else {
    $i_113=$14;$nres_014=$nres_1;
   }
  }
 }

 $16=((_sprintf((($126)|0),((120)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$nres_0_lcssa,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $17=((HEAP32[((14352)>>2)])|0);
 $18=((($17)-($nres_0_lcssa))|0);
 $19=((_sprintf((($126)|0),((10216)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$18,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $20=((HEAP32[((14376)>>2)])|0);
 $21=((_sprintf((($126)|0),((10000)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$20,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $22=((HEAP32[((14368)>>2)])|0);
 $23=((_sprintf((($126)|0),((9784)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$22,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $24=((HEAP32[((14328)>>2)])|0);
 $25=((_sprintf((($126)|0),((9312)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$24,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $26=((HEAP8[(15624)])|0);
 $27=(($26<<24)>>24);
 $28=((10912+($27<<2))|0);
 $29=((HEAP32[(($28)>>2)])|0);
 $30=((_sprintf((($126)|0),((8840)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$29,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $31=((HEAP32[((15584)>>2)])|0);
 $32=(+((($31|0))|0));
 $33=(+(HEAPF64[((12168)>>3)]));
 $34=($32)*($33);
 $35=((_sprintf((($126)|0),((8424)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAPF64[((tempVarArgs)>>3)]=$34,HEAP32[(((tempVarArgs)+(8))>>2)]=17096,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $36=(+(HEAPF64[((11240)>>3)]));
 $37=((_sprintf((($126)|0),((8240)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$36,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $38=((HEAP32[((17728)>>2)])|0);
 $39=((_sprintf((($126)|0),((7792)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$38,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $40=((HEAP32[((14672)>>2)])|0);
 $41=((_sprintf((($126)|0),((7008)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$40,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $42=(+(HEAPF64[((11392)>>3)]));
 $43=((_sprintf((($126)|0),((6312)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$42,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $44=((HEAP32[((14648)>>2)])|0);
 $45=((_sprintf((($126)|0),((5672)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$44,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $46=((HEAP8[(13856)])|0);
 $47=(($46<<24)>>24)==0;
 $48=((HEAP32[((17544)>>2)])|0);
 $49=($48|0)==0;
 $or_cond11=$47|$49;
 do {
  if ($or_cond11) {
   (_memcpy((($126)|0), ((5424)|0), 45)|0);
  } else {
   if ((((($46<<24)>>24))|0)==((3)|0)) {
    $55=((HEAP32[((12224)>>2)])|0);
    $56=((HEAP32[((14408)>>2)])|0);
    $57=(($56+((($55)*(72))&-1))|0);
    $58=((_sprintf((($126)|0),((5160)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$57,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    break;
   } else if ((((($46<<24)>>24))|0)==((2)|0)) {
    (_memcpy((($126)|0), ((4952)|0), 44)|0);
    break;
   } else if ((((($46<<24)>>24))|0)==((1)|0)) {
    $53=((_sprintf((($126)|0),((5296)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=17696,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    break;
   } else {
    break;
   }
  }
 } while(0);
 _writeline($126);
 $61=((HEAP8[(13856)])|0);
 $62=(($61<<24)>>24)!=0;
 $63=((HEAP32[((17544)>>2)])|0);
 $64=($63|0)>0;
 $or_cond=$62&$64;
 if ($or_cond) {
  $66=((HEAP32[((13872)>>2)])|0);
  $67=(+((($66|0))|0));
  $68=$67;
  $69=($68)/((60.0));
  $70=((_sprintf((($126)|0),((4816)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$69,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline($126);
  $71=(+(HEAPF64[((11400)>>3)]));
  $72=(+(HEAPF64[((12072)>>3)]));
  $73=($71)*($72);
  $74=((_sprintf((($126)|0),((4624)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAPF64[((tempVarArgs)>>3)]=$73,HEAP32[(((tempVarArgs)+(8))>>2)]=16040,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline($126);
 }
 $76=(+(HEAPF64[((10648)>>3)]));
 $77=((_sprintf((($126)|0),((4480)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$76,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $78=(+(HEAPF64[((10480)>>3)]));
 $79=($78)/((0.000011));
 $80=((_sprintf((($126)|0),((4360)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$79,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $81=(+(HEAPF64[((11376)>>3)]));
 $82=($81)/((1.3e-8));
 $83=((_sprintf((($126)|0),((4224)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$82,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $84=(+(HEAPF64[((11368)>>3)]));
 $85=((_sprintf((($126)|0),((4096)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$84,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $86=((HEAP32[((17544)>>2)])|0);
 $87=(+((($86|0))|0));
 $88=(+(HEAPF64[((12168)>>3)]));
 $89=($87)*($88);
 $90=((_sprintf((($126)|0),((3960)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAPF64[((tempVarArgs)>>3)]=$89,HEAP32[(((tempVarArgs)+(8))>>2)]=17096,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline($126);
 $91=((HEAP8[(13288)])|0);
 $92=(($91<<24)>>24)==0;
 if ($92) {
  _writeline(1768);
  STACKTOP=sp;return;
 }
 (_memcpy((($126)|0), ((3848)|0), 24)|0);
 _writeline($126);
 $94=((HEAP8[(14400)])|0);
 $95=(($94<<24)>>24)==0;
 if ($95) {
  _writeline(3744);
  $_pr=((HEAP8[(14400)])|0);
  $98=$_pr;
 } else {
  $98=$94;
 }

 $99=(($98<<24)>>24)==1;
 if ($99) {
  _writeline(3632);
 }
 $102=((HEAP8[(14400)])|0);
 $103=(($102<<24)>>24)==2;
 if ($103) {
  _writeline(3584);
 }
 _writelimits(1,4);
 $106=((HEAP8[(14952)])|0);
 $107=(($106<<24)>>24)==0;
 if ($107) {
  _writeline(3544);
  $_pr12=((HEAP8[(14952)])|0);
  $110=$_pr12;
 } else {
  $110=$106;
 }

 $111=(($110<<24)>>24)==1;
 if ($111) {
  _writeline(3488);
 }
 $114=((HEAP8[(14952)])|0);
 $115=(($114<<24)>>24)==2;
 if ($115) {
  _writeline(3448);
 }
 _writelimits(6,9);
 _writeline(1768);
 STACKTOP=sp;return;
}


function _writeline($s){
 $s=($s)|0;
 var $1=0,$2=0,$4=0,$5=0,$7=0,$8=0,$9=0,$11=0,$12=0,$13=0,$14=0,$15=0,$19=0,$20=0,$21=0,$24=0,$25=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=((HEAP32[((13296)>>2)])|0);
 $2=($1|0)==0;
 if ($2) {
  STACKTOP=sp;return;
 }
 $4=((HEAP8[(13288)])|0);
 $5=(($4<<24)>>24)==0;
 do {
  if (!($5)) {
   $7=((HEAP32[((14968)>>2)])|0);
   $8=((HEAP32[((13960)>>2)])|0);
   $9=($7|0)==($8|0);
   if (!($9)) {
    break;
   }
   $11=((HEAP32[((13968)>>2)])|0);
   $12=((($11)+(1))|0);
   HEAP32[((13968)>>2)]=$12;
   $13=((HEAP32[((13296)>>2)])|0);
   $14=((_fprintf((($13)|0),((1560)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$12,HEAP32[(((tempVarArgs)+(8))>>2)]=12928,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   $15=($14|0)==-1;
   if ($15) {
    HEAP8[(15616)]=1;
   }
   HEAP32[((14968)>>2)]=3;
  }
 } while(0);
 $19=((HEAP32[((13296)>>2)])|0);
 $20=((_fprintf((($19)|0),((1536)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$s,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 $21=($20|0)==-1;
 if ($21) {
  HEAP8[(15616)]=1;
 }
 $24=((HEAP32[((14968)>>2)])|0);
 $25=((($24)+(1))|0);
 HEAP32[((14968)>>2)]=$25;
 STACKTOP=sp;return;
}


function _writelimits($j1,$j2){
 $j1=($j1)|0;
 $j2=($j2)|0;
 var $1=0,$j_011=0,$2=0,$3=0,$4=.0,$5=0,$7=0,$8=0,$9=0,$11=0,$12=.0,$13=0,$15=0,$16=0,$17=0,$19=0,$20=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=($j1|0)>($j2|0);
 if ($1) {
  STACKTOP=sp;return;
 } else {
  $j_011=$j1;
 }
 while(1) {

  $2=((15656+((($j_011)*(88))&-1))|0);
  $3=((15656+((($j_011)*(88))&-1)+72)|0);
  $4=(+(HEAPF64[(($3)>>3)]));
  $5=$4<(10000000000.0);
  if ($5) {
   $7=(($2)|0);
   $8=((15656+((($j_011)*(88))&-1)+32)|0);
   $9=((_sprintf(((14488)|0),((352)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,HEAP32[((tempVarArgs)>>2)]=$7,HEAPF64[(((tempVarArgs)+(8))>>3)]=$4,HEAP32[(((tempVarArgs)+(16))>>2)]=$8,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   _writeline(14488);
  }
  $11=((15656+((($j_011)*(88))&-1)+80)|0);
  $12=(+(HEAPF64[(($11)>>3)]));
  $13=$12>(-10000000000.0);
  if ($13) {
   $15=(($2)|0);
   $16=((15656+((($j_011)*(88))&-1)+32)|0);
   $17=((_sprintf(((14488)|0),((296)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,HEAP32[((tempVarArgs)>>2)]=$15,HEAPF64[(((tempVarArgs)+(8))>>3)]=$12,HEAP32[(((tempVarArgs)+(16))>>2)]=$16,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   _writeline(14488);
  }
  $19=((($j_011)+(1))|0);
  $20=($19|0)>($j2|0);
  if ($20) {
   break;
  } else {
   $j_011=$19;
  }
 }
 STACKTOP=sp;return;
}


function _writehydstat($iter,$relerr){
 $iter=($iter)|0;
 $relerr=+($relerr);
 var $s1=0,$atime=0,$1=0,$2=0,$3=0,$4=0,$5=0,$7=.0,$8=0,$9=0,$11=0,$13=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$i_030=0,$22=0;
 var $23=0,$24=0,$25=0,$26=0,$27=.0,$28=0,$30=.0,$32=.0,$33=0,$35=0,$36=0,$37=.0,$38=0,$40=0,$42=0,$43=0,$44=0,$45=0,$46=0,$newstat_0=0;
 var $48=0,$49=0,$50=0,$51=0,$52=0,$53=0,$55=0,$56=0,$57=0,$58=.0,$59=0,$60=0,$61=0,$62=0,$63=0,$65=0,$66=0,$67=.0,$68=0,$69=.0;
 var $70=.0,$71=.0,$72=.0,$73=0,$75=0,$77=0,$78=0,$79=0,$80=0,$82=0,$83=0,$84=0,$i_128=0,$86=0,$87=0,$88=0,$89=0,$90=0,$91=0,$92=0;
 var $93=0,$94=0,$96=0,$97=0,$98=0,$99=0,$100=0,$101=0,$102=0,$103=0,$104=0,$106=0,$107=0,$108=0,$110=0,$111=0,$112=0,$113=0,$114=0,$116=0;
 var $117=0,$118=0,$119=0,$120=0,$122=0,$123=0,$124=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+272)|0;
 $s1=((sp)|0);
 $atime=(((sp)+(256))|0);
 $1=(($atime)|0);
 $2=((HEAP32[((15576)>>2)])|0);
 $3=((_clocktime(17744,$2))|0);
 $4=((_strcpy((($1)|0),(($3)|0)))|0);
 $5=($iter|0)>0;
 if ($5) {
  $7=(+(HEAPF64[((11240)>>3)]));
  $8=$7<$relerr;
  $9=(($s1)|0);
  if ($8) {
   $13=((_sprintf((($9)|0),((3320)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,HEAP32[((tempVarArgs)>>2)]=$1,HEAP32[(((tempVarArgs)+(8))>>2)]=$iter,HEAPF64[(((tempVarArgs)+(16))>>3)]=$relerr,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  } else {
   $11=((_sprintf((($9)|0),((3400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$1,HEAP32[(((tempVarArgs)+(8))>>2)]=$iter,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  }
  _writeline($9);
 }
 $15=((HEAP32[((14352)>>2)])|0);
 $16=($15|0)<1;
 if (!($16)) {
  $17=(($s1)|0);
  $i_030=1;
  while(1) {

   $22=((HEAP32[((13176)>>2)])|0);
   $23=(($22+((($i_030)*(112))&-1))|0);
   $24=((HEAP32[(($23)>>2)])|0);
   $25=((HEAP32[((17632)>>2)])|0);
   $26=(($25+($24<<3))|0);
   $27=(+(HEAPF64[(($26)>>3)]));
   $28=$27<(0.0);
   if ($28) {
    $30=((-.0))-($27);
    $32=$30;
   } else {
    $32=$27;
   }

   $33=$32<(0.001);
   do {
    if ($33) {
     $newstat_0=2;
    } else {
     $35=((HEAP32[((17632)>>2)])|0);
     $36=(($35+($24<<3))|0);
     $37=(+(HEAPF64[(($36)>>3)]));
     $38=$37>(0.0);
     if ($38) {
      $newstat_0=8;
      break;
     }
     $40=$37<(0.0);
     if ($40) {
      $newstat_0=9;
      break;
     }
     $42=((HEAP32[((14424)>>2)])|0);
     $43=((($42)+($i_030))|0);
     $44=((HEAP32[((14320)>>2)])|0);
     $45=(($44+$43)|0);
     $46=((HEAP8[($45)])|0);
     $newstat_0=$46;
    }
   } while(0);

   $48=((HEAP32[((14424)>>2)])|0);
   $49=((($48)+($i_030))|0);
   $50=((HEAP32[((14320)>>2)])|0);
   $51=(($50+$49)|0);
   $52=((HEAP8[($51)])|0);
   $53=(($newstat_0<<24)>>24)==(($52<<24)>>24);
   if (!($53)) {
    $55=(($newstat_0<<24)>>24);
    $56=((HEAP32[((13176)>>2)])|0);
    $57=(($56+((($i_030)*(112))&-1)+8)|0);
    $58=(+(HEAPF64[(($57)>>3)]));
    $59=$58>(0.0);
    $60=((HEAP32[((14408)>>2)])|0);
    $61=(($60+((($24)*(72))&-1))|0);
    $62=((10608+($55<<2))|0);
    $63=((HEAP32[(($62)>>2)])|0);
    if ($59) {
     $65=((HEAP32[((15600)>>2)])|0);
     $66=(($65+($24<<3))|0);
     $67=(+(HEAPF64[(($66)>>3)]));
     $68=(($60+((($24)*(72))&-1)+32)|0);
     $69=(+(HEAPF64[(($68)>>3)]));
     $70=($67)-($69);
     $71=(+(HEAPF64[((12056)>>3)]));
     $72=($70)*($71);
     $73=((_sprintf((($17)|0),((3272)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 40)|0,HEAP32[((tempVarArgs)>>2)]=$1,HEAP32[(((tempVarArgs)+(8))>>2)]=$61,HEAP32[(((tempVarArgs)+(16))>>2)]=$63,HEAPF64[(((tempVarArgs)+(24))>>3)]=$72,HEAP32[(((tempVarArgs)+(32))>>2)]=15864,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    } else {
     $75=((_sprintf((($17)|0),((3224)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,HEAP32[((tempVarArgs)>>2)]=$1,HEAP32[(((tempVarArgs)+(8))>>2)]=$61,HEAP32[(((tempVarArgs)+(16))>>2)]=$63,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    }
    _writeline($17);
    $77=((HEAP32[((14424)>>2)])|0);
    $78=((($77)+($i_030))|0);
    $79=((HEAP32[((14320)>>2)])|0);
    $80=(($79+$78)|0);
    HEAP8[($80)]=$newstat_0;
   }
   $82=((($i_030)+(1))|0);
   $83=((HEAP32[((14352)>>2)])|0);
   $84=($82|0)>($83|0);
   if ($84) {
    break;
   } else {
    $i_030=$82;
   }
  }
 }
 $18=((HEAP32[((14424)>>2)])|0);
 $19=($18|0)<1;
 if ($19) {
  _writeline(1768);
  STACKTOP=sp;return;
 }
 $20=(($s1)|0);
 $i_128=1;
 while(1) {

  $86=((HEAP32[((13232)>>2)])|0);
  $87=(($86+$i_128)|0);
  $88=((HEAP8[($87)])|0);
  $89=(($88<<24)>>24);
  $90=((HEAP32[((14320)>>2)])|0);
  $91=(($90+$i_128)|0);
  $92=((HEAP8[($91)])|0);
  $93=(($92<<24)>>24);
  $94=(($88<<24)>>24)==(($92<<24)>>24);
  if (!($94)) {
   $96=((HEAP32[((15576)>>2)])|0);
   $97=($96|0)==0;
   $98=((HEAP32[((14960)>>2)])|0);
   $99=(($98+((($i_128)*(104))&-1)+96)|0);
   $100=((HEAP8[($99)])|0);
   $101=(($100<<24)>>24);
   $102=((11168+($101<<2))|0);
   $103=((HEAP32[(($102)>>2)])|0);
   $104=(($98+((($i_128)*(104))&-1))|0);
   if ($97) {
    $106=((10608+($89<<2))|0);
    $107=((HEAP32[(($106)>>2)])|0);
    $108=((_sprintf((($20)|0),((3120)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 32)|0,HEAP32[((tempVarArgs)>>2)]=$1,HEAP32[(((tempVarArgs)+(8))>>2)]=$103,HEAP32[(((tempVarArgs)+(16))>>2)]=$104,HEAP32[(((tempVarArgs)+(24))>>2)]=$107,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   } else {
    $110=((10608+($93<<2))|0);
    $111=((HEAP32[(($110)>>2)])|0);
    $112=((10608+($89<<2))|0);
    $113=((HEAP32[(($112)>>2)])|0);
    $114=((_sprintf((($20)|0),((3008)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 40)|0,HEAP32[((tempVarArgs)>>2)]=$1,HEAP32[(((tempVarArgs)+(8))>>2)]=$103,HEAP32[(((tempVarArgs)+(16))>>2)]=$104,HEAP32[(((tempVarArgs)+(24))>>2)]=$111,HEAP32[(((tempVarArgs)+(32))>>2)]=$113,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   }
   _writeline($20);
   $116=((HEAP32[((13232)>>2)])|0);
   $117=(($116+$i_128)|0);
   $118=((HEAP8[($117)])|0);
   $119=((HEAP32[((14320)>>2)])|0);
   $120=(($119+$i_128)|0);
   HEAP8[($120)]=$118;
  }
  $122=((($i_128)+(1))|0);
  $123=((HEAP32[((14424)>>2)])|0);
  $124=($122|0)>($123|0);
  if ($124) {
   break;
  } else {
   $i_128=$122;
  }
 }
 _writeline(1768);
 STACKTOP=sp;return;
}


function _clocktime($atime,$seconds){
 $atime=($atime)|0;
 $seconds=($seconds)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=(((($seconds|0))/(3600))&-1);
 $2=(((($seconds|0))%(3600))&-1);
 $3=(((($2|0))/(60))&-1);
 $4=((($1)*(-3600))&-1);
 $5=((($4)+($seconds))|0);
 $6=((($3)*(-60))&-1);
 $7=((($5)+($6))|0);
 $8=((_sprintf((($atime)|0),((264)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,HEAP32[((tempVarArgs)>>2)]=$1,HEAP32[(((tempVarArgs)+(8))>>2)]=$3,HEAP32[(((tempVarArgs)+(16))>>2)]=$7,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 STACKTOP=sp;return (($atime)|0);
}


function _writeheader($type,$contin){
 $type=($type)|0;
 $contin=($contin)|0;
 var $s=0,$s1=0,$s2=0,$s3=0,$1=0,$2=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$15=0,$16=0,$strlen25=0,$endptr26=0;
 var $18=0,$20=0,$21=0,$22=0,$26=0,$27=0,$strlen23=0,$endptr24=0,$30=0,$31=0,$32=0,$34=0,$36=0,$37=0,$39=0,$40=0,$41=0,$42=0,$43=0,$45=0;
 var $46=0,$47=0,$50=0,$51=0,$52=0,$54=0,$56=0,$strlen21=0,$endptr22=0,$58=0,$59=0,$60=0,$61=0,$62=0,$63=0,$64=0,$66=0,$67=0,$68=0,$69=0;
 var $n_1=0,$71=0,$72=0,$74=0,$75=0,$76=0,$77=0,$78=0,$n_2=0,$80=0,$81=0,$82=0,$84=0,$86=0,$87=0,$89=0,$90=0,$91=0,$92=0,$93=0;
 var $95=0,$96=0,$97=0,$100=0,$101=0,$102=0,$104=0,$106=0,$strlen=0,$endptr=0,$108=0,$109=0,$110=0,$111=0,$112=0,$n_328=0,$i_127=0,$114=0,$115=0,$116=0;
 var $118=0,$119=0,$120=0,$121=0,$122=0,$123=0,$124=0,$n_4=0,$126=0,$127=0,$129=0,$130=0,$133=0,$134=0,$135=0,$136=0,$137=0,$n_1_1=0,$139=0,$140=0;
 var $142=0,$143=0,$144=0,$145=0,$146=0,$n_1_2=0,$148=0,$149=0,$151=0,$152=0,$153=0,$154=0,$155=0,$n_1_3=0,$157=0,$158=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+1024)|0;
 $s=((sp)|0);
 $s1=(((sp)+(256))|0);
 $s2=(((sp)+(512))|0);
 $s3=(((sp)+(768))|0);
 $1=((HEAP8[(13288)])|0);
 $2=(($1<<24)>>24)==0;
 do {
  if (!($2)) {
   $4=((HEAP32[((14968)>>2)])|0);
   $5=((($4)+(11))|0);
   $6=((HEAP32[((13960)>>2)])|0);
   $7=($5|0)>($6|0);
   if (!($7)) {
    break;
   }
   $8=((HEAP32[((14968)>>2)])|0);
   $9=((HEAP32[((13960)>>2)])|0);
   $10=($8|0)<($9|0);
   if (!($10)) {
    break;
   }
   while(1) {
    _writeline(1768);
    $11=((HEAP32[((14968)>>2)])|0);
    $12=((HEAP32[((13960)>>2)])|0);
    $13=($11|0)<($12|0);
    if (!($13)) {
     break;
    }
   }
  }
 } while(0);
 _writeline(1768);
 do {
  if (((($type|0))|0)==((0)|0)) {
   $15=(($s)|0);
   (_memcpy((($15)|0), ((2352)|0), 18)|0);
   $16=($contin|0)==0;
   if (!($16)) {
    $strlen25=((_strlen((($15)|0)))|0);
    $endptr26=(($s+$strlen25)|0);
    (_memcpy((($endptr26)|0), ((2272)|0), 13)|0);
   }
   _writeline($15);
   $18=((_fillstr($15,45,70))|0);
   _writeline($15);
   STACKTOP=sp;return;
  } else if (((($type|0))|0)==((1)|0)) {
   $20=((HEAP8[(12032)])|0);
   $21=(($20<<24)>>24)==1;
   $22=(($s1)|0);
   if ($21) {
    HEAP8[($22)]=((HEAP8[(2256)])|0);HEAP8[((($22)+(1))|0)]=((HEAP8[(2257)])|0);HEAP8[((($22)+(2))|0)]=((HEAP8[(2258)])|0);HEAP8[((($22)+(3))|0)]=((HEAP8[(2259)])|0);HEAP8[((($22)+(4))|0)]=((HEAP8[(2260)])|0);HEAP8[((($22)+(5))|0)]=((HEAP8[(2261)])|0);
   } else {
    HEAP8[($22)]=((HEAP8[(2232)])|0);HEAP8[((($22)+(1))|0)]=((HEAP8[(2233)])|0);HEAP8[((($22)+(2))|0)]=((HEAP8[(2234)])|0);HEAP8[((($22)+(3))|0)]=((HEAP8[(2235)])|0);HEAP8[((($22)+(4))|0)]=((HEAP8[(2236)])|0);HEAP8[((($22)+(5))|0)]=((HEAP8[(2237)])|0);
   }
   $26=(($s)|0);
   (_memcpy((($26)|0), ((2200)|0), 14)|0);
   $27=($contin|0)==0;
   if (!($27)) {
    $strlen23=((_strlen((($26)|0)))|0);
    $endptr24=(($s+$strlen23)|0);
    (_memcpy((($endptr24)|0), ((2272)|0), 13)|0);
   }
   _writeline($26);
   $30=((_fillstr($26,45,63))|0);
   _writeline($26);
   (_memcpy((($26)|0), ((2128)|0), 64)|0);
   _writeline($26);
   $31=((_sprintf((($26)|0),((2056)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$22,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   _writeline($26);
   $32=((_fillstr($26,45,63))|0);
   _writeline($26);
   if (((($type|0))|0)==((3)|0)) {
    break;
   } else if (((($type|0))|0)==((2)|0)) {
    label = 15;
    break;
   }
   STACKTOP=sp;return;
  } else if (((($type|0))|0)==((2)|0)) {
   label = 15;
  } else if (!(((($type|0))|0)==((3)|0))) {
   STACKTOP=sp;return;
  }
 } while(0);
 do {
  if ((label|0) == 15) {
   $34=((HEAP8[(12208)])|0);
   do {
    if ((((($34<<24)>>24))|0)==((0)|0)) {
     $45=((HEAP32[((17544)>>2)])|0);
     $46=($45|0)==0;
     $47=(($s)|0);
     if ($46) {
      (_memcpy((($47)|0), ((1936)|0), 14)|0);
      break;
     } else {
      $50=((HEAP32[((15576)>>2)])|0);
      $51=((_clocktime(17744,$50))|0);
      $52=((_sprintf((($47)|0),((1896)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$51,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
      break;
     }
    } else if ((((($34<<24)>>24))|0)==((4)|0)) {
     $36=(($s)|0);
     $37=((_sprintf((($36)|0),((1984)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=1960,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    } else {
     $39=(($34<<24)>>24);
     $40=(($s)|0);
     $41=((10576+($39<<2))|0);
     $42=((HEAP32[(($41)>>2)])|0);
     $43=((_sprintf((($40)|0),((1984)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$42,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    }
   } while(0);
   $54=($contin|0)==0;
   if (!($54)) {
    $56=(($s)|0);
    $strlen21=((_strlen((($56)|0)))|0);
    $endptr22=(($s+$strlen21)|0);
    (_memcpy((($endptr22)|0), ((2272)|0), 13)|0);
   }
   $58=(($s)|0);
   _writeline($58);
   $59=(($s2)|0);
   $60=((_sprintf((($59)|0),((1808)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=11472,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   HEAP8[($58)]=((HEAP8[(1784)])|0);HEAP8[((($58)+(1))|0)]=((HEAP8[(1785)])|0);HEAP8[((($58)+(2))|0)]=((HEAP8[(1786)])|0);HEAP8[((($58)+(3))|0)]=((HEAP8[(1787)])|0);HEAP8[((($58)+(4))|0)]=((HEAP8[(1788)])|0);
   $61=(($s3)|0);
   $62=((_sprintf((($61)|0),((2616)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$58,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   $63=((HEAP8[(15720)])|0);
   $64=(($63<<24)>>24)==1;
   if ($64) {
    $66=((_sprintf((($58)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=15656,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $67=((_strcat((($59)|0),(($58)|0)))|0);
    $68=((_sprintf((($58)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=15688,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $69=((_strcat((($61)|0),(($58)|0)))|0);
    $n_1=25;
   } else {
    $n_1=15;
   }

   $71=((HEAP8[(15808)])|0);
   $72=(($71<<24)>>24)==1;
   if ($72) {
    $133=((($n_1)+(10))|0);
    $134=((_sprintf((($58)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=15744,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $135=((_strcat((($59)|0),(($58)|0)))|0);
    $136=((_sprintf((($58)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=15776,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $137=((_strcat((($61)|0),(($58)|0)))|0);
    $n_1_1=$133;
   } else {
    $n_1_1=$n_1;
   }

   $139=((HEAP8[(15896)])|0);
   $140=(($139<<24)>>24)==1;
   if ($140) {
    $142=((($n_1_1)+(10))|0);
    $143=((_sprintf((($58)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=15832,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $144=((_strcat((($59)|0),(($58)|0)))|0);
    $145=((_sprintf((($58)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=15864,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $146=((_strcat((($61)|0),(($58)|0)))|0);
    $n_1_2=$142;
   } else {
    $n_1_2=$n_1_1;
   }

   $148=((HEAP8[(15984)])|0);
   $149=(($148<<24)>>24)==1;
   if ($149) {
    $151=((($n_1_2)+(10))|0);
    $152=((_sprintf((($58)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=15920,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $153=((_strcat((($59)|0),(($58)|0)))|0);
    $154=((_sprintf((($58)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=15952,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $155=((_strcat((($61)|0),(($58)|0)))|0);
    $n_1_3=$151;
   } else {
    $n_1_3=$n_1_2;
   }

   $157=((HEAP8[(16072)])|0);
   $158=(($157<<24)>>24)==1;
   if ($158) {
    $74=((($n_1_3)+(10))|0);
    $75=((_sprintf((($58)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=17696,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $76=((_strcat((($59)|0),(($58)|0)))|0);
    $77=((_sprintf((($58)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=17664,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $78=((_strcat((($61)|0),(($58)|0)))|0);
    $n_2=$74;
   } else {
    $n_2=$n_1_3;
   }

   $80=(($s1)|0);
   $81=((_fillstr($80,45,$n_2))|0);
   _writeline($80);
   _writeline($59);
   _writeline($61);
   _writeline($80);
   $82=($type|0)==3;
   if ($82) {
    break;
   }
   STACKTOP=sp;return;
  }
 } while(0);
 $84=((HEAP8[(12208)])|0);
 do {
  if ((((($84<<24)>>24))|0)==((0)|0)) {
   $95=((HEAP32[((17544)>>2)])|0);
   $96=($95|0)==0;
   $97=(($s)|0);
   if ($96) {
    (_memcpy((($97)|0), ((1696)|0), 14)|0);
    break;
   } else {
    $100=((HEAP32[((15576)>>2)])|0);
    $101=((_clocktime(17744,$100))|0);
    $102=((_sprintf((($97)|0),((1640)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$101,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    break;
   }
  } else if ((((($84<<24)>>24))|0)==((4)|0)) {
   $86=(($s)|0);
   $87=((_sprintf((($86)|0),((1736)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=1960,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  } else {
   $89=(($84<<24)>>24);
   $90=(($s)|0);
   $91=((10576+($89<<2))|0);
   $92=((HEAP32[(($91)>>2)])|0);
   $93=((_sprintf((($90)|0),((1736)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$92,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  }
 } while(0);
 $104=($contin|0)==0;
 if (!($104)) {
  $106=(($s)|0);
  $strlen=((_strlen((($106)|0)))|0);
  $endptr=(($s+$strlen)|0);
  (_memcpy((($endptr)|0), ((2272)|0), 13)|0);
 }
 $108=(($s)|0);
 _writeline($108);
 $109=(($s2)|0);
 $110=((_sprintf((($109)|0),((1808)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=11472,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 HEAP8[($108)]=((HEAP8[(1616)])|0);HEAP8[((($108)+(1))|0)]=((HEAP8[(1617)])|0);HEAP8[((($108)+(2))|0)]=((HEAP8[(1618)])|0);HEAP8[((($108)+(3))|0)]=((HEAP8[(1619)])|0);HEAP8[((($108)+(4))|0)]=((HEAP8[(1620)])|0);
 $111=(($s3)|0);
 $112=((_sprintf((($111)|0),((2616)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$108,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 $i_127=5;$n_328=15;
 while(1) {


  $114=((15656+((($i_127)*(88))&-1)+64)|0);
  $115=((HEAP8[($114)])|0);
  $116=(($115<<24)>>24)==1;
  if ($116) {
   $118=((($n_328)+(10))|0);
   $119=((15656+((($i_127)*(88))&-1))|0);
   $120=((_sprintf((($108)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$119,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   $121=((_strcat((($109)|0),(($108)|0)))|0);
   $122=((15656+((($i_127)*(88))&-1)+32)|0);
   $123=((_sprintf((($108)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$122,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   $124=((_strcat((($111)|0),(($108)|0)))|0);
   $n_4=$118;
  } else {
   $n_4=$n_328;
  }

  $126=((($i_127)+(1))|0);
  $127=($126|0)<15;
  if ($127) {
   $i_127=$126;$n_328=$n_4;
  } else {
   break;
  }
 }
 $129=(($s1)|0);
 $130=((_fillstr($129,45,$n_4))|0);
 _writeline($129);
 _writeline($109);
 _writeline($111);
 _writeline($129);
 STACKTOP=sp;return;
}


function _fillstr($s,$ch,$n){
 $s=($s)|0;
 $ch=($ch)|0;
 $n=($n)|0;
 var $1=0,$2=0,$4=0,$5=0,label=0;

 $1=($n|0)<0;
 if (!($1)) {
  $2=((($n)+(1))|0);
  _memset((((($s)|0))|0), (((($ch)|0))|0), (((($2)|0))|0))|0;
 }
 $4=((($n)+(1))|0);
 $5=(($s+$4)|0);
 HEAP8[($5)]=0;
 return (($s)|0);
}


function _writenodetable($x){
 $x=($x)|0;
 var $s=0,$s1=0,$y=0,$1=0,$2=0,$3=0,$4=0,$5=0,$i_019=0,$7=0,$8=0,$9=.0,$10=.0,$11=.0,$12=0,$13=0,$14=.0,$15=.0,$16=0,$17=0;
 var $18=0,$19=0,$20=.0,$21=.0,$22=0,$23=0,$24=0,$25=0,$26=.0,$27=.0,$28=0,$29=0,$30=0,$31=0,$32=.0,$33=.0,$34=0,$35=0,$36=0,$38=0;
 var $39=0,$40=0,$41=0,$43=0,$44=0,$46=0,$47=0,$48=0,$51=0,$52=0,$53=0,$54=0,$55=0,$57=0,$58=.0,$59=.0,$60=0,$62=0,$64=0,$65=0;
 var $67=0,$69=0,$70=0,$strlen=0,$endptr=0,$72=0,$73=0,$74=0,$75=0,$78=0,$79=0,$80=0,$82=0,$83=.0,$84=.0,$85=0,$87=0,$88=0,$90=0,$92=0;
 var $94=0,$95=0,$97=0,$98=.0,$99=.0,$100=0,$102=0,$103=0,$105=0,$107=0,$109=0,$110=0,$112=0,$113=.0,$114=.0,$115=0,$117=0,$118=0,$120=0,$122=0;
 var $124=0,$125=0,$127=0,$128=.0,$129=.0,$130=0,$132=0,$133=0,$135=0,$137=0,$139=0,$140=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+440)|0;
 $s=((sp)|0);
 $s1=(((sp)+(256))|0);
 $y=(((sp)+(272))|0);
 _writeheader(2,0);
 $1=((HEAP32[((14416)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  _writeline(1768);
  STACKTOP=sp;return;
 }
 $3=(($y)|0);
 $4=(($s)|0);
 $5=(($s1)|0);
 $i_019=1;
 while(1) {

  $7=((HEAP32[((14408)>>2)])|0);
  $8=(($7+((($i_019)*(72))&-1)+32)|0);
  $9=(+(HEAPF64[(($8)>>3)]));
  $10=(+(HEAPF64[((12040)>>3)]));
  $11=($9)*($10);
  HEAPF64[(($3)>>3)]=$11;
  $12=((HEAP32[(($x)>>2)])|0);
  $13=(($12+($i_019<<2))|0);
  $14=(+(HEAPF32[(($13)>>2)]));
  $15=$14;
  $16=(($y+8)|0);
  HEAPF64[(($16)>>3)]=$15;
  $17=(($x+4)|0);
  $18=((HEAP32[(($17)>>2)])|0);
  $19=(($18+($i_019<<2))|0);
  $20=(+(HEAPF32[(($19)>>2)]));
  $21=$20;
  $22=(($y+16)|0);
  HEAPF64[(($22)>>3)]=$21;
  $23=(($x+8)|0);
  $24=((HEAP32[(($23)>>2)])|0);
  $25=(($24+($i_019<<2))|0);
  $26=(+(HEAPF32[(($25)>>2)]));
  $27=$26;
  $28=(($y+24)|0);
  HEAPF64[(($28)>>3)]=$27;
  $29=(($x+12)|0);
  $30=((HEAP32[(($29)>>2)])|0);
  $31=(($30+($i_019<<2))|0);
  $32=(+(HEAPF32[(($31)>>2)]));
  $33=$32;
  $34=(($y+32)|0);
  HEAPF64[(($34)>>3)]=$33;
  $35=((HEAP8[(14400)])|0);
  $36=(($35<<24)>>24)==1;
  if ($36) {
   label = 5;
  } else {
   $38=((HEAP32[((14408)>>2)])|0);
   $39=(($38+((($i_019)*(72))&-1)+64)|0);
   $40=((HEAP8[($39)])|0);
   $41=(($40<<24)>>24)==0;
   if (!($41)) {
    label = 5;
   }
  }
  do {
   if ((label|0) == 5) {
    label = 0;
    $43=((_checklimits($3,0,4))|0);
    $44=($43|0)==0;
    if ($44) {
     break;
    }
    $46=((HEAP32[((14968)>>2)])|0);
    $47=((HEAP32[((13960)>>2)])|0);
    $48=($46|0)==($47|0);
    if ($48) {
     _writeheader(2,1);
    }
    $51=((HEAP32[((14408)>>2)])|0);
    $52=(($51+((($i_019)*(72))&-1))|0);
    $53=((_sprintf((($4)|0),((2616)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$52,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $54=((HEAP8[(15720)])|0);
    $55=(($54<<24)>>24)==1;
    if ($55) {
     $57=(($y)|0);
     $58=(+(HEAPF64[(($57)>>3)]));
     $59=(+(Math_abs((+($58)))));
     $60=$59>(1000000.0);
     if ($60) {
      $62=((_sprintf((($5)|0),((2536)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$58,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     } else {
      $64=((HEAP32[((15724)>>2)])|0);
      $65=((_sprintf((($5)|0),((2448)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$64,HEAPF64[(((tempVarArgs)+(8))>>3)]=$58,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     }
     $67=((_strcat((($4)|0),(($5)|0)))|0);
    }
    $69=((HEAP8[(15808)])|0);
    $70=(($69<<24)>>24)==1;
    if ($70) {
     $82=(($y+8)|0);
     $83=(+(HEAPF64[(($82)>>3)]));
     $84=(+(Math_abs((+($83)))));
     $85=$84>(1000000.0);
     if ($85) {
      $90=((_sprintf((($5)|0),((2536)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$83,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     } else {
      $87=((HEAP32[((15812)>>2)])|0);
      $88=((_sprintf((($5)|0),((2448)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$87,HEAPF64[(((tempVarArgs)+(8))>>3)]=$83,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     }
     $92=((_strcat((($4)|0),(($5)|0)))|0);
    }
    $94=((HEAP8[(15896)])|0);
    $95=(($94<<24)>>24)==1;
    if ($95) {
     $97=(($y+16)|0);
     $98=(+(HEAPF64[(($97)>>3)]));
     $99=(+(Math_abs((+($98)))));
     $100=$99>(1000000.0);
     if ($100) {
      $105=((_sprintf((($5)|0),((2536)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$98,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     } else {
      $102=((HEAP32[((15900)>>2)])|0);
      $103=((_sprintf((($5)|0),((2448)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$102,HEAPF64[(((tempVarArgs)+(8))>>3)]=$98,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     }
     $107=((_strcat((($4)|0),(($5)|0)))|0);
    }
    $109=((HEAP8[(15984)])|0);
    $110=(($109<<24)>>24)==1;
    if ($110) {
     $112=(($y+24)|0);
     $113=(+(HEAPF64[(($112)>>3)]));
     $114=(+(Math_abs((+($113)))));
     $115=$114>(1000000.0);
     if ($115) {
      $120=((_sprintf((($5)|0),((2536)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$113,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     } else {
      $117=((HEAP32[((15988)>>2)])|0);
      $118=((_sprintf((($5)|0),((2448)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$117,HEAPF64[(((tempVarArgs)+(8))>>3)]=$113,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     }
     $122=((_strcat((($4)|0),(($5)|0)))|0);
    }
    $124=((HEAP8[(16072)])|0);
    $125=(($124<<24)>>24)==1;
    if ($125) {
     $127=(($y+32)|0);
     $128=(+(HEAPF64[(($127)>>3)]));
     $129=(+(Math_abs((+($128)))));
     $130=$129>(1000000.0);
     if ($130) {
      $135=((_sprintf((($5)|0),((2536)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$128,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     } else {
      $132=((HEAP32[((16076)>>2)])|0);
      $133=((_sprintf((($5)|0),((2448)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$132,HEAPF64[(((tempVarArgs)+(8))>>3)]=$128,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     }
     $137=((_strcat((($4)|0),(($5)|0)))|0);
    }
    $139=((HEAP32[((14432)>>2)])|0);
    $140=($i_019|0)>($139|0);
    if ($140) {
     $strlen=((_strlen((($4)|0)))|0);
     $endptr=(($s+$strlen)|0);
     HEAP8[($endptr)]=((HEAP8[(2416)])|0);HEAP8[((($endptr)+(1))|0)]=((HEAP8[(2417)])|0);HEAP8[((($endptr)+(2))|0)]=((HEAP8[(2418)])|0);
     $72=((_getnodetype($i_019))|0);
     $73=((11096+($72<<2))|0);
     $74=((HEAP32[(($73)>>2)])|0);
     $75=((_strcat((($4)|0),(($74)|0)))|0);
    }
    _writeline($4);
   }
  } while(0);
  $78=((($i_019)+(1))|0);
  $79=((HEAP32[((14416)>>2)])|0);
  $80=($78|0)>($79|0);
  if ($80) {
   break;
  } else {
   $i_019=$78;
  }
 }
 _writeline(1768);
 STACKTOP=sp;return;
}


function _writelinktable($x){
 $x=($x)|0;
 var $s=0,$s1=0,$y=0,$1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$i_022=0,$11=0,$12=0,$13=.0,$14=.0,$15=.0,$16=0,$17=0;
 var $18=.0,$19=.0,$20=.0,$21=0,$22=0,$23=.0,$24=.0,$25=0,$26=0,$27=0,$28=0,$29=.0,$30=.0,$31=0,$32=0,$33=0,$34=0,$35=.0,$36=.0,$37=0;
 var $38=0,$39=0,$40=0,$41=.0,$42=.0,$43=0,$44=0,$45=0,$46=0,$47=.0,$48=.0,$49=0,$50=0,$51=0,$52=0,$53=.0,$54=.0,$55=0,$56=0,$57=0;
 var $58=0,$59=.0,$60=.0,$61=0,$62=0,$63=0,$64=0,$65=.0,$66=.0,$67=0,$68=0,$69=0,$71=0,$72=0,$73=0,$74=0,$76=0,$77=0,$79=0,$80=0;
 var $81=0,$84=0,$85=0,$86=0,$j_121=0,$88=0,$89=0,$90=0,$92=0,$93=0,$94=.0,$96=0,$98=0,$_=0,$k_0=0,$100=0,$101=0,$102=0,$104=.0,$105=0;
 var $107=0,$109=0,$110=0,$111=0,$113=0,$115=0,$116=0,$118=0,$119=0,$120=0,$121=0,$123=0,$strlen=0,$endptr=0,$124=0,$125=0,$126=0,$129=0,$130=0,$131=0;
 var label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+440)|0;
 $s=((sp)|0);
 $s1=(((sp)+(256))|0);
 $y=(((sp)+(272))|0);
 _writeheader(3,0);
 $1=((HEAP32[((14424)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  _writeline(1768);
  STACKTOP=sp;return;
 }
 $3=(($y+40)|0);
 $4=(($y+48)|0);
 $5=(($y)|0);
 $6=(($s)|0);
 $7=(($s1)|0);
 $8=(($s1)|0);
 $9=(($s1)|0);
 $i_022=1;
 while(1) {

  $11=((HEAP32[((14960)>>2)])|0);
  $12=(($11+((($i_022)*(104))&-1)+48)|0);
  $13=(+(HEAPF64[(($12)>>3)]));
  $14=(+(HEAPF64[((12080)>>3)]));
  $15=($13)*($14);
  HEAPF64[(($3)>>3)]=$15;
  $16=((HEAP32[((14960)>>2)])|0);
  $17=(($16+((($i_022)*(104))&-1)+40)|0);
  $18=(+(HEAPF64[(($17)>>3)]));
  $19=(+(HEAPF64[((12088)>>3)]));
  $20=($18)*($19);
  HEAPF64[(($4)>>3)]=$20;
  $21=((HEAP32[(($x)>>2)])|0);
  $22=(($21+($i_022<<2))|0);
  $23=(+(HEAPF32[(($22)>>2)]));
  $24=$23;
  $25=(($y+56)|0);
  HEAPF64[(($25)>>3)]=$24;
  $26=(($x+4)|0);
  $27=((HEAP32[(($26)>>2)])|0);
  $28=(($27+($i_022<<2))|0);
  $29=(+(HEAPF32[(($28)>>2)]));
  $30=$29;
  $31=(($y+64)|0);
  HEAPF64[(($31)>>3)]=$30;
  $32=(($x+8)|0);
  $33=((HEAP32[(($32)>>2)])|0);
  $34=(($33+($i_022<<2))|0);
  $35=(+(HEAPF32[(($34)>>2)]));
  $36=$35;
  $37=(($y+72)|0);
  HEAPF64[(($37)>>3)]=$36;
  $38=(($x+12)|0);
  $39=((HEAP32[(($38)>>2)])|0);
  $40=(($39+($i_022<<2))|0);
  $41=(+(HEAPF32[(($40)>>2)]));
  $42=$41;
  $43=(($y+80)|0);
  HEAPF64[(($43)>>3)]=$42;
  $44=(($x+16)|0);
  $45=((HEAP32[(($44)>>2)])|0);
  $46=(($45+($i_022<<2))|0);
  $47=(+(HEAPF32[(($46)>>2)]));
  $48=$47;
  $49=(($y+88)|0);
  HEAPF64[(($49)>>3)]=$48;
  $50=(($x+20)|0);
  $51=((HEAP32[(($50)>>2)])|0);
  $52=(($51+($i_022<<2))|0);
  $53=(+(HEAPF32[(($52)>>2)]));
  $54=$53;
  $55=(($y+96)|0);
  HEAPF64[(($55)>>3)]=$54;
  $56=(($x+24)|0);
  $57=((HEAP32[(($56)>>2)])|0);
  $58=(($57+($i_022<<2))|0);
  $59=(+(HEAPF32[(($58)>>2)]));
  $60=$59;
  $61=(($y+104)|0);
  HEAPF64[(($61)>>3)]=$60;
  $62=(($x+28)|0);
  $63=((HEAP32[(($62)>>2)])|0);
  $64=(($63+($i_022<<2))|0);
  $65=(+(HEAPF32[(($64)>>2)]));
  $66=$65;
  $67=(($y+112)|0);
  HEAPF64[(($67)>>3)]=$66;
  $68=((HEAP8[(14952)])|0);
  $69=(($68<<24)>>24)==1;
  if ($69) {
   label = 5;
  } else {
   $71=((HEAP32[((14960)>>2)])|0);
   $72=(($71+((($i_022)*(104))&-1)+98)|0);
   $73=((HEAP8[($72)])|0);
   $74=(($73<<24)>>24)==0;
   if (!($74)) {
    label = 5;
   }
  }
  do {
   if ((label|0) == 5) {
    label = 0;
    $76=((_checklimits($5,6,14))|0);
    $77=($76|0)==0;
    if ($77) {
     break;
    }
    $79=((HEAP32[((14968)>>2)])|0);
    $80=((HEAP32[((13960)>>2)])|0);
    $81=($79|0)==($80|0);
    if ($81) {
     _writeheader(3,1);
    }
    $84=((HEAP32[((14960)>>2)])|0);
    $85=(($84+((($i_022)*(104))&-1))|0);
    $86=((_sprintf((($6)|0),((2616)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$85,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    $j_121=5;
    while(1) {

     $88=((15656+((($j_121)*(88))&-1)+64)|0);
     $89=((HEAP8[($88)])|0);
     $90=(($89<<24)>>24)==1;
     if ($90) {
      $92=($j_121|0)==11;
      $93=(($y+($j_121<<3))|0);
      $94=(+(HEAPF64[(($93)>>3)]));
      do {
       if ($92) {
        $96=$94>(2.0);
        if ($96) {
         $98=$94==(4.0);
         $_=($98?4:3);
         $k_0=$_;
        } else {
         $k_0=2;
        }

        $100=((10608+($k_0<<2))|0);
        $101=((HEAP32[(($100)>>2)])|0);
        $102=((_sprintf((($7)|0),((2400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$101,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
       } else {
        $104=(+(Math_abs((+($94)))));
        $105=$104>(1000000.0);
        if ($105) {
         $107=((_sprintf((($9)|0),((2536)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAPF64[((tempVarArgs)>>3)]=$94,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
         break;
        } else {
         $109=((15656+((($j_121)*(88))&-1)+68)|0);
         $110=((HEAP32[(($109)>>2)])|0);
         $111=((_sprintf((($9)|0),((2448)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$110,HEAPF64[(((tempVarArgs)+(8))>>3)]=$94,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
         break;
        }
       }
      } while(0);
      $113=((_strcat((($6)|0),(($8)|0)))|0);
     }
     $115=((($j_121)+(1))|0);
     $116=($115|0)<15;
     if ($116) {
      $j_121=$115;
     } else {
      break;
     }
    }
    $118=((HEAP32[((14960)>>2)])|0);
    $119=(($118+((($i_022)*(104))&-1)+96)|0);
    $120=((HEAP8[($119)])|0);
    $121=(($120<<24)>>24)>1;
    if ($121) {
     $123=(($120<<24)>>24);
     $strlen=((_strlen((($6)|0)))|0);
     $endptr=(($s+$strlen)|0);
     HEAP8[($endptr)]=((HEAP8[(2416)])|0);HEAP8[((($endptr)+(1))|0)]=((HEAP8[(2417)])|0);HEAP8[((($endptr)+(2))|0)]=((HEAP8[(2418)])|0);
     $124=((11168+($123<<2))|0);
     $125=((HEAP32[(($124)>>2)])|0);
     $126=((_strcat((($6)|0),(($125)|0)))|0);
    }
    _writeline($6);
   }
  } while(0);
  $129=((($i_022)+(1))|0);
  $130=((HEAP32[((14424)>>2)])|0);
  $131=($129|0)>($130|0);
  if ($131) {
   break;
  } else {
   $i_022=$129;
  }
 }
 _writeline(1768);
 STACKTOP=sp;return;
}


function _checklimits($y,$j1,$j2){
 $y=($y)|0;
 $j1=($j1)|0;
 $j2=($j2)|0;
 var $j_0=0,$2=0,$4=0,$5=.0,$6=0,$7=.0,$8=0,$10=0,$11=.0,$12=0,$13=0,$_0=0,label=0;

 $j_0=$j1;
 while(1) {

  $2=($j_0|0)>($j2|0);
  if ($2) {
   $_0=1;
   label = 5;
   break;
  }
  $4=(($y+($j_0<<3))|0);
  $5=(+(HEAPF64[(($4)>>3)]));
  $6=((15656+((($j_0)*(88))&-1)+72)|0);
  $7=(+(HEAPF64[(($6)>>3)]));
  $8=$5>$7;
  if ($8) {
   $_0=0;
   label = 5;
   break;
  }
  $10=((15656+((($j_0)*(88))&-1)+80)|0);
  $11=(+(HEAPF64[(($10)>>3)]));
  $12=$5<$11;
  $13=((($j_0)+(1))|0);
  if ($12) {
   $_0=0;
   label = 5;
   break;
  } else {
   $j_0=$13;
  }
 }
 if ((label|0) == 5) {

  return (($_0)|0);
 }
  return 0;
}


function _getnodetype($i){
 $i=($i)|0;
 var $1=0,$2=0,$4=0,$5=0,$6=0,$7=.0,$8=0,$_=0,$_0=0,label=0;

 $1=((HEAP32[((14432)>>2)])|0);
 $2=($1|0)<($i|0);
 if (!($2)) {
  $_0=0;

  return (($_0)|0);
 }
 $4=((($i)-($1))|0);
 $5=((HEAP32[((13176)>>2)])|0);
 $6=(($5+((($4)*(112))&-1)+8)|0);
 $7=(+(HEAPF64[(($6)>>3)]));
 $8=$7==(0.0);
 $_=($8?1:2);
 $_0=$_;

 return (($_0)|0);
}


function _writerelerr($iter,$relerr){
 $iter=($iter)|0;
 $relerr=+($relerr);
 var $1=0,$3=0,$4=0,$5=0,$7=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=($iter|0)==0;
 if ($1) {
  $3=((HEAP32[((15576)>>2)])|0);
  $4=((_clocktime(17744,$3))|0);
  $5=((_sprintf(((14488)|0),((1496)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$4,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline(14488);
  STACKTOP=sp;return;
 } else {
  $7=((_sprintf(((14488)|0),((1424)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$iter,HEAPF64[(((tempVarArgs)+(8))>>3)]=$relerr,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline(14488);
  STACKTOP=sp;return;
 }
}


function _writestatchange($k,$s1,$s2){
 $k=($k)|0;
 $s1=($s1)|0;
 $s2=($s2)|0;
 var $1=0,$3=0,$4=0,$5=.0,$6=0,$7=0,$8=0,$9=0,$11=.0,$12=.0,$14=.0,$15=.0,$setting_0=.0,$17=0,$18=0,$19=0,$20=0,$21=0,$22=0,$23=0;
 var $24=0,$26=0,$28=0,$_=0,$j1_0=0,$30=0,$32=0,$_16=0,$j2_0=0,$34=0,$36=0,$37=0,$38=0,$39=0,$40=0,$41=0,$42=0,$43=0,$44=0,$45=0;
 var $46=0,$47=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=(($s1<<24)>>24)==(($s2<<24)>>24);
 if ($1) {
  $3=((HEAP32[((15000)>>2)])|0);
  $4=(($3+($k<<3))|0);
  $5=(+(HEAPF64[(($4)>>3)]));
  $6=((HEAP32[((14960)>>2)])|0);
  $7=(($6+((($k)*(104))&-1)+96)|0);
  $8=((HEAP8[($7)])|0);
  $9=(($8<<24)>>24);
  if (((($9|0))|0)==((6)|0)) {
   $14=(+(HEAPF64[((12096)>>3)]));
   $15=($5)*($14);
   $setting_0=$15;
  } else if (((($9|0))|0)==((3)|0)|((($9|0))|0)==((4)|0)|((($9|0))|0)==((5)|0)) {
   $11=(+(HEAPF64[((12064)>>3)]));
   $12=($5)*($11);
   $setting_0=$12;
  } else {
   $setting_0=$5;
  }

  $17=((HEAP32[((14960)>>2)])|0);
  $18=(($17+((($k)*(104))&-1)+96)|0);
  $19=((HEAP8[($18)])|0);
  $20=(($19<<24)>>24);
  $21=((11168+($20<<2))|0);
  $22=((HEAP32[(($21)>>2)])|0);
  $23=(($17+((($k)*(104))&-1))|0);
  $24=((_sprintf(((14488)|0),((1344)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,HEAP32[((tempVarArgs)>>2)]=$22,HEAP32[(((tempVarArgs)+(8))>>2)]=$23,HEAPF64[(((tempVarArgs)+(16))>>3)]=$setting_0,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
  _writeline(14488);
  STACKTOP=sp;return;
 }
 $26=(($s1<<24)>>24)==4;
 if ($26) {
  $j1_0=4;
 } else {
  $28=(($s1<<24)>>24)<3;
  $_=($28?2:3);
  $j1_0=$_;
 }

 $30=(($s2<<24)>>24)==4;
 if ($30) {
  $j2_0=4;
 } else {
  $32=(($s2<<24)>>24)<3;
  $_16=($32?2:3);
  $j2_0=$_16;
 }

 $34=($j1_0|0)==($j2_0|0);
 if ($34) {
  STACKTOP=sp;return;
 }
 $36=((HEAP32[((14960)>>2)])|0);
 $37=(($36+((($k)*(104))&-1)+96)|0);
 $38=((HEAP8[($37)])|0);
 $39=(($38<<24)>>24);
 $40=((11168+($39<<2))|0);
 $41=((HEAP32[(($40)>>2)])|0);
 $42=(($36+((($k)*(104))&-1))|0);
 $43=((10608+($j1_0<<2))|0);
 $44=((HEAP32[(($43)>>2)])|0);
 $45=((10608+($j2_0<<2))|0);
 $46=((HEAP32[(($45)>>2)])|0);
 $47=((_sprintf(((14488)|0),((1280)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 32)|0,HEAP32[((tempVarArgs)>>2)]=$41,HEAP32[(((tempVarArgs)+(8))>>2)]=$42,HEAP32[(((tempVarArgs)+(16))>>2)]=$44,HEAP32[(((tempVarArgs)+(24))>>2)]=$46,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline(14488);
 STACKTOP=sp;return;
}


function _writecontrolaction($k,$i){
 $k=($k)|0;
 $i=($i)|0;
 var $1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$21=0;
 var $22=0,$23=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=((HEAP32[((17656)>>2)])|0);
 $2=(($1+((($i)*(40))&-1)+33)|0);
 $3=((HEAP8[($2)])|0);
 $4=(($3<<24)>>24);
 if (((($4|0))|0)==((2)|0)|((($4|0))|0)==((3)|0)) {
  $25=((HEAP32[((15576)>>2)])|0);
  $26=((_clocktime(17744,$25))|0);
  $27=((HEAP32[((14960)>>2)])|0);
  $28=(($27+((($k)*(104))&-1)+96)|0);
  $29=((HEAP8[($28)])|0);
  $30=(($29<<24)>>24);
  $31=((11168+($30<<2))|0);
  $32=((HEAP32[(($31)>>2)])|0);
  $33=(($27+((($k)*(104))&-1))|0);
  $34=((_sprintf(((14488)|0),((1112)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,HEAP32[((tempVarArgs)>>2)]=$26,HEAP32[(((tempVarArgs)+(8))>>2)]=$32,HEAP32[(((tempVarArgs)+(16))>>2)]=$33,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 } else if (((($4|0))|0)==((0)|0)|((($4|0))|0)==((1)|0)) {
  $6=((HEAP32[((17656)>>2)])|0);
  $7=(($6+((($i)*(40))&-1)+4)|0);
  $8=((HEAP32[(($7)>>2)])|0);
  $9=((HEAP32[((15576)>>2)])|0);
  $10=((_clocktime(17744,$9))|0);
  $11=((HEAP32[((14960)>>2)])|0);
  $12=(($11+((($k)*(104))&-1)+96)|0);
  $13=((HEAP8[($12)])|0);
  $14=(($13<<24)>>24);
  $15=((11168+($14<<2))|0);
  $16=((HEAP32[(($15)>>2)])|0);
  $17=(($11+((($k)*(104))&-1))|0);
  $18=((_getnodetype($8))|0);
  $19=((11096+($18<<2))|0);
  $20=((HEAP32[(($19)>>2)])|0);
  $21=((HEAP32[((14408)>>2)])|0);
  $22=(($21+((($8)*(72))&-1))|0);
  $23=((_sprintf(((14488)|0),((1176)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 40)|0,HEAP32[((tempVarArgs)>>2)]=$10,HEAP32[(((tempVarArgs)+(8))>>2)]=$16,HEAP32[(((tempVarArgs)+(16))>>2)]=$17,HEAP32[(((tempVarArgs)+(24))>>2)]=$20,HEAP32[(((tempVarArgs)+(32))>>2)]=$22,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 } else {
  STACKTOP=sp;return;
 }
 _writeline(14488);
 STACKTOP=sp;return;
}


function _writeruleaction($k,$ruleID){
 $k=($k)|0;
 $ruleID=($ruleID)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=((HEAP32[((15576)>>2)])|0);
 $2=((_clocktime(17744,$1))|0);
 $3=((HEAP32[((14960)>>2)])|0);
 $4=(($3+((($k)*(104))&-1)+96)|0);
 $5=((HEAP8[($4)])|0);
 $6=(($5<<24)>>24);
 $7=((11168+($6<<2))|0);
 $8=((HEAP32[(($7)>>2)])|0);
 $9=(($3+((($k)*(104))&-1))|0);
 $10=((_sprintf(((14488)|0),((1064)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 32)|0,HEAP32[((tempVarArgs)>>2)]=$2,HEAP32[(((tempVarArgs)+(8))>>2)]=$8,HEAP32[(((tempVarArgs)+(16))>>2)]=$9,HEAP32[(((tempVarArgs)+(24))>>2)]=$ruleID,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline(14488);
 STACKTOP=sp;return;
}


function _writehydwarn($iter,$relerr){
 $iter=($iter)|0;
 $relerr=+($relerr);
 var $1=0,$2=0,$3=.0,$4=0,$or_cond=0,$6=0,$7=0,$8=0,$9=0,$10=0,$flag_0=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$flag_2_ph=0,$19=0,$20=0;
 var $i_040=0,$22=0,$23=.0,$24=0,$25=.0,$26=0,$28=0,$29=.0,$30=0,$32=0,$33=0,$34=0,$35=0,$36=0,$39=0,$40=0,$flag_2_lcssa=0,$41=0,$42=0,$flag_237=0;
 var $i_136=0,$43=0,$44=0,$45=0,$46=0,$47=0,$48=0,$49=0,$51=0,$52=0,$53=0,$54=0,$55=0,$56=0,$57=0,$58=0,$59=0,$60=0,$61=0,$62=0;
 var $63=0,$64=0,$65=0,$flag_3=0,$68=0,$69=0,$70=0,$flag_434=0,$i_233=0,$71=0,$72=0,$73=0,$74=0,$75=0,$76=0,$77=0,$79=0,$80=0,$81=.0,$82=0;
 var $83=0,$84=.0,$85=0,$86=.0,$87=.0,$88=0,$s_0=0,$89=0,$s_1=0,$91=0,$92=0,$93=0,$94=0,$95=0,$96=0,$97=0,$98=0,$99=0,$100=0,$101=0;
 var $flag_5=0,$104=0,$105=0,$106=0,$flag_4_lcssa=0,$107=0,$108=0,$109=.0,$110=0,$or_cond30=0,$112=0,$113=0,$114=0,$115=0,$116=0,$strlen=0,$endptr=0,$119=0,$120=0,$123=0;
 var $124=0,$125=0,$flag_632=0,$126=0,$128=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=((HEAP32[((14648)>>2)])|0);
 $2=($1|0)>=($iter|0);
 $3=(+(HEAPF64[((11240)>>3)]));
 $4=$3<$relerr;
 $or_cond=$2|$4;
 do {
  if ($or_cond) {
   $flag_0=0;
  } else {
   $6=((HEAP32[((15576)>>2)])|0);
   $7=((_clocktime(17744,$6))|0);
   $8=((_sprintf(((14488)|0),((976)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$7,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   $9=((HEAP8[(14568)])|0);
   $10=(($9<<24)>>24)==0;
   if ($10) {
    $flag_0=2;
    break;
   }
   _writeline(14488);
   $flag_0=2;
  }
 } while(0);

 $13=((HEAP32[((14432)>>2)])|0);
 $14=($13|0)<1;
 L5: do {
  if ($14) {
   $flag_2_ph=$flag_0;
  } else {
   $15=((HEAP32[((15600)>>2)])|0);
   $16=((HEAP32[((14408)>>2)])|0);
   $17=((HEAP32[((17632)>>2)])|0);
   $18=((HEAP32[((14432)>>2)])|0);
   $i_040=1;
   while(1) {

    $22=(($15+($i_040<<3))|0);
    $23=(+(HEAPF64[(($22)>>3)]));
    $24=(($16+((($i_040)*(72))&-1)+32)|0);
    $25=(+(HEAPF64[(($24)>>3)]));
    $26=$23<$25;
    if ($26) {
     $28=(($17+($i_040<<3))|0);
     $29=(+(HEAPF64[(($28)>>3)]));
     $30=$29>(0.0);
     if ($30) {
      break;
     }
    }
    $39=((($i_040)+(1))|0);
    $40=($39|0)>($18|0);
    if ($40) {
     $flag_2_ph=$flag_0;
     break L5;
    } else {
     $i_040=$39;
    }
   }
   $32=((HEAP32[((15576)>>2)])|0);
   $33=((_clocktime(17744,$32))|0);
   $34=((_sprintf(((14488)|0),((912)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$33,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   $35=((HEAP8[(14568)])|0);
   $36=(($35<<24)>>24)==0;
   if ($36) {
    $flag_2_ph=6;
    break;
   }
   _writeline(14488);
   $flag_2_ph=6;
  }
 } while(0);

 $19=((HEAP32[((14328)>>2)])|0);
 $20=($19|0)<1;
 if ($20) {
  $flag_2_lcssa=$flag_2_ph;
 } else {
  $i_136=1;$flag_237=$flag_2_ph;
  while(1) {


   $43=((HEAP32[((12024)>>2)])|0);
   $44=(($43+($i_136<<2))|0);
   $45=((HEAP32[(($44)>>2)])|0);
   $46=((HEAP32[((13232)>>2)])|0);
   $47=(($46+$45)|0);
   $48=((HEAP8[($47)])|0);
   $49=(($48<<24)>>24)>5;
   do {
    if ($49) {
     $51=(($48<<24)>>24);
     $52=((HEAP32[((14960)>>2)])|0);
     $53=(($52+((($45)*(104))&-1)+96)|0);
     $54=((HEAP8[($53)])|0);
     $55=(($54<<24)>>24);
     $56=((11168+($55<<2))|0);
     $57=((HEAP32[(($56)>>2)])|0);
     $58=(($52+((($45)*(104))&-1))|0);
     $59=((10608+($51<<2))|0);
     $60=((HEAP32[(($59)>>2)])|0);
     $61=((HEAP32[((15576)>>2)])|0);
     $62=((_clocktime(17744,$61))|0);
     $63=((_sprintf(((14488)|0),((864)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 32)|0,HEAP32[((tempVarArgs)>>2)]=$57,HEAP32[(((tempVarArgs)+(8))>>2)]=$58,HEAP32[(((tempVarArgs)+(16))>>2)]=$60,HEAP32[(((tempVarArgs)+(24))>>2)]=$62,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     $64=((HEAP8[(14568)])|0);
     $65=(($64<<24)>>24)==0;
     if ($65) {
      $flag_3=5;
      break;
     }
     _writeline(14488);
     $flag_3=5;
    } else {
     $flag_3=$flag_237;
    }
   } while(0);

   $68=((($i_136)+(1))|0);
   $69=((HEAP32[((14328)>>2)])|0);
   $70=($68|0)>($69|0);
   if ($70) {
    $flag_2_lcssa=$flag_3;
    break;
   } else {
    $i_136=$68;$flag_237=$flag_3;
   }
  }
 }

 $41=((HEAP32[((14368)>>2)])|0);
 $42=($41|0)<1;
 if ($42) {
  $flag_4_lcssa=$flag_2_lcssa;
 } else {
  $i_233=1;$flag_434=$flag_2_lcssa;
  while(1) {


   $71=((HEAP32[((13888)>>2)])|0);
   $72=(($71+($i_233<<7))|0);
   $73=((HEAP32[(($72)>>2)])|0);
   $74=((HEAP32[((13232)>>2)])|0);
   $75=(($74+$73)|0);
   $76=((HEAP8[($75)])|0);
   $77=(($76<<24)>>24)>2;
   if ($77) {
    $79=((HEAP32[((13880)>>2)])|0);
    $80=(($79+($73<<3))|0);
    $81=(+(HEAPF64[(($80)>>3)]));
    $82=((HEAP32[((15000)>>2)])|0);
    $83=(($82+($73<<3))|0);
    $84=(+(HEAPF64[(($83)>>3)]));
    $85=(($71+($i_233<<7)+16)|0);
    $86=(+(HEAPF64[(($85)>>3)]));
    $87=($84)*($86);
    $88=$81>$87;
    $s_0=($88?5:$76);
    $89=$81<(0.0);
    if ($89) {
     $92=0;
     label = 20;
    } else {
     $s_1=$s_0;
     label = 19;
    }
   } else {
    $s_1=$76;
    label = 19;
   }
   if ((label|0) == 19) {
    label = 0;

    $91=(($s_1<<24)>>24);
    if ((((($s_1<<24)>>24))|0)==((0)|0)|(((($s_1<<24)>>24))|0)==((5)|0)) {
     $92=$91;
     label = 20;
    } else {
     $flag_5=$flag_434;
    }
   }
   do {
    if ((label|0) == 20) {
     label = 0;

     $93=((HEAP32[((14960)>>2)])|0);
     $94=(($93+((($73)*(104))&-1))|0);
     $95=((10608+($92<<2))|0);
     $96=((HEAP32[(($95)>>2)])|0);
     $97=((HEAP32[((15576)>>2)])|0);
     $98=((_clocktime(17744,$97))|0);
     $99=((_sprintf(((14488)|0),((816)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,HEAP32[((tempVarArgs)>>2)]=$94,HEAP32[(((tempVarArgs)+(8))>>2)]=$96,HEAP32[(((tempVarArgs)+(16))>>2)]=$98,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
     $100=((HEAP8[(14568)])|0);
     $101=(($100<<24)>>24)==0;
     if ($101) {
      $flag_5=4;
      break;
     }
     _writeline(14488);
     $flag_5=4;
    }
   } while(0);

   $104=((($i_233)+(1))|0);
   $105=((HEAP32[((14368)>>2)])|0);
   $106=($104|0)>($105|0);
   if ($106) {
    $flag_4_lcssa=$flag_5;
    break;
   } else {
    $i_233=$104;$flag_434=$flag_5;
   }
  }
 }

 $107=((HEAP32[((14648)>>2)])|0);
 $108=($107|0)<($iter|0);
 $109=(+(HEAPF64[((11240)>>3)]));
 $110=$109<$relerr;
 $or_cond30=$108&$110;
 do {
  if ($or_cond30) {
   $112=((HEAP32[((15576)>>2)])|0);
   $113=((_clocktime(17744,$112))|0);
   $114=((_sprintf(((14488)|0),((760)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$113,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
   $115=((HEAP32[((17512)>>2)])|0);
   $116=($115|0)==-1;
   if ($116) {
    $strlen=((_strlen(((14488)|0)))|0);
    $endptr=((14488+$strlen)|0);
    (_memcpy((($endptr)|0), ((704)|0), 19)|0);
   }
   $119=((HEAP8[(14568)])|0);
   $120=(($119<<24)>>24)==0;
   if ($120) {
    $flag_632=1;$125=1;
    break;
   }
   _writeline(14488);
   $flag_632=1;$125=1;
  } else {
   $123=(($flag_4_lcssa<<24)>>24);
   $124=(($flag_4_lcssa<<24)>>24)>0;
   if ($124) {
    $flag_632=$flag_4_lcssa;$125=$123;
    break;
   } else {
    $128=$123;
   }

   STACKTOP=sp;return (($128)|0);
  }
 } while(0);


 $126=((_disconnected())|0);
 HEAP8[(12008)]=$flag_632;
 $128=$125;

 STACKTOP=sp;return (($128)|0);
}


function _disconnected(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$scevgep=0,$21=0;
 var $smax=0,$_lcssa=0,$22=0,$23=0,$i_051=0,$25=0,$26=0,$27=0,$28=0,$i_146=0,$mcount_045=0,$29=0,$30=0,$31=.0,$32=0,$34=0,$35=0,$36=0,$mcount_1=0,$38=0;
 var $39=0,$40=0,$mcount_0_lcssa=0,$41=0,$42=0,$i_243=0,$count_042=0,$j_041=0,$43=0,$44=0,$45=0,$47=0,$48=0,$49=.0,$50=0,$52=0,$53=0,$54=0,$55=0,$or_cond=0;
 var $57=0,$58=0,$59=0,$60=0,$61=0,$j_1=0,$count_1=0,$63=0,$64=0,$65=0,$66=0,$67=0,$68=0,$or_cond40=0,$70=0,$72=0,$73=0,$74=0,$75=0,$count_0_lcssa55=0;
 var $77=0,$78=0,$_0=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=((HEAP32[((14416)>>2)])|0);
 $2=((($1)+(1))|0);
 $3=((_calloc($2,4))|0);
 $4=$3;
 $5=((HEAP32[((14416)>>2)])|0);
 $6=((($5)+(1))|0);
 $7=((_calloc($6,1))|0);
 $8=($3|0)==0;
 $9=($8?101:0);
 if ($8) {
  $14=$9;
 } else {
  $11=($7|0)==0;
  $12=($11?101:0);
  $14=$12;
 }

 $15=($14|0)==0;
 if (!($15)) {
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
 $16=((HEAP32[((14352)>>2)])|0);
 $17=($16|0)<1;
 if ($17) {
  $_lcssa=$16;
 } else {
  $18=((HEAP32[((14432)>>2)])|0);
  $19=((HEAP32[((14352)>>2)])|0);
  $20=((($18)+(1))|0);
  $scevgep=(($7+$20)|0);
  $21=($19|0)>1;
  $smax=($21?$19:1);
  _memset((((($scevgep)|0))|0), ((((1)|0))|0), (((($smax)|0))|0))|0;
  $i_051=1;
  while(1) {

   $25=((($18)+($i_051))|0);
   $26=(($4+($i_051<<2))|0);
   HEAP32[(($26)>>2)]=$25;
   $27=((($i_051)+(1))|0);
   $28=($27|0)>($19|0);
   if ($28) {
    $_lcssa=$19;
    break;
   } else {
    $i_051=$27;
   }
  }
 }

 $22=((HEAP32[((14432)>>2)])|0);
 $23=($22|0)<1;
 if ($23) {
  $mcount_0_lcssa=$_lcssa;
 } else {
  $mcount_045=$_lcssa;$i_146=1;
  while(1) {


   $29=((HEAP32[((17632)>>2)])|0);
   $30=(($29+($i_146<<3))|0);
   $31=(+(HEAPF64[(($30)>>3)]));
   $32=$31<(0.0);
   if ($32) {
    $34=((($mcount_045)+(1))|0);
    $35=(($4+($34<<2))|0);
    HEAP32[(($35)>>2)]=$i_146;
    $36=(($7+$i_146)|0);
    HEAP8[($36)]=1;
    $mcount_1=$34;
   } else {
    $mcount_1=$mcount_045;
   }

   $38=((($i_146)+(1))|0);
   $39=((HEAP32[((14432)>>2)])|0);
   $40=($38|0)>($39|0);
   if ($40) {
    $mcount_0_lcssa=$mcount_1;
    break;
   } else {
    $mcount_045=$mcount_1;$i_146=$38;
   }
  }
 }

 _marknodes($mcount_0_lcssa,$4,$7);
 $41=((HEAP32[((14432)>>2)])|0);
 $42=($41|0)<1;
 do {
  if ($42) {
   $count_0_lcssa55=0;
  } else {
   $j_041=0;$count_042=0;$i_243=1;
   while(1) {



    $43=(($7+$i_243)|0);
    $44=((HEAP8[($43)])|0);
    $45=(($44<<24)>>24)==0;
    do {
     if ($45) {
      $47=((HEAP32[((17632)>>2)])|0);
      $48=(($47+($i_243<<3))|0);
      $49=(+(HEAPF64[(($48)>>3)]));
      $50=$49!=(0.0);
      if (!($50)) {
       $count_1=$count_042;$j_1=$j_041;
       break;
      }
      $52=((($count_042)+(1))|0);
      $53=($52|0)>10;
      $54=((HEAP8[(14568)])|0);
      $55=(($54<<24)>>24)==0;
      $or_cond=$53|$55;
      if ($or_cond) {
       $count_1=$52;$j_1=$i_243;
       break;
      }
      $57=((HEAP32[((14408)>>2)])|0);
      $58=(($57+((($i_243)*(72))&-1))|0);
      $59=((HEAP32[((15576)>>2)])|0);
      $60=((_clocktime(17744,$59))|0);
      $61=((_sprintf(((14488)|0),((544)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$58,HEAP32[(((tempVarArgs)+(8))>>2)]=$60,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
      _writeline(14488);
      $count_1=$52;$j_1=$i_243;
     } else {
      $count_1=$count_042;$j_1=$j_041;
     }
    } while(0);


    $63=((($i_243)+(1))|0);
    $64=((HEAP32[((14432)>>2)])|0);
    $65=($63|0)>($64|0);
    if ($65) {
     break;
    } else {
     $j_041=$j_1;$count_042=$count_1;$i_243=$63;
    }
   }
   $66=($count_1|0)<1;
   $67=((HEAP8[(14568)])|0);
   $68=(($67<<24)>>24)==0;
   $or_cond40=$66|$68;
   if ($or_cond40) {
    $count_0_lcssa55=$count_1;
    break;
   }
   $70=($count_1|0)>10;
   if ($70) {
    $72=((($count_1)-(10))|0);
    $73=((HEAP32[((15576)>>2)])|0);
    $74=((_clocktime(17744,$73))|0);
    $75=((_sprintf(((14488)|0),((464)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$72,HEAP32[(((tempVarArgs)+(8))>>2)]=$74,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
    _writeline(14488);
   }
   _getclosedlink($j_1,$7);
   $count_0_lcssa55=$count_1;
  }
 } while(0);

 _free($4);
 _free($7);
 $_0=$count_0_lcssa55;

 STACKTOP=sp;return (($_0)|0);
}


function _writehyderr($errnode){
 $errnode=($errnode)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$10=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=((HEAP32[((15576)>>2)])|0);
 $2=((_clocktime(17744,$1))|0);
 $3=((HEAP32[((14408)>>2)])|0);
 $4=(($3+((($errnode)*(72))&-1))|0);
 $5=((_sprintf(((14488)|0),((648)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,HEAP32[((tempVarArgs)>>2)]=$2,HEAP32[(((tempVarArgs)+(8))>>2)]=$4,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 $6=((HEAP8[(14568)])|0);
 $7=(($6<<24)>>24)==0;
 if ($7) {
  _writehydstat(0,0.0);
  $10=((_disconnected())|0);
  STACKTOP=sp;return;
 }
 _writeline(14488);
 _writehydstat(0,0.0);
 $10=((_disconnected())|0);
 STACKTOP=sp;return;
}


function _marknodes($m,$nodelist,$marked){
 $m=($m)|0;
 $nodelist=($nodelist)|0;
 $marked=($marked)|0;
 var $1=0,$n_022=0,$_021=0,$2=0,$3=0,$4=0,$5=0,$alink_017=0,$6=0,$alink_020=0,$_118=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$15=0,$16=0;
 var $17=0,$18=0,$20=0,$21=0,$22=0,$23=0,$25=0,$26=0,$27=0,$28=0,$30=0,$31=0,$_2=0,$33=0,$alink_0=0,$34=0,$_1_lcssa=0,$35=0,$36=0,label=0;

 $1=($m|0)<1;
 if ($1) {
  return;
 } else {
  $_021=$m;$n_022=1;
 }
 while(1) {


  $2=(($nodelist+($n_022<<2))|0);
  $3=((HEAP32[(($2)>>2)])|0);
  $4=((HEAP32[((17776)>>2)])|0);
  $5=(($4+($3<<2))|0);
  $alink_017=((HEAP32[(($5)>>2)])|0);
  $6=($alink_017|0)==0;
  if ($6) {
   $_1_lcssa=$_021;
  } else {
   $_118=$_021;$alink_020=$alink_017;
   while(1) {


    $7=(($alink_020+4)|0);
    $8=((HEAP32[(($7)>>2)])|0);
    $9=(($alink_020)|0);
    $10=((HEAP32[(($9)>>2)])|0);
    $11=(($marked+$10)|0);
    $12=((HEAP8[($11)])|0);
    $13=(($12<<24)>>24)==0;
    do {
     if ($13) {
      $15=((HEAP32[((14960)>>2)])|0);
      $16=(($15+((($8)*(104))&-1)+96)|0);
      $17=((HEAP8[($16)])|0);
      $18=(($17<<24)>>24);
      if (((($18|0))|0)==((0)|0)|((($18|0))|0)==((3)|0)|((($18|0))|0)==((4)|0)) {
       $20=((HEAP32[((14960)>>2)])|0);
       $21=(($20+((($8)*(104))&-1)+32)|0);
       $22=((HEAP32[(($21)>>2)])|0);
       $23=($10|0)==($22|0);
       if ($23) {
        $_2=$_118;
        break;
       }
      }
      $25=((HEAP32[((13232)>>2)])|0);
      $26=(($25+$8)|0);
      $27=((HEAP8[($26)])|0);
      $28=(($27<<24)>>24)>2;
      if (!($28)) {
       $_2=$_118;
       break;
      }
      HEAP8[($11)]=1;
      $30=((($_118)+(1))|0);
      $31=(($nodelist+($30<<2))|0);
      HEAP32[(($31)>>2)]=$10;
      $_2=$30;
     } else {
      $_2=$_118;
     }
    } while(0);

    $33=(($alink_020+8)|0);
    $alink_0=((HEAP32[(($33)>>2)])|0);
    $34=($alink_0|0)==0;
    if ($34) {
     $_1_lcssa=$_2;
     break;
    } else {
     $_118=$_2;$alink_020=$alink_0;
    }
   }
  }

  $35=((($n_022)+(1))|0);
  $36=($35|0)>($_1_lcssa|0);
  if ($36) {
   break;
  } else {
   $_021=$_1_lcssa;$n_022=$35;
  }
 }
 return;
}


function _getclosedlink($i,$marked){
 $i=($i)|0;
 $marked=($marked)|0;
 var $1=0,$2=0,$3=0,$alink_012=0,$4=0,$alink_013=0,$5=0,$6=0,$7=0,$8=0,$10=0,$11=0,$12=0,$13=0,$14=0,$17=0,$alink_0=0,$18=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;
 $1=(($marked+$i)|0);
 HEAP8[($1)]=2;
 $2=((HEAP32[((17776)>>2)])|0);
 $3=(($2+($i<<2))|0);
 $alink_012=((HEAP32[(($3)>>2)])|0);
 $4=($alink_012|0)==0;
 if ($4) {
  STACKTOP=sp;return;
 } else {
  $alink_013=$alink_012;
 }
 while(1) {

  $5=(($alink_013)|0);
  $6=((HEAP32[(($5)>>2)])|0);
  $7=(($marked+$6)|0);
  $8=((HEAP8[($7)])|0);
  if ((((($8<<24)>>24))|0)==((1)|0)) {
   break;
  } else if (!((((($8<<24)>>24))|0)==((2)|0))) {
   _getclosedlink($6,$marked);
  }
  $17=(($alink_013+8)|0);
  $alink_0=((HEAP32[(($17)>>2)])|0);
  $18=($alink_0|0)==0;
  if ($18) {
   label = 6;
   break;
  } else {
   $alink_013=$alink_0;
  }
 }
 if ((label|0) == 6) {
  STACKTOP=sp;return;
 }
 $10=(($alink_013+4)|0);
 $11=((HEAP32[(($10)>>2)])|0);
 $12=((HEAP32[((14960)>>2)])|0);
 $13=(($12+((($11)*(104))&-1))|0);
 $14=((_sprintf(((14488)|0),((400)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$13,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline(14488);
 STACKTOP=sp;return;
}


function _writetime($fmt){
 $fmt=($fmt)|0;
 var $timer=0,$1=0,$2=0,$3=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $timer=((sp)|0);
 $1=((_time((($timer)|0)))|0);
 $2=((_ctime((($timer)|0)))|0);
 $3=((_sprintf(((14488)|0),(($fmt)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,HEAP32[((tempVarArgs)>>2)]=$2,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 _writeline(14488);
 STACKTOP=sp;return;
}


function _initrules(){
 var label=0;

 HEAP32[((13248)>>2)]=6;
 HEAP32[((13256)>>2)]=0;
 return;
}


function _addrule($tok){
 $tok=($tok)|0;
 var $1=0,$2=0,$4=0,$5=0,label=0;

 $1=((_match($tok,1544))|0);
 $2=($1|0)==0;
 if ($2) {
  return;
 }
 $4=((HEAP32[((14592)>>2)])|0);
 $5=((($4)+(1))|0);
 HEAP32[((14592)>>2)]=$5;
 return;
}


function _allocrules(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$_=0,label=0;

 $1=((HEAP32[((14592)>>2)])|0);
 $2=((($1)+(1))|0);
 $3=((_calloc($2,56))|0);
 $4=$3;
 HEAP32[((13256)>>2)]=$4;
 $5=($3|0)==0;
 $_=($5?101:0);
 return (($_)|0);
}


function _freerules(){
 var $1=0,$2=0,label=0;

 _clearrules();
 $1=((HEAP32[((13256)>>2)])|0);
 _free($1);
 return;
}


function _clearrules(){
 var $1=0,$2=0,$i_022=0,$3=0,$4=0,$5=0,$6=0,$p_013=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$a_014=0,$15=0,$16=0,$17=0;
 var $18=0,$19=0,$20=0,$21=0,$22=0,$a_118=0,$23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,label=0;

 $1=((HEAP32[((14360)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $i_022=1;
 }
 while(1) {

  $3=((HEAP32[((13256)>>2)])|0);
  $4=(($3+((($i_022)*(56))&-1)+40)|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=($5|0)==0;
  if (!($6)) {
   $p_013=$5;
   while(1) {

    $7=(($p_013+32)|0);
    $8=((HEAP32[(($7)>>2)])|0);
    _free($p_013);
    $10=($8|0)==0;
    if ($10) {
     break;
    } else {
     $p_013=$8;
    }
   }
  }
  $11=((HEAP32[((13256)>>2)])|0);
  $12=(($11+((($i_022)*(56))&-1)+44)|0);
  $13=((HEAP32[(($12)>>2)])|0);
  $14=($13|0)==0;
  if (!($14)) {
   $a_014=$13;
   while(1) {

    $15=(($a_014+16)|0);
    $16=((HEAP32[(($15)>>2)])|0);
    _free($a_014);
    $18=($16|0)==0;
    if ($18) {
     break;
    } else {
     $a_014=$16;
    }
   }
  }
  $19=((HEAP32[((13256)>>2)])|0);
  $20=(($19+((($i_022)*(56))&-1)+48)|0);
  $21=((HEAP32[(($20)>>2)])|0);
  $22=($21|0)==0;
  if (!($22)) {
   $a_118=$21;
   while(1) {

    $23=(($a_118+16)|0);
    $24=((HEAP32[(($23)>>2)])|0);
    _free($a_118);
    $26=($24|0)==0;
    if ($26) {
     break;
    } else {
     $a_118=$24;
    }
   }
  }
  $27=((($i_022)+(1))|0);
  $28=((HEAP32[((14360)>>2)])|0);
  $29=($27|0)>($28|0);
  if ($29) {
   break;
  } else {
   $i_022=$27;
  }
 }
 return;
}


function _checkrules($dt){
 $dt=($dt)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$i_07=0,$6=0,$7=0,$8=0,$10=0,$11=0,$13=0,$14=0,$15=0,$18=0,$19=0,$20=0,$_pr=0,$21=0,$23=0;
 var $r_0=0,label=0;

 $1=((HEAP32[((15576)>>2)])|0);
 $2=(((1)-($dt))|0);
 $3=((($2)+($1))|0);
 HEAP32[((13168)>>2)]=$3;
 HEAP32[((17784)>>2)]=0;
 $4=((HEAP32[((14360)>>2)])|0);
 $5=($4|0)<1;
 if ($5) {
  $r_0=0;

  _clearactlist();
  return (($r_0)|0);
 } else {
  $i_07=1;
 }
 while(1) {

  $6=((_evalpremises($i_07))|0);
  $7=($6|0)==1;
  $8=((HEAP32[((13256)>>2)])|0);
  do {
   if ($7) {
    $10=(($8+((($i_07)*(56))&-1)+44)|0);
    $11=((HEAP32[(($10)>>2)])|0);
    _updateactlist($i_07,$11);
   } else {
    $13=(($8+((($i_07)*(56))&-1)+48)|0);
    $14=((HEAP32[(($13)>>2)])|0);
    $15=($14|0)==0;
    if ($15) {
     break;
    }
    _updateactlist($i_07,$14);
   }
  } while(0);
  $18=((($i_07)+(1))|0);
  $19=((HEAP32[((14360)>>2)])|0);
  $20=($18|0)>($19|0);
  if ($20) {
   break;
  } else {
   $i_07=$18;
  }
 }
 $_pr=((HEAP32[((17784)>>2)])|0);
 $21=($_pr|0)==0;
 if ($21) {
  $r_0=0;

  _clearactlist();
  return (($r_0)|0);
 }
 $23=((_takeactions())|0);
 $r_0=$23;

 _clearactlist();
 return (($r_0)|0);
}


function _evalpremises($i){
 $i=($i)|0;
 var $1=0,$2=0,$p_07=0,$3=0,$p_09=0,$result_08=0,$4=0,$5=0,$6=0,$7=0,$10=0,$13=0,$result_1=0,$15=0,$p_0=0,$16=0,$_0=0,label=0;

 $1=((HEAP32[((13256)>>2)])|0);
 $2=(($1+((($i)*(56))&-1)+40)|0);
 $p_07=((HEAP32[(($2)>>2)])|0);
 $3=($p_07|0)==0;
 if ($3) {
  $_0=1;

  return (($_0)|0);
 } else {
  $result_08=1;$p_09=$p_07;
 }
 L3: while(1) {


  $4=(($p_09)|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=($5|0)==3;
  $7=($result_08|0)==0;
  do {
   if ($6) {
    if (!($7)) {
     $result_1=$result_08;
     break;
    }
    $10=((_checkpremise($p_09))|0);
    $result_1=$10;
   } else {
    if ($7) {
     $_0=0;
     label = 8;
     break L3;
    }
    $13=((_checkpremise($p_09))|0);
    $result_1=$13;
   }
  } while(0);

  $15=(($p_09+32)|0);
  $p_0=((HEAP32[(($15)>>2)])|0);
  $16=($p_0|0)==0;
  if ($16) {
   $_0=$result_1;
   label = 8;
   break;
  } else {
   $result_08=$result_1;$p_09=$p_0;
  }
 }
 if ((label|0) == 8) {

  return (($_0)|0);
 }
  return 0;
}


function _updateactlist($i,$actions){
 $i=($i)|0;
 $actions=($actions)|0;
 var $1=0,$a_010=0,$2=0,$3=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$16=0,$17=0,$18=0,label=0;

 $1=($actions|0)==0;
 if ($1) {
  return;
 } else {
  $a_010=$actions;
 }
 while(1) {

  $2=((_checkaction($i,$a_010))|0);
  $3=($2|0)==0;
  do {
   if ($3) {
    $5=((_malloc(12))|0);
    $6=($5|0)==0;
    if ($6) {
     break;
    }
    $8=$5;
    $9=(($5+4)|0);
    $10=$9;
    HEAP32[(($10)>>2)]=$a_010;
    $11=$5;
    HEAP32[(($11)>>2)]=$i;
    $12=((HEAP32[((17784)>>2)])|0);
    $13=(($5+8)|0);
    $14=$13;
    HEAP32[(($14)>>2)]=$12;
    HEAP32[((17784)>>2)]=$8;
   }
  } while(0);
  $16=(($a_010+16)|0);
  $17=((HEAP32[(($16)>>2)])|0);
  $18=($17|0)==0;
  if ($18) {
   break;
  } else {
   $a_010=$17;
  }
 }
 return;
}


function _takeactions(){
 var $item_030=0,$1=0,$item_033=0,$n_031=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=.0,$12=0,$13=.0,$14=0,$15=0,$16=0,$17=0;
 var $or_cond=0,$19=0,$20=0,$or_cond27=0,$22=0,$24=0,$25=0,$26=0,$27=0,$29=.0,$30=.0,$32=.0,$33=.0,$x_0=.0,$35=.0,$36=0,$38=.0,$40=.0,$41=0,$42=0;
 var $43=0,$44=0,$45=0,$47=0,$48=0,$49=0,$51=0,$52=0,$53=0,$54=0,$n_1=0,$56=0,$item_0=0,$57=0,$n_0_lcssa=0,label=0;

 $item_030=((HEAP32[((17784)>>2)])|0);
 $1=($item_030|0)==0;
 if ($1) {
  $n_0_lcssa=0;

  return (($n_0_lcssa)|0);
 } else {
  $n_031=0;$item_033=$item_030;
 }
 while(1) {


  $2=(($item_033+4)|0);
  $3=((HEAP32[(($2)>>2)])|0);
  $4=(($3)|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=((HEAP32[((13232)>>2)])|0);
  $7=(($6+$5)|0);
  $8=((HEAP8[($7)])|0);
  $9=((HEAP32[((15000)>>2)])|0);
  $10=(($9+($5<<3))|0);
  $11=(+(HEAPF64[(($10)>>3)]));
  $12=(($3+8)|0);
  $13=(+(HEAPF64[(($12)>>3)]));
  $14=(($3+4)|0);
  $15=((HEAP32[(($14)>>2)])|0);
  $16=($15|0)==1;
  $17=(($8<<24)>>24)<3;
  $or_cond=$16&$17;
  do {
   if ($or_cond) {
    _setlinkstatus($5,1,$7,$10);
    label = 14;
   } else {
    $19=($15|0)==2;
    $20=(($8<<24)>>24)>2;
    $or_cond27=$19&$20;
    if ($or_cond27) {
     _setlinkstatus($5,0,$7,$10);
     label = 14;
     break;
    }
    $22=$13!=(-10000000000.0);
    if (!($22)) {
     $n_1=$n_031;
     break;
    }
    $24=((HEAP32[((14960)>>2)])|0);
    $25=(($24+((($5)*(104))&-1)+96)|0);
    $26=((HEAP8[($25)])|0);
    $27=(($26<<24)>>24);
    if (((($27|0))|0)==((6)|0)) {
     $32=(+(HEAPF64[((12096)>>3)]));
     $33=($13)/($32);
     $x_0=$33;
    } else if (((($27|0))|0)==((3)|0)|((($27|0))|0)==((4)|0)|((($27|0))|0)==((5)|0)) {
     $29=(+(HEAPF64[((12064)>>3)]));
     $30=($13)/($29);
     $x_0=$30;
    } else {
     $x_0=$13;
    }

    $35=($x_0)-($11);
    $36=$35<(0.0);
    if ($36) {
     $38=((-.0))-($35);
     $40=$38;
    } else {
     $40=$35;
    }

    $41=$40>(0.001);
    if (!($41)) {
     $n_1=$n_031;
     break;
    }
    $42=((HEAP32[((13232)>>2)])|0);
    $43=(($42+$5)|0);
    $44=((HEAP32[((15000)>>2)])|0);
    $45=(($44+($5<<3))|0);
    _setlinksetting($5,$x_0,$43,$45);
    label = 14;
   }
  } while(0);
  do {
   if ((label|0) == 14) {
    label = 0;
    $47=((($n_031)+(1))|0);
    $48=((HEAP8[(13192)])|0);
    $49=(($48<<24)>>24)==0;
    if ($49) {
     $n_1=$47;
     break;
    }
    $51=(($item_033)|0);
    $52=((HEAP32[(($51)>>2)])|0);
    $53=((HEAP32[((13256)>>2)])|0);
    $54=(($53+((($52)*(56))&-1))|0);
    _writeruleaction($5,$54);
    $n_1=$47;
   }
  } while(0);

  $56=(($item_033+8)|0);
  $item_0=((HEAP32[(($56)>>2)])|0);
  $57=($item_0|0)==0;
  if ($57) {
   $n_0_lcssa=$n_1;
   break;
  } else {
   $n_031=$n_1;$item_033=$item_0;
  }
 }

 return (($n_0_lcssa)|0);
}


function _clearactlist(){
 var $1=0,$2=0,$a_03=0,$3=0,$4=0,$5=0,$6=0,label=0;

 $1=((HEAP32[((17784)>>2)])|0);
 $2=($1|0)==0;
 if ($2) {
  return;
 } else {
  $a_03=$1;
 }
 while(1) {

  $3=(($a_03+8)|0);
  $4=((HEAP32[(($3)>>2)])|0);
  _free($a_03);
  $6=($4|0)==0;
  if ($6) {
   break;
  } else {
   $a_03=$4;
  }
 }
 return;
}


function _ruledata(){
 var $1=0,$2=0,$4=0,$5=0,$6=0,$7=0,$9=0,$10=0,$12=0,$14=0,$15=0,$17=0,$_off6=0,$19=0,$21=0,$23=0,$24=0,$26=0,$28=0,$29=0;
 var $31=0,$33=0,$34=0,$36=0,$38=0,$_off=0,$39=0,$41=0,$err_0=0,$43=0,$err_07=0,$_0=0,label=0;

 $1=((HEAP32[((13248)>>2)])|0);
 $2=($1|0)==7;
 if ($2) {
  $_0=0;

  return (($_0)|0);
 }
 $4=((HEAP32[((12232)>>2)])|0);
 $5=((_findmatch($4,10784))|0);
 L4: do {
  switch (($5|0)) {
  case 6: {
   $38=((HEAP32[((13248)>>2)])|0);
   $_off=((($38)-(4))|0);
   $39=($_off>>>0)>((1)>>>0);
   if ($39) {
    $err_07=221;
    break L4;
   }
   HEAP32[((13248)>>2)]=6;
   $41=((_newpriority())|0);
   $err_0=$41;
   label = 18;
   break;
  }
  case 1: {
   $9=((HEAP32[((13248)>>2)])|0);
   $10=($9|0)==0;
   if (!($10)) {
    $err_07=221;
    break L4;
   }
   HEAP32[((13248)>>2)]=1;
   $12=((_newpremise(2))|0);
   $err_0=$12;
   label = 18;
   break;
  }
  case 3: {
   $23=((HEAP32[((13248)>>2)])|0);
   $24=($23|0)==1;
   if (!($24)) {
    $err_07=221;
    break L4;
   }
   $26=((_newpremise(3))|0);
   $err_0=$26;
   label = 18;
   break;
  }
  case 4: {
   $28=((HEAP32[((13248)>>2)])|0);
   $29=($28|0)==1;
   if (!($29)) {
    $err_07=221;
    break L4;
   }
   HEAP32[((13248)>>2)]=4;
   $31=((_newaction())|0);
   $err_0=$31;
   label = 18;
   break;
  }
  case 5: {
   $33=((HEAP32[((13248)>>2)])|0);
   $34=($33|0)==4;
   if (!($34)) {
    $err_07=221;
    break L4;
   }
   HEAP32[((13248)>>2)]=5;
   $36=((_newaction())|0);
   $err_0=$36;
   label = 18;
   break;
  }
  case 2: {
   $14=((HEAP32[((13248)>>2)])|0);
   $15=($14|0)==1;
   if ($15) {
    $17=((_newpremise(2))|0);
    $err_0=$17;
    label = 18;
    break L4;
   }
   $_off6=((($14)-(4))|0);
   $19=($_off6>>>0)<((2)>>>0);
   if (!($19)) {
    $err_07=221;
    break L4;
   }
   $21=((_newaction())|0);
   $err_0=$21;
   label = 18;
   break;
  }
  case 0: {
   $6=((HEAP32[((14360)>>2)])|0);
   $7=((($6)+(1))|0);
   HEAP32[((14360)>>2)]=$7;
   _newrule();
   HEAP32[((13248)>>2)]=0;
   $_0=0;

   return (($_0)|0);
  }
  default: {
   $err_07=201;
  }
  }
 } while(0);
 do {
  if ((label|0) == 18) {

   $43=($err_0|0)==0;
   if ($43) {
    $_0=0;
   } else {
    $err_07=$err_0;
    break;
   }

   return (($_0)|0);
  }
 } while(0);

 HEAP32[((13248)>>2)]=7;
 _ruleerrmsg($err_07);
 $_0=200;

 return (($_0)|0);
}


function _newrule(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,label=0;

 $1=((HEAP32[((14360)>>2)])|0);
 $2=((HEAP32[((13256)>>2)])|0);
 $3=(($2+((($1)*(56))&-1))|0);
 $4=((HEAP32[((12236)>>2)])|0);
 $5=((_strncpy((($3)|0),(($4)|0),((31)|0)))|0);
 $6=((HEAP32[((14360)>>2)])|0);
 $7=((HEAP32[((13256)>>2)])|0);
 $8=(($7+((($6)*(56))&-1)+40)|0);
 HEAP32[(($8)>>2)]=0;
 $9=((HEAP32[((14360)>>2)])|0);
 $10=((HEAP32[((13256)>>2)])|0);
 $11=(($10+((($9)*(56))&-1)+44)|0);
 HEAP32[(($11)>>2)]=0;
 $12=((HEAP32[((14360)>>2)])|0);
 $13=((HEAP32[((13256)>>2)])|0);
 $14=(($13+((($12)*(56))&-1)+48)|0);
 HEAP32[(($14)>>2)]=0;
 $15=((HEAP32[((14360)>>2)])|0);
 $16=((HEAP32[((13256)>>2)])|0);
 $17=(($16+((($15)*(56))&-1)+32)|0);
 HEAPF64[(($17)>>3)]=0.0;
 HEAP32[((13936)>>2)]=0;
 return;
}


function _newpremise($logop){
 $logop=($logop)|0;
 var $x=0,$1=0,$_off42=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$11=0,$12=0,$13=0,$16=0,$17=0,$18=0,$21=0,$22=0,$24=0,$25=0,$26=0;
 var $_off=0,$switch=0,$i_0=0,$j_0=0,$v_0=0,$29=0,$_=0,$30=0,$31=0,$32=0,$33=0,$r_0=0,$v_0_off=0,$40=0,$41=0,$43=0,$44=0,$46=0,$47=.0,$49=.0;
 var $storemerge_in=.0,$storemerge=.0,$51=0,$53=0,$54=0,$55=0,$56=0,$57=0,$59=0,$60=0,$61=0,$62=0,$63=0,$64=0,$v_0_off43=0,$66=0,$68=.0,$69=.0,$s_0=0,$71=0;
 var $72=0,$73=0,$75=0,$76=0,$77=0,$78=0,$79=0,$80=0,$81=0,$82=0,$83=0,$84=0,$85=0,$86=.0,$87=0,$88=0,$89=0,$90=0,$91=0,$92=0;
 var $94=0,$95=0,$96=0,$98=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $x=((sp)|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $_off42=((($1)-(5))|0);
 $2=($_off42>>>0)>((1)>>>0);
 if ($2) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $4=((HEAP32[((12236)>>2)])|0);
 $5=((_findmatch($4,11056))|0);
 $6=($5|0)==8;
 L4: do {
  if ($6) {
   $8=((HEAP32[((12240)>>2)])|0);
   $9=((_findmatch($8,10488))|0);
   if (((($9|0))|0)==((10)|0)|((($9|0))|0)==((9)|0)|((($9|0))|0)==((0)|0)) {
    $v_0=$9;$j_0=0;$i_0=8;
    break;
   } else {
    $_0=201;
   }

   STACKTOP=sp;return (($_0)|0);
  } else {
   $11=((HEAP32[((12244)>>2)])|0);
   $12=((_findmatch($11,10488))|0);
   $13=($12|0)<0;
   if ($13) {
    $_0=201;

    STACKTOP=sp;return (($_0)|0);
   }
   switch (($5|0)) {
   case 7:case 3:case 4:case 5: {
    $24=((HEAP32[((12240)>>2)])|0);
    $25=((_findlink($24))|0);
    $26=($25|0)==0;
    if ($26) {
     $_0=204;

     STACKTOP=sp;return (($_0)|0);
    }
    $_off=((($12)-(5))|0);
    $switch=($_off>>>0)<((3)>>>0);
    if ($switch) {
     $v_0=$12;$j_0=$25;$i_0=7;
     break L4;
    } else {
     $_0=201;
    }

    STACKTOP=sp;return (($_0)|0);
   }
   case 6:case 0:case 1:case 2: {
    $16=((HEAP32[((12240)>>2)])|0);
    $17=((_findnode($16))|0);
    $18=($17|0)==0;
    if ($18) {
     $_0=203;

     STACKTOP=sp;return (($_0)|0);
    }
    switch (($12|0)) {
    case 0:case 1:case 2:case 3:case 4: {
     $v_0=$12;$j_0=$17;$i_0=6;
     break L4;
    }
    case 11:case 12: {
     break;
    }
    default: {
     $_0=201;

     STACKTOP=sp;return (($_0)|0);
    }
    }
    $21=((HEAP32[((14432)>>2)])|0);
    $22=($17|0)>($21|0);
    if ($22) {
     $v_0=$12;$j_0=$17;$i_0=6;
     break L4;
    } else {
     $_0=201;
    }

    STACKTOP=sp;return (($_0)|0);
   }
   default: {
    $_0=201;

    STACKTOP=sp;return (($_0)|0);
   }
   }
  }
 } while(0);



 $29=($i_0|0)==8;
 $_=($29?3:4);
 $30=((12232+($_<<2))|0);
 $31=((HEAP32[(($30)>>2)])|0);
 $32=((_findmatch($31,11008))|0);
 $33=($32|0)<0;
 if ($33) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 if (((($32|0))|0)==((6)|0)) {
  $r_0=0;
 } else if (((($32|0))|0)==((9)|0)) {
  $r_0=5;
 } else if (((($32|0))|0)==((8)|0)) {
  $r_0=4;
 } else if (((($32|0))|0)==((7)|0)) {
  $r_0=1;
 } else {
  $r_0=$32;
 }

 HEAPF64[(($x)>>3)]=-10000000000.0;
 $v_0_off=((($v_0)-(9))|0);
 $40=($v_0_off>>>0)<((2)>>>0);
 $41=((HEAP32[((14336)>>2)])|0);
 do {
  if ($40) {
   $43=($41|0)==6;
   $44=((HEAP32[((12248)>>2)])|0);
   if ($43) {
    $46=((HEAP32[((12252)>>2)])|0);
    $47=(+(_hour($44,$46)));
    $storemerge_in=$47;
   } else {
    $49=(+(_hour($44,11480)));
    $storemerge_in=$49;
   }

   $storemerge=($storemerge_in)*((3600.0));
   HEAPF64[(($x)>>3)]=$storemerge;
   $51=$storemerge<(0.0);
   if ($51) {
    $_0=202;
   } else {
    $s_0=0;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  } else {
   $53=((($41)-(1))|0);
   $54=((12232+($53<<2))|0);
   $55=((HEAP32[(($54)>>2)])|0);
   $56=((_findmatch($55,10544))|0);
   $57=($56|0)>0;
   if ($57) {
    $s_0=$56;
    break;
   }
   $59=((HEAP32[((14336)>>2)])|0);
   $60=((($59)-(1))|0);
   $61=((12232+($60<<2))|0);
   $62=((HEAP32[(($61)>>2)])|0);
   $63=((_getfloat($62,$x))|0);
   $64=($63|0)==0;
   if ($64) {
    $_0=202;

    STACKTOP=sp;return (($_0)|0);
   }
   $v_0_off43=((($v_0)-(11))|0);
   $66=($v_0_off43>>>0)<((2)>>>0);
   if (!($66)) {
    $s_0=0;
    break;
   }
   $68=(+(HEAPF64[(($x)>>3)]));
   $69=($68)*((3600.0));
   HEAPF64[(($x)>>3)]=$69;
   $s_0=0;
  }
 } while(0);

 $71=((_malloc(40))|0);
 $72=$71;
 $73=($71|0)==0;
 if ($73) {
  $_0=101;

  STACKTOP=sp;return (($_0)|0);
 }
 $75=(($71+4)|0);
 $76=$75;
 HEAP32[(($76)>>2)]=$i_0;
 $77=(($71+8)|0);
 $78=$77;
 HEAP32[(($78)>>2)]=$j_0;
 $79=(($71+12)|0);
 $80=$79;
 HEAP32[(($80)>>2)]=$v_0;
 $81=(($71+16)|0);
 $82=$81;
 HEAP32[(($82)>>2)]=$r_0;
 $83=$71;
 HEAP32[(($83)>>2)]=$logop;
 $84=(($71+20)|0);
 $85=$84;
 HEAP32[(($85)>>2)]=$s_0;
 $86=(+(HEAPF64[(($x)>>3)]));
 $87=(($71+24)|0);
 $88=$87;
 HEAPF64[(($88)>>3)]=$86;
 $89=(($71+32)|0);
 $90=$89;
 HEAP32[(($90)>>2)]=0;
 $91=((HEAP32[((13936)>>2)])|0);
 $92=($91|0)==0;
 if ($92) {
  $94=((HEAP32[((14360)>>2)])|0);
  $95=((HEAP32[((13256)>>2)])|0);
  $96=(($95+((($94)*(56))&-1)+40)|0);
  HEAP32[(($96)>>2)]=$72;
 } else {
  $98=(($91+32)|0);
  HEAP32[(($98)>>2)]=$72;
 }
 HEAP32[((13936)>>2)]=$72;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _newaction(){
 var $x=0,$1=0,$2=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$13=0,$14=0,$15=0,$17=0,$18=0,$19=0,$20=.0,$21=0,$or_cond=0,$_pr=.0;
 var $23=.0,$s_0=0,$24=0,$26=0,$27=0,$28=0,$29=0,$31=.0,$32=0,$34=0,$35=0,$36=0,$37=0,$39=0,$_=0,$s_2=0,$41=0,$42=0,$43=0,$45=0;
 var $46=0,$47=0,$48=.0,$49=0,$50=0,$51=0,$52=0,$53=0,$54=0,$56=0,$57=0,$58=0,$59=0,$60=0,$61=0,$62=0,$64=0,$65=0,$66=0,$67=0;
 var $68=0,$69=0,$70=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $x=((sp)|0);
 $1=((HEAP32[((14336)>>2)])|0);
 $2=($1|0)==6;
 if (!($2)) {
  $_0=201;

  STACKTOP=sp;return (($_0)|0);
 }
 $4=((HEAP32[((12240)>>2)])|0);
 $5=((_findlink($4))|0);
 $6=($5|0)==0;
 if ($6) {
  $_0=204;

  STACKTOP=sp;return (($_0)|0);
 }
 $8=((HEAP32[((14960)>>2)])|0);
 $9=(($8+((($5)*(104))&-1)+96)|0);
 $10=((HEAP8[($9)])|0);
 $11=(($10<<24)>>24)==0;
 if ($11) {
  $_0=207;

  STACKTOP=sp;return (($_0)|0);
 }
 HEAPF64[(($x)>>3)]=-10000000000.0;
 $13=((HEAP32[((12252)>>2)])|0);
 $14=((_findmatch($13,10544))|0);
 $15=($14|0)>0;
 do {
  if ($15) {
   $_pr=(+(HEAPF64[(($x)>>3)]));
   $s_0=$14;$23=$_pr;
  } else {
   $17=((HEAP32[((12252)>>2)])|0);
   $18=((_getfloat($17,$x))|0);
   $19=($18|0)==0;
   $20=(+(HEAPF64[(($x)>>3)]));
   $21=$20<(0.0);
   $or_cond=$19|$21;
   if ($or_cond) {
    $_0=202;
   } else {
    $s_0=-1;$23=$20;
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);


 $24=$23!=(-10000000000.0);
 do {
  if ($24) {
   $26=((HEAP32[((14960)>>2)])|0);
   $27=(($26+((($5)*(104))&-1)+96)|0);
   $28=((HEAP8[($27)])|0);
   $29=(($28<<24)>>24)==8;
   if ($29) {
    $_0=202;
   } else {
    break;
   }

   STACKTOP=sp;return (($_0)|0);
  }
 } while(0);
 $31=(+(HEAPF64[(($x)>>3)]));
 $32=$31!=(-10000000000.0);
 do {
  if ($32) {
   $34=((HEAP32[((14960)>>2)])|0);
   $35=(($34+((($5)*(104))&-1)+96)|0);
   $36=((HEAP8[($35)])|0);
   $37=(($36<<24)>>24)==1;
   if (!($37)) {
    $s_2=$s_0;
    break;
   }
   $39=$31==(0.0);
   $_=($39?2:1);
   HEAPF64[(($x)>>3)]=-10000000000.0;
   $s_2=$_;
  } else {
   $s_2=$s_0;
  }
 } while(0);

 $41=((_malloc(24))|0);
 $42=$41;
 $43=($41|0)==0;
 if ($43) {
  $_0=101;

  STACKTOP=sp;return (($_0)|0);
 }
 $45=$41;
 HEAP32[(($45)>>2)]=$5;
 $46=(($41+4)|0);
 $47=$46;
 HEAP32[(($47)>>2)]=$s_2;
 $48=(+(HEAPF64[(($x)>>3)]));
 $49=(($41+8)|0);
 $50=$49;
 HEAPF64[(($50)>>3)]=$48;
 $51=((HEAP32[((13248)>>2)])|0);
 $52=($51|0)==4;
 $53=((HEAP32[((14360)>>2)])|0);
 $54=((HEAP32[((13256)>>2)])|0);
 if ($52) {
  $56=(($54+((($53)*(56))&-1)+44)|0);
  $57=((HEAP32[(($56)>>2)])|0);
  $58=(($41+16)|0);
  $59=$58;
  HEAP32[(($59)>>2)]=$57;
  $60=((HEAP32[((14360)>>2)])|0);
  $61=((HEAP32[((13256)>>2)])|0);
  $62=(($61+((($60)*(56))&-1)+44)|0);
  HEAP32[(($62)>>2)]=$42;
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 } else {
  $64=(($54+((($53)*(56))&-1)+48)|0);
  $65=((HEAP32[(($64)>>2)])|0);
  $66=(($41+16)|0);
  $67=$66;
  HEAP32[(($67)>>2)]=$65;
  $68=((HEAP32[((14360)>>2)])|0);
  $69=((HEAP32[((13256)>>2)])|0);
  $70=(($69+((($68)*(56))&-1)+48)|0);
  HEAP32[(($70)>>2)]=$42;
  $_0=0;

  STACKTOP=sp;return (($_0)|0);
 }
}


function _newpriority(){
 var $x=0,$1=0,$2=0,$3=0,$5=.0,$6=0,$7=0,$8=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $x=((sp)|0);
 $1=((HEAP32[((12236)>>2)])|0);
 $2=((_getfloat($1,$x))|0);
 $3=($2|0)==0;
 if ($3) {
  $_0=202;

  STACKTOP=sp;return (($_0)|0);
 }
 $5=(+(HEAPF64[(($x)>>3)]));
 $6=((HEAP32[((14360)>>2)])|0);
 $7=((HEAP32[((13256)>>2)])|0);
 $8=(($7+((($6)*(56))&-1)+32)|0);
 HEAPF64[(($8)>>3)]=$5;
 $_0=0;

 STACKTOP=sp;return (($_0)|0);
}


function _ruleerrmsg($err){
 $err=($err)|0;
 var $label=0,$fmt=0,$2=0,$4=0,$6=0,$8=0,$10=0,$12=0,$14=0,$15=0,$16=0,$strlen5=0,$endptr6=0,$18=0,$19=0,$20=0,$21=0,$22=0,$25=0,$26=0;
 var $27=0,$strlen=0,$endptr=0,$28=0,$29=0,$30=0,$31=0,$32=0,$i_07=0,$strlen3=0,$endptr4=0,$33=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0,label=0;
 var tempVarArgs=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+344)|0;
 $label=((sp)|0);
 $fmt=(((sp)+(88))|0);
 switch (($err|0)) {
 case 201: {
  $2=(($fmt)|0);
  (_memcpy((($2)|0), ((2952)|0), 52)|0);
  break;
 }
 case 203: {
  $6=(($fmt)|0);
  (_memcpy((($6)|0), ((2736)|0), 54)|0);
  break;
 }
 case 204: {
  $8=(($fmt)|0);
  (_memcpy((($8)|0), ((2632)|0), 54)|0);
  break;
 }
 case 221: {
  $12=(($fmt)|0);
  (_memcpy((($12)|0), ((2472)|0), 57)|0);
  break;
 }
 case 207: {
  $10=(($fmt)|0);
  (_memcpy((($10)|0), ((2552)|0), 63)|0);
  break;
 }
 case 202: {
  $4=(($fmt)|0);
  (_memcpy((($4)|0), ((2832)|0), 61)|0);
  break;
 }
 default: {
  STACKTOP=sp;return;
 }
 }
 $14=((HEAP32[((14360)>>2)])|0);
 $15=($14|0)>0;
 $16=(($label)|0);
 if ($15) {
  HEAP8[($16)]=((HEAP8[(2440)])|0);HEAP8[((($16)+(1))|0)]=((HEAP8[(2441)])|0);HEAP8[((($16)+(2))|0)]=((HEAP8[(2442)])|0);HEAP8[((($16)+(3))|0)]=((HEAP8[(2443)])|0);HEAP8[((($16)+(4))|0)]=((HEAP8[(2444)])|0);
  $strlen5=((_strlen((($16)|0)))|0);
  $endptr6=(($label+$strlen5)|0);
  $18=$endptr6;
  tempBigInt=32;HEAP8[($18)]=tempBigInt&0xff;tempBigInt = tempBigInt>>8;HEAP8[((($18)+(1))|0)]=tempBigInt&0xff;
  $19=((HEAP32[((14360)>>2)])|0);
  $20=((HEAP32[((13256)>>2)])|0);
  $21=(($20+((($19)*(56))&-1))|0);
  $22=((_strcat((($16)|0),(($21)|0)))|0);
 } else {
  (_memcpy((($16)|0), ((2384)|0), 16)|0);
 }
 $25=(($fmt)|0);
 $26=((_sprintf(((14488)|0),(($25)|0),(((tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = (((STACKTOP)+7)&-8),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs))|0)))|0); STACKTOP=tempVarArgs;
 $27=((_strcat(((14488)|0),(($16)|0)))|0);
 $strlen=((_strlen(((14488)|0)))|0);
 $endptr=((14488+$strlen)|0);
 $28=$endptr;
 tempBigInt=58;HEAP8[($28)]=tempBigInt&0xff;tempBigInt = tempBigInt>>8;HEAP8[((($28)+(1))|0)]=tempBigInt&0xff;
 _writeline(14488);
 $29=((HEAP32[((12232)>>2)])|0);
 $30=((_strcpy((($25)|0),(($29)|0)))|0);
 $31=((HEAP32[((14336)>>2)])|0);
 $32=($31|0)>1;
 if ($32) {
  $i_07=1;
  while(1) {

   $strlen3=((_strlen((($25)|0)))|0);
   $endptr4=(($fmt+$strlen3)|0);
   $33=$endptr4;
   tempBigInt=32;HEAP8[($33)]=tempBigInt&0xff;tempBigInt = tempBigInt>>8;HEAP8[((($33)+(1))|0)]=tempBigInt&0xff;
   $34=((12232+($i_07<<2))|0);
   $35=((HEAP32[(($34)>>2)])|0);
   $36=((_strcat((($25)|0),(($35)|0)))|0);
   $37=((($i_07)+(1))|0);
   $38=((HEAP32[((14336)>>2)])|0);
   $39=($37|0)<($38|0);
   if ($39) {
    $i_07=$37;
   } else {
    break;
   }
  }
 }
 _writeline($25);
 STACKTOP=sp;return;
}


function _checkpremise($p){
 $p=($p)|0;
 var $1=0,$2=0,$_off=0,$switch=0,$4=0,$6=0,$7=0,$8=0,$10=0,$12=0,$_0=0,label=0;

 $1=(($p+12)|0);
 $2=((HEAP32[(($1)>>2)])|0);
 $_off=((($2)-(9))|0);
 $switch=($_off>>>0)<((2)>>>0);
 if ($switch) {
  $4=((_checktime($p))|0);
  $_0=$4;

  return (($_0)|0);
 }
 $6=(($p+20)|0);
 $7=((HEAP32[(($6)>>2)])|0);
 $8=($7|0)>0;
 if ($8) {
  $10=((_checkstatus($p))|0);
  $_0=$10;

  return (($_0)|0);
 } else {
  $12=((_checkvalue($p))|0);
  $_0=$12;

  return (($_0)|0);
 }
}


function _checktime($p){
 $p=($p)|0;
 var $1=0,$2=0,$4=0,$5=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$t1_0=0,$t2_0=0,$15=0,$16=.0,$17=0,$18=0,$19=0,$21=0,$23=0;
 var $25=0,$27=0,$29=0,$_not=0,$30=0,$or_cond=0,$or_cond22=0,$or_cond22_sink=0,$34=0,$35=0,$or_cond23=0,$37=0,$38=0,$or_cond24=0,$_0=0,label=0;

 $1=(($p+12)|0);
 $2=((HEAP32[(($1)>>2)])|0);
 if (((($2|0))|0)==((9)|0)) {
  $4=((HEAP32[((13168)>>2)])|0);
  $5=((HEAP32[((15576)>>2)])|0);
  $t2_0=$5;$t1_0=$4;
 } else if (((($2|0))|0)==((10)|0)) {
  $7=((HEAP32[((13168)>>2)])|0);
  $8=((HEAP32[((12216)>>2)])|0);
  $9=((($8)+($7))|0);
  $10=(((($9|0))%(86400))&-1);
  $11=((HEAP32[((15576)>>2)])|0);
  $12=((($11)+($8))|0);
  $13=(((($12|0))%(86400))&-1);
  $t2_0=$13;$t1_0=$10;
 } else {
  $_0=0;

  return (($_0)|0);
 }


 $15=(($p+24)|0);
 $16=(+(HEAPF64[(($15)>>3)]));
 $17=(~~($16));
 $18=(($p+16)|0);
 $19=((HEAP32[(($18)>>2)])|0);
 L6: do {
  switch (($19|0)) {
  case 4: {
   $21=($t2_0|0)<($17|0);
   if ($21) {
    break L6;
   } else {
    $_0=0;
   }

   return (($_0)|0);
  }
  case 3: {
   $27=($t2_0|0)<($17|0);
   if ($27) {
    $_0=0;
   } else {
    break L6;
   }

   return (($_0)|0);
  }
  case 2: {
   $23=($t2_0|0)>($17|0);
   if ($23) {
    $_0=0;
   } else {
    break L6;
   }

   return (($_0)|0);
  }
  case 5: {
   $25=($t2_0|0)>($17|0);
   if ($25) {
    break L6;
   } else {
    $_0=0;
   }

   return (($_0)|0);
  }
  case 0:case 1: {
   $29=($t2_0|0)<($t1_0|0);
   $_not=($17|0)<($t1_0|0);
   $30=($17|0)>($t2_0|0);
   if ($29) {
    $or_cond=$_not&$30;
    $or_cond22_sink=$or_cond;
   } else {
    $or_cond22=$_not|$30;
    $or_cond22_sink=$or_cond22;
   }

   $34=((HEAP32[(($18)>>2)])|0);
   $35=($34|0)==0;
   $or_cond23=$35&$or_cond22_sink;
   if ($or_cond23) {
    $_0=0;

    return (($_0)|0);
   }
   $37=($34|0)==1;
   $38=$or_cond22_sink^1;
   $or_cond24=$37&$38;
   if ($or_cond24) {
    $_0=0;
   } else {
    break L6;
   }

   return (($_0)|0);
  }
  default: {
  }
  }
 } while(0);
 $_0=1;

 return (($_0)|0);
}


function _checkstatus($p){
 $p=($p)|0;
 var $1=0,$2=0,$_off=0,$switch=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$_=0,$j_0=0,$13=0,$14=0,$16=0,$17=0,$18=0,$20=0,$21=0;
 var $23=0,$24=0,$25=0,$_0=0,label=0;

 $1=(($p+20)|0);
 $2=((HEAP32[(($1)>>2)])|0);
 $_off=((($2)-(1))|0);
 $switch=($_off>>>0)<((3)>>>0);
 do {
  if ($switch) {
   $4=(($p+8)|0);
   $5=((HEAP32[(($4)>>2)])|0);
   $6=((HEAP32[((13232)>>2)])|0);
   $7=(($6+$5)|0);
   $8=((HEAP8[($7)])|0);
   $9=(($8<<24)>>24)<3;
   if ($9) {
    $j_0=2;
   } else {
    $11=(($8<<24)>>24)==4;
    $_=($11?3:1);
    $j_0=$_;
   }

   $13=((HEAP32[(($1)>>2)])|0);
   $14=($j_0|0)==($13|0);
   do {
    if ($14) {
     $16=(($p+16)|0);
     $17=((HEAP32[(($16)>>2)])|0);
     $18=($17|0)==0;
     if ($18) {
      $_0=1;
     } else {
      break;
     }

     return (($_0)|0);
    }
   } while(0);
   $20=((HEAP32[(($1)>>2)])|0);
   $21=($j_0|0)==($20|0);
   if ($21) {
    break;
   }
   $23=(($p+16)|0);
   $24=((HEAP32[(($23)>>2)])|0);
   $25=($24|0)==1;
   if ($25) {
    $_0=1;
   } else {
    break;
   }

   return (($_0)|0);
  }
 } while(0);
 $_0=0;

 return (($_0)|0);
}


function _checkvalue($p){
 $p=($p)|0;
 var $1=0,$2=0,$3=0,$4=0,$6=0,$7=0,$8=0,$10=.0,$11=.0,$12=.0,$14=0,$15=0,$16=.0,$17=.0,$18=.0,$20=0,$21=0,$22=.0,$23=.0,$24=.0;
 var $26=0,$27=0,$28=.0,$29=0,$30=0,$31=.0,$32=.0,$33=.0,$34=.0,$36=0,$37=0,$38=.0,$39=0,$40=0,$41=.0,$42=.0,$43=.0,$44=.0,$46=0,$47=0;
 var $48=.0,$49=0,$51=.0,$53=.0,$54=.0,$55=.0,$57=0,$58=0,$59=.0,$60=0,$62=0,$63=0,$64=0,$65=0,$67=.0,$68=.0,$70=.0,$71=.0,$73=0,$74=0;
 var $76=0,$77=0,$78=0,$79=.0,$80=0,$82=0,$83=0,$84=.0,$85=0,$87=0,$88=.0,$89=0,$90=.0,$91=.0,$92=.0,$94=0,$95=0,$97=0,$98=0,$99=0;
 var $100=.0,$101=0,$103=0,$104=0,$105=.0,$106=0,$108=0,$109=.0,$110=0,$111=.0,$112=.0,$113=.0,$x_0=.0,$115=0,$116=0,$118=0,$119=.0,$120=.0,$121=0,$123=.0;
 var $125=.0,$126=0,$128=0,$129=.0,$130=.0,$131=0,$133=.0,$135=.0,$136=0,$138=0,$139=.0,$140=.0,$141=0,$143=0,$144=.0,$145=.0,$146=0,$148=0,$149=.0,$150=.0;
 var $151=0,$153=0,$154=.0,$155=.0,$156=0,$_0=0,label=0;

 $1=(($p+8)|0);
 $2=((HEAP32[(($1)>>2)])|0);
 $3=(($p+12)|0);
 $4=((HEAP32[(($3)>>2)])|0);
 L1: do {
  switch (($4|0)) {
  case 11: {
   $73=((HEAP32[((14432)>>2)])|0);
   $74=($2|0)>($73|0);
   if (!($74)) {
    $_0=0;

    return (($_0)|0);
   }
   $76=((($2)-($73))|0);
   $77=((HEAP32[((13176)>>2)])|0);
   $78=(($77+((($76)*(112))&-1)+8)|0);
   $79=(+(HEAPF64[(($78)>>3)]));
   $80=$79==(0.0);
   if ($80) {
    $_0=0;

    return (($_0)|0);
   }
   $82=((HEAP32[((17632)>>2)])|0);
   $83=(($82+($2<<3))|0);
   $84=(+(HEAPF64[(($83)>>3)]));
   $85=$84>(0.000001);
   if ($85) {
    $87=(($77+((($76)*(112))&-1)+48)|0);
    $88=(+(HEAPF64[(($87)>>3)]));
    $89=(($77+((($76)*(112))&-1)+72)|0);
    $90=(+(HEAPF64[(($89)>>3)]));
    $91=($88)-($90);
    $92=($91)/($84);
    $x_0=$92;
    break L1;
   } else {
    $_0=0;

    return (($_0)|0);
   }
  }
  case 1:case 2: {
   $20=((HEAP32[((15600)>>2)])|0);
   $21=(($20+($2<<3))|0);
   $22=(+(HEAPF64[(($21)>>3)]));
   $23=(+(HEAPF64[((12056)>>3)]));
   $24=($22)*($23);
   $x_0=$24;
   break;
  }
  case 7: {
   $57=((HEAP32[((15000)>>2)])|0);
   $58=(($57+($2<<3))|0);
   $59=(+(HEAPF64[(($58)>>3)]));
   $60=$59==(-10000000000.0);
   if ($60) {
    $_0=0;

    return (($_0)|0);
   }
   $62=((HEAP32[((14960)>>2)])|0);
   $63=(($62+((($2)*(104))&-1)+96)|0);
   $64=((HEAP8[($63)])|0);
   $65=(($64<<24)>>24);
   if (((($65|0))|0)==((3)|0)|((($65|0))|0)==((4)|0)|((($65|0))|0)==((5)|0)) {
    $67=(+(HEAPF64[((12064)>>3)]));
    $68=($59)*($67);
    $x_0=$68;
    break L1;
   } else if (((($65|0))|0)==((6)|0)) {
    $70=(+(HEAPF64[((12096)>>3)]));
    $71=($59)*($70);
    $x_0=$71;
    break L1;
   } else {
    $x_0=$59;
    break L1;
   }
  }
  case 4: {
   $26=((HEAP32[((15600)>>2)])|0);
   $27=(($26+($2<<3))|0);
   $28=(+(HEAPF64[(($27)>>3)]));
   $29=((HEAP32[((14408)>>2)])|0);
   $30=(($29+((($2)*(72))&-1)+32)|0);
   $31=(+(HEAPF64[(($30)>>3)]));
   $32=($28)-($31);
   $33=(+(HEAPF64[((12064)>>3)]));
   $34=($32)*($33);
   $x_0=$34;
   break;
  }
  case 0: {
   $6=(($p+4)|0);
   $7=((HEAP32[(($6)>>2)])|0);
   $8=($7|0)==8;
   if ($8) {
    $10=(+(HEAPF64[((11360)>>3)]));
    $11=(+(HEAPF64[((12048)>>3)]));
    $12=($10)*($11);
    $x_0=$12;
    break L1;
   } else {
    $14=((HEAP32[((17632)>>2)])|0);
    $15=(($14+($2<<3))|0);
    $16=(+(HEAPF64[(($15)>>3)]));
    $17=(+(HEAPF64[((12048)>>3)]));
    $18=($16)*($17);
    $x_0=$18;
    break L1;
   }
  }
  case 5: {
   $46=((HEAP32[((13880)>>2)])|0);
   $47=(($46+($2<<3))|0);
   $48=(+(HEAPF64[(($47)>>3)]));
   $49=$48<(0.0);
   if ($49) {
    $51=((-.0))-($48);
    $53=$51;
   } else {
    $53=$48;
   }

   $54=(+(HEAPF64[((12096)>>3)]));
   $55=($53)*($54);
   $x_0=$55;
   break;
  }
  case 12: {
   $94=((HEAP32[((14432)>>2)])|0);
   $95=($2|0)>($94|0);
   if (!($95)) {
    $_0=0;

    return (($_0)|0);
   }
   $97=((($2)-($94))|0);
   $98=((HEAP32[((13176)>>2)])|0);
   $99=(($98+((($97)*(112))&-1)+8)|0);
   $100=(+(HEAPF64[(($99)>>3)]));
   $101=$100==(0.0);
   if ($101) {
    $_0=0;

    return (($_0)|0);
   }
   $103=((HEAP32[((17632)>>2)])|0);
   $104=(($103+($2<<3))|0);
   $105=(+(HEAPF64[(($104)>>3)]));
   $106=$105<(-0.000001);
   if ($106) {
    $108=(($98+((($97)*(112))&-1)+40)|0);
    $109=(+(HEAPF64[(($108)>>3)]));
    $110=(($98+((($97)*(112))&-1)+72)|0);
    $111=(+(HEAPF64[(($110)>>3)]));
    $112=($109)-($111);
    $113=($112)/($105);
    $x_0=$113;
    break L1;
   } else {
    $_0=0;

    return (($_0)|0);
   }
  }
  case 3: {
   $36=((HEAP32[((15600)>>2)])|0);
   $37=(($36+($2<<3))|0);
   $38=(+(HEAPF64[(($37)>>3)]));
   $39=((HEAP32[((14408)>>2)])|0);
   $40=(($39+((($2)*(72))&-1)+32)|0);
   $41=(+(HEAPF64[(($40)>>3)]));
   $42=($38)-($41);
   $43=(+(HEAPF64[((12056)>>3)]));
   $44=($42)*($43);
   $x_0=$44;
   break;
  }
  default: {
   $_0=0;

   return (($_0)|0);
  }
  }
 } while(0);

 $115=(($p+16)|0);
 $116=((HEAP32[(($115)>>2)])|0);
 L42: do {
  switch (($116|0)) {
  case 1: {
   $128=(($p+24)|0);
   $129=(+(HEAPF64[(($128)>>3)]));
   $130=($x_0)-($129);
   $131=$130<(0.0);
   if ($131) {
    $133=((-.0))-($130);
    $135=$133;
   } else {
    $135=$130;
   }

   $136=$135<(0.001);
   if ($136) {
    $_0=0;
   } else {
    break L42;
   }

   return (($_0)|0);
  }
  case 3: {
   $153=(($p+24)|0);
   $154=(+(HEAPF64[(($153)>>3)]));
   $155=($154)+((0.001));
   $156=$x_0<$155;
   if ($156) {
    $_0=0;
   } else {
    break L42;
   }

   return (($_0)|0);
  }
  case 4: {
   $138=(($p+24)|0);
   $139=(+(HEAPF64[(($138)>>3)]));
   $140=($139)+((0.001));
   $141=$x_0>$140;
   if ($141) {
    $_0=0;
   } else {
    break L42;
   }

   return (($_0)|0);
  }
  case 0: {
   $118=(($p+24)|0);
   $119=(+(HEAPF64[(($118)>>3)]));
   $120=($x_0)-($119);
   $121=$120<(0.0);
   if ($121) {
    $123=((-.0))-($120);
    $125=$123;
   } else {
    $125=$120;
   }

   $126=$125>(0.001);
   if ($126) {
    $_0=0;
   } else {
    break L42;
   }

   return (($_0)|0);
  }
  case 2: {
   $143=(($p+24)|0);
   $144=(+(HEAPF64[(($143)>>3)]));
   $145=($144)+((-0.001));
   $146=$x_0>$145;
   if ($146) {
    $_0=0;
   } else {
    break L42;
   }

   return (($_0)|0);
  }
  case 5: {
   $148=(($p+24)|0);
   $149=(+(HEAPF64[(($148)>>3)]));
   $150=($149)+((-0.001));
   $151=$x_0<$150;
   if ($151) {
    $_0=0;
   } else {
    break L42;
   }

   return (($_0)|0);
  }
  default: {
  }
  }
 } while(0);
 $_0=1;

 return (($_0)|0);
}


function _checkaction($i,$a){
 $i=($i)|0;
 $a=($a)|0;
 var $1=0,$2=0,$item_0_in=0,$item_0=0,$4=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$14=0,$15=0,$16=0,$17=.0,$18=0,$19=.0,$20=0,$_0=0;
 var label=0;

 $1=(($a)|0);
 $2=((HEAP32[(($1)>>2)])|0);
 $item_0_in=17784;
 while(1) {

  $item_0=((HEAP32[(($item_0_in)>>2)])|0);
  $4=($item_0|0)==0;
  if ($4) {
   $_0=0;
   label = 6;
   break;
  }
  $6=(($item_0+4)|0);
  $7=((HEAP32[(($6)>>2)])|0);
  $8=(($item_0)|0);
  $9=(($7)|0);
  $10=((HEAP32[(($9)>>2)])|0);
  $11=($10|0)==($2|0);
  $12=(($item_0+8)|0);
  if ($11) {
   break;
  } else {
   $item_0_in=$12;
  }
 }
 if ((label|0) == 6) {

  return (($_0)|0);
 }
 $14=((HEAP32[(($8)>>2)])|0);
 $15=((HEAP32[((13256)>>2)])|0);
 $16=(($15+((($i)*(56))&-1)+32)|0);
 $17=(+(HEAPF64[(($16)>>3)]));
 $18=(($15+((($14)*(56))&-1)+32)|0);
 $19=(+(HEAPF64[(($18)>>3)]));
 $20=$17>$19;
 if (!($20)) {
  $_0=1;

  return (($_0)|0);
 }
 HEAP32[(($6)>>2)]=$a;
 HEAP32[(($8)>>2)]=$i;
 $_0=1;

 return (($_0)|0);
}


function _createsparse(){
 var $1=0,$2=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$18=0,$19=0,$21=0,$22=0,$23=0,$24=0;
 var $26=0,$27=0,$28=0,$30=0,$31=0,$32=0,$33=0,$_0=0,label=0;

 $1=((_allocsparse())|0);
 $2=($1|0)==0;
 if (!($2)) {
  $_0=$1;

  return (($_0)|0);
 }
 $4=((HEAP32[((14416)>>2)])|0);
 $5=((($4)+(1))|0);
 $6=((_calloc($5,4))|0);
 $7=$6;
 HEAP32[((17552)>>2)]=$7;
 $8=($6|0)==0;
 $9=($8?101:0);
 do {
  if ($8) {
   $14=$9;
   label = 5;
  } else {
   $11=((_buildlists(1))|0);
   $12=($11|0)==0;
   if (!($12)) {
    $14=$11;
    label = 5;
    break;
   }
   _xparalinks();
   _countdegree();
   $13=((HEAP32[((14424)>>2)])|0);
   HEAP32[((14472)>>2)]=$13;
   label = 6;
  }
 } while(0);
 if ((label|0) == 5) {

  $15=((HEAP32[((14424)>>2)])|0);
  HEAP32[((14472)>>2)]=$15;
  $16=($14|0)>100;
  if ($16) {
   $31=$14;
  } else {
   label = 6;
  }
 }
 do {
  if ((label|0) == 6) {
   $18=((_reordernodes())|0);
   $19=($18|0)>100;
   if ($19) {
    $31=$18;
    break;
   }
   $21=((HEAP32[((14432)>>2)])|0);
   $22=((_storesparse($21))|0);
   $23=($22|0)==0;
   if ($23) {
    _freelists();
   } else {
    $24=($22|0)>100;
    if ($24) {
     $31=$22;
     break;
    }
   }
   $26=((HEAP32[((14432)>>2)])|0);
   $27=((_ordersparse($26))|0);
   $28=($27|0)>100;
   if ($28) {
    $31=$27;
    break;
   }
   $30=((_buildlists(0))|0);
   $31=$30;
  }
 } while(0);

 $32=((HEAP32[((17552)>>2)])|0);
 _free($32);
 $_0=$31;

 return (($_0)|0);
}


function _allocsparse(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$19=0,$21=0;
 var $22=0,$23=0,$25=0,$26=0,$28=0,$29=0,$30=0,$32=0,$33=0,$34=0,$35=0,label=0;

 $1=((HEAP32[((14416)>>2)])|0);
 $2=((($1)+(1))|0);
 $3=((_calloc($2,4))|0);
 $4=$3;
 HEAP32[((17776)>>2)]=$4;
 $5=((HEAP32[((14416)>>2)])|0);
 $6=((($5)+(1))|0);
 $7=((_calloc($6,4))|0);
 $8=$7;
 HEAP32[((14288)>>2)]=$8;
 $9=((HEAP32[((14416)>>2)])|0);
 $10=((($9)+(1))|0);
 $11=((_calloc($10,4))|0);
 $12=$11;
 HEAP32[((13832)>>2)]=$12;
 $13=((HEAP32[((14424)>>2)])|0);
 $14=((($13)+(1))|0);
 $15=((_calloc($14,4))|0);
 $16=$15;
 HEAP32[((14448)>>2)]=$16;
 $17=((HEAP32[((17776)>>2)])|0);
 $18=($17|0)==0;
 $19=($18?101:0);
 if ($18) {
  $25=$19;
 } else {
  $21=((HEAP32[((14288)>>2)])|0);
  $22=($21|0)==0;
  $23=($22?101:0);
  $25=$23;
 }

 $26=($25|0)==101;
 if ($26) {
  $35=101;

  return (($35)|0);
 }
 $28=((HEAP32[((13832)>>2)])|0);
 $29=($28|0)==0;
 $30=($29?101:0);
 if ($29) {
  $35=$30;

  return (($35)|0);
 }
 $32=((HEAP32[((14448)>>2)])|0);
 $33=($32|0)==0;
 $34=($33?101:0);
 $35=$34;

 return (($35)|0);
}


function _buildlists($paraflag){
 $paraflag=($paraflag)|0;
 var $1=0,$2=0,$3=0,$pmark_029=0,$k_028=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$pmark_1=0,$13=0,$14=0,$16=0,$17=0,$18=0,$_=0,$19=0,$20=0;
 var $21=0,$22=0,$23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$31=0,$32=0,$_27=0,$33=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0,$40=0;
 var $41=0,$42=0,$43=0,$44=0,$_0=0,label=0;

 $1=((HEAP32[((14424)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  $_0=0;

  return (($_0)|0);
 }
 $3=($paraflag|0)==0;
 $k_028=1;$pmark_029=0;
 while(1) {


  $5=((HEAP32[((14960)>>2)])|0);
  $6=(($5+((($k_028)*(104))&-1)+32)|0);
  $7=((HEAP32[(($6)>>2)])|0);
  $8=(($5+((($k_028)*(104))&-1)+36)|0);
  $9=((HEAP32[(($8)>>2)])|0);
  if ($3) {
   $pmark_1=$pmark_029;
  } else {
   $11=((_paralink($7,$9,$k_028))|0);
   $pmark_1=$11;
  }

  $13=((_malloc(12))|0);
  $14=($13|0)==0;
  if ($14) {
   $_0=101;
   label = 8;
   break;
  }
  $16=$13;
  $17=($pmark_1|0)!=0;
  $18=$13;
  $_=($17?0:$9);
  HEAP32[(($18)>>2)]=$_;
  $19=(($13+4)|0);
  $20=$19;
  HEAP32[(($20)>>2)]=$k_028;
  $21=((HEAP32[((17776)>>2)])|0);
  $22=(($21+($7<<2))|0);
  $23=((HEAP32[(($22)>>2)])|0);
  $24=(($13+8)|0);
  $25=$24;
  HEAP32[(($25)>>2)]=$23;
  $26=((HEAP32[((17776)>>2)])|0);
  $27=(($26+($7<<2))|0);
  HEAP32[(($27)>>2)]=$16;
  $28=((_malloc(12))|0);
  $29=($28|0)==0;
  if ($29) {
   $_0=101;
   label = 8;
   break;
  }
  $31=$28;
  $32=$28;
  $_27=($17?0:$7);
  HEAP32[(($32)>>2)]=$_27;
  $33=(($28+4)|0);
  $34=$33;
  HEAP32[(($34)>>2)]=$k_028;
  $35=((HEAP32[((17776)>>2)])|0);
  $36=(($35+($9<<2))|0);
  $37=((HEAP32[(($36)>>2)])|0);
  $38=(($28+8)|0);
  $39=$38;
  HEAP32[(($39)>>2)]=$37;
  $40=((HEAP32[((17776)>>2)])|0);
  $41=(($40+($9<<2))|0);
  HEAP32[(($41)>>2)]=$31;
  $42=((($k_028)+(1))|0);
  $43=((HEAP32[((14424)>>2)])|0);
  $44=($42|0)>($43|0);
  if ($44) {
   $_0=0;
   label = 8;
   break;
  } else {
   $k_028=$42;$pmark_029=$pmark_1;
  }
 }
 if ((label|0) == 8) {

  return (($_0)|0);
 }
  return 0;
}


function _xparalinks(){
 var $1=0,$2=0,$i_020=0,$3=0,$4=0,$alink_01517=0,$5=0,$alink_01519=0,$blink_0_ph18=0,$6=0,$7=0,$alink_016=0,$9=0,$10=0,$11=0,$12=0,$14=0,$16=0,$17=0,$18=0;
 var $19=0,$20=0,$alink_0_in_ph_be=0,$blink_0_ph_be=0,$alink_015=0,$21=0,$23=0,$alink_0=0,$24=0,$25=0,$26=0,$27=0,label=0;

 $1=((HEAP32[((14416)>>2)])|0);
 $2=($1|0)<1;
 if ($2) {
  return;
 } else {
  $i_020=1;
 }
 while(1) {

  $3=((HEAP32[((17776)>>2)])|0);
  $4=(($3+($i_020<<2))|0);
  $alink_01517=((HEAP32[(($4)>>2)])|0);
  $5=($alink_01517|0)==0;
  L5: do {
   if (!($5)) {
    $blink_0_ph18=0;$alink_01519=$alink_01517;
    while(1) {


     $6=($blink_0_ph18|0)==0;
     $7=(($blink_0_ph18+8)|0);
     $alink_016=$alink_01519;
     while(1) {

      $9=(($alink_016)|0);
      $10=((HEAP32[(($9)>>2)])|0);
      $11=($10|0)==0;
      $12=(($alink_016+8)|0);
      if (!($11)) {
       $blink_0_ph_be=$alink_016;$alink_0_in_ph_be=$12;
       break;
      }
      $14=((HEAP32[(($12)>>2)])|0);
      if ($6) {
       label = 6;
       break;
      }
      HEAP32[(($7)>>2)]=$14;
      _free($alink_016);
      $alink_0=((HEAP32[(($7)>>2)])|0);
      $24=($alink_0|0)==0;
      if ($24) {
       break L5;
      } else {
       $alink_016=$alink_0;
      }
     }
     if ((label|0) == 6) {
      label = 0;
      $16=((HEAP32[((17776)>>2)])|0);
      $17=(($16+($i_020<<2))|0);
      HEAP32[(($17)>>2)]=$14;
      _free($alink_016);
      $19=((HEAP32[((17776)>>2)])|0);
      $20=(($19+($i_020<<2))|0);
      $blink_0_ph_be=0;$alink_0_in_ph_be=$20;
     }


     $alink_015=((HEAP32[(($alink_0_in_ph_be)>>2)])|0);
     $21=($alink_015|0)==0;
     if ($21) {
      break;
     } else {
      $blink_0_ph18=$blink_0_ph_be;$alink_01519=$alink_015;
     }
    }
   }
  } while(0);
  $25=((($i_020)+(1))|0);
  $26=((HEAP32[((14416)>>2)])|0);
  $27=($25|0)>($26|0);
  if ($27) {
   break;
  } else {
   $i_020=$25;
  }
 }
 return;
}


function _countdegree(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$i_08=0,$8=0,$9=0,$alink_06=0,$10=0,$alink_07=0,$11=0,$12=0,$13=0,$15=0,$16=0,$17=0,$18=0;
 var $20=0,$alink_0=0,$21=0,$22=0,$23=0,$24=0,label=0;

 $1=((HEAP32[((17552)>>2)])|0);
 $2=$1;
 $3=((HEAP32[((14416)>>2)])|0);
 $4=$3<<2;
 $5=((($4)+(4))|0);
 _memset((((($2)|0))|0), ((((0)|0))|0), (((($5)|0))|0))|0;
 $6=((HEAP32[((14432)>>2)])|0);
 $7=($6|0)<1;
 if ($7) {
  return;
 } else {
  $i_08=1;
 }
 while(1) {

  $8=((HEAP32[((17776)>>2)])|0);
  $9=(($8+($i_08<<2))|0);
  $alink_06=((HEAP32[(($9)>>2)])|0);
  $10=($alink_06|0)==0;
  if (!($10)) {
   $alink_07=$alink_06;
   while(1) {

    $11=(($alink_07)|0);
    $12=((HEAP32[(($11)>>2)])|0);
    $13=($12|0)>0;
    if ($13) {
     $15=((HEAP32[((17552)>>2)])|0);
     $16=(($15+($i_08<<2))|0);
     $17=((HEAP32[(($16)>>2)])|0);
     $18=((($17)+(1))|0);
     HEAP32[(($16)>>2)]=$18;
    }
    $20=(($alink_07+8)|0);
    $alink_0=((HEAP32[(($20)>>2)])|0);
    $21=($alink_0|0)==0;
    if ($21) {
     break;
    } else {
     $alink_07=$alink_0;
    }
   }
  }
  $22=((($i_08)+(1))|0);
  $23=((HEAP32[((14432)>>2)])|0);
  $24=($22|0)>($23|0);
  if ($24) {
   break;
  } else {
   $i_08=$22;
  }
 }
 return;
}


function _reordernodes(){
 var $1=0,$2=0,$k_024=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$k_122=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0;
 var $20=0,$21=0,$22=0,$23=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$k_220=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0,$_0=0,label=0;

 $1=((HEAP32[((14416)>>2)])|0);
 $2=($1|0)<1;
 if (!($2)) {
  $k_024=1;
  while(1) {

   $3=((HEAP32[((13832)>>2)])|0);
   $4=(($3+($k_024<<2))|0);
   HEAP32[(($4)>>2)]=$k_024;
   $5=((HEAP32[((14288)>>2)])|0);
   $6=(($5+($k_024<<2))|0);
   HEAP32[(($6)>>2)]=$k_024;
   $7=((($k_024)+(1))|0);
   $8=((HEAP32[((14416)>>2)])|0);
   $9=($7|0)>($8|0);
   if ($9) {
    break;
   } else {
    $k_024=$7;
   }
  }
 }
 $10=((HEAP32[((14432)>>2)])|0);
 $11=($10|0)<1;
 if ($11) {
  $_0=0;

  return (($_0)|0);
 } else {
  $k_122=1;
 }
 while(1) {

  $13=((_mindegree($k_122,$10))|0);
  $14=((HEAP32[((14288)>>2)])|0);
  $15=(($14+($13<<2))|0);
  $16=((HEAP32[(($15)>>2)])|0);
  $17=((_growlist($16))|0);
  $18=($17|0)==0;
  if ($18) {
   $_0=101;
   label = 8;
   break;
  }
  $20=((HEAP32[((14288)>>2)])|0);
  $21=(($20+($k_122<<2))|0);
  $22=((HEAP32[(($21)>>2)])|0);
  $23=(($20+($13<<2))|0);
  HEAP32[(($23)>>2)]=$22;
  $24=((HEAP32[((14288)>>2)])|0);
  $25=(($24+($k_122<<2))|0);
  HEAP32[(($25)>>2)]=$16;
  $26=((HEAP32[((17552)>>2)])|0);
  $27=(($26+($16<<2))|0);
  HEAP32[(($27)>>2)]=0;
  $28=((($k_122)+(1))|0);
  $29=($28|0)>($10|0);
  if ($29) {
   break;
  } else {
   $k_122=$28;
  }
 }
 if ((label|0) == 8) {

  return (($_0)|0);
 }
 $12=($10|0)<1;
 if ($12) {
  $_0=0;

  return (($_0)|0);
 } else {
  $k_220=1;
 }
 while(1) {

  $30=((HEAP32[((14288)>>2)])|0);
  $31=(($30+($k_220<<2))|0);
  $32=((HEAP32[(($31)>>2)])|0);
  $33=((HEAP32[((13832)>>2)])|0);
  $34=(($33+($32<<2))|0);
  HEAP32[(($34)>>2)]=$k_220;
  $35=((($k_220)+(1))|0);
  $36=($35|0)>($10|0);
  if ($36) {
   $_0=0;
   break;
  } else {
   $k_220=$35;
  }
 }

 return (($_0)|0);
}


function _storesparse($n){
 $n=($n)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$16=0,$17=0,$18=0,$20=0,$21=0,$23=0;
 var $24=0,$25=0,$27=0,$28=0,$29=0,$k_031=0,$i_030=0,$30=0,$31=0,$32=0,$33=0,$34=0,$alink_025=0,$35=0,$alink_028=0,$m_027=0,$k_126=0,$36=0,$37=0,$38=0;
 var $39=0,$40=0,$41=0,$42=0,$or_cond=0,$44=0,$45=0,$46=0,$47=0,$48=0,$49=0,$50=0,$51=0,$k_2=0,$m_1=0,$53=0,$alink_0=0,$54=0,$m_0_lcssa=0,$k_1_lcssa=0;
 var $55=0,$56=0,$57=0,$58=0,$59=0,$60=0,$61=0,$62=0,label=0;

 $1=((($n)+(2))|0);
 $2=((_calloc($1,4))|0);
 $3=$2;
 HEAP32[((11992)>>2)]=$3;
 $4=((HEAP32[((14472)>>2)])|0);
 $5=((($4)+(2))|0);
 $6=((_calloc($5,4))|0);
 $7=$6;
 HEAP32[((14480)>>2)]=$7;
 $8=((HEAP32[((14472)>>2)])|0);
 $9=((($8)+(2))|0);
 $10=((_calloc($9,4))|0);
 $11=$10;
 HEAP32[((14992)>>2)]=$11;
 $12=((HEAP32[((11992)>>2)])|0);
 $13=($12|0)==0;
 $14=($13?101:0);
 if ($13) {
  $20=$14;
 } else {
  $16=((HEAP32[((14480)>>2)])|0);
  $17=($16|0)==0;
  $18=($17?101:0);
  $20=$18;
 }

 $21=($20|0)==101;
 if ($21) {
  $62=101;

  return (($62)|0);
 }
 $23=((HEAP32[((14992)>>2)])|0);
 $24=($23|0)==0;
 $25=($24?101:0);
 if ($24) {
  $62=$25;

  return (($62)|0);
 }
 $27=((HEAP32[((11992)>>2)])|0);
 $28=(($27+4)|0);
 HEAP32[(($28)>>2)]=1;
 $29=($n|0)<1;
 if ($29) {
  $62=$25;

  return (($62)|0);
 } else {
  $i_030=1;$k_031=0;
 }
 while(1) {


  $30=((HEAP32[((14288)>>2)])|0);
  $31=(($30+($i_030<<2))|0);
  $32=((HEAP32[(($31)>>2)])|0);
  $33=((HEAP32[((17776)>>2)])|0);
  $34=(($33+($32<<2))|0);
  $alink_025=((HEAP32[(($34)>>2)])|0);
  $35=($alink_025|0)==0;
  if ($35) {
   $k_1_lcssa=$k_031;$m_0_lcssa=0;
  } else {
   $k_126=$k_031;$m_027=0;$alink_028=$alink_025;
   while(1) {



    $36=(($alink_028)|0);
    $37=((HEAP32[(($36)>>2)])|0);
    $38=((HEAP32[((13832)>>2)])|0);
    $39=(($38+($37<<2))|0);
    $40=((HEAP32[(($39)>>2)])|0);
    $41=($40|0)<=($i_030|0);
    $42=($40|0)>($n|0);
    $or_cond=$41|$42;
    if ($or_cond) {
     $m_1=$m_027;$k_2=$k_126;
    } else {
     $44=(($alink_028+4)|0);
     $45=((HEAP32[(($44)>>2)])|0);
     $46=((($m_027)+(1))|0);
     $47=((($k_126)+(1))|0);
     $48=((HEAP32[((14480)>>2)])|0);
     $49=(($48+($47<<2))|0);
     HEAP32[(($49)>>2)]=$40;
     $50=((HEAP32[((14992)>>2)])|0);
     $51=(($50+($47<<2))|0);
     HEAP32[(($51)>>2)]=$45;
     $m_1=$46;$k_2=$47;
    }


    $53=(($alink_028+8)|0);
    $alink_0=((HEAP32[(($53)>>2)])|0);
    $54=($alink_0|0)==0;
    if ($54) {
     $k_1_lcssa=$k_2;$m_0_lcssa=$m_1;
     break;
    } else {
     $k_126=$k_2;$m_027=$m_1;$alink_028=$alink_0;
    }
   }
  }


  $55=((HEAP32[((11992)>>2)])|0);
  $56=(($55+($i_030<<2))|0);
  $57=((HEAP32[(($56)>>2)])|0);
  $58=((($57)+($m_0_lcssa))|0);
  $59=((($i_030)+(1))|0);
  $60=(($55+($59<<2))|0);
  HEAP32[(($60)>>2)]=$58;
  $61=($59|0)>($n|0);
  if ($61) {
   $62=$25;
   break;
  } else {
   $i_030=$59;$k_031=$k_1_lcssa;
  }
 }

 return (($62)|0);
}


function _freelists(){
 var $1=0,$2=0,$i_012=0,$_pn7=0,$alink_0_in8=0,$alink_09=0,$3=0,$alink_011=0,$alink_0_in10=0,$4=0,$5=0,$6=0,$_pn=0,$alink_0_in=0,$alink_0=0,$7=0,$8=0,$9=0,$10=0,label=0;

 $1=((HEAP32[((14416)>>2)])|0);
 $2=($1|0)<0;
 if ($2) {
  return;
 } else {
  $i_012=0;
 }
 while(1) {

  $_pn7=((HEAP32[((17776)>>2)])|0);
  $alink_0_in8=(($_pn7+($i_012<<2))|0);
  $alink_09=((HEAP32[(($alink_0_in8)>>2)])|0);
  $3=($alink_09|0)==0;
  if (!($3)) {
   $alink_0_in10=$alink_0_in8;$alink_011=$alink_09;
   while(1) {


    $4=(($alink_011+8)|0);
    $5=((HEAP32[(($4)>>2)])|0);
    HEAP32[(($alink_0_in10)>>2)]=$5;
    _free($alink_011);
    $_pn=((HEAP32[((17776)>>2)])|0);
    $alink_0_in=(($_pn+($i_012<<2))|0);
    $alink_0=((HEAP32[(($alink_0_in)>>2)])|0);
    $7=($alink_0|0)==0;
    if ($7) {
     break;
    } else {
     $alink_0_in10=$alink_0_in;$alink_011=$alink_0;
    }
   }
  }
  $8=((($i_012)+(1))|0);
  $9=((HEAP32[((14416)>>2)])|0);
  $10=($8|0)>($9|0);
  if ($10) {
   break;
  } else {
   $i_012=$8;
  }
 }
 return;
}


function _ordersparse($n){
 $n=($n)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$17=0,$18=0,$20=0,$21=0,$23=0;
 var $24=0,$26=0,$27=0,$28=0,$29=0,$30=0,$scevgep=0,$31=0,$32=0,$i_152=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0,$40=0,$k_049=0,$41=0,$42=0;
 var $43=0,$44=0,$45=0,$46=0,$47=0,$48=0,$49=0,$50=0,$51=0,$52=0,$53=0,$54=0,$i_248=0,$55=0,$56=0,$57=0,$58=0,$59=0,$60=0,$61=0;
 var $62=0,$63=0,$64=0,$65=0,$66=0,$67=0,$68=0,$69=0,$70=0,$71=0,$72=0,$73=0,label=0;

 $1=((($n)+(2))|0);
 $2=((_calloc($1,4))|0);
 $3=$2;
 $4=((HEAP32[((14472)>>2)])|0);
 $5=((($4)+(2))|0);
 $6=((_calloc($5,4))|0);
 $7=$6;
 $8=((HEAP32[((14472)>>2)])|0);
 $9=((($8)+(2))|0);
 $10=((_calloc($9,4))|0);
 $11=$10;
 $12=((_calloc($1,4))|0);
 $13=$12;
 $14=($2|0)==0;
 $15=($14?101:0);
 if ($14) {
  $20=$15;
 } else {
  $17=($6|0)==0;
  $18=($17?101:0);
  $20=$18;
 }

 $21=($20|0)==101;
 if ($21) {
  $69=101;

  _free($3);
  _free($7);
  _free($11);
  _free($13);
  return (($69)|0);
 }
 $23=($10|0)==0;
 $24=($23?101:0);
 if ($23) {
  $69=$24;

  _free($3);
  _free($7);
  _free($11);
  _free($13);
  return (($69)|0);
 }
 $26=($12|0)==0;
 $27=($26?101:0);
 if ($26) {
  $69=$27;

  _free($3);
  _free($7);
  _free($11);
  _free($13);
  return (($69)|0);
 }
 $28=($n|0)<1;
 do {
  if ($28) {
   $29=(($2+4)|0);
   $30=$29;
   HEAP32[(($30)>>2)]=1;
  } else {
   $scevgep=(($12+4)|0);
   $31=$n<<2;
   _memset((((($scevgep)|0))|0), ((((0)|0))|0), (((($31)|0))|0))|0;
   $i_152=1;
   while(1) {

    $34=((HEAP32[((11992)>>2)])|0);
    $35=(($34+($i_152<<2))|0);
    $36=((HEAP32[(($35)>>2)])|0);
    $37=((($i_152)+(1))|0);
    $38=(($34+($37<<2))|0);
    $39=((HEAP32[(($38)>>2)])|0);
    $40=($36|0)<($39|0);
    if ($40) {
     $k_049=$36;
     while(1) {

      $41=((HEAP32[((14480)>>2)])|0);
      $42=(($41+($k_049<<2))|0);
      $43=((HEAP32[(($42)>>2)])|0);
      $44=(($13+($43<<2))|0);
      $45=((HEAP32[(($44)>>2)])|0);
      $46=((($45)+(1))|0);
      HEAP32[(($44)>>2)]=$46;
      $47=((($k_049)+(1))|0);
      $48=((HEAP32[((11992)>>2)])|0);
      $49=(($48+($37<<2))|0);
      $50=((HEAP32[(($49)>>2)])|0);
      $51=($47|0)<($50|0);
      if ($51) {
       $k_049=$47;
      } else {
       break;
      }
     }
    }
    $32=($37|0)>($n|0);
    if ($32) {
     break;
    } else {
     $i_152=$37;
    }
   }
   $52=(($2+4)|0);
   $53=$52;
   HEAP32[(($53)>>2)]=1;
   $54=($n|0)<1;
   if ($54) {
    break;
   } else {
    $i_248=1;
   }
   while(1) {

    $55=(($3+($i_248<<2))|0);
    $56=((HEAP32[(($55)>>2)])|0);
    $57=(($13+($i_248<<2))|0);
    $58=((HEAP32[(($57)>>2)])|0);
    $59=((($58)+($56))|0);
    $60=((($i_248)+(1))|0);
    $61=(($3+($60<<2))|0);
    HEAP32[(($61)>>2)]=$59;
    $62=($60|0)>($n|0);
    if ($62) {
     break;
    } else {
     $i_248=$60;
    }
   }
  }
 } while(0);
 $63=((HEAP32[((11992)>>2)])|0);
 $64=((HEAP32[((14480)>>2)])|0);
 $65=((HEAP32[((14992)>>2)])|0);
 _transpose($n,$63,$64,$65,$3,$7,$11,$13);
 $66=((HEAP32[((11992)>>2)])|0);
 $67=((HEAP32[((14480)>>2)])|0);
 $68=((HEAP32[((14992)>>2)])|0);
 _transpose($n,$3,$7,$11,$66,$67,$68,$13);
 $69=$27;

 _free($3);
 _free($7);
 _free($11);
 _free($13);
 return (($69)|0);
}


function _freesparse(){
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,label=0;

 _freelists();
 $1=((HEAP32[((17776)>>2)])|0);
 _free($1);
 $3=((HEAP32[((14288)>>2)])|0);
 _free($3);
 $5=((HEAP32[((13832)>>2)])|0);
 _free($5);
 $7=((HEAP32[((14448)>>2)])|0);
 _free($7);
 $9=((HEAP32[((11992)>>2)])|0);
 _free($9);
 $11=((HEAP32[((14480)>>2)])|0);
 _free($11);
 $13=((HEAP32[((14992)>>2)])|0);
 _free($13);
 return;
}


function _paralink($i,$j,$k){
 $i=($i)|0;
 $j=($j)|0;
 $k=($k)|0;
 var $1=0,$2=0,$alink_0_in=0,$alink_0=0,$4=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$13=0,$14=0,$16=0,$17=0,$_0=0,label=0;

 $1=((HEAP32[((17776)>>2)])|0);
 $2=(($1+($i<<2))|0);
 $alink_0_in=$2;
 while(1) {

  $alink_0=((HEAP32[(($alink_0_in)>>2)])|0);
  $4=($alink_0|0)==0;
  if ($4) {
   label = 5;
   break;
  }
  $6=(($alink_0)|0);
  $7=((HEAP32[(($6)>>2)])|0);
  $8=($7|0)==($j|0);
  $9=(($alink_0+8)|0);
  if ($8) {
   label = 4;
   break;
  } else {
   $alink_0_in=$9;
  }
 }
 if ((label|0) == 4) {
  $11=(($alink_0+4)|0);
  $12=((HEAP32[(($11)>>2)])|0);
  $13=((HEAP32[((14448)>>2)])|0);
  $14=(($13+($k<<2))|0);
  HEAP32[(($14)>>2)]=$12;
  $_0=1;

  return (($_0)|0);
 }
 else if ((label|0) == 5) {
  $16=((HEAP32[((14448)>>2)])|0);
  $17=(($16+($k<<2))|0);
  HEAP32[(($17)>>2)]=$k;
  $_0=0;

  return (($_0)|0);
 }
  return 0;
}


function _mindegree($k,$n){
 $k=($k)|0;
 $n=($n)|0;
 var $1=0,$2=0,$3=0,$imin_010=0,$min_09=0,$i_08=0,$5=0,$6=0,$7=0,$8=0,$9=0,$_min_0=0,$i_0_imin_0=0,$10=0,$11=0,$imin_0_lcssa=0,label=0;

 $1=($k|0)>($n|0);
 if ($1) {
  $imin_0_lcssa=$n;

  return (($imin_0_lcssa)|0);
 }
 $2=((HEAP32[((14288)>>2)])|0);
 $3=((HEAP32[((17552)>>2)])|0);
 $i_08=$k;$min_09=$n;$imin_010=$n;
 while(1) {



  $5=(($2+($i_08<<2))|0);
  $6=((HEAP32[(($5)>>2)])|0);
  $7=(($3+($6<<2))|0);
  $8=((HEAP32[(($7)>>2)])|0);
  $9=($8|0)<($min_09|0);
  $_min_0=($9?$8:$min_09);
  $i_0_imin_0=($9?$i_08:$imin_010);
  $10=((($i_08)+(1))|0);
  $11=($10|0)>($n|0);
  if ($11) {
   $imin_0_lcssa=$i_0_imin_0;
   break;
  } else {
   $i_08=$10;$min_09=$_min_0;$imin_010=$i_0_imin_0;
  }
 }

 return (($imin_0_lcssa)|0);
}


function _growlist($knode){
 $knode=($knode)|0;
 var $1=0,$2=0,$alink_06=0,$3=0,$alink_07=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$13=0,$15=0,$alink_0=0,$16=0,$_0=0,label=0;

 $1=((HEAP32[((17776)>>2)])|0);
 $2=(($1+($knode<<2))|0);
 $alink_06=((HEAP32[(($2)>>2)])|0);
 $3=($alink_06|0)==0;
 if ($3) {
  $_0=1;

  return (($_0)|0);
 } else {
  $alink_07=$alink_06;
 }
 while(1) {

  $4=(($alink_07)|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=((HEAP32[((17552)>>2)])|0);
  $7=(($6+($5<<2))|0);
  $8=((HEAP32[(($7)>>2)])|0);
  $9=($8|0)>0;
  if ($9) {
   $11=((($8)-(1))|0);
   HEAP32[(($7)>>2)]=$11;
   $12=((_newlink($alink_07))|0);
   $13=($12|0)==0;
   if ($13) {
    $_0=0;
    label = 5;
    break;
   }
  }
  $15=(($alink_07+8)|0);
  $alink_0=((HEAP32[(($15)>>2)])|0);
  $16=($alink_0|0)==0;
  if ($16) {
   $_0=1;
   label = 5;
   break;
  } else {
   $alink_07=$alink_0;
  }
 }
 if ((label|0) == 5) {

  return (($_0)|0);
 }
  return 0;
}


function _newlink($alink){
 $alink=($alink)|0;
 var $1=0,$2=0,$blink_0_in12=0,$blink_013=0,$3=0,$blink_014=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$blink_0_in=0,$blink_0=0,$13=0,$15=0,$16=0,$17=0;
 var $18=0,$20=0,$21=0,$22=0,$24=0,$25=0,$26=0,$27=0,$28=0,$29=0,$30=0,$31=0,$_0=0,label=0;

 $1=(($alink)|0);
 $2=((HEAP32[(($1)>>2)])|0);
 $blink_0_in12=(($alink+8)|0);
 $blink_013=((HEAP32[(($blink_0_in12)>>2)])|0);
 $3=($blink_013|0)==0;
 if ($3) {
  $_0=1;

  return (($_0)|0);
 } else {
  $blink_014=$blink_013;
 }
 L3: while(1) {

  $4=(($blink_014)|0);
  $5=((HEAP32[(($4)>>2)])|0);
  $6=((HEAP32[((17552)>>2)])|0);
  $7=(($6+($5<<2))|0);
  $8=((HEAP32[(($7)>>2)])|0);
  $9=($8|0)>0;
  do {
   if ($9) {
    $11=((_linked($2,$5))|0);
    $12=($11|0)==0;
    if (!($12)) {
     break;
    }
    $15=((HEAP32[((14472)>>2)])|0);
    $16=((($15)+(1))|0);
    HEAP32[((14472)>>2)]=$16;
    $17=((_addlink($2,$5,$16))|0);
    $18=($17|0)==0;
    if ($18) {
     $_0=0;
     label = 8;
     break L3;
    }
    $20=((HEAP32[((14472)>>2)])|0);
    $21=((_addlink($5,$2,$20))|0);
    $22=($21|0)==0;
    if ($22) {
     $_0=0;
     label = 8;
     break L3;
    }
    $24=((HEAP32[((17552)>>2)])|0);
    $25=(($24+($2<<2))|0);
    $26=((HEAP32[(($25)>>2)])|0);
    $27=((($26)+(1))|0);
    HEAP32[(($25)>>2)]=$27;
    $28=((HEAP32[((17552)>>2)])|0);
    $29=(($28+($5<<2))|0);
    $30=((HEAP32[(($29)>>2)])|0);
    $31=((($30)+(1))|0);
    HEAP32[(($29)>>2)]=$31;
   }
  } while(0);
  $blink_0_in=(($blink_014+8)|0);
  $blink_0=((HEAP32[(($blink_0_in)>>2)])|0);
  $13=($blink_0|0)==0;
  if ($13) {
   $_0=1;
   label = 8;
   break;
  } else {
   $blink_014=$blink_0;
  }
 }
 if ((label|0) == 8) {

  return (($_0)|0);
 }
  return 0;
}


function _linked($i,$j){
 $i=($i)|0;
 $j=($j)|0;
 var $1=0,$2=0,$alink_0_in=0,$alink_0=0,$4=0,$6=0,$7=0,$8=0,$9=0,$_0=0,label=0;

 $1=((HEAP32[((17776)>>2)])|0);
 $2=(($1+($i<<2))|0);
 $alink_0_in=$2;
 while(1) {

  $alink_0=((HEAP32[(($alink_0_in)>>2)])|0);
  $4=($alink_0|0)==0;
  if ($4) {
   $_0=0;
   label = 4;
   break;
  }
  $6=(($alink_0)|0);
  $7=((HEAP32[(($6)>>2)])|0);
  $8=($7|0)==($j|0);
  $9=(($alink_0+8)|0);
  if ($8) {
   $_0=1;
   label = 4;
   break;
  } else {
   $alink_0_in=$9;
  }
 }
 if ((label|0) == 4) {

  return (($_0)|0);
 }
  return 0;
}


function _addlink($i,$j,$n){
 $i=($i)|0;
 $j=($j)|0;
 $n=($n)|0;
 var $1=0,$2=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$_0=0,label=0;

 $1=((_malloc(12))|0);
 $2=($1|0)==0;
 if ($2) {
  $_0=0;

  return (($_0)|0);
 }
 $4=$1;
 $5=$1;
 HEAP32[(($5)>>2)]=$j;
 $6=(($1+4)|0);
 $7=$6;
 HEAP32[(($7)>>2)]=$n;
 $8=((HEAP32[((17776)>>2)])|0);
 $9=(($8+($i<<2))|0);
 $10=((HEAP32[(($9)>>2)])|0);
 $11=(($1+8)|0);
 $12=$11;
 HEAP32[(($12)>>2)]=$10;
 $13=((HEAP32[((17776)>>2)])|0);
 $14=(($13+($i<<2))|0);
 HEAP32[(($14)>>2)]=$4;
 $_0=1;

 return (($_0)|0);
}


function _transpose($n,$il,$jl,$xl,$ilt,$jlt,$xlt,$nzt){
 $n=($n)|0;
 $il=($il)|0;
 $jl=($jl)|0;
 $xl=($xl)|0;
 $ilt=($ilt)|0;
 $jlt=($jlt)|0;
 $xlt=($xlt)|0;
 $nzt=($nzt)|0;
 var $1=0,$scevgep=0,$scevgep31=0,$2=0,$3=0,$i_126=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$k_025=0,$11=0,$12=0,$13=0,$14=0,$15=0,$16=0,$17=0;
 var $18=0,$19=0,$20=0,$21=0,$22=0,$23=0,$24=0,$25=0,$26=0,label=0;

 $1=($n|0)<1;
 if ($1) {
  return;
 }
 $scevgep=(($nzt+4)|0);
 $scevgep31=$scevgep;
 $2=$n<<2;
 _memset((((($scevgep31)|0))|0), ((((0)|0))|0), (((($2)|0))|0))|0;
 $i_126=1;
 while(1) {

  $5=(($il+($i_126<<2))|0);
  $6=((HEAP32[(($5)>>2)])|0);
  $7=((($i_126)+(1))|0);
  $8=(($il+($7<<2))|0);
  $9=((HEAP32[(($8)>>2)])|0);
  $10=($6|0)<($9|0);
  if ($10) {
   $k_025=$6;
   while(1) {

    $11=(($jl+($k_025<<2))|0);
    $12=((HEAP32[(($11)>>2)])|0);
    $13=(($ilt+($12<<2))|0);
    $14=((HEAP32[(($13)>>2)])|0);
    $15=(($nzt+($12<<2))|0);
    $16=((HEAP32[(($15)>>2)])|0);
    $17=((($16)+($14))|0);
    $18=(($jlt+($17<<2))|0);
    HEAP32[(($18)>>2)]=$i_126;
    $19=(($xl+($k_025<<2))|0);
    $20=((HEAP32[(($19)>>2)])|0);
    $21=(($xlt+($17<<2))|0);
    HEAP32[(($21)>>2)]=$20;
    $22=((HEAP32[(($15)>>2)])|0);
    $23=((($22)+(1))|0);
    HEAP32[(($15)>>2)]=$23;
    $24=((($k_025)+(1))|0);
    $25=((HEAP32[(($8)>>2)])|0);
    $26=($24|0)<($25|0);
    if ($26) {
     $k_025=$24;
    } else {
     break;
    }
   }
  }
  $3=($7|0)>($n|0);
  if ($3) {
   break;
  } else {
   $i_126=$7;
  }
 }
 return;
}


function _linsolve($n,$Aii,$Aij,$B){
 $n=($n)|0;
 $Aii=($Aii)|0;
 $Aij=($Aij)|0;
 $B=($B)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$14=0,$15=0,$17=0,$18=0,$19=0,$20=0,$22=0,$23=0,$24=0;
 var $25=0,$j_0164=0,$26=0,$27=0,$28=0,$diagj_0154=.0,$k_0153=0,$29=0,$30=0,$31=0,$32=0,$33=0,$34=0,$35=0,$36=0,$37=.0,$38=.0,$39=.0,$40=0,$41=0;
 var $42=0,$43=0,$44=0,$45=0,$46=0,$47=0,$49=0,$50=0,$51=0,$52=0,$53=0,$54=0,$i_0150=0,$55=0,$56=0,$57=0,$58=0,$59=0,$60=0,$61=0;
 var $62=.0,$63=.0,$64=0,$65=.0,$66=.0,$67=0,$68=0,$diagj_0_lcssa=.0,$69=0,$70=.0,$71=.0,$72=0,$74=.0,$75=0,$76=0,$77=0,$78=0,$79=0,$80=0,$81=0;
 var $82=0,$83=0,$85=0,$86=0,$87=0,$88=0,$89=0,$90=0,$91=0,$i_1158=0,$92=0,$93=0,$94=0,$95=0,$96=0,$97=0,$98=0,$99=.0,$100=0,$101=.0;
 var $102=.0,$103=.0,$104=0,$105=0,$106=0,$j_1147=0,$107=0,$108=.0,$109=0,$110=.0,$111=.0,$112=0,$113=0,$114=0,$115=0,$116=0,$117=0,$118=0,$119=0,$120=0;
 var $i_2144=0,$121=0,$122=0,$123=0,$124=0,$125=0,$126=0,$127=0,$128=.0,$129=.0,$130=0,$131=.0,$132=.0,$133=0,$134=0,$j_2140=0,$135=0,$136=.0,$137=0,$138=0;
 var $139=0,$140=0,$141=0,$142=0,$143=0,$144=0,$145=0,$146=0,$i_3137=0,$bj_0136=.0,$148=0,$149=0,$150=0,$151=0,$152=0,$153=.0,$154=0,$155=.0,$156=.0,$157=.0;
 var $158=0,$159=0,$bj_1=.0,$160=0,$161=.0,$162=.0,$163=0,$164=0,$errcode_0=0,$165=0,$166=0,$167=0,label=0;

 $1=((($n)+(1))|0);
 $2=((_calloc($1,8))|0);
 $3=$2;
 $4=((_calloc($1,4))|0);
 $5=$4;
 $6=((_calloc($1,4))|0);
 $7=$6;
 $8=($2|0)==0;
 $9=($8?101:0);
 if ($8) {
  $14=$9;
 } else {
  $11=($4|0)==0;
  $12=($11?101:0);
  $14=$12;
 }

 $15=($14|0)==101;
 do {
  if ($15) {
   $19=101;
  } else {
   $17=($6|0)==0;
   $18=($17?101:0);
   if ($17) {
    $19=$18;
    break;
   }
   $22=$1<<3;
   _memset((((($2)|0))|0), ((((0)|0))|0), (((($22)|0))|0))|0;
   $23=$1<<2;
   _memset((((($4)|0))|0), ((((0)|0))|0), (((($23)|0))|0))|0;
   $24=($n|0)<1;
   if ($24) {
    $errcode_0=$18;

    _free($3);
    _free($5);
    _free($7);
    return (($errcode_0)|0);
   } else {
    $j_0164=1;
   }
   while(1) {

    $26=(($5+($j_0164<<2))|0);
    $27=((HEAP32[(($26)>>2)])|0);
    $28=($27|0)==0;
    if ($28) {
     $diagj_0_lcssa=0.0;
    } else {
     $k_0153=$27;$diagj_0154=0.0;
     while(1) {


      $29=(($5+($k_0153<<2))|0);
      $30=((HEAP32[(($29)>>2)])|0);
      $31=(($7+($k_0153<<2))|0);
      $32=((HEAP32[(($31)>>2)])|0);
      $33=((HEAP32[((14992)>>2)])|0);
      $34=(($33+($32<<2))|0);
      $35=((HEAP32[(($34)>>2)])|0);
      $36=(($Aij+($35<<3))|0);
      $37=(+(HEAPF64[(($36)>>3)]));
      $38=($37)*($37);
      $39=($diagj_0154)+($38);
      $40=((($32)+(1))|0);
      $41=((($k_0153)+(1))|0);
      $42=((HEAP32[((11992)>>2)])|0);
      $43=(($42+($41<<2))|0);
      $44=((HEAP32[(($43)>>2)])|0);
      $45=((($44)-(1))|0);
      $46=($45|0)<($40|0);
      do {
       if (!($46)) {
        HEAP32[(($31)>>2)]=$40;
        $49=((HEAP32[((14480)>>2)])|0);
        $50=(($49+($40<<2))|0);
        $51=((HEAP32[(($50)>>2)])|0);
        $52=(($5+($51<<2))|0);
        $53=((HEAP32[(($52)>>2)])|0);
        HEAP32[(($29)>>2)]=$53;
        HEAP32[(($52)>>2)]=$k_0153;
        $54=($40|0)>($45|0);
        if ($54) {
         break;
        } else {
         $i_0150=$40;
        }
        while(1) {

         $55=((HEAP32[((14480)>>2)])|0);
         $56=(($55+($i_0150<<2))|0);
         $57=((HEAP32[(($56)>>2)])|0);
         $58=((HEAP32[((14992)>>2)])|0);
         $59=(($58+($i_0150<<2))|0);
         $60=((HEAP32[(($59)>>2)])|0);
         $61=(($Aij+($60<<3))|0);
         $62=(+(HEAPF64[(($61)>>3)]));
         $63=($37)*($62);
         $64=(($3+($57<<3))|0);
         $65=(+(HEAPF64[(($64)>>3)]));
         $66=($65)+($63);
         HEAPF64[(($64)>>3)]=$66;
         $67=((($i_0150)+(1))|0);
         $68=($67|0)>($45|0);
         if ($68) {
          break;
         } else {
          $i_0150=$67;
         }
        }
       }
      } while(0);
      $47=($30|0)==0;
      if ($47) {
       $diagj_0_lcssa=$39;
       break;
      } else {
       $k_0153=$30;$diagj_0154=$39;
      }
     }
    }

    $69=(($Aii+($j_0164<<3))|0);
    $70=(+(HEAPF64[(($69)>>3)]));
    $71=($70)-($diagj_0_lcssa);
    $72=$71>(0.0);
    if (!($72)) {
     $errcode_0=$j_0164;
     label = 26;
     break;
    }
    $74=(+(Math_sqrt($71)));
    HEAPF64[(($69)>>3)]=$74;
    $75=((HEAP32[((11992)>>2)])|0);
    $76=(($75+($j_0164<<2))|0);
    $77=((HEAP32[(($76)>>2)])|0);
    $78=((($j_0164)+(1))|0);
    $79=(($75+($78<<2))|0);
    $80=((HEAP32[(($79)>>2)])|0);
    $81=((($80)-(1))|0);
    $82=($81|0)<($77|0);
    do {
     if (!($82)) {
      $85=(($7+($j_0164<<2))|0);
      HEAP32[(($85)>>2)]=$77;
      $86=((HEAP32[((14480)>>2)])|0);
      $87=(($86+($77<<2))|0);
      $88=((HEAP32[(($87)>>2)])|0);
      $89=(($5+($88<<2))|0);
      $90=((HEAP32[(($89)>>2)])|0);
      HEAP32[(($26)>>2)]=$90;
      HEAP32[(($89)>>2)]=$j_0164;
      $91=($77|0)>($81|0);
      if ($91) {
       break;
      } else {
       $i_1158=$77;
      }
      while(1) {

       $92=((HEAP32[((14480)>>2)])|0);
       $93=(($92+($i_1158<<2))|0);
       $94=((HEAP32[(($93)>>2)])|0);
       $95=((HEAP32[((14992)>>2)])|0);
       $96=(($95+($i_1158<<2))|0);
       $97=((HEAP32[(($96)>>2)])|0);
       $98=(($Aij+($97<<3))|0);
       $99=(+(HEAPF64[(($98)>>3)]));
       $100=(($3+($94<<3))|0);
       $101=(+(HEAPF64[(($100)>>3)]));
       $102=($99)-($101);
       $103=($102)/($74);
       HEAPF64[(($98)>>3)]=$103;
       HEAPF64[(($100)>>3)]=0.0;
       $104=((($i_1158)+(1))|0);
       $105=($104|0)>($81|0);
       if ($105) {
        break;
       } else {
        $i_1158=$104;
       }
      }
     }
    } while(0);
    $83=($78|0)>($n|0);
    if ($83) {
     break;
    } else {
     $j_0164=$78;
    }
   }
   if ((label|0) == 26) {

    _free($3);
    _free($5);
    _free($7);
    return (($errcode_0)|0);
   }
   $25=($n|0)<1;
   if ($25) {
    $errcode_0=$18;

    _free($3);
    _free($5);
    _free($7);
    return (($errcode_0)|0);
   } else {
    $j_1147=1;
   }
   while(1) {

    $107=(($B+($j_1147<<3))|0);
    $108=(+(HEAPF64[(($107)>>3)]));
    $109=(($Aii+($j_1147<<3))|0);
    $110=(+(HEAPF64[(($109)>>3)]));
    $111=($108)/($110);
    HEAPF64[(($107)>>3)]=$111;
    $112=((HEAP32[((11992)>>2)])|0);
    $113=(($112+($j_1147<<2))|0);
    $114=((HEAP32[(($113)>>2)])|0);
    $115=((($j_1147)+(1))|0);
    $116=(($112+($115<<2))|0);
    $117=((HEAP32[(($116)>>2)])|0);
    $118=((($117)-(1))|0);
    $119=($114|0)>($118|0);
    if (!($119)) {
     $i_2144=$114;
     while(1) {

      $121=((HEAP32[((14480)>>2)])|0);
      $122=(($121+($i_2144<<2))|0);
      $123=((HEAP32[(($122)>>2)])|0);
      $124=((HEAP32[((14992)>>2)])|0);
      $125=(($124+($i_2144<<2))|0);
      $126=((HEAP32[(($125)>>2)])|0);
      $127=(($Aij+($126<<3))|0);
      $128=(+(HEAPF64[(($127)>>3)]));
      $129=($111)*($128);
      $130=(($B+($123<<3))|0);
      $131=(+(HEAPF64[(($130)>>3)]));
      $132=($131)-($129);
      HEAPF64[(($130)>>3)]=$132;
      $133=((($i_2144)+(1))|0);
      $134=($133|0)>($118|0);
      if ($134) {
       break;
      } else {
       $i_2144=$133;
      }
     }
    }
    $120=($115|0)>($n|0);
    if ($120) {
     break;
    } else {
     $j_1147=$115;
    }
   }
   $106=($n|0)>0;
   if ($106) {
    $j_2140=$n;
   } else {
    $errcode_0=$18;

    _free($3);
    _free($5);
    _free($7);
    return (($errcode_0)|0);
   }
   while(1) {

    $135=(($B+($j_2140<<3))|0);
    $136=(+(HEAPF64[(($135)>>3)]));
    $137=((HEAP32[((11992)>>2)])|0);
    $138=(($137+($j_2140<<2))|0);
    $139=((HEAP32[(($138)>>2)])|0);
    $140=((($j_2140)+(1))|0);
    $141=(($137+($140<<2))|0);
    $142=((HEAP32[(($141)>>2)])|0);
    $143=((($142)-(1))|0);
    $144=($139|0)>($143|0);
    if ($144) {
     $bj_1=$136;
    } else {
     $145=((HEAP32[((14480)>>2)])|0);
     $146=((HEAP32[((14992)>>2)])|0);
     $bj_0136=$136;$i_3137=$139;
     while(1) {


      $148=(($145+($i_3137<<2))|0);
      $149=((HEAP32[(($148)>>2)])|0);
      $150=(($146+($i_3137<<2))|0);
      $151=((HEAP32[(($150)>>2)])|0);
      $152=(($Aij+($151<<3))|0);
      $153=(+(HEAPF64[(($152)>>3)]));
      $154=(($B+($149<<3))|0);
      $155=(+(HEAPF64[(($154)>>3)]));
      $156=($153)*($155);
      $157=($bj_0136)-($156);
      $158=((($i_3137)+(1))|0);
      $159=($158|0)>($143|0);
      if ($159) {
       $bj_1=$157;
       break;
      } else {
       $bj_0136=$157;$i_3137=$158;
      }
     }
    }

    $160=(($Aii+($j_2140<<3))|0);
    $161=(+(HEAPF64[(($160)>>3)]));
    $162=($bj_1)/($161);
    HEAPF64[(($135)>>3)]=$162;
    $163=((($j_2140)-(1))|0);
    $164=($163|0)>0;
    if ($164) {
     $j_2140=$163;
    } else {
     $errcode_0=$18;
     break;
    }
   }

   _free($3);
   _free($5);
   _free($7);
   return (($errcode_0)|0);
  }
 } while(0);

 $20=(((-$19))|0);
 $errcode_0=$20;

 _free($3);
 _free($5);
 _free($7);
 return (($errcode_0)|0);
}



function _malloc($bytes){
 $bytes=($bytes)|0;
 var $1=0,$3=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$_sum111=0,$21=0,$22=0,$23=0;
 var $24=0,$25=0,$27=0,$28=0,$29=0,$31=0,$32=0,$33=0,$35=0,$36=0,$37=0,$40=0,$41=0,$42=0,$43=0,$_sum113114=0,$44=0,$45=0,$46=0,$47=0;
 var $48=0,$50=0,$51=0,$53=0,$55=0,$56=0,$57=0,$58=0,$59=0,$60=0,$61=0,$62=0,$63=0,$64=0,$65=0,$66=0,$67=0,$68=0,$69=0,$70=0;
 var $71=0,$72=0,$73=0,$74=0,$75=0,$76=0,$77=0,$78=0,$79=0,$80=0,$81=0,$82=0,$83=0,$84=0,$85=0,$_sum104=0,$86=0,$87=0,$88=0,$89=0;
 var $90=0,$92=0,$93=0,$94=0,$96=0,$97=0,$98=0,$100=0,$101=0,$102=0,$105=0,$106=0,$107=0,$108=0,$109=0,$110=0,$111=0,$112=0,$_sum106107=0,$113=0;
 var $114=0,$115=0,$116=0,$117=0,$118=0,$120=0,$121=0,$122=0,$123=0,$124=0,$125=0,$126=0,$127=0,$128=0,$130=0,$_sum109_pre=0,$_pre=0,$_sum110=0,$132=0,$133=0;
 var $134=0,$135=0,$136=0,$_pre_phi=0,$F4_0=0,$139=0,$140=0,$141=0,$143=0,$145=0,$146=0,$148=0,$149=0,$150=0,$151=0,$152=0,$153=0,$154=0,$155=0,$156=0;
 var $157=0,$158=0,$159=0,$160=0,$161=0,$162=0,$163=0,$164=0,$165=0,$166=0,$167=0,$168=0,$169=0,$170=0,$171=0,$172=0,$173=0,$174=0,$175=0,$176=0;
 var $rsize_0_i=0,$v_0_i=0,$t_0_i=0,$178=0,$179=0,$180=0,$182=0,$183=0,$184=0,$185=0,$186=0,$187=0,$188=0,$189=0,$190=0,$_rsize_0_i=0,$_v_0_i=0,$192=0,$193=0,$194=0;
 var $196=0,$197=0,$198=0,$200=0,$201=0,$202=0,$203=0,$204=0,$206=0,$207=0,$208=0,$209=0,$211=0,$212=0,$213=0,$215=0,$216=0,$217=0,$220=0,$221=0;
 var $222=0,$224=0,$225=0,$226=0,$RP_0_i=0,$R_0_i=0,$227=0,$228=0,$229=0,$231=0,$232=0,$233=0,$235=0,$236=0,$R_1_i=0,$240=0,$242=0,$243=0,$244=0,$245=0;
 var $246=0,$cond_i=0,$248=0,$249=0,$250=0,$251=0,$252=0,$254=0,$255=0,$256=0,$258=0,$259=0,$260=0,$263=0,$266=0,$268=0,$269=0,$270=0,$272=0,$273=0;
 var $274=0,$275=0,$277=0,$278=0,$279=0,$281=0,$282=0,$285=0,$286=0,$287=0,$289=0,$290=0,$291=0,$293=0,$294=0,$298=0,$300=0,$301=0,$302=0,$_sum4_i=0;
 var $303=0,$304=0,$305=0,$306=0,$308=0,$309=0,$310=0,$_sum_i137=0,$311=0,$312=0,$_sum1_i=0,$313=0,$314=0,$315=0,$316=0,$318=0,$319=0,$320=0,$321=0,$322=0;
 var $323=0,$324=0,$325=0,$326=0,$328=0,$_sum2_pre_i=0,$_pre_i=0,$_sum3_i=0,$330=0,$331=0,$332=0,$333=0,$334=0,$_pre_phi_i=0,$F1_0_i=0,$337=0,$338=0,$339=0,$342=0,$343=0;
 var $344=0,$346=0,$348=0,$349=0,$350=0,$351=0,$353=0,$354=0,$355=0,$357=0,$359=0,$360=0,$361=0,$362=0,$363=0,$364=0,$365=0,$366=0,$367=0,$368=0;
 var $369=0,$370=0,$371=0,$372=0,$373=0,$374=0,$375=0,$376=0,$377=0,$378=0,$379=0,$380=0,$idx_0_i=0,$382=0,$383=0,$384=0,$386=0,$388=0,$389=0,$391=0;
 var $392=0,$rst_0_i=0,$sizebits_0_i=0,$t_0_i116=0,$rsize_0_i117=0,$v_0_i118=0,$394=0,$395=0,$396=0,$397=0,$398=0,$400=0,$rsize_1_i=0,$v_1_i=0,$402=0,$403=0,$404=0,$405=0,$406=0,$407=0;
 var $408=0,$or_cond_i=0,$rst_1_i=0,$409=0,$410=0,$t_1_i=0,$rsize_2_i=0,$v_2_i=0,$411=0,$412=0,$or_cond21_i=0,$414=0,$415=0,$416=0,$417=0,$418=0,$420=0,$421=0,$422=0,$423=0;
 var $424=0,$425=0,$426=0,$427=0,$428=0,$429=0,$430=0,$431=0,$432=0,$433=0,$434=0,$435=0,$436=0,$437=0,$438=0,$439=0,$440=0,$441=0,$442=0,$443=0;
 var $444=0,$t_2_ph_i=0,$445=0,$v_330_i=0,$rsize_329_i=0,$t_228_i=0,$446=0,$447=0,$448=0,$449=0,$450=0,$_rsize_3_i=0,$t_2_v_3_i=0,$451=0,$452=0,$453=0,$454=0,$455=0,$456=0,$v_3_lcssa_i=0;
 var $rsize_3_lcssa_i=0,$457=0,$459=0,$460=0,$461=0,$463=0,$464=0,$465=0,$467=0,$468=0,$469=0,$471=0,$472=0,$473=0,$474=0,$475=0,$477=0,$478=0,$479=0,$480=0;
 var $482=0,$483=0,$484=0,$486=0,$487=0,$488=0,$491=0,$492=0,$493=0,$495=0,$496=0,$497=0,$RP_0_i119=0,$R_0_i120=0,$498=0,$499=0,$500=0,$502=0,$503=0,$504=0;
 var $506=0,$507=0,$R_1_i122=0,$511=0,$513=0,$514=0,$515=0,$516=0,$517=0,$cond_i123=0,$519=0,$520=0,$521=0,$522=0,$523=0,$525=0,$526=0,$527=0,$529=0,$530=0;
 var $531=0,$534=0,$537=0,$539=0,$540=0,$541=0,$543=0,$544=0,$545=0,$546=0,$548=0,$549=0,$550=0,$552=0,$553=0,$556=0,$557=0,$558=0,$560=0,$561=0;
 var $562=0,$564=0,$565=0,$569=0,$571=0,$572=0,$573=0,$_sum19_i=0,$574=0,$575=0,$576=0,$577=0,$579=0,$580=0,$581=0,$_sum_i125136=0,$582=0,$583=0,$_sum1_i126=0,$584=0;
 var $585=0,$586=0,$587=0,$589=0,$590=0,$591=0,$592=0,$593=0,$594=0,$595=0,$597=0,$_sum15_pre_i=0,$_pre_i127=0,$_sum18_i=0,$599=0,$600=0,$601=0,$602=0,$603=0,$_pre_phi_i128=0;
 var $F5_0_i=0,$606=0,$_sum16_i=0,$607=0,$608=0,$_sum17_i=0,$609=0,$610=0,$612=0,$613=0,$614=0,$616=0,$618=0,$619=0,$620=0,$621=0,$622=0,$623=0,$624=0,$625=0;
 var $626=0,$627=0,$628=0,$629=0,$630=0,$631=0,$632=0,$633=0,$634=0,$635=0,$636=0,$637=0,$638=0,$639=0,$I7_0_i=0,$641=0,$_sum2_i=0,$642=0,$643=0,$_sum3_i129=0;
 var $644=0,$_sum4_i130=0,$645=0,$646=0,$647=0,$648=0,$649=0,$650=0,$651=0,$653=0,$654=0,$_sum5_i=0,$655=0,$656=0,$_sum6_i=0,$657=0,$658=0,$_sum7_i=0,$659=0,$660=0;
 var $662=0,$663=0,$665=0,$666=0,$668=0,$669=0,$T_0_i=0,$K12_0_i=0,$671=0,$672=0,$673=0,$674=0,$676=0,$677=0,$678=0,$679=0,$680=0,$682=0,$683=0,$684=0;
 var $_sum12_i=0,$686=0,$687=0,$_sum13_i=0,$688=0,$689=0,$_sum14_i=0,$690=0,$691=0,$694=0,$695=0,$696=0,$697=0,$698=0,$700=0,$701=0,$703=0,$_sum9_i=0,$704=0,$705=0;
 var $_sum10_i=0,$706=0,$707=0,$_sum11_i=0,$708=0,$709=0,$711=0,$712=0,$713=0,$nb_0=0,$714=0,$715=0,$717=0,$718=0,$719=0,$721=0,$722=0,$723=0,$724=0,$_sum102=0;
 var $725=0,$726=0,$727=0,$728=0,$729=0,$730=0,$732=0,$733=0,$734=0,$_sum101=0,$735=0,$736=0,$737=0,$738=0,$740=0,$741=0,$743=0,$744=0,$746=0,$747=0;
 var $748=0,$749=0,$750=0,$751=0,$_sum=0,$752=0,$753=0,$754=0,$755=0,$756=0,$757=0,$759=0,$760=0,$762=0,$763=0,$764=0,$765=0,$767=0,$768=0,$769=0;
 var $771=0,$772=0,$773=0,$774=0,$775=0,$776=0,$777=0,$779=0,$780=0,$782=0,$783=0,$784=0,$785=0,$or_cond1_i=0,$787=0,$788=0,$789=0,$791=0,$792=0,$794=0;
 var $sp_0_i_i=0,$796=0,$797=0,$798=0,$800=0,$801=0,$802=0,$803=0,$805=0,$806=0,$807=0,$808=0,$809=0,$810=0,$812=0,$813=0,$814=0,$815=0,$816=0,$818=0;
 var $819=0,$820=0,$821=0,$822=0,$ssize_0_i=0,$824=0,$825=0,$826=0,$827=0,$or_cond_i131=0,$829=0,$830=0,$832=0,$833=0,$or_cond2_i=0,$835=0,$836=0,$ssize_0__i=0,$__i=0,$838=0;
 var $839=0,$840=0,$841=0,$843=0,$844=0,$845=0,$846=0,$847=0,$_3_i=0,$_4_i=0,$ssize_1_i=0,$br_0_i=0,$tsize_0_i=0,$tbase_0_i=0,$849=0,$850=0,$852=0,$853=0,$or_cond5_i=0,$854=0;
 var $or_cond6_i=0,$856=0,$857=0,$858=0,$859=0,$860=0,$861=0,$863=0,$864=0,$866=0,$868=0,$ssize_2_i=0,$870=0,$tsize_0303639_i=0,$871=0,$872=0,$tsize_1_i=0,$874=0,$876=0,$877=0;
 var $notlhs_i=0,$notrhs_i=0,$or_cond8_not_i=0,$878=0,$or_cond9_i=0,$879=0,$880=0,$881=0,$882=0,$883=0,$_tsize_1_i=0,$_tbase_1_i=0,$884=0,$tbase_245_i=0,$tsize_244_i=0,$885=0,$886=0,$887=0,$888=0,$890=0;
 var $891=0,$893=0,$894=0,$895=0,$or_cond10_i=0,$897=0,$i_02_i_i=0,$899=0,$900=0,$901=0,$_sum_i_i=0,$902=0,$_sum1_i_i=0,$903=0,$904=0,$905=0,$906=0,$907=0,$908=0,$909=0;
 var $910=0,$912=0,$913=0,$914=0,$915=0,$916=0,$917=0,$918=0,$_sum_i14_i=0,$919=0,$920=0,$_sum2_i_i=0,$921=0,$922=0,$923=0,$sp_067_i=0,$924=0,$925=0,$926=0,$927=0;
 var $928=0,$929=0,$931=0,$932=0,$933=0,$934=0,$935=0,$936=0,$937=0,$939=0,$940=0,$941=0,$or_cond47_i=0,$943=0,$944=0,$945=0,$946=0,$947=0,$948=0,$949=0;
 var $950=0,$951=0,$953=0,$954=0,$955=0,$956=0,$957=0,$958=0,$959=0,$_sum_i18_i=0,$960=0,$961=0,$_sum2_i19_i=0,$962=0,$963=0,$964=0,$965=0,$966=0,$968=0,$sp_160_i=0;
 var $970=0,$971=0,$972=0,$974=0,$975=0,$976=0,$977=0,$978=0,$979=0,$980=0,$982=0,$983=0,$984=0,$985=0,$986=0,$987=0,$988=0,$990=0,$991=0,$993=0;
 var $994=0,$_sum93_i=0,$995=0,$996=0,$997=0,$998=0,$1000=0,$1001=0,$1003=0,$_sum94_i=0,$1004=0,$1005=0,$1006=0,$1007=0,$1008=0,$_sum_i21_i=0,$1009=0,$1010=0,$1011=0,$1012=0;
 var $_sum1_i22_i=0,$1013=0,$1014=0,$1015=0,$1016=0,$1018=0,$1019=0,$1020=0,$_sum46_i_i=0,$1021=0,$1022=0,$1024=0,$1025=0,$1027=0,$1028=0,$1029=0,$_sum44_i_i=0,$1030=0,$1031=0,$_sum45_i_i=0;
 var $1032=0,$1033=0,$_sum2_i23_i=0,$_sum95_i=0,$1035=0,$1036=0,$1037=0,$1038=0,$1039=0,$1041=0,$1042=0,$1043=0,$_sum3940_i_i=0,$_sum105_i=0,$1045=0,$1046=0,$1047=0,$_sum41_i_i=0,$_sum106_i=0,$1048=0;
 var $1049=0,$1050=0,$1051=0,$1052=0,$1053=0,$1054=0,$1056=0,$1057=0,$1058=0,$1060=0,$1061=0,$1062=0,$1063=0,$1065=0,$1066=0,$1067=0,$1068=0,$1070=0,$_pre56_i_i=0,$1072=0;
 var $1073=0,$1074=0,$1076=0,$1077=0,$1078=0,$_pre_phi57_i_i=0,$1079=0,$1081=0,$_sum34_i_i=0,$_sum96_i=0,$1082=0,$1083=0,$1084=0,$_sum5_i_i=0,$_sum97_i=0,$1085=0,$1086=0,$1087=0,$1088=0,$_sum3637_i_i=0;
 var $_sum98_i=0,$1090=0,$1091=0,$1092=0,$1093=0,$1094=0,$1095=0,$1097=0,$1098=0,$1099=0,$1101=0,$1102=0,$1103=0,$_sum67_i_i=0,$_sum103_i=0,$1106=0,$1107=0,$1108=0,$1109=0,$_sum104_i=0;
 var $1111=0,$1112=0,$1113=0,$1114=0,$RP_0_i_i=0,$R_0_i_i=0,$1115=0,$1116=0,$1117=0,$1119=0,$1120=0,$1121=0,$1123=0,$1124=0,$1125=0,$R_1_i_i=0,$1129=0,$_sum31_i_i=0,$_sum99_i=0,$1131=0;
 var $1132=0,$1133=0,$1134=0,$1135=0,$1136=0,$cond_i_i=0,$1138=0,$1139=0,$1140=0,$1141=0,$1142=0,$1144=0,$1145=0,$1146=0,$1148=0,$1149=0,$1150=0,$1153=0,$1156=0,$1158=0;
 var $1159=0,$1160=0,$1162=0,$_sum3233_i_i=0,$_sum100_i=0,$1163=0,$1164=0,$1165=0,$1166=0,$1168=0,$1169=0,$1170=0,$1172=0,$1173=0,$_sum101_i=0,$1176=0,$1177=0,$1178=0,$1179=0,$1181=0;
 var $1182=0,$1183=0,$1185=0,$1186=0,$_sum9_i_i=0,$_sum102_i=0,$1190=0,$1191=0,$1192=0,$qsize_0_i_i=0,$oldfirst_0_i_i=0,$1194=0,$1195=0,$1196=0,$1197=0,$_sum10_i_i=0,$1198=0,$1199=0,$_sum11_i_i=0,$1200=0;
 var $1201=0,$1202=0,$1203=0,$1205=0,$1206=0,$1207=0,$1208=0,$1209=0,$1210=0,$1211=0,$1213=0,$_sum27_pre_i_i=0,$_pre_i24_i=0,$_sum30_i_i=0,$1215=0,$1216=0,$1217=0,$1218=0,$1219=0,$_pre_phi_i25_i=0;
 var $F4_0_i_i=0,$1222=0,$_sum28_i_i=0,$1223=0,$1224=0,$_sum29_i_i=0,$1225=0,$1226=0,$1228=0,$1229=0,$1230=0,$1232=0,$1234=0,$1235=0,$1236=0,$1237=0,$1238=0,$1239=0,$1240=0,$1241=0;
 var $1242=0,$1243=0,$1244=0,$1245=0,$1246=0,$1247=0,$1248=0,$1249=0,$1250=0,$1251=0,$1252=0,$1253=0,$1254=0,$1255=0,$I7_0_i_i=0,$1257=0,$_sum12_i26_i=0,$1258=0,$1259=0,$_sum13_i_i=0;
 var $1260=0,$_sum14_i_i=0,$1261=0,$1262=0,$1263=0,$1264=0,$1265=0,$1266=0,$1267=0,$1269=0,$1270=0,$_sum15_i_i=0,$1271=0,$1272=0,$_sum16_i_i=0,$1273=0,$1274=0,$_sum17_i_i=0,$1275=0,$1276=0;
 var $1278=0,$1279=0,$1281=0,$1282=0,$1284=0,$1285=0,$T_0_i27_i=0,$K8_0_i_i=0,$1287=0,$1288=0,$1289=0,$1290=0,$1292=0,$1293=0,$1294=0,$1295=0,$1296=0,$1298=0,$1299=0,$1300=0;
 var $_sum24_i_i=0,$1302=0,$1303=0,$_sum25_i_i=0,$1304=0,$1305=0,$_sum26_i_i=0,$1306=0,$1307=0,$1310=0,$1311=0,$1312=0,$1313=0,$1314=0,$1316=0,$1317=0,$1319=0,$_sum21_i_i=0,$1320=0,$1321=0;
 var $_sum22_i_i=0,$1322=0,$1323=0,$_sum23_i_i=0,$1324=0,$1325=0,$_sum1819_i_i=0,$1326=0,$1327=0,$sp_0_i_i_i=0,$1329=0,$1330=0,$1331=0,$1333=0,$1334=0,$1335=0,$1336=0,$1338=0,$1339=0,$_sum_i15_i=0;
 var $_sum1_i16_i=0,$1340=0,$1341=0,$1342=0,$1343=0,$1345=0,$1346=0,$1348=0,$_sum2_i17_i=0,$1349=0,$1350=0,$1351=0,$1352=0,$1353=0,$1354=0,$1355=0,$1356=0,$1357=0,$1358=0,$1359=0;
 var $1360=0,$1362=0,$1363=0,$1364=0,$1365=0,$1366=0,$1367=0,$1368=0,$_sum_i_i_i=0,$1369=0,$1370=0,$_sum2_i_i_i=0,$1371=0,$1372=0,$1373=0,$1374=0,$1375=0,$1376=0,$1377=0,$1378=0;
 var $1379=0,$1380=0,$1381=0,$1382=0,$1383=0,$1384=0,$1385=0,$1387=0,$1388=0,$1389=0,$1390=0,$_sum3_i_i=0,$1391=0,$1392=0,$1393=0,$1394=0,$1395=0,$1396=0,$1397=0,$1398=0;
 var $1399=0,$1401=0,$1402=0,$1403=0,$1404=0,$1405=0,$1406=0,$1407=0,$1409=0,$_sum11_pre_i_i=0,$_pre_i_i=0,$_sum12_i_i=0,$1411=0,$1412=0,$1413=0,$1414=0,$1415=0,$_pre_phi_i_i=0,$F_0_i_i=0,$1418=0;
 var $1419=0,$1420=0,$1422=0,$1423=0,$1424=0,$1426=0,$1428=0,$1429=0,$1430=0,$1431=0,$1432=0,$1433=0,$1434=0,$1435=0,$1436=0,$1437=0,$1438=0,$1439=0,$1440=0,$1441=0;
 var $1442=0,$1443=0,$1444=0,$1445=0,$1446=0,$1447=0,$1448=0,$1449=0,$I1_0_i_i=0,$1451=0,$1452=0,$I1_0_c_i_i=0,$1453=0,$1454=0,$1455=0,$1456=0,$1457=0,$1458=0,$1460=0,$1461=0;
 var $_c_i_i=0,$1462=0,$1463=0,$1465=0,$1466=0,$1468=0,$1469=0,$1471=0,$1472=0,$T_0_i_i=0,$K2_0_i_i=0,$1474=0,$1475=0,$1476=0,$1477=0,$1479=0,$1480=0,$1481=0,$1482=0,$1483=0;
 var $1485=0,$1486=0,$1487=0,$1489=0,$T_0_c8_i_i=0,$1490=0,$1491=0,$1494=0,$1495=0,$1496=0,$1497=0,$1498=0,$1500=0,$1501=0,$1503=0,$1504=0,$_c7_i_i=0,$1505=0,$T_0_c_i_i=0,$1506=0;
 var $1507=0,$1508=0,$1510=0,$1511=0,$1512=0,$1513=0,$1514=0,$1515=0,$_sum_i134=0,$1516=0,$1517=0,$1518=0,$1519=0,$1520=0,$1521=0,$1522=0,$mem_0=0,label=0;

 $1=($bytes>>>0)<((245)>>>0);
 do {
  if ($1) {
   $3=($bytes>>>0)<((11)>>>0);
   if ($3) {
    $8=16;
   } else {
    $5=((($bytes)+(11))|0);
    $6=$5&-8;
    $8=$6;
   }

   $9=$8>>>3;
   $10=((HEAP32[((11512)>>2)])|0);
   $11=$10>>>($9>>>0);
   $12=$11&3;
   $13=($12|0)==0;
   if (!($13)) {
    $15=$11&1;
    $16=$15^1;
    $17=((($16)+($9))|0);
    $18=$17<<1;
    $19=((11552+($18<<2))|0);
    $20=$19;
    $_sum111=((($18)+(2))|0);
    $21=((11552+($_sum111<<2))|0);
    $22=((HEAP32[(($21)>>2)])|0);
    $23=(($22+8)|0);
    $24=((HEAP32[(($23)>>2)])|0);
    $25=($20|0)==($24|0);
    do {
     if ($25) {
      $27=1<<$17;
      $28=$27^-1;
      $29=$10&$28;
      HEAP32[((11512)>>2)]=$29;
     } else {
      $31=$24;
      $32=((HEAP32[((11528)>>2)])|0);
      $33=($31>>>0)<($32>>>0);
      if ($33) {
       _abort(); return ((0)|0);
      }
      $35=(($24+12)|0);
      $36=((HEAP32[(($35)>>2)])|0);
      $37=($36|0)==($22|0);
      if ($37) {
       HEAP32[(($35)>>2)]=$20;
       HEAP32[(($21)>>2)]=$24;
       break;
      } else {
       _abort(); return ((0)|0);
      }
     }
    } while(0);
    $40=$17<<3;
    $41=$40|3;
    $42=(($22+4)|0);
    HEAP32[(($42)>>2)]=$41;
    $43=$22;
    $_sum113114=$40|4;
    $44=(($43+$_sum113114)|0);
    $45=$44;
    $46=((HEAP32[(($45)>>2)])|0);
    $47=$46|1;
    HEAP32[(($45)>>2)]=$47;
    $48=$23;
    $mem_0=$48;

    return (($mem_0)|0);
   }
   $50=((HEAP32[((11520)>>2)])|0);
   $51=($8>>>0)>($50>>>0);
   if (!($51)) {
    $nb_0=$8;
    break;
   }
   $53=($11|0)==0;
   if (!($53)) {
    $55=$11<<$9;
    $56=2<<$9;
    $57=(((-$56))|0);
    $58=$56|$57;
    $59=$55&$58;
    $60=(((-$59))|0);
    $61=$59&$60;
    $62=((($61)-(1))|0);
    $63=$62>>>12;
    $64=$63&16;
    $65=$62>>>($64>>>0);
    $66=$65>>>5;
    $67=$66&8;
    $68=$67|$64;
    $69=$65>>>($67>>>0);
    $70=$69>>>2;
    $71=$70&4;
    $72=$68|$71;
    $73=$69>>>($71>>>0);
    $74=$73>>>1;
    $75=$74&2;
    $76=$72|$75;
    $77=$73>>>($75>>>0);
    $78=$77>>>1;
    $79=$78&1;
    $80=$76|$79;
    $81=$77>>>($79>>>0);
    $82=((($80)+($81))|0);
    $83=$82<<1;
    $84=((11552+($83<<2))|0);
    $85=$84;
    $_sum104=((($83)+(2))|0);
    $86=((11552+($_sum104<<2))|0);
    $87=((HEAP32[(($86)>>2)])|0);
    $88=(($87+8)|0);
    $89=((HEAP32[(($88)>>2)])|0);
    $90=($85|0)==($89|0);
    do {
     if ($90) {
      $92=1<<$82;
      $93=$92^-1;
      $94=$10&$93;
      HEAP32[((11512)>>2)]=$94;
     } else {
      $96=$89;
      $97=((HEAP32[((11528)>>2)])|0);
      $98=($96>>>0)<($97>>>0);
      if ($98) {
       _abort(); return ((0)|0);
      }
      $100=(($89+12)|0);
      $101=((HEAP32[(($100)>>2)])|0);
      $102=($101|0)==($87|0);
      if ($102) {
       HEAP32[(($100)>>2)]=$85;
       HEAP32[(($86)>>2)]=$89;
       break;
      } else {
       _abort(); return ((0)|0);
      }
     }
    } while(0);
    $105=$82<<3;
    $106=((($105)-($8))|0);
    $107=$8|3;
    $108=(($87+4)|0);
    HEAP32[(($108)>>2)]=$107;
    $109=$87;
    $110=(($109+$8)|0);
    $111=$110;
    $112=$106|1;
    $_sum106107=$8|4;
    $113=(($109+$_sum106107)|0);
    $114=$113;
    HEAP32[(($114)>>2)]=$112;
    $115=(($109+$105)|0);
    $116=$115;
    HEAP32[(($116)>>2)]=$106;
    $117=((HEAP32[((11520)>>2)])|0);
    $118=($117|0)==0;
    if (!($118)) {
     $120=((HEAP32[((11532)>>2)])|0);
     $121=$117>>>3;
     $122=$121<<1;
     $123=((11552+($122<<2))|0);
     $124=$123;
     $125=((HEAP32[((11512)>>2)])|0);
     $126=1<<$121;
     $127=$125&$126;
     $128=($127|0)==0;
     do {
      if ($128) {
       $130=$125|$126;
       HEAP32[((11512)>>2)]=$130;
       $_sum109_pre=((($122)+(2))|0);
       $_pre=((11552+($_sum109_pre<<2))|0);
       $F4_0=$124;$_pre_phi=$_pre;
      } else {
       $_sum110=((($122)+(2))|0);
       $132=((11552+($_sum110<<2))|0);
       $133=((HEAP32[(($132)>>2)])|0);
       $134=$133;
       $135=((HEAP32[((11528)>>2)])|0);
       $136=($134>>>0)<($135>>>0);
       if (!($136)) {
        $F4_0=$133;$_pre_phi=$132;
        break;
       }
       _abort(); return ((0)|0);
      }
     } while(0);


     HEAP32[(($_pre_phi)>>2)]=$120;
     $139=(($F4_0+12)|0);
     HEAP32[(($139)>>2)]=$120;
     $140=(($120+8)|0);
     HEAP32[(($140)>>2)]=$F4_0;
     $141=(($120+12)|0);
     HEAP32[(($141)>>2)]=$124;
    }
    HEAP32[((11520)>>2)]=$106;
    HEAP32[((11532)>>2)]=$111;
    $143=$88;
    $mem_0=$143;

    return (($mem_0)|0);
   }
   $145=((HEAP32[((11516)>>2)])|0);
   $146=($145|0)==0;
   if ($146) {
    $nb_0=$8;
    break;
   }
   $148=(((-$145))|0);
   $149=$145&$148;
   $150=((($149)-(1))|0);
   $151=$150>>>12;
   $152=$151&16;
   $153=$150>>>($152>>>0);
   $154=$153>>>5;
   $155=$154&8;
   $156=$155|$152;
   $157=$153>>>($155>>>0);
   $158=$157>>>2;
   $159=$158&4;
   $160=$156|$159;
   $161=$157>>>($159>>>0);
   $162=$161>>>1;
   $163=$162&2;
   $164=$160|$163;
   $165=$161>>>($163>>>0);
   $166=$165>>>1;
   $167=$166&1;
   $168=$164|$167;
   $169=$165>>>($167>>>0);
   $170=((($168)+($169))|0);
   $171=((11816+($170<<2))|0);
   $172=((HEAP32[(($171)>>2)])|0);
   $173=(($172+4)|0);
   $174=((HEAP32[(($173)>>2)])|0);
   $175=$174&-8;
   $176=((($175)-($8))|0);
   $t_0_i=$172;$v_0_i=$172;$rsize_0_i=$176;
   while(1) {



    $178=(($t_0_i+16)|0);
    $179=((HEAP32[(($178)>>2)])|0);
    $180=($179|0)==0;
    if ($180) {
     $182=(($t_0_i+20)|0);
     $183=((HEAP32[(($182)>>2)])|0);
     $184=($183|0)==0;
     if ($184) {
      break;
     } else {
      $185=$183;
     }
    } else {
     $185=$179;
    }

    $186=(($185+4)|0);
    $187=((HEAP32[(($186)>>2)])|0);
    $188=$187&-8;
    $189=((($188)-($8))|0);
    $190=($189>>>0)<($rsize_0_i>>>0);
    $_rsize_0_i=($190?$189:$rsize_0_i);
    $_v_0_i=($190?$185:$v_0_i);
    $t_0_i=$185;$v_0_i=$_v_0_i;$rsize_0_i=$_rsize_0_i;
   }
   $192=$v_0_i;
   $193=((HEAP32[((11528)>>2)])|0);
   $194=($192>>>0)<($193>>>0);
   if ($194) {
    _abort(); return ((0)|0);
   }
   $196=(($192+$8)|0);
   $197=$196;
   $198=($192>>>0)<($196>>>0);
   if (!($198)) {
    _abort(); return ((0)|0);
   }
   $200=(($v_0_i+24)|0);
   $201=((HEAP32[(($200)>>2)])|0);
   $202=(($v_0_i+12)|0);
   $203=((HEAP32[(($202)>>2)])|0);
   $204=($203|0)==($v_0_i|0);
   do {
    if ($204) {
     $220=(($v_0_i+20)|0);
     $221=((HEAP32[(($220)>>2)])|0);
     $222=($221|0)==0;
     if ($222) {
      $224=(($v_0_i+16)|0);
      $225=((HEAP32[(($224)>>2)])|0);
      $226=($225|0)==0;
      if ($226) {
       $R_1_i=0;
       break;
      } else {
       $R_0_i=$225;$RP_0_i=$224;
      }
     } else {
      $R_0_i=$221;$RP_0_i=$220;
     }
     while(1) {


      $227=(($R_0_i+20)|0);
      $228=((HEAP32[(($227)>>2)])|0);
      $229=($228|0)==0;
      if (!($229)) {
       $R_0_i=$228;$RP_0_i=$227;
       continue;
      }
      $231=(($R_0_i+16)|0);
      $232=((HEAP32[(($231)>>2)])|0);
      $233=($232|0)==0;
      if ($233) {
       break;
      } else {
       $R_0_i=$232;$RP_0_i=$231;
      }
     }
     $235=$RP_0_i;
     $236=($235>>>0)<($193>>>0);
     if ($236) {
      _abort(); return ((0)|0);
     } else {
      HEAP32[(($RP_0_i)>>2)]=0;
      $R_1_i=$R_0_i;
      break;
     }
    } else {
     $206=(($v_0_i+8)|0);
     $207=((HEAP32[(($206)>>2)])|0);
     $208=$207;
     $209=($208>>>0)<($193>>>0);
     if ($209) {
      _abort(); return ((0)|0);
     }
     $211=(($207+12)|0);
     $212=((HEAP32[(($211)>>2)])|0);
     $213=($212|0)==($v_0_i|0);
     if (!($213)) {
      _abort(); return ((0)|0);
     }
     $215=(($203+8)|0);
     $216=((HEAP32[(($215)>>2)])|0);
     $217=($216|0)==($v_0_i|0);
     if ($217) {
      HEAP32[(($211)>>2)]=$203;
      HEAP32[(($215)>>2)]=$207;
      $R_1_i=$203;
      break;
     } else {
      _abort(); return ((0)|0);
     }
    }
   } while(0);

   $240=($201|0)==0;
   L78: do {
    if (!($240)) {
     $242=(($v_0_i+28)|0);
     $243=((HEAP32[(($242)>>2)])|0);
     $244=((11816+($243<<2))|0);
     $245=((HEAP32[(($244)>>2)])|0);
     $246=($v_0_i|0)==($245|0);
     do {
      if ($246) {
       HEAP32[(($244)>>2)]=$R_1_i;
       $cond_i=($R_1_i|0)==0;
       if (!($cond_i)) {
        break;
       }
       $248=((HEAP32[(($242)>>2)])|0);
       $249=1<<$248;
       $250=$249^-1;
       $251=((HEAP32[((11516)>>2)])|0);
       $252=$251&$250;
       HEAP32[((11516)>>2)]=$252;
       break L78;
      } else {
       $254=$201;
       $255=((HEAP32[((11528)>>2)])|0);
       $256=($254>>>0)<($255>>>0);
       if ($256) {
        _abort(); return ((0)|0);
       }
       $258=(($201+16)|0);
       $259=((HEAP32[(($258)>>2)])|0);
       $260=($259|0)==($v_0_i|0);
       if ($260) {
        HEAP32[(($258)>>2)]=$R_1_i;
       } else {
        $263=(($201+20)|0);
        HEAP32[(($263)>>2)]=$R_1_i;
       }
       $266=($R_1_i|0)==0;
       if ($266) {
        break L78;
       }
      }
     } while(0);
     $268=$R_1_i;
     $269=((HEAP32[((11528)>>2)])|0);
     $270=($268>>>0)<($269>>>0);
     if ($270) {
      _abort(); return ((0)|0);
     }
     $272=(($R_1_i+24)|0);
     HEAP32[(($272)>>2)]=$201;
     $273=(($v_0_i+16)|0);
     $274=((HEAP32[(($273)>>2)])|0);
     $275=($274|0)==0;
     do {
      if (!($275)) {
       $277=$274;
       $278=((HEAP32[((11528)>>2)])|0);
       $279=($277>>>0)<($278>>>0);
       if ($279) {
        _abort(); return ((0)|0);
       } else {
        $281=(($R_1_i+16)|0);
        HEAP32[(($281)>>2)]=$274;
        $282=(($274+24)|0);
        HEAP32[(($282)>>2)]=$R_1_i;
        break;
       }
      }
     } while(0);
     $285=(($v_0_i+20)|0);
     $286=((HEAP32[(($285)>>2)])|0);
     $287=($286|0)==0;
     if ($287) {
      break;
     }
     $289=$286;
     $290=((HEAP32[((11528)>>2)])|0);
     $291=($289>>>0)<($290>>>0);
     if ($291) {
      _abort(); return ((0)|0);
     } else {
      $293=(($R_1_i+20)|0);
      HEAP32[(($293)>>2)]=$286;
      $294=(($286+24)|0);
      HEAP32[(($294)>>2)]=$R_1_i;
      break;
     }
    }
   } while(0);
   $298=($rsize_0_i>>>0)<((16)>>>0);
   if ($298) {
    $300=((($rsize_0_i)+($8))|0);
    $301=$300|3;
    $302=(($v_0_i+4)|0);
    HEAP32[(($302)>>2)]=$301;
    $_sum4_i=((($300)+(4))|0);
    $303=(($192+$_sum4_i)|0);
    $304=$303;
    $305=((HEAP32[(($304)>>2)])|0);
    $306=$305|1;
    HEAP32[(($304)>>2)]=$306;
   } else {
    $308=$8|3;
    $309=(($v_0_i+4)|0);
    HEAP32[(($309)>>2)]=$308;
    $310=$rsize_0_i|1;
    $_sum_i137=$8|4;
    $311=(($192+$_sum_i137)|0);
    $312=$311;
    HEAP32[(($312)>>2)]=$310;
    $_sum1_i=((($rsize_0_i)+($8))|0);
    $313=(($192+$_sum1_i)|0);
    $314=$313;
    HEAP32[(($314)>>2)]=$rsize_0_i;
    $315=((HEAP32[((11520)>>2)])|0);
    $316=($315|0)==0;
    if (!($316)) {
     $318=((HEAP32[((11532)>>2)])|0);
     $319=$315>>>3;
     $320=$319<<1;
     $321=((11552+($320<<2))|0);
     $322=$321;
     $323=((HEAP32[((11512)>>2)])|0);
     $324=1<<$319;
     $325=$323&$324;
     $326=($325|0)==0;
     do {
      if ($326) {
       $328=$323|$324;
       HEAP32[((11512)>>2)]=$328;
       $_sum2_pre_i=((($320)+(2))|0);
       $_pre_i=((11552+($_sum2_pre_i<<2))|0);
       $F1_0_i=$322;$_pre_phi_i=$_pre_i;
      } else {
       $_sum3_i=((($320)+(2))|0);
       $330=((11552+($_sum3_i<<2))|0);
       $331=((HEAP32[(($330)>>2)])|0);
       $332=$331;
       $333=((HEAP32[((11528)>>2)])|0);
       $334=($332>>>0)<($333>>>0);
       if (!($334)) {
        $F1_0_i=$331;$_pre_phi_i=$330;
        break;
       }
       _abort(); return ((0)|0);
      }
     } while(0);


     HEAP32[(($_pre_phi_i)>>2)]=$318;
     $337=(($F1_0_i+12)|0);
     HEAP32[(($337)>>2)]=$318;
     $338=(($318+8)|0);
     HEAP32[(($338)>>2)]=$F1_0_i;
     $339=(($318+12)|0);
     HEAP32[(($339)>>2)]=$322;
    }
    HEAP32[((11520)>>2)]=$rsize_0_i;
    HEAP32[((11532)>>2)]=$197;
   }
   $342=(($v_0_i+8)|0);
   $343=$342;
   $344=($342|0)==0;
   if ($344) {
    $nb_0=$8;
    break;
   } else {
    $mem_0=$343;
   }

   return (($mem_0)|0);
  } else {
   $346=($bytes>>>0)>((4294967231)>>>0);
   if ($346) {
    $nb_0=-1;
    break;
   }
   $348=((($bytes)+(11))|0);
   $349=$348&-8;
   $350=((HEAP32[((11516)>>2)])|0);
   $351=($350|0)==0;
   if ($351) {
    $nb_0=$349;
    break;
   }
   $353=(((-$349))|0);
   $354=$348>>>8;
   $355=($354|0)==0;
   do {
    if ($355) {
     $idx_0_i=0;
    } else {
     $357=($349>>>0)>((16777215)>>>0);
     if ($357) {
      $idx_0_i=31;
      break;
     }
     $359=((($354)+(1048320))|0);
     $360=$359>>>16;
     $361=$360&8;
     $362=$354<<$361;
     $363=((($362)+(520192))|0);
     $364=$363>>>16;
     $365=$364&4;
     $366=$365|$361;
     $367=$362<<$365;
     $368=((($367)+(245760))|0);
     $369=$368>>>16;
     $370=$369&2;
     $371=$366|$370;
     $372=(((14)-($371))|0);
     $373=$367<<$370;
     $374=$373>>>15;
     $375=((($372)+($374))|0);
     $376=$375<<1;
     $377=((($375)+(7))|0);
     $378=$349>>>($377>>>0);
     $379=$378&1;
     $380=$379|$376;
     $idx_0_i=$380;
    }
   } while(0);

   $382=((11816+($idx_0_i<<2))|0);
   $383=((HEAP32[(($382)>>2)])|0);
   $384=($383|0)==0;
   L126: do {
    if ($384) {
     $v_2_i=0;$rsize_2_i=$353;$t_1_i=0;
    } else {
     $386=($idx_0_i|0)==31;
     if ($386) {
      $391=0;
     } else {
      $388=$idx_0_i>>>1;
      $389=(((25)-($388))|0);
      $391=$389;
     }

     $392=$349<<$391;
     $v_0_i118=0;$rsize_0_i117=$353;$t_0_i116=$383;$sizebits_0_i=$392;$rst_0_i=0;
     while(1) {





      $394=(($t_0_i116+4)|0);
      $395=((HEAP32[(($394)>>2)])|0);
      $396=$395&-8;
      $397=((($396)-($349))|0);
      $398=($397>>>0)<($rsize_0_i117>>>0);
      if ($398) {
       $400=($396|0)==($349|0);
       if ($400) {
        $v_2_i=$t_0_i116;$rsize_2_i=$397;$t_1_i=$t_0_i116;
        break L126;
       } else {
        $v_1_i=$t_0_i116;$rsize_1_i=$397;
       }
      } else {
       $v_1_i=$v_0_i118;$rsize_1_i=$rsize_0_i117;
      }


      $402=(($t_0_i116+20)|0);
      $403=((HEAP32[(($402)>>2)])|0);
      $404=$sizebits_0_i>>>31;
      $405=(($t_0_i116+16+($404<<2))|0);
      $406=((HEAP32[(($405)>>2)])|0);
      $407=($403|0)==0;
      $408=($403|0)==($406|0);
      $or_cond_i=$407|$408;
      $rst_1_i=($or_cond_i?$rst_0_i:$403);
      $409=($406|0)==0;
      $410=$sizebits_0_i<<1;
      if ($409) {
       $v_2_i=$v_1_i;$rsize_2_i=$rsize_1_i;$t_1_i=$rst_1_i;
       break;
      } else {
       $v_0_i118=$v_1_i;$rsize_0_i117=$rsize_1_i;$t_0_i116=$406;$sizebits_0_i=$410;$rst_0_i=$rst_1_i;
      }
     }
    }
   } while(0);



   $411=($t_1_i|0)==0;
   $412=($v_2_i|0)==0;
   $or_cond21_i=$411&$412;
   if ($or_cond21_i) {
    $414=2<<$idx_0_i;
    $415=(((-$414))|0);
    $416=$414|$415;
    $417=$350&$416;
    $418=($417|0)==0;
    if ($418) {
     $nb_0=$349;
     break;
    }
    $420=(((-$417))|0);
    $421=$417&$420;
    $422=((($421)-(1))|0);
    $423=$422>>>12;
    $424=$423&16;
    $425=$422>>>($424>>>0);
    $426=$425>>>5;
    $427=$426&8;
    $428=$427|$424;
    $429=$425>>>($427>>>0);
    $430=$429>>>2;
    $431=$430&4;
    $432=$428|$431;
    $433=$429>>>($431>>>0);
    $434=$433>>>1;
    $435=$434&2;
    $436=$432|$435;
    $437=$433>>>($435>>>0);
    $438=$437>>>1;
    $439=$438&1;
    $440=$436|$439;
    $441=$437>>>($439>>>0);
    $442=((($440)+($441))|0);
    $443=((11816+($442<<2))|0);
    $444=((HEAP32[(($443)>>2)])|0);
    $t_2_ph_i=$444;
   } else {
    $t_2_ph_i=$t_1_i;
   }

   $445=($t_2_ph_i|0)==0;
   if ($445) {
    $rsize_3_lcssa_i=$rsize_2_i;$v_3_lcssa_i=$v_2_i;
   } else {
    $t_228_i=$t_2_ph_i;$rsize_329_i=$rsize_2_i;$v_330_i=$v_2_i;
    while(1) {



     $446=(($t_228_i+4)|0);
     $447=((HEAP32[(($446)>>2)])|0);
     $448=$447&-8;
     $449=((($448)-($349))|0);
     $450=($449>>>0)<($rsize_329_i>>>0);
     $_rsize_3_i=($450?$449:$rsize_329_i);
     $t_2_v_3_i=($450?$t_228_i:$v_330_i);
     $451=(($t_228_i+16)|0);
     $452=((HEAP32[(($451)>>2)])|0);
     $453=($452|0)==0;
     if (!($453)) {
      $t_228_i=$452;$rsize_329_i=$_rsize_3_i;$v_330_i=$t_2_v_3_i;
      continue;
     }
     $454=(($t_228_i+20)|0);
     $455=((HEAP32[(($454)>>2)])|0);
     $456=($455|0)==0;
     if ($456) {
      $rsize_3_lcssa_i=$_rsize_3_i;$v_3_lcssa_i=$t_2_v_3_i;
      break;
     } else {
      $t_228_i=$455;$rsize_329_i=$_rsize_3_i;$v_330_i=$t_2_v_3_i;
     }
    }
   }


   $457=($v_3_lcssa_i|0)==0;
   if ($457) {
    $nb_0=$349;
    break;
   }
   $459=((HEAP32[((11520)>>2)])|0);
   $460=((($459)-($349))|0);
   $461=($rsize_3_lcssa_i>>>0)<($460>>>0);
   if (!($461)) {
    $nb_0=$349;
    break;
   }
   $463=$v_3_lcssa_i;
   $464=((HEAP32[((11528)>>2)])|0);
   $465=($463>>>0)<($464>>>0);
   if ($465) {
    _abort(); return ((0)|0);
   }
   $467=(($463+$349)|0);
   $468=$467;
   $469=($463>>>0)<($467>>>0);
   if (!($469)) {
    _abort(); return ((0)|0);
   }
   $471=(($v_3_lcssa_i+24)|0);
   $472=((HEAP32[(($471)>>2)])|0);
   $473=(($v_3_lcssa_i+12)|0);
   $474=((HEAP32[(($473)>>2)])|0);
   $475=($474|0)==($v_3_lcssa_i|0);
   do {
    if ($475) {
     $491=(($v_3_lcssa_i+20)|0);
     $492=((HEAP32[(($491)>>2)])|0);
     $493=($492|0)==0;
     if ($493) {
      $495=(($v_3_lcssa_i+16)|0);
      $496=((HEAP32[(($495)>>2)])|0);
      $497=($496|0)==0;
      if ($497) {
       $R_1_i122=0;
       break;
      } else {
       $R_0_i120=$496;$RP_0_i119=$495;
      }
     } else {
      $R_0_i120=$492;$RP_0_i119=$491;
     }
     while(1) {


      $498=(($R_0_i120+20)|0);
      $499=((HEAP32[(($498)>>2)])|0);
      $500=($499|0)==0;
      if (!($500)) {
       $R_0_i120=$499;$RP_0_i119=$498;
       continue;
      }
      $502=(($R_0_i120+16)|0);
      $503=((HEAP32[(($502)>>2)])|0);
      $504=($503|0)==0;
      if ($504) {
       break;
      } else {
       $R_0_i120=$503;$RP_0_i119=$502;
      }
     }
     $506=$RP_0_i119;
     $507=($506>>>0)<($464>>>0);
     if ($507) {
      _abort(); return ((0)|0);
     } else {
      HEAP32[(($RP_0_i119)>>2)]=0;
      $R_1_i122=$R_0_i120;
      break;
     }
    } else {
     $477=(($v_3_lcssa_i+8)|0);
     $478=((HEAP32[(($477)>>2)])|0);
     $479=$478;
     $480=($479>>>0)<($464>>>0);
     if ($480) {
      _abort(); return ((0)|0);
     }
     $482=(($478+12)|0);
     $483=((HEAP32[(($482)>>2)])|0);
     $484=($483|0)==($v_3_lcssa_i|0);
     if (!($484)) {
      _abort(); return ((0)|0);
     }
     $486=(($474+8)|0);
     $487=((HEAP32[(($486)>>2)])|0);
     $488=($487|0)==($v_3_lcssa_i|0);
     if ($488) {
      HEAP32[(($482)>>2)]=$474;
      HEAP32[(($486)>>2)]=$478;
      $R_1_i122=$474;
      break;
     } else {
      _abort(); return ((0)|0);
     }
    }
   } while(0);

   $511=($472|0)==0;
   L176: do {
    if (!($511)) {
     $513=(($v_3_lcssa_i+28)|0);
     $514=((HEAP32[(($513)>>2)])|0);
     $515=((11816+($514<<2))|0);
     $516=((HEAP32[(($515)>>2)])|0);
     $517=($v_3_lcssa_i|0)==($516|0);
     do {
      if ($517) {
       HEAP32[(($515)>>2)]=$R_1_i122;
       $cond_i123=($R_1_i122|0)==0;
       if (!($cond_i123)) {
        break;
       }
       $519=((HEAP32[(($513)>>2)])|0);
       $520=1<<$519;
       $521=$520^-1;
       $522=((HEAP32[((11516)>>2)])|0);
       $523=$522&$521;
       HEAP32[((11516)>>2)]=$523;
       break L176;
      } else {
       $525=$472;
       $526=((HEAP32[((11528)>>2)])|0);
       $527=($525>>>0)<($526>>>0);
       if ($527) {
        _abort(); return ((0)|0);
       }
       $529=(($472+16)|0);
       $530=((HEAP32[(($529)>>2)])|0);
       $531=($530|0)==($v_3_lcssa_i|0);
       if ($531) {
        HEAP32[(($529)>>2)]=$R_1_i122;
       } else {
        $534=(($472+20)|0);
        HEAP32[(($534)>>2)]=$R_1_i122;
       }
       $537=($R_1_i122|0)==0;
       if ($537) {
        break L176;
       }
      }
     } while(0);
     $539=$R_1_i122;
     $540=((HEAP32[((11528)>>2)])|0);
     $541=($539>>>0)<($540>>>0);
     if ($541) {
      _abort(); return ((0)|0);
     }
     $543=(($R_1_i122+24)|0);
     HEAP32[(($543)>>2)]=$472;
     $544=(($v_3_lcssa_i+16)|0);
     $545=((HEAP32[(($544)>>2)])|0);
     $546=($545|0)==0;
     do {
      if (!($546)) {
       $548=$545;
       $549=((HEAP32[((11528)>>2)])|0);
       $550=($548>>>0)<($549>>>0);
       if ($550) {
        _abort(); return ((0)|0);
       } else {
        $552=(($R_1_i122+16)|0);
        HEAP32[(($552)>>2)]=$545;
        $553=(($545+24)|0);
        HEAP32[(($553)>>2)]=$R_1_i122;
        break;
       }
      }
     } while(0);
     $556=(($v_3_lcssa_i+20)|0);
     $557=((HEAP32[(($556)>>2)])|0);
     $558=($557|0)==0;
     if ($558) {
      break;
     }
     $560=$557;
     $561=((HEAP32[((11528)>>2)])|0);
     $562=($560>>>0)<($561>>>0);
     if ($562) {
      _abort(); return ((0)|0);
     } else {
      $564=(($R_1_i122+20)|0);
      HEAP32[(($564)>>2)]=$557;
      $565=(($557+24)|0);
      HEAP32[(($565)>>2)]=$R_1_i122;
      break;
     }
    }
   } while(0);
   $569=($rsize_3_lcssa_i>>>0)<((16)>>>0);
   do {
    if ($569) {
     $571=((($rsize_3_lcssa_i)+($349))|0);
     $572=$571|3;
     $573=(($v_3_lcssa_i+4)|0);
     HEAP32[(($573)>>2)]=$572;
     $_sum19_i=((($571)+(4))|0);
     $574=(($463+$_sum19_i)|0);
     $575=$574;
     $576=((HEAP32[(($575)>>2)])|0);
     $577=$576|1;
     HEAP32[(($575)>>2)]=$577;
    } else {
     $579=$349|3;
     $580=(($v_3_lcssa_i+4)|0);
     HEAP32[(($580)>>2)]=$579;
     $581=$rsize_3_lcssa_i|1;
     $_sum_i125136=$349|4;
     $582=(($463+$_sum_i125136)|0);
     $583=$582;
     HEAP32[(($583)>>2)]=$581;
     $_sum1_i126=((($rsize_3_lcssa_i)+($349))|0);
     $584=(($463+$_sum1_i126)|0);
     $585=$584;
     HEAP32[(($585)>>2)]=$rsize_3_lcssa_i;
     $586=$rsize_3_lcssa_i>>>3;
     $587=($rsize_3_lcssa_i>>>0)<((256)>>>0);
     if ($587) {
      $589=$586<<1;
      $590=((11552+($589<<2))|0);
      $591=$590;
      $592=((HEAP32[((11512)>>2)])|0);
      $593=1<<$586;
      $594=$592&$593;
      $595=($594|0)==0;
      do {
       if ($595) {
        $597=$592|$593;
        HEAP32[((11512)>>2)]=$597;
        $_sum15_pre_i=((($589)+(2))|0);
        $_pre_i127=((11552+($_sum15_pre_i<<2))|0);
        $F5_0_i=$591;$_pre_phi_i128=$_pre_i127;
       } else {
        $_sum18_i=((($589)+(2))|0);
        $599=((11552+($_sum18_i<<2))|0);
        $600=((HEAP32[(($599)>>2)])|0);
        $601=$600;
        $602=((HEAP32[((11528)>>2)])|0);
        $603=($601>>>0)<($602>>>0);
        if (!($603)) {
         $F5_0_i=$600;$_pre_phi_i128=$599;
         break;
        }
        _abort(); return ((0)|0);
       }
      } while(0);


      HEAP32[(($_pre_phi_i128)>>2)]=$468;
      $606=(($F5_0_i+12)|0);
      HEAP32[(($606)>>2)]=$468;
      $_sum16_i=((($349)+(8))|0);
      $607=(($463+$_sum16_i)|0);
      $608=$607;
      HEAP32[(($608)>>2)]=$F5_0_i;
      $_sum17_i=((($349)+(12))|0);
      $609=(($463+$_sum17_i)|0);
      $610=$609;
      HEAP32[(($610)>>2)]=$591;
      break;
     }
     $612=$467;
     $613=$rsize_3_lcssa_i>>>8;
     $614=($613|0)==0;
     do {
      if ($614) {
       $I7_0_i=0;
      } else {
       $616=($rsize_3_lcssa_i>>>0)>((16777215)>>>0);
       if ($616) {
        $I7_0_i=31;
        break;
       }
       $618=((($613)+(1048320))|0);
       $619=$618>>>16;
       $620=$619&8;
       $621=$613<<$620;
       $622=((($621)+(520192))|0);
       $623=$622>>>16;
       $624=$623&4;
       $625=$624|$620;
       $626=$621<<$624;
       $627=((($626)+(245760))|0);
       $628=$627>>>16;
       $629=$628&2;
       $630=$625|$629;
       $631=(((14)-($630))|0);
       $632=$626<<$629;
       $633=$632>>>15;
       $634=((($631)+($633))|0);
       $635=$634<<1;
       $636=((($634)+(7))|0);
       $637=$rsize_3_lcssa_i>>>($636>>>0);
       $638=$637&1;
       $639=$638|$635;
       $I7_0_i=$639;
      }
     } while(0);

     $641=((11816+($I7_0_i<<2))|0);
     $_sum2_i=((($349)+(28))|0);
     $642=(($463+$_sum2_i)|0);
     $643=$642;
     HEAP32[(($643)>>2)]=$I7_0_i;
     $_sum3_i129=((($349)+(16))|0);
     $644=(($463+$_sum3_i129)|0);
     $_sum4_i130=((($349)+(20))|0);
     $645=(($463+$_sum4_i130)|0);
     $646=$645;
     HEAP32[(($646)>>2)]=0;
     $647=$644;
     HEAP32[(($647)>>2)]=0;
     $648=((HEAP32[((11516)>>2)])|0);
     $649=1<<$I7_0_i;
     $650=$648&$649;
     $651=($650|0)==0;
     if ($651) {
      $653=$648|$649;
      HEAP32[((11516)>>2)]=$653;
      HEAP32[(($641)>>2)]=$612;
      $654=$641;
      $_sum5_i=((($349)+(24))|0);
      $655=(($463+$_sum5_i)|0);
      $656=$655;
      HEAP32[(($656)>>2)]=$654;
      $_sum6_i=((($349)+(12))|0);
      $657=(($463+$_sum6_i)|0);
      $658=$657;
      HEAP32[(($658)>>2)]=$612;
      $_sum7_i=((($349)+(8))|0);
      $659=(($463+$_sum7_i)|0);
      $660=$659;
      HEAP32[(($660)>>2)]=$612;
      break;
     }
     $662=((HEAP32[(($641)>>2)])|0);
     $663=($I7_0_i|0)==31;
     if ($663) {
      $668=0;
     } else {
      $665=$I7_0_i>>>1;
      $666=(((25)-($665))|0);
      $668=$666;
     }

     $669=$rsize_3_lcssa_i<<$668;
     $K12_0_i=$669;$T_0_i=$662;
     while(1) {


      $671=(($T_0_i+4)|0);
      $672=((HEAP32[(($671)>>2)])|0);
      $673=$672&-8;
      $674=($673|0)==($rsize_3_lcssa_i|0);
      if ($674) {
       break;
      }
      $676=$K12_0_i>>>31;
      $677=(($T_0_i+16+($676<<2))|0);
      $678=((HEAP32[(($677)>>2)])|0);
      $679=($678|0)==0;
      $680=$K12_0_i<<1;
      if ($679) {
       label = 151;
       break;
      } else {
       $K12_0_i=$680;$T_0_i=$678;
      }
     }
     if ((label|0) == 151) {
      $682=$677;
      $683=((HEAP32[((11528)>>2)])|0);
      $684=($682>>>0)<($683>>>0);
      if ($684) {
       _abort(); return ((0)|0);
      } else {
       HEAP32[(($677)>>2)]=$612;
       $_sum12_i=((($349)+(24))|0);
       $686=(($463+$_sum12_i)|0);
       $687=$686;
       HEAP32[(($687)>>2)]=$T_0_i;
       $_sum13_i=((($349)+(12))|0);
       $688=(($463+$_sum13_i)|0);
       $689=$688;
       HEAP32[(($689)>>2)]=$612;
       $_sum14_i=((($349)+(8))|0);
       $690=(($463+$_sum14_i)|0);
       $691=$690;
       HEAP32[(($691)>>2)]=$612;
       break;
      }
     }
     $694=(($T_0_i+8)|0);
     $695=((HEAP32[(($694)>>2)])|0);
     $696=$T_0_i;
     $697=((HEAP32[((11528)>>2)])|0);
     $698=($696>>>0)<($697>>>0);
     if ($698) {
      _abort(); return ((0)|0);
     }
     $700=$695;
     $701=($700>>>0)<($697>>>0);
     if ($701) {
      _abort(); return ((0)|0);
     } else {
      $703=(($695+12)|0);
      HEAP32[(($703)>>2)]=$612;
      HEAP32[(($694)>>2)]=$612;
      $_sum9_i=((($349)+(8))|0);
      $704=(($463+$_sum9_i)|0);
      $705=$704;
      HEAP32[(($705)>>2)]=$695;
      $_sum10_i=((($349)+(12))|0);
      $706=(($463+$_sum10_i)|0);
      $707=$706;
      HEAP32[(($707)>>2)]=$T_0_i;
      $_sum11_i=((($349)+(24))|0);
      $708=(($463+$_sum11_i)|0);
      $709=$708;
      HEAP32[(($709)>>2)]=0;
      break;
     }
    }
   } while(0);
   $711=(($v_3_lcssa_i+8)|0);
   $712=$711;
   $713=($711|0)==0;
   if ($713) {
    $nb_0=$349;
    break;
   } else {
    $mem_0=$712;
   }

   return (($mem_0)|0);
  }
 } while(0);

 $714=((HEAP32[((11520)>>2)])|0);
 $715=($nb_0>>>0)>($714>>>0);
 if (!($715)) {
  $717=((($714)-($nb_0))|0);
  $718=((HEAP32[((11532)>>2)])|0);
  $719=($717>>>0)>((15)>>>0);
  if ($719) {
   $721=$718;
   $722=(($721+$nb_0)|0);
   $723=$722;
   HEAP32[((11532)>>2)]=$723;
   HEAP32[((11520)>>2)]=$717;
   $724=$717|1;
   $_sum102=((($nb_0)+(4))|0);
   $725=(($721+$_sum102)|0);
   $726=$725;
   HEAP32[(($726)>>2)]=$724;
   $727=(($721+$714)|0);
   $728=$727;
   HEAP32[(($728)>>2)]=$717;
   $729=$nb_0|3;
   $730=(($718+4)|0);
   HEAP32[(($730)>>2)]=$729;
  } else {
   HEAP32[((11520)>>2)]=0;
   HEAP32[((11532)>>2)]=0;
   $732=$714|3;
   $733=(($718+4)|0);
   HEAP32[(($733)>>2)]=$732;
   $734=$718;
   $_sum101=((($714)+(4))|0);
   $735=(($734+$_sum101)|0);
   $736=$735;
   $737=((HEAP32[(($736)>>2)])|0);
   $738=$737|1;
   HEAP32[(($736)>>2)]=$738;
  }
  $740=(($718+8)|0);
  $741=$740;
  $mem_0=$741;

  return (($mem_0)|0);
 }
 $743=((HEAP32[((11524)>>2)])|0);
 $744=($nb_0>>>0)<($743>>>0);
 if ($744) {
  $746=((($743)-($nb_0))|0);
  HEAP32[((11524)>>2)]=$746;
  $747=((HEAP32[((11536)>>2)])|0);
  $748=$747;
  $749=(($748+$nb_0)|0);
  $750=$749;
  HEAP32[((11536)>>2)]=$750;
  $751=$746|1;
  $_sum=((($nb_0)+(4))|0);
  $752=(($748+$_sum)|0);
  $753=$752;
  HEAP32[(($753)>>2)]=$751;
  $754=$nb_0|3;
  $755=(($747+4)|0);
  HEAP32[(($755)>>2)]=$754;
  $756=(($747+8)|0);
  $757=$756;
  $mem_0=$757;

  return (($mem_0)|0);
 }
 $759=((HEAP32[((11448)>>2)])|0);
 $760=($759|0)==0;
 do {
  if ($760) {
   $762=((_sysconf(((30)|0)))|0);
   $763=((($762)-(1))|0);
   $764=$763&$762;
   $765=($764|0)==0;
   if ($765) {
    HEAP32[((11456)>>2)]=$762;
    HEAP32[((11452)>>2)]=$762;
    HEAP32[((11460)>>2)]=-1;
    HEAP32[((11464)>>2)]=-1;
    HEAP32[((11468)>>2)]=0;
    HEAP32[((11956)>>2)]=0;
    $767=((_time(((0)|0)))|0);
    $768=$767&-16;
    $769=$768^1431655768;
    HEAP32[((11448)>>2)]=$769;
    break;
   } else {
    _abort(); return ((0)|0);
   }
  }
 } while(0);
 $771=((($nb_0)+(48))|0);
 $772=((HEAP32[((11456)>>2)])|0);
 $773=((($nb_0)+(47))|0);
 $774=((($772)+($773))|0);
 $775=(((-$772))|0);
 $776=$774&$775;
 $777=($776>>>0)>($nb_0>>>0);
 if (!($777)) {
  $mem_0=0;

  return (($mem_0)|0);
 }
 $779=((HEAP32[((11952)>>2)])|0);
 $780=($779|0)==0;
 do {
  if (!($780)) {
   $782=((HEAP32[((11944)>>2)])|0);
   $783=((($782)+($776))|0);
   $784=($783>>>0)<=($782>>>0);
   $785=($783>>>0)>($779>>>0);
   $or_cond1_i=$784|$785;
   if ($or_cond1_i) {
    $mem_0=0;
   } else {
    break;
   }

   return (($mem_0)|0);
  }
 } while(0);
 $787=((HEAP32[((11956)>>2)])|0);
 $788=$787&4;
 $789=($788|0)==0;
 L268: do {
  if ($789) {
   $791=((HEAP32[((11536)>>2)])|0);
   $792=($791|0)==0;
   L270: do {
    if ($792) {
     label = 181;
    } else {
     $794=$791;
     $sp_0_i_i=11960;
     while(1) {

      $796=(($sp_0_i_i)|0);
      $797=((HEAP32[(($796)>>2)])|0);
      $798=($797>>>0)>($794>>>0);
      if (!($798)) {
       $800=(($sp_0_i_i+4)|0);
       $801=((HEAP32[(($800)>>2)])|0);
       $802=(($797+$801)|0);
       $803=($802>>>0)>($794>>>0);
       if ($803) {
        break;
       }
      }
      $805=(($sp_0_i_i+8)|0);
      $806=((HEAP32[(($805)>>2)])|0);
      $807=($806|0)==0;
      if ($807) {
       label = 181;
       break L270;
      } else {
       $sp_0_i_i=$806;
      }
     }
     $808=($sp_0_i_i|0)==0;
     if ($808) {
      label = 181;
      break;
     }
     $838=((HEAP32[((11524)>>2)])|0);
     $839=((($774)-($838))|0);
     $840=$839&$775;
     $841=($840>>>0)<((2147483647)>>>0);
     if (!($841)) {
      $tsize_0303639_i=0;
      break;
     }
     $843=((_sbrk((($840)|0)))|0);
     $844=((HEAP32[(($796)>>2)])|0);
     $845=((HEAP32[(($800)>>2)])|0);
     $846=(($844+$845)|0);
     $847=($843|0)==($846|0);
     $_3_i=($847?$840:0);
     $_4_i=($847?$843:-1);
     $tbase_0_i=$_4_i;$tsize_0_i=$_3_i;$br_0_i=$843;$ssize_1_i=$840;
     label = 190;
    }
   } while(0);
   do {
    if ((label|0) == 181) {
     $809=((_sbrk(((0)|0)))|0);
     $810=($809|0)==-1;
     if ($810) {
      $tsize_0303639_i=0;
      break;
     }
     $812=$809;
     $813=((HEAP32[((11452)>>2)])|0);
     $814=((($813)-(1))|0);
     $815=$814&$812;
     $816=($815|0)==0;
     if ($816) {
      $ssize_0_i=$776;
     } else {
      $818=((($814)+($812))|0);
      $819=(((-$813))|0);
      $820=$818&$819;
      $821=((($776)-($812))|0);
      $822=((($821)+($820))|0);
      $ssize_0_i=$822;
     }

     $824=((HEAP32[((11944)>>2)])|0);
     $825=((($824)+($ssize_0_i))|0);
     $826=($ssize_0_i>>>0)>($nb_0>>>0);
     $827=($ssize_0_i>>>0)<((2147483647)>>>0);
     $or_cond_i131=$826&$827;
     if (!($or_cond_i131)) {
      $tsize_0303639_i=0;
      break;
     }
     $829=((HEAP32[((11952)>>2)])|0);
     $830=($829|0)==0;
     if (!($830)) {
      $832=($825>>>0)<=($824>>>0);
      $833=($825>>>0)>($829>>>0);
      $or_cond2_i=$832|$833;
      if ($or_cond2_i) {
       $tsize_0303639_i=0;
       break;
      }
     }
     $835=((_sbrk((($ssize_0_i)|0)))|0);
     $836=($835|0)==($809|0);
     $ssize_0__i=($836?$ssize_0_i:0);
     $__i=($836?$809:-1);
     $tbase_0_i=$__i;$tsize_0_i=$ssize_0__i;$br_0_i=$835;$ssize_1_i=$ssize_0_i;
     label = 190;
    }
   } while(0);
   L290: do {
    if ((label|0) == 190) {




     $849=(((-$ssize_1_i))|0);
     $850=($tbase_0_i|0)==-1;
     if (!($850)) {
      $tsize_244_i=$tsize_0_i;$tbase_245_i=$tbase_0_i;
      label = 201;
      break L268;
     }
     $852=($br_0_i|0)!=-1;
     $853=($ssize_1_i>>>0)<((2147483647)>>>0);
     $or_cond5_i=$852&$853;
     $854=($ssize_1_i>>>0)<($771>>>0);
     $or_cond6_i=$or_cond5_i&$854;
     do {
      if ($or_cond6_i) {
       $856=((HEAP32[((11456)>>2)])|0);
       $857=((($773)-($ssize_1_i))|0);
       $858=((($857)+($856))|0);
       $859=(((-$856))|0);
       $860=$858&$859;
       $861=($860>>>0)<((2147483647)>>>0);
       if (!($861)) {
        $ssize_2_i=$ssize_1_i;
        break;
       }
       $863=((_sbrk((($860)|0)))|0);
       $864=($863|0)==-1;
       if ($864) {
        $868=((_sbrk((($849)|0)))|0);
        $tsize_0303639_i=$tsize_0_i;
        break L290;
       } else {
        $866=((($860)+($ssize_1_i))|0);
        $ssize_2_i=$866;
        break;
       }
      } else {
       $ssize_2_i=$ssize_1_i;
      }
     } while(0);

     $870=($br_0_i|0)==-1;
     if ($870) {
      $tsize_0303639_i=$tsize_0_i;
     } else {
      $tsize_244_i=$ssize_2_i;$tbase_245_i=$br_0_i;
      label = 201;
      break L268;
     }
    }
   } while(0);

   $871=((HEAP32[((11956)>>2)])|0);
   $872=$871|4;
   HEAP32[((11956)>>2)]=$872;
   $tsize_1_i=$tsize_0303639_i;
   label = 198;
  } else {
   $tsize_1_i=0;
   label = 198;
  }
 } while(0);
 do {
  if ((label|0) == 198) {

   $874=($776>>>0)<((2147483647)>>>0);
   if (!($874)) {
    break;
   }
   $876=((_sbrk((($776)|0)))|0);
   $877=((_sbrk(((0)|0)))|0);
   $notlhs_i=($876|0)!=-1;
   $notrhs_i=($877|0)!=-1;
   $or_cond8_not_i=$notrhs_i&$notlhs_i;
   $878=($876>>>0)<($877>>>0);
   $or_cond9_i=$or_cond8_not_i&$878;
   if (!($or_cond9_i)) {
    break;
   }
   $879=$877;
   $880=$876;
   $881=((($879)-($880))|0);
   $882=((($nb_0)+(40))|0);
   $883=($881>>>0)>($882>>>0);
   $_tsize_1_i=($883?$881:$tsize_1_i);
   $_tbase_1_i=($883?$876:-1);
   $884=($_tbase_1_i|0)==-1;
   if (!($884)) {
    $tsize_244_i=$_tsize_1_i;$tbase_245_i=$_tbase_1_i;
    label = 201;
   }
  }
 } while(0);
 do {
  if ((label|0) == 201) {


   $885=((HEAP32[((11944)>>2)])|0);
   $886=((($885)+($tsize_244_i))|0);
   HEAP32[((11944)>>2)]=$886;
   $887=((HEAP32[((11948)>>2)])|0);
   $888=($886>>>0)>($887>>>0);
   if ($888) {
    HEAP32[((11948)>>2)]=$886;
   }
   $890=((HEAP32[((11536)>>2)])|0);
   $891=($890|0)==0;
   L310: do {
    if ($891) {
     $893=((HEAP32[((11528)>>2)])|0);
     $894=($893|0)==0;
     $895=($tbase_245_i>>>0)<($893>>>0);
     $or_cond10_i=$894|$895;
     if ($or_cond10_i) {
      HEAP32[((11528)>>2)]=$tbase_245_i;
     }
     HEAP32[((11960)>>2)]=$tbase_245_i;
     HEAP32[((11964)>>2)]=$tsize_244_i;
     HEAP32[((11972)>>2)]=0;
     $897=((HEAP32[((11448)>>2)])|0);
     HEAP32[((11548)>>2)]=$897;
     HEAP32[((11544)>>2)]=-1;
     $i_02_i_i=0;
     while(1) {

      $899=$i_02_i_i<<1;
      $900=((11552+($899<<2))|0);
      $901=$900;
      $_sum_i_i=((($899)+(3))|0);
      $902=((11552+($_sum_i_i<<2))|0);
      HEAP32[(($902)>>2)]=$901;
      $_sum1_i_i=((($899)+(2))|0);
      $903=((11552+($_sum1_i_i<<2))|0);
      HEAP32[(($903)>>2)]=$901;
      $904=((($i_02_i_i)+(1))|0);
      $905=($904>>>0)<((32)>>>0);
      if ($905) {
       $i_02_i_i=$904;
      } else {
       break;
      }
     }
     $906=((($tsize_244_i)-(40))|0);
     $907=(($tbase_245_i+8)|0);
     $908=$907;
     $909=$908&7;
     $910=($909|0)==0;
     if ($910) {
      $914=0;
     } else {
      $912=(((-$908))|0);
      $913=$912&7;
      $914=$913;
     }

     $915=(($tbase_245_i+$914)|0);
     $916=$915;
     $917=((($906)-($914))|0);
     HEAP32[((11536)>>2)]=$916;
     HEAP32[((11524)>>2)]=$917;
     $918=$917|1;
     $_sum_i14_i=((($914)+(4))|0);
     $919=(($tbase_245_i+$_sum_i14_i)|0);
     $920=$919;
     HEAP32[(($920)>>2)]=$918;
     $_sum2_i_i=((($tsize_244_i)-(36))|0);
     $921=(($tbase_245_i+$_sum2_i_i)|0);
     $922=$921;
     HEAP32[(($922)>>2)]=40;
     $923=((HEAP32[((11464)>>2)])|0);
     HEAP32[((11540)>>2)]=$923;
    } else {
     $sp_067_i=11960;
     while(1) {

      $924=(($sp_067_i)|0);
      $925=((HEAP32[(($924)>>2)])|0);
      $926=(($sp_067_i+4)|0);
      $927=((HEAP32[(($926)>>2)])|0);
      $928=(($925+$927)|0);
      $929=($tbase_245_i|0)==($928|0);
      if ($929) {
       label = 213;
       break;
      }
      $931=(($sp_067_i+8)|0);
      $932=((HEAP32[(($931)>>2)])|0);
      $933=($932|0)==0;
      if ($933) {
       break;
      } else {
       $sp_067_i=$932;
      }
     }
     do {
      if ((label|0) == 213) {
       $934=(($sp_067_i+12)|0);
       $935=((HEAP32[(($934)>>2)])|0);
       $936=$935&8;
       $937=($936|0)==0;
       if (!($937)) {
        break;
       }
       $939=$890;
       $940=($939>>>0)>=($925>>>0);
       $941=($939>>>0)<($tbase_245_i>>>0);
       $or_cond47_i=$940&$941;
       if (!($or_cond47_i)) {
        break;
       }
       $943=((($927)+($tsize_244_i))|0);
       HEAP32[(($926)>>2)]=$943;
       $944=((HEAP32[((11536)>>2)])|0);
       $945=((HEAP32[((11524)>>2)])|0);
       $946=((($945)+($tsize_244_i))|0);
       $947=$944;
       $948=(($944+8)|0);
       $949=$948;
       $950=$949&7;
       $951=($950|0)==0;
       if ($951) {
        $955=0;
       } else {
        $953=(((-$949))|0);
        $954=$953&7;
        $955=$954;
       }

       $956=(($947+$955)|0);
       $957=$956;
       $958=((($946)-($955))|0);
       HEAP32[((11536)>>2)]=$957;
       HEAP32[((11524)>>2)]=$958;
       $959=$958|1;
       $_sum_i18_i=((($955)+(4))|0);
       $960=(($947+$_sum_i18_i)|0);
       $961=$960;
       HEAP32[(($961)>>2)]=$959;
       $_sum2_i19_i=((($946)+(4))|0);
       $962=(($947+$_sum2_i19_i)|0);
       $963=$962;
       HEAP32[(($963)>>2)]=40;
       $964=((HEAP32[((11464)>>2)])|0);
       HEAP32[((11540)>>2)]=$964;
       break L310;
      }
     } while(0);
     $965=((HEAP32[((11528)>>2)])|0);
     $966=($tbase_245_i>>>0)<($965>>>0);
     if ($966) {
      HEAP32[((11528)>>2)]=$tbase_245_i;
     }
     $968=(($tbase_245_i+$tsize_244_i)|0);
     $sp_160_i=11960;
     while(1) {

      $970=(($sp_160_i)|0);
      $971=((HEAP32[(($970)>>2)])|0);
      $972=($971|0)==($968|0);
      if ($972) {
       label = 223;
       break;
      }
      $974=(($sp_160_i+8)|0);
      $975=((HEAP32[(($974)>>2)])|0);
      $976=($975|0)==0;
      if ($976) {
       break;
      } else {
       $sp_160_i=$975;
      }
     }
     do {
      if ((label|0) == 223) {
       $977=(($sp_160_i+12)|0);
       $978=((HEAP32[(($977)>>2)])|0);
       $979=$978&8;
       $980=($979|0)==0;
       if (!($980)) {
        break;
       }
       HEAP32[(($970)>>2)]=$tbase_245_i;
       $982=(($sp_160_i+4)|0);
       $983=((HEAP32[(($982)>>2)])|0);
       $984=((($983)+($tsize_244_i))|0);
       HEAP32[(($982)>>2)]=$984;
       $985=(($tbase_245_i+8)|0);
       $986=$985;
       $987=$986&7;
       $988=($987|0)==0;
       if ($988) {
        $993=0;
       } else {
        $990=(((-$986))|0);
        $991=$990&7;
        $993=$991;
       }

       $994=(($tbase_245_i+$993)|0);
       $_sum93_i=((($tsize_244_i)+(8))|0);
       $995=(($tbase_245_i+$_sum93_i)|0);
       $996=$995;
       $997=$996&7;
       $998=($997|0)==0;
       if ($998) {
        $1003=0;
       } else {
        $1000=(((-$996))|0);
        $1001=$1000&7;
        $1003=$1001;
       }

       $_sum94_i=((($1003)+($tsize_244_i))|0);
       $1004=(($tbase_245_i+$_sum94_i)|0);
       $1005=$1004;
       $1006=$1004;
       $1007=$994;
       $1008=((($1006)-($1007))|0);
       $_sum_i21_i=((($993)+($nb_0))|0);
       $1009=(($tbase_245_i+$_sum_i21_i)|0);
       $1010=$1009;
       $1011=((($1008)-($nb_0))|0);
       $1012=$nb_0|3;
       $_sum1_i22_i=((($993)+(4))|0);
       $1013=(($tbase_245_i+$_sum1_i22_i)|0);
       $1014=$1013;
       HEAP32[(($1014)>>2)]=$1012;
       $1015=((HEAP32[((11536)>>2)])|0);
       $1016=($1005|0)==($1015|0);
       do {
        if ($1016) {
         $1018=((HEAP32[((11524)>>2)])|0);
         $1019=((($1018)+($1011))|0);
         HEAP32[((11524)>>2)]=$1019;
         HEAP32[((11536)>>2)]=$1010;
         $1020=$1019|1;
         $_sum46_i_i=((($_sum_i21_i)+(4))|0);
         $1021=(($tbase_245_i+$_sum46_i_i)|0);
         $1022=$1021;
         HEAP32[(($1022)>>2)]=$1020;
        } else {
         $1024=((HEAP32[((11532)>>2)])|0);
         $1025=($1005|0)==($1024|0);
         if ($1025) {
          $1027=((HEAP32[((11520)>>2)])|0);
          $1028=((($1027)+($1011))|0);
          HEAP32[((11520)>>2)]=$1028;
          HEAP32[((11532)>>2)]=$1010;
          $1029=$1028|1;
          $_sum44_i_i=((($_sum_i21_i)+(4))|0);
          $1030=(($tbase_245_i+$_sum44_i_i)|0);
          $1031=$1030;
          HEAP32[(($1031)>>2)]=$1029;
          $_sum45_i_i=((($1028)+($_sum_i21_i))|0);
          $1032=(($tbase_245_i+$_sum45_i_i)|0);
          $1033=$1032;
          HEAP32[(($1033)>>2)]=$1028;
          break;
         }
         $_sum2_i23_i=((($tsize_244_i)+(4))|0);
         $_sum95_i=((($_sum2_i23_i)+($1003))|0);
         $1035=(($tbase_245_i+$_sum95_i)|0);
         $1036=$1035;
         $1037=((HEAP32[(($1036)>>2)])|0);
         $1038=$1037&3;
         $1039=($1038|0)==1;
         if ($1039) {
          $1041=$1037&-8;
          $1042=$1037>>>3;
          $1043=($1037>>>0)<((256)>>>0);
          L355: do {
           if ($1043) {
            $_sum3940_i_i=$1003|8;
            $_sum105_i=((($_sum3940_i_i)+($tsize_244_i))|0);
            $1045=(($tbase_245_i+$_sum105_i)|0);
            $1046=$1045;
            $1047=((HEAP32[(($1046)>>2)])|0);
            $_sum41_i_i=((($tsize_244_i)+(12))|0);
            $_sum106_i=((($_sum41_i_i)+($1003))|0);
            $1048=(($tbase_245_i+$_sum106_i)|0);
            $1049=$1048;
            $1050=((HEAP32[(($1049)>>2)])|0);
            $1051=$1042<<1;
            $1052=((11552+($1051<<2))|0);
            $1053=$1052;
            $1054=($1047|0)==($1053|0);
            do {
             if (!($1054)) {
              $1056=$1047;
              $1057=((HEAP32[((11528)>>2)])|0);
              $1058=($1056>>>0)<($1057>>>0);
              if ($1058) {
               _abort(); return ((0)|0);
              }
              $1060=(($1047+12)|0);
              $1061=((HEAP32[(($1060)>>2)])|0);
              $1062=($1061|0)==($1005|0);
              if ($1062) {
               break;
              }
              _abort(); return ((0)|0);
             }
            } while(0);
            $1063=($1050|0)==($1047|0);
            if ($1063) {
             $1065=1<<$1042;
             $1066=$1065^-1;
             $1067=((HEAP32[((11512)>>2)])|0);
             $1068=$1067&$1066;
             HEAP32[((11512)>>2)]=$1068;
             break;
            }
            $1070=($1050|0)==($1053|0);
            do {
             if ($1070) {
              $_pre56_i_i=(($1050+8)|0);
              $_pre_phi57_i_i=$_pre56_i_i;
             } else {
              $1072=$1050;
              $1073=((HEAP32[((11528)>>2)])|0);
              $1074=($1072>>>0)<($1073>>>0);
              if ($1074) {
               _abort(); return ((0)|0);
              }
              $1076=(($1050+8)|0);
              $1077=((HEAP32[(($1076)>>2)])|0);
              $1078=($1077|0)==($1005|0);
              if ($1078) {
               $_pre_phi57_i_i=$1076;
               break;
              }
              _abort(); return ((0)|0);
             }
            } while(0);

            $1079=(($1047+12)|0);
            HEAP32[(($1079)>>2)]=$1050;
            HEAP32[(($_pre_phi57_i_i)>>2)]=$1047;
           } else {
            $1081=$1004;
            $_sum34_i_i=$1003|24;
            $_sum96_i=((($_sum34_i_i)+($tsize_244_i))|0);
            $1082=(($tbase_245_i+$_sum96_i)|0);
            $1083=$1082;
            $1084=((HEAP32[(($1083)>>2)])|0);
            $_sum5_i_i=((($tsize_244_i)+(12))|0);
            $_sum97_i=((($_sum5_i_i)+($1003))|0);
            $1085=(($tbase_245_i+$_sum97_i)|0);
            $1086=$1085;
            $1087=((HEAP32[(($1086)>>2)])|0);
            $1088=($1087|0)==($1081|0);
            do {
             if ($1088) {
              $_sum67_i_i=$1003|16;
              $_sum103_i=((($_sum2_i23_i)+($_sum67_i_i))|0);
              $1106=(($tbase_245_i+$_sum103_i)|0);
              $1107=$1106;
              $1108=((HEAP32[(($1107)>>2)])|0);
              $1109=($1108|0)==0;
              if ($1109) {
               $_sum104_i=((($_sum67_i_i)+($tsize_244_i))|0);
               $1111=(($tbase_245_i+$_sum104_i)|0);
               $1112=$1111;
               $1113=((HEAP32[(($1112)>>2)])|0);
               $1114=($1113|0)==0;
               if ($1114) {
                $R_1_i_i=0;
                break;
               } else {
                $R_0_i_i=$1113;$RP_0_i_i=$1112;
               }
              } else {
               $R_0_i_i=$1108;$RP_0_i_i=$1107;
              }
              while(1) {


               $1115=(($R_0_i_i+20)|0);
               $1116=((HEAP32[(($1115)>>2)])|0);
               $1117=($1116|0)==0;
               if (!($1117)) {
                $R_0_i_i=$1116;$RP_0_i_i=$1115;
                continue;
               }
               $1119=(($R_0_i_i+16)|0);
               $1120=((HEAP32[(($1119)>>2)])|0);
               $1121=($1120|0)==0;
               if ($1121) {
                break;
               } else {
                $R_0_i_i=$1120;$RP_0_i_i=$1119;
               }
              }
              $1123=$RP_0_i_i;
              $1124=((HEAP32[((11528)>>2)])|0);
              $1125=($1123>>>0)<($1124>>>0);
              if ($1125) {
               _abort(); return ((0)|0);
              } else {
               HEAP32[(($RP_0_i_i)>>2)]=0;
               $R_1_i_i=$R_0_i_i;
               break;
              }
             } else {
              $_sum3637_i_i=$1003|8;
              $_sum98_i=((($_sum3637_i_i)+($tsize_244_i))|0);
              $1090=(($tbase_245_i+$_sum98_i)|0);
              $1091=$1090;
              $1092=((HEAP32[(($1091)>>2)])|0);
              $1093=$1092;
              $1094=((HEAP32[((11528)>>2)])|0);
              $1095=($1093>>>0)<($1094>>>0);
              if ($1095) {
               _abort(); return ((0)|0);
              }
              $1097=(($1092+12)|0);
              $1098=((HEAP32[(($1097)>>2)])|0);
              $1099=($1098|0)==($1081|0);
              if (!($1099)) {
               _abort(); return ((0)|0);
              }
              $1101=(($1087+8)|0);
              $1102=((HEAP32[(($1101)>>2)])|0);
              $1103=($1102|0)==($1081|0);
              if ($1103) {
               HEAP32[(($1097)>>2)]=$1087;
               HEAP32[(($1101)>>2)]=$1092;
               $R_1_i_i=$1087;
               break;
              } else {
               _abort(); return ((0)|0);
              }
             }
            } while(0);

            $1129=($1084|0)==0;
            if ($1129) {
             break;
            }
            $_sum31_i_i=((($tsize_244_i)+(28))|0);
            $_sum99_i=((($_sum31_i_i)+($1003))|0);
            $1131=(($tbase_245_i+$_sum99_i)|0);
            $1132=$1131;
            $1133=((HEAP32[(($1132)>>2)])|0);
            $1134=((11816+($1133<<2))|0);
            $1135=((HEAP32[(($1134)>>2)])|0);
            $1136=($1081|0)==($1135|0);
            do {
             if ($1136) {
              HEAP32[(($1134)>>2)]=$R_1_i_i;
              $cond_i_i=($R_1_i_i|0)==0;
              if (!($cond_i_i)) {
               break;
              }
              $1138=((HEAP32[(($1132)>>2)])|0);
              $1139=1<<$1138;
              $1140=$1139^-1;
              $1141=((HEAP32[((11516)>>2)])|0);
              $1142=$1141&$1140;
              HEAP32[((11516)>>2)]=$1142;
              break L355;
             } else {
              $1144=$1084;
              $1145=((HEAP32[((11528)>>2)])|0);
              $1146=($1144>>>0)<($1145>>>0);
              if ($1146) {
               _abort(); return ((0)|0);
              }
              $1148=(($1084+16)|0);
              $1149=((HEAP32[(($1148)>>2)])|0);
              $1150=($1149|0)==($1081|0);
              if ($1150) {
               HEAP32[(($1148)>>2)]=$R_1_i_i;
              } else {
               $1153=(($1084+20)|0);
               HEAP32[(($1153)>>2)]=$R_1_i_i;
              }
              $1156=($R_1_i_i|0)==0;
              if ($1156) {
               break L355;
              }
             }
            } while(0);
            $1158=$R_1_i_i;
            $1159=((HEAP32[((11528)>>2)])|0);
            $1160=($1158>>>0)<($1159>>>0);
            if ($1160) {
             _abort(); return ((0)|0);
            }
            $1162=(($R_1_i_i+24)|0);
            HEAP32[(($1162)>>2)]=$1084;
            $_sum3233_i_i=$1003|16;
            $_sum100_i=((($_sum3233_i_i)+($tsize_244_i))|0);
            $1163=(($tbase_245_i+$_sum100_i)|0);
            $1164=$1163;
            $1165=((HEAP32[(($1164)>>2)])|0);
            $1166=($1165|0)==0;
            do {
             if (!($1166)) {
              $1168=$1165;
              $1169=((HEAP32[((11528)>>2)])|0);
              $1170=($1168>>>0)<($1169>>>0);
              if ($1170) {
               _abort(); return ((0)|0);
              } else {
               $1172=(($R_1_i_i+16)|0);
               HEAP32[(($1172)>>2)]=$1165;
               $1173=(($1165+24)|0);
               HEAP32[(($1173)>>2)]=$R_1_i_i;
               break;
              }
             }
            } while(0);
            $_sum101_i=((($_sum2_i23_i)+($_sum3233_i_i))|0);
            $1176=(($tbase_245_i+$_sum101_i)|0);
            $1177=$1176;
            $1178=((HEAP32[(($1177)>>2)])|0);
            $1179=($1178|0)==0;
            if ($1179) {
             break;
            }
            $1181=$1178;
            $1182=((HEAP32[((11528)>>2)])|0);
            $1183=($1181>>>0)<($1182>>>0);
            if ($1183) {
             _abort(); return ((0)|0);
            } else {
             $1185=(($R_1_i_i+20)|0);
             HEAP32[(($1185)>>2)]=$1178;
             $1186=(($1178+24)|0);
             HEAP32[(($1186)>>2)]=$R_1_i_i;
             break;
            }
           }
          } while(0);
          $_sum9_i_i=$1041|$1003;
          $_sum102_i=((($_sum9_i_i)+($tsize_244_i))|0);
          $1190=(($tbase_245_i+$_sum102_i)|0);
          $1191=$1190;
          $1192=((($1041)+($1011))|0);
          $oldfirst_0_i_i=$1191;$qsize_0_i_i=$1192;
         } else {
          $oldfirst_0_i_i=$1005;$qsize_0_i_i=$1011;
         }


         $1194=(($oldfirst_0_i_i+4)|0);
         $1195=((HEAP32[(($1194)>>2)])|0);
         $1196=$1195&-2;
         HEAP32[(($1194)>>2)]=$1196;
         $1197=$qsize_0_i_i|1;
         $_sum10_i_i=((($_sum_i21_i)+(4))|0);
         $1198=(($tbase_245_i+$_sum10_i_i)|0);
         $1199=$1198;
         HEAP32[(($1199)>>2)]=$1197;
         $_sum11_i_i=((($qsize_0_i_i)+($_sum_i21_i))|0);
         $1200=(($tbase_245_i+$_sum11_i_i)|0);
         $1201=$1200;
         HEAP32[(($1201)>>2)]=$qsize_0_i_i;
         $1202=$qsize_0_i_i>>>3;
         $1203=($qsize_0_i_i>>>0)<((256)>>>0);
         if ($1203) {
          $1205=$1202<<1;
          $1206=((11552+($1205<<2))|0);
          $1207=$1206;
          $1208=((HEAP32[((11512)>>2)])|0);
          $1209=1<<$1202;
          $1210=$1208&$1209;
          $1211=($1210|0)==0;
          do {
           if ($1211) {
            $1213=$1208|$1209;
            HEAP32[((11512)>>2)]=$1213;
            $_sum27_pre_i_i=((($1205)+(2))|0);
            $_pre_i24_i=((11552+($_sum27_pre_i_i<<2))|0);
            $F4_0_i_i=$1207;$_pre_phi_i25_i=$_pre_i24_i;
           } else {
            $_sum30_i_i=((($1205)+(2))|0);
            $1215=((11552+($_sum30_i_i<<2))|0);
            $1216=((HEAP32[(($1215)>>2)])|0);
            $1217=$1216;
            $1218=((HEAP32[((11528)>>2)])|0);
            $1219=($1217>>>0)<($1218>>>0);
            if (!($1219)) {
             $F4_0_i_i=$1216;$_pre_phi_i25_i=$1215;
             break;
            }
            _abort(); return ((0)|0);
           }
          } while(0);


          HEAP32[(($_pre_phi_i25_i)>>2)]=$1010;
          $1222=(($F4_0_i_i+12)|0);
          HEAP32[(($1222)>>2)]=$1010;
          $_sum28_i_i=((($_sum_i21_i)+(8))|0);
          $1223=(($tbase_245_i+$_sum28_i_i)|0);
          $1224=$1223;
          HEAP32[(($1224)>>2)]=$F4_0_i_i;
          $_sum29_i_i=((($_sum_i21_i)+(12))|0);
          $1225=(($tbase_245_i+$_sum29_i_i)|0);
          $1226=$1225;
          HEAP32[(($1226)>>2)]=$1207;
          break;
         }
         $1228=$1009;
         $1229=$qsize_0_i_i>>>8;
         $1230=($1229|0)==0;
         do {
          if ($1230) {
           $I7_0_i_i=0;
          } else {
           $1232=($qsize_0_i_i>>>0)>((16777215)>>>0);
           if ($1232) {
            $I7_0_i_i=31;
            break;
           }
           $1234=((($1229)+(1048320))|0);
           $1235=$1234>>>16;
           $1236=$1235&8;
           $1237=$1229<<$1236;
           $1238=((($1237)+(520192))|0);
           $1239=$1238>>>16;
           $1240=$1239&4;
           $1241=$1240|$1236;
           $1242=$1237<<$1240;
           $1243=((($1242)+(245760))|0);
           $1244=$1243>>>16;
           $1245=$1244&2;
           $1246=$1241|$1245;
           $1247=(((14)-($1246))|0);
           $1248=$1242<<$1245;
           $1249=$1248>>>15;
           $1250=((($1247)+($1249))|0);
           $1251=$1250<<1;
           $1252=((($1250)+(7))|0);
           $1253=$qsize_0_i_i>>>($1252>>>0);
           $1254=$1253&1;
           $1255=$1254|$1251;
           $I7_0_i_i=$1255;
          }
         } while(0);

         $1257=((11816+($I7_0_i_i<<2))|0);
         $_sum12_i26_i=((($_sum_i21_i)+(28))|0);
         $1258=(($tbase_245_i+$_sum12_i26_i)|0);
         $1259=$1258;
         HEAP32[(($1259)>>2)]=$I7_0_i_i;
         $_sum13_i_i=((($_sum_i21_i)+(16))|0);
         $1260=(($tbase_245_i+$_sum13_i_i)|0);
         $_sum14_i_i=((($_sum_i21_i)+(20))|0);
         $1261=(($tbase_245_i+$_sum14_i_i)|0);
         $1262=$1261;
         HEAP32[(($1262)>>2)]=0;
         $1263=$1260;
         HEAP32[(($1263)>>2)]=0;
         $1264=((HEAP32[((11516)>>2)])|0);
         $1265=1<<$I7_0_i_i;
         $1266=$1264&$1265;
         $1267=($1266|0)==0;
         if ($1267) {
          $1269=$1264|$1265;
          HEAP32[((11516)>>2)]=$1269;
          HEAP32[(($1257)>>2)]=$1228;
          $1270=$1257;
          $_sum15_i_i=((($_sum_i21_i)+(24))|0);
          $1271=(($tbase_245_i+$_sum15_i_i)|0);
          $1272=$1271;
          HEAP32[(($1272)>>2)]=$1270;
          $_sum16_i_i=((($_sum_i21_i)+(12))|0);
          $1273=(($tbase_245_i+$_sum16_i_i)|0);
          $1274=$1273;
          HEAP32[(($1274)>>2)]=$1228;
          $_sum17_i_i=((($_sum_i21_i)+(8))|0);
          $1275=(($tbase_245_i+$_sum17_i_i)|0);
          $1276=$1275;
          HEAP32[(($1276)>>2)]=$1228;
          break;
         }
         $1278=((HEAP32[(($1257)>>2)])|0);
         $1279=($I7_0_i_i|0)==31;
         if ($1279) {
          $1284=0;
         } else {
          $1281=$I7_0_i_i>>>1;
          $1282=(((25)-($1281))|0);
          $1284=$1282;
         }

         $1285=$qsize_0_i_i<<$1284;
         $K8_0_i_i=$1285;$T_0_i27_i=$1278;
         while(1) {


          $1287=(($T_0_i27_i+4)|0);
          $1288=((HEAP32[(($1287)>>2)])|0);
          $1289=$1288&-8;
          $1290=($1289|0)==($qsize_0_i_i|0);
          if ($1290) {
           break;
          }
          $1292=$K8_0_i_i>>>31;
          $1293=(($T_0_i27_i+16+($1292<<2))|0);
          $1294=((HEAP32[(($1293)>>2)])|0);
          $1295=($1294|0)==0;
          $1296=$K8_0_i_i<<1;
          if ($1295) {
           label = 296;
           break;
          } else {
           $K8_0_i_i=$1296;$T_0_i27_i=$1294;
          }
         }
         if ((label|0) == 296) {
          $1298=$1293;
          $1299=((HEAP32[((11528)>>2)])|0);
          $1300=($1298>>>0)<($1299>>>0);
          if ($1300) {
           _abort(); return ((0)|0);
          } else {
           HEAP32[(($1293)>>2)]=$1228;
           $_sum24_i_i=((($_sum_i21_i)+(24))|0);
           $1302=(($tbase_245_i+$_sum24_i_i)|0);
           $1303=$1302;
           HEAP32[(($1303)>>2)]=$T_0_i27_i;
           $_sum25_i_i=((($_sum_i21_i)+(12))|0);
           $1304=(($tbase_245_i+$_sum25_i_i)|0);
           $1305=$1304;
           HEAP32[(($1305)>>2)]=$1228;
           $_sum26_i_i=((($_sum_i21_i)+(8))|0);
           $1306=(($tbase_245_i+$_sum26_i_i)|0);
           $1307=$1306;
           HEAP32[(($1307)>>2)]=$1228;
           break;
          }
         }
         $1310=(($T_0_i27_i+8)|0);
         $1311=((HEAP32[(($1310)>>2)])|0);
         $1312=$T_0_i27_i;
         $1313=((HEAP32[((11528)>>2)])|0);
         $1314=($1312>>>0)<($1313>>>0);
         if ($1314) {
          _abort(); return ((0)|0);
         }
         $1316=$1311;
         $1317=($1316>>>0)<($1313>>>0);
         if ($1317) {
          _abort(); return ((0)|0);
         } else {
          $1319=(($1311+12)|0);
          HEAP32[(($1319)>>2)]=$1228;
          HEAP32[(($1310)>>2)]=$1228;
          $_sum21_i_i=((($_sum_i21_i)+(8))|0);
          $1320=(($tbase_245_i+$_sum21_i_i)|0);
          $1321=$1320;
          HEAP32[(($1321)>>2)]=$1311;
          $_sum22_i_i=((($_sum_i21_i)+(12))|0);
          $1322=(($tbase_245_i+$_sum22_i_i)|0);
          $1323=$1322;
          HEAP32[(($1323)>>2)]=$T_0_i27_i;
          $_sum23_i_i=((($_sum_i21_i)+(24))|0);
          $1324=(($tbase_245_i+$_sum23_i_i)|0);
          $1325=$1324;
          HEAP32[(($1325)>>2)]=0;
          break;
         }
        }
       } while(0);
       $_sum1819_i_i=$993|8;
       $1326=(($tbase_245_i+$_sum1819_i_i)|0);
       $mem_0=$1326;

       return (($mem_0)|0);
      }
     } while(0);
     $1327=$890;
     $sp_0_i_i_i=11960;
     while(1) {

      $1329=(($sp_0_i_i_i)|0);
      $1330=((HEAP32[(($1329)>>2)])|0);
      $1331=($1330>>>0)>($1327>>>0);
      if (!($1331)) {
       $1333=(($sp_0_i_i_i+4)|0);
       $1334=((HEAP32[(($1333)>>2)])|0);
       $1335=(($1330+$1334)|0);
       $1336=($1335>>>0)>($1327>>>0);
       if ($1336) {
        break;
       }
      }
      $1338=(($sp_0_i_i_i+8)|0);
      $1339=((HEAP32[(($1338)>>2)])|0);
      $sp_0_i_i_i=$1339;
     }
     $_sum_i15_i=((($1334)-(47))|0);
     $_sum1_i16_i=((($1334)-(39))|0);
     $1340=(($1330+$_sum1_i16_i)|0);
     $1341=$1340;
     $1342=$1341&7;
     $1343=($1342|0)==0;
     if ($1343) {
      $1348=0;
     } else {
      $1345=(((-$1341))|0);
      $1346=$1345&7;
      $1348=$1346;
     }

     $_sum2_i17_i=((($_sum_i15_i)+($1348))|0);
     $1349=(($1330+$_sum2_i17_i)|0);
     $1350=(($890+16)|0);
     $1351=$1350;
     $1352=($1349>>>0)<($1351>>>0);
     $1353=($1352?$1327:$1349);
     $1354=(($1353+8)|0);
     $1355=$1354;
     $1356=((($tsize_244_i)-(40))|0);
     $1357=(($tbase_245_i+8)|0);
     $1358=$1357;
     $1359=$1358&7;
     $1360=($1359|0)==0;
     if ($1360) {
      $1364=0;
     } else {
      $1362=(((-$1358))|0);
      $1363=$1362&7;
      $1364=$1363;
     }

     $1365=(($tbase_245_i+$1364)|0);
     $1366=$1365;
     $1367=((($1356)-($1364))|0);
     HEAP32[((11536)>>2)]=$1366;
     HEAP32[((11524)>>2)]=$1367;
     $1368=$1367|1;
     $_sum_i_i_i=((($1364)+(4))|0);
     $1369=(($tbase_245_i+$_sum_i_i_i)|0);
     $1370=$1369;
     HEAP32[(($1370)>>2)]=$1368;
     $_sum2_i_i_i=((($tsize_244_i)-(36))|0);
     $1371=(($tbase_245_i+$_sum2_i_i_i)|0);
     $1372=$1371;
     HEAP32[(($1372)>>2)]=40;
     $1373=((HEAP32[((11464)>>2)])|0);
     HEAP32[((11540)>>2)]=$1373;
     $1374=(($1353+4)|0);
     $1375=$1374;
     HEAP32[(($1375)>>2)]=27;
     HEAP32[(($1354)>>2)]=((HEAP32[((11960)>>2)])|0);HEAP32[((($1354)+(4))>>2)]=((HEAP32[((11964)>>2)])|0);HEAP32[((($1354)+(8))>>2)]=((HEAP32[((11968)>>2)])|0);HEAP32[((($1354)+(12))>>2)]=((HEAP32[((11972)>>2)])|0);
     HEAP32[((11960)>>2)]=$tbase_245_i;
     HEAP32[((11964)>>2)]=$tsize_244_i;
     HEAP32[((11972)>>2)]=0;
     HEAP32[((11968)>>2)]=$1355;
     $1376=(($1353+28)|0);
     $1377=$1376;
     HEAP32[(($1377)>>2)]=7;
     $1378=(($1353+32)|0);
     $1379=($1378>>>0)<($1335>>>0);
     if ($1379) {
      $1380=$1377;
      while(1) {

       $1381=(($1380+4)|0);
       HEAP32[(($1381)>>2)]=7;
       $1382=(($1380+8)|0);
       $1383=$1382;
       $1384=($1383>>>0)<($1335>>>0);
       if ($1384) {
        $1380=$1381;
       } else {
        break;
       }
      }
     }
     $1385=($1353|0)==($1327|0);
     if ($1385) {
      break;
     }
     $1387=$1353;
     $1388=$890;
     $1389=((($1387)-($1388))|0);
     $1390=(($1327+$1389)|0);
     $_sum3_i_i=((($1389)+(4))|0);
     $1391=(($1327+$_sum3_i_i)|0);
     $1392=$1391;
     $1393=((HEAP32[(($1392)>>2)])|0);
     $1394=$1393&-2;
     HEAP32[(($1392)>>2)]=$1394;
     $1395=$1389|1;
     $1396=(($890+4)|0);
     HEAP32[(($1396)>>2)]=$1395;
     $1397=$1390;
     HEAP32[(($1397)>>2)]=$1389;
     $1398=$1389>>>3;
     $1399=($1389>>>0)<((256)>>>0);
     if ($1399) {
      $1401=$1398<<1;
      $1402=((11552+($1401<<2))|0);
      $1403=$1402;
      $1404=((HEAP32[((11512)>>2)])|0);
      $1405=1<<$1398;
      $1406=$1404&$1405;
      $1407=($1406|0)==0;
      do {
       if ($1407) {
        $1409=$1404|$1405;
        HEAP32[((11512)>>2)]=$1409;
        $_sum11_pre_i_i=((($1401)+(2))|0);
        $_pre_i_i=((11552+($_sum11_pre_i_i<<2))|0);
        $F_0_i_i=$1403;$_pre_phi_i_i=$_pre_i_i;
       } else {
        $_sum12_i_i=((($1401)+(2))|0);
        $1411=((11552+($_sum12_i_i<<2))|0);
        $1412=((HEAP32[(($1411)>>2)])|0);
        $1413=$1412;
        $1414=((HEAP32[((11528)>>2)])|0);
        $1415=($1413>>>0)<($1414>>>0);
        if (!($1415)) {
         $F_0_i_i=$1412;$_pre_phi_i_i=$1411;
         break;
        }
        _abort(); return ((0)|0);
       }
      } while(0);


      HEAP32[(($_pre_phi_i_i)>>2)]=$890;
      $1418=(($F_0_i_i+12)|0);
      HEAP32[(($1418)>>2)]=$890;
      $1419=(($890+8)|0);
      HEAP32[(($1419)>>2)]=$F_0_i_i;
      $1420=(($890+12)|0);
      HEAP32[(($1420)>>2)]=$1403;
      break;
     }
     $1422=$890;
     $1423=$1389>>>8;
     $1424=($1423|0)==0;
     do {
      if ($1424) {
       $I1_0_i_i=0;
      } else {
       $1426=($1389>>>0)>((16777215)>>>0);
       if ($1426) {
        $I1_0_i_i=31;
        break;
       }
       $1428=((($1423)+(1048320))|0);
       $1429=$1428>>>16;
       $1430=$1429&8;
       $1431=$1423<<$1430;
       $1432=((($1431)+(520192))|0);
       $1433=$1432>>>16;
       $1434=$1433&4;
       $1435=$1434|$1430;
       $1436=$1431<<$1434;
       $1437=((($1436)+(245760))|0);
       $1438=$1437>>>16;
       $1439=$1438&2;
       $1440=$1435|$1439;
       $1441=(((14)-($1440))|0);
       $1442=$1436<<$1439;
       $1443=$1442>>>15;
       $1444=((($1441)+($1443))|0);
       $1445=$1444<<1;
       $1446=((($1444)+(7))|0);
       $1447=$1389>>>($1446>>>0);
       $1448=$1447&1;
       $1449=$1448|$1445;
       $I1_0_i_i=$1449;
      }
     } while(0);

     $1451=((11816+($I1_0_i_i<<2))|0);
     $1452=(($890+28)|0);
     $I1_0_c_i_i=$I1_0_i_i;
     HEAP32[(($1452)>>2)]=$I1_0_c_i_i;
     $1453=(($890+20)|0);
     HEAP32[(($1453)>>2)]=0;
     $1454=(($890+16)|0);
     HEAP32[(($1454)>>2)]=0;
     $1455=((HEAP32[((11516)>>2)])|0);
     $1456=1<<$I1_0_i_i;
     $1457=$1455&$1456;
     $1458=($1457|0)==0;
     if ($1458) {
      $1460=$1455|$1456;
      HEAP32[((11516)>>2)]=$1460;
      HEAP32[(($1451)>>2)]=$1422;
      $1461=(($890+24)|0);
      $_c_i_i=$1451;
      HEAP32[(($1461)>>2)]=$_c_i_i;
      $1462=(($890+12)|0);
      HEAP32[(($1462)>>2)]=$890;
      $1463=(($890+8)|0);
      HEAP32[(($1463)>>2)]=$890;
      break;
     }
     $1465=((HEAP32[(($1451)>>2)])|0);
     $1466=($I1_0_i_i|0)==31;
     if ($1466) {
      $1471=0;
     } else {
      $1468=$I1_0_i_i>>>1;
      $1469=(((25)-($1468))|0);
      $1471=$1469;
     }

     $1472=$1389<<$1471;
     $K2_0_i_i=$1472;$T_0_i_i=$1465;
     while(1) {


      $1474=(($T_0_i_i+4)|0);
      $1475=((HEAP32[(($1474)>>2)])|0);
      $1476=$1475&-8;
      $1477=($1476|0)==($1389|0);
      if ($1477) {
       break;
      }
      $1479=$K2_0_i_i>>>31;
      $1480=(($T_0_i_i+16+($1479<<2))|0);
      $1481=((HEAP32[(($1480)>>2)])|0);
      $1482=($1481|0)==0;
      $1483=$K2_0_i_i<<1;
      if ($1482) {
       label = 331;
       break;
      } else {
       $K2_0_i_i=$1483;$T_0_i_i=$1481;
      }
     }
     if ((label|0) == 331) {
      $1485=$1480;
      $1486=((HEAP32[((11528)>>2)])|0);
      $1487=($1485>>>0)<($1486>>>0);
      if ($1487) {
       _abort(); return ((0)|0);
      } else {
       HEAP32[(($1480)>>2)]=$1422;
       $1489=(($890+24)|0);
       $T_0_c8_i_i=$T_0_i_i;
       HEAP32[(($1489)>>2)]=$T_0_c8_i_i;
       $1490=(($890+12)|0);
       HEAP32[(($1490)>>2)]=$890;
       $1491=(($890+8)|0);
       HEAP32[(($1491)>>2)]=$890;
       break;
      }
     }
     $1494=(($T_0_i_i+8)|0);
     $1495=((HEAP32[(($1494)>>2)])|0);
     $1496=$T_0_i_i;
     $1497=((HEAP32[((11528)>>2)])|0);
     $1498=($1496>>>0)<($1497>>>0);
     if ($1498) {
      _abort(); return ((0)|0);
     }
     $1500=$1495;
     $1501=($1500>>>0)<($1497>>>0);
     if ($1501) {
      _abort(); return ((0)|0);
     } else {
      $1503=(($1495+12)|0);
      HEAP32[(($1503)>>2)]=$1422;
      HEAP32[(($1494)>>2)]=$1422;
      $1504=(($890+8)|0);
      $_c7_i_i=$1495;
      HEAP32[(($1504)>>2)]=$_c7_i_i;
      $1505=(($890+12)|0);
      $T_0_c_i_i=$T_0_i_i;
      HEAP32[(($1505)>>2)]=$T_0_c_i_i;
      $1506=(($890+24)|0);
      HEAP32[(($1506)>>2)]=0;
      break;
     }
    }
   } while(0);
   $1507=((HEAP32[((11524)>>2)])|0);
   $1508=($1507>>>0)>($nb_0>>>0);
   if (!($1508)) {
    break;
   }
   $1510=((($1507)-($nb_0))|0);
   HEAP32[((11524)>>2)]=$1510;
   $1511=((HEAP32[((11536)>>2)])|0);
   $1512=$1511;
   $1513=(($1512+$nb_0)|0);
   $1514=$1513;
   HEAP32[((11536)>>2)]=$1514;
   $1515=$1510|1;
   $_sum_i134=((($nb_0)+(4))|0);
   $1516=(($1512+$_sum_i134)|0);
   $1517=$1516;
   HEAP32[(($1517)>>2)]=$1515;
   $1518=$nb_0|3;
   $1519=(($1511+4)|0);
   HEAP32[(($1519)>>2)]=$1518;
   $1520=(($1511+8)|0);
   $1521=$1520;
   $mem_0=$1521;

   return (($mem_0)|0);
  }
 } while(0);
 $1522=((___errno_location())|0);
 HEAP32[(($1522)>>2)]=12;
 $mem_0=0;

 return (($mem_0)|0);
}


function _free($mem){
 $mem=($mem)|0;
 var $1=0,$3=0,$4=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$12=0,$14=0,$_sum=0,$15=0,$16=0,$17=0,$18=0,$20=0,$21=0,$22=0,$_sum232=0;
 var $24=0,$25=0,$26=0,$27=0,$29=0,$30=0,$32=0,$33=0,$_sum276=0,$35=0,$36=0,$37=0,$_sum277=0,$38=0,$39=0,$40=0,$41=0,$42=0,$43=0,$44=0;
 var $46=0,$47=0,$49=0,$50=0,$51=0,$52=0,$54=0,$55=0,$56=0,$57=0,$59=0,$_pre305=0,$61=0,$62=0,$64=0,$65=0,$66=0,$_pre_phi306=0,$67=0,$69=0;
 var $_sum266=0,$70=0,$71=0,$72=0,$_sum267=0,$73=0,$74=0,$75=0,$76=0,$_sum273=0,$78=0,$79=0,$80=0,$81=0,$82=0,$84=0,$85=0,$86=0,$88=0,$89=0;
 var $90=0,$_sum269=0,$93=0,$94=0,$95=0,$96=0,$_sum268=0,$98=0,$99=0,$100=0,$101=0,$RP_0=0,$R_0=0,$102=0,$103=0,$104=0,$106=0,$107=0,$108=0,$110=0;
 var $111=0,$R_1=0,$115=0,$_sum270=0,$117=0,$118=0,$119=0,$120=0,$121=0,$122=0,$cond=0,$124=0,$125=0,$126=0,$127=0,$128=0,$130=0,$131=0,$132=0,$134=0;
 var $135=0,$136=0,$139=0,$142=0,$144=0,$145=0,$146=0,$148=0,$_sum271=0,$149=0,$150=0,$151=0,$152=0,$154=0,$155=0,$156=0,$158=0,$159=0,$_sum272=0,$162=0;
 var $163=0,$164=0,$165=0,$167=0,$168=0,$169=0,$171=0,$172=0,$_sum233=0,$176=0,$177=0,$178=0,$179=0,$180=0,$182=0,$183=0,$184=0,$_sum264=0,$185=0,$186=0;
 var $187=0,$psize_0=0,$p_0=0,$189=0,$190=0,$_sum263=0,$192=0,$193=0,$194=0,$195=0,$phitmp=0,$197=0,$198=0,$200=0,$201=0,$203=0,$204=0,$205=0,$206=0,$207=0;
 var $208=0,$211=0,$212=0,$214=0,$215=0,$216=0,$217=0,$218=0,$219=0,$221=0,$222=0,$223=0,$224=0,$226=0,$227=0,$228=0,$_sum257258=0,$229=0,$230=0,$231=0;
 var $232=0,$233=0,$234=0,$235=0,$237=0,$238=0,$239=0,$241=0,$242=0,$243=0,$244=0,$246=0,$247=0,$248=0,$249=0,$251=0,$_pre303=0,$253=0,$254=0,$255=0;
 var $257=0,$258=0,$259=0,$_pre_phi304=0,$260=0,$262=0,$_sum235=0,$263=0,$264=0,$265=0,$_sum236237=0,$266=0,$267=0,$268=0,$269=0,$271=0,$272=0,$273=0,$274=0,$275=0;
 var $276=0,$278=0,$279=0,$280=0,$282=0,$283=0,$284=0,$_sum239=0,$287=0,$288=0,$289=0,$290=0,$_sum238=0,$292=0,$293=0,$294=0,$295=0,$RP9_0=0,$R7_0=0,$296=0;
 var $297=0,$298=0,$300=0,$301=0,$302=0,$304=0,$305=0,$306=0,$R7_1=0,$310=0,$_sum250=0,$312=0,$313=0,$314=0,$315=0,$316=0,$317=0,$cond298=0,$319=0,$320=0;
 var $321=0,$322=0,$323=0,$325=0,$326=0,$327=0,$329=0,$330=0,$331=0,$334=0,$337=0,$339=0,$340=0,$341=0,$343=0,$_sum251=0,$344=0,$345=0,$346=0,$347=0;
 var $349=0,$350=0,$351=0,$353=0,$354=0,$_sum252=0,$357=0,$358=0,$359=0,$360=0,$362=0,$363=0,$364=0,$366=0,$367=0,$371=0,$372=0,$373=0,$374=0,$375=0;
 var $376=0,$379=0,$380=0,$381=0,$382=0,$383=0,$psize_1=0,$385=0,$386=0,$388=0,$389=0,$390=0,$391=0,$392=0,$393=0,$394=0,$396=0,$_sum248_pre=0,$_pre=0,$_sum249=0;
 var $398=0,$399=0,$400=0,$401=0,$402=0,$_pre_phi=0,$F16_0=0,$405=0,$406=0,$407=0,$409=0,$410=0,$411=0,$413=0,$415=0,$416=0,$417=0,$418=0,$419=0,$420=0;
 var $421=0,$422=0,$423=0,$424=0,$425=0,$426=0,$427=0,$428=0,$429=0,$430=0,$431=0,$432=0,$433=0,$434=0,$435=0,$436=0,$I18_0=0,$438=0,$439=0,$I18_0_c=0;
 var $440=0,$441=0,$442=0,$443=0,$444=0,$445=0,$447=0,$448=0,$_c=0,$449=0,$450=0,$452=0,$453=0,$455=0,$456=0,$458=0,$459=0,$T_0=0,$K19_0=0,$461=0;
 var $462=0,$463=0,$464=0,$466=0,$467=0,$468=0,$469=0,$470=0,$472=0,$473=0,$474=0,$476=0,$T_0_c245=0,$477=0,$478=0,$481=0,$482=0,$483=0,$484=0,$485=0;
 var $487=0,$488=0,$490=0,$491=0,$_c244=0,$492=0,$T_0_c=0,$493=0,$495=0,$496=0,$497=0,$sp_0_in_i=0,$sp_0_i=0,$498=0,$499=0,label=0;

 $1=($mem|0)==0;
 if ($1) {
  return;
 }
 $3=((($mem)-(8))|0);
 $4=$3;
 $5=((HEAP32[((11528)>>2)])|0);
 $6=($3>>>0)<($5>>>0);
 if ($6) {
  _abort();

 }
 $8=((($mem)-(4))|0);
 $9=$8;
 $10=((HEAP32[(($9)>>2)])|0);
 $11=$10&3;
 $12=($11|0)==1;
 if ($12) {
  _abort();

 }
 $14=$10&-8;
 $_sum=((($14)-(8))|0);
 $15=(($mem+$_sum)|0);
 $16=$15;
 $17=$10&1;
 $18=($17|0)==0;
 L10: do {
  if ($18) {
   $20=$3;
   $21=((HEAP32[(($20)>>2)])|0);
   $22=($11|0)==0;
   if ($22) {
    return;
   }
   $_sum232=(((-8)-($21))|0);
   $24=(($mem+$_sum232)|0);
   $25=$24;
   $26=((($21)+($14))|0);
   $27=($24>>>0)<($5>>>0);
   if ($27) {
    _abort();

   }
   $29=((HEAP32[((11532)>>2)])|0);
   $30=($25|0)==($29|0);
   if ($30) {
    $_sum233=((($14)-(4))|0);
    $176=(($mem+$_sum233)|0);
    $177=$176;
    $178=((HEAP32[(($177)>>2)])|0);
    $179=$178&3;
    $180=($179|0)==3;
    if (!($180)) {
     $p_0=$25;$psize_0=$26;
     break;
    }
    HEAP32[((11520)>>2)]=$26;
    $182=((HEAP32[(($177)>>2)])|0);
    $183=$182&-2;
    HEAP32[(($177)>>2)]=$183;
    $184=$26|1;
    $_sum264=((($_sum232)+(4))|0);
    $185=(($mem+$_sum264)|0);
    $186=$185;
    HEAP32[(($186)>>2)]=$184;
    $187=$15;
    HEAP32[(($187)>>2)]=$26;
    return;
   }
   $32=$21>>>3;
   $33=($21>>>0)<((256)>>>0);
   if ($33) {
    $_sum276=((($_sum232)+(8))|0);
    $35=(($mem+$_sum276)|0);
    $36=$35;
    $37=((HEAP32[(($36)>>2)])|0);
    $_sum277=((($_sum232)+(12))|0);
    $38=(($mem+$_sum277)|0);
    $39=$38;
    $40=((HEAP32[(($39)>>2)])|0);
    $41=$32<<1;
    $42=((11552+($41<<2))|0);
    $43=$42;
    $44=($37|0)==($43|0);
    do {
     if (!($44)) {
      $46=$37;
      $47=($46>>>0)<($5>>>0);
      if ($47) {
       _abort();

      }
      $49=(($37+12)|0);
      $50=((HEAP32[(($49)>>2)])|0);
      $51=($50|0)==($25|0);
      if ($51) {
       break;
      }
      _abort();

     }
    } while(0);
    $52=($40|0)==($37|0);
    if ($52) {
     $54=1<<$32;
     $55=$54^-1;
     $56=((HEAP32[((11512)>>2)])|0);
     $57=$56&$55;
     HEAP32[((11512)>>2)]=$57;
     $p_0=$25;$psize_0=$26;
     break;
    }
    $59=($40|0)==($43|0);
    do {
     if ($59) {
      $_pre305=(($40+8)|0);
      $_pre_phi306=$_pre305;
     } else {
      $61=$40;
      $62=($61>>>0)<($5>>>0);
      if ($62) {
       _abort();

      }
      $64=(($40+8)|0);
      $65=((HEAP32[(($64)>>2)])|0);
      $66=($65|0)==($25|0);
      if ($66) {
       $_pre_phi306=$64;
       break;
      }
      _abort();

     }
    } while(0);

    $67=(($37+12)|0);
    HEAP32[(($67)>>2)]=$40;
    HEAP32[(($_pre_phi306)>>2)]=$37;
    $p_0=$25;$psize_0=$26;
    break;
   }
   $69=$24;
   $_sum266=((($_sum232)+(24))|0);
   $70=(($mem+$_sum266)|0);
   $71=$70;
   $72=((HEAP32[(($71)>>2)])|0);
   $_sum267=((($_sum232)+(12))|0);
   $73=(($mem+$_sum267)|0);
   $74=$73;
   $75=((HEAP32[(($74)>>2)])|0);
   $76=($75|0)==($69|0);
   do {
    if ($76) {
     $_sum269=((($_sum232)+(20))|0);
     $93=(($mem+$_sum269)|0);
     $94=$93;
     $95=((HEAP32[(($94)>>2)])|0);
     $96=($95|0)==0;
     if ($96) {
      $_sum268=((($_sum232)+(16))|0);
      $98=(($mem+$_sum268)|0);
      $99=$98;
      $100=((HEAP32[(($99)>>2)])|0);
      $101=($100|0)==0;
      if ($101) {
       $R_1=0;
       break;
      } else {
       $R_0=$100;$RP_0=$99;
      }
     } else {
      $R_0=$95;$RP_0=$94;
     }
     while(1) {


      $102=(($R_0+20)|0);
      $103=((HEAP32[(($102)>>2)])|0);
      $104=($103|0)==0;
      if (!($104)) {
       $R_0=$103;$RP_0=$102;
       continue;
      }
      $106=(($R_0+16)|0);
      $107=((HEAP32[(($106)>>2)])|0);
      $108=($107|0)==0;
      if ($108) {
       break;
      } else {
       $R_0=$107;$RP_0=$106;
      }
     }
     $110=$RP_0;
     $111=($110>>>0)<($5>>>0);
     if ($111) {
      _abort();

     } else {
      HEAP32[(($RP_0)>>2)]=0;
      $R_1=$R_0;
      break;
     }
    } else {
     $_sum273=((($_sum232)+(8))|0);
     $78=(($mem+$_sum273)|0);
     $79=$78;
     $80=((HEAP32[(($79)>>2)])|0);
     $81=$80;
     $82=($81>>>0)<($5>>>0);
     if ($82) {
      _abort();

     }
     $84=(($80+12)|0);
     $85=((HEAP32[(($84)>>2)])|0);
     $86=($85|0)==($69|0);
     if (!($86)) {
      _abort();

     }
     $88=(($75+8)|0);
     $89=((HEAP32[(($88)>>2)])|0);
     $90=($89|0)==($69|0);
     if ($90) {
      HEAP32[(($84)>>2)]=$75;
      HEAP32[(($88)>>2)]=$80;
      $R_1=$75;
      break;
     } else {
      _abort();

     }
    }
   } while(0);

   $115=($72|0)==0;
   if ($115) {
    $p_0=$25;$psize_0=$26;
    break;
   }
   $_sum270=((($_sum232)+(28))|0);
   $117=(($mem+$_sum270)|0);
   $118=$117;
   $119=((HEAP32[(($118)>>2)])|0);
   $120=((11816+($119<<2))|0);
   $121=((HEAP32[(($120)>>2)])|0);
   $122=($69|0)==($121|0);
   do {
    if ($122) {
     HEAP32[(($120)>>2)]=$R_1;
     $cond=($R_1|0)==0;
     if (!($cond)) {
      break;
     }
     $124=((HEAP32[(($118)>>2)])|0);
     $125=1<<$124;
     $126=$125^-1;
     $127=((HEAP32[((11516)>>2)])|0);
     $128=$127&$126;
     HEAP32[((11516)>>2)]=$128;
     $p_0=$25;$psize_0=$26;
     break L10;
    } else {
     $130=$72;
     $131=((HEAP32[((11528)>>2)])|0);
     $132=($130>>>0)<($131>>>0);
     if ($132) {
      _abort();

     }
     $134=(($72+16)|0);
     $135=((HEAP32[(($134)>>2)])|0);
     $136=($135|0)==($69|0);
     if ($136) {
      HEAP32[(($134)>>2)]=$R_1;
     } else {
      $139=(($72+20)|0);
      HEAP32[(($139)>>2)]=$R_1;
     }
     $142=($R_1|0)==0;
     if ($142) {
      $p_0=$25;$psize_0=$26;
      break L10;
     }
    }
   } while(0);
   $144=$R_1;
   $145=((HEAP32[((11528)>>2)])|0);
   $146=($144>>>0)<($145>>>0);
   if ($146) {
    _abort();

   }
   $148=(($R_1+24)|0);
   HEAP32[(($148)>>2)]=$72;
   $_sum271=((($_sum232)+(16))|0);
   $149=(($mem+$_sum271)|0);
   $150=$149;
   $151=((HEAP32[(($150)>>2)])|0);
   $152=($151|0)==0;
   do {
    if (!($152)) {
     $154=$151;
     $155=((HEAP32[((11528)>>2)])|0);
     $156=($154>>>0)<($155>>>0);
     if ($156) {
      _abort();

     } else {
      $158=(($R_1+16)|0);
      HEAP32[(($158)>>2)]=$151;
      $159=(($151+24)|0);
      HEAP32[(($159)>>2)]=$R_1;
      break;
     }
    }
   } while(0);
   $_sum272=((($_sum232)+(20))|0);
   $162=(($mem+$_sum272)|0);
   $163=$162;
   $164=((HEAP32[(($163)>>2)])|0);
   $165=($164|0)==0;
   if ($165) {
    $p_0=$25;$psize_0=$26;
    break;
   }
   $167=$164;
   $168=((HEAP32[((11528)>>2)])|0);
   $169=($167>>>0)<($168>>>0);
   if ($169) {
    _abort();

   } else {
    $171=(($R_1+20)|0);
    HEAP32[(($171)>>2)]=$164;
    $172=(($164+24)|0);
    HEAP32[(($172)>>2)]=$R_1;
    $p_0=$25;$psize_0=$26;
    break;
   }
  } else {
   $p_0=$4;$psize_0=$14;
  }
 } while(0);


 $189=$p_0;
 $190=($189>>>0)<($15>>>0);
 if (!($190)) {
  _abort();

 }
 $_sum263=((($14)-(4))|0);
 $192=(($mem+$_sum263)|0);
 $193=$192;
 $194=((HEAP32[(($193)>>2)])|0);
 $195=$194&1;
 $phitmp=($195|0)==0;
 if ($phitmp) {
  _abort();

 }
 $197=$194&2;
 $198=($197|0)==0;
 do {
  if ($198) {
   $200=((HEAP32[((11536)>>2)])|0);
   $201=($16|0)==($200|0);
   if ($201) {
    $203=((HEAP32[((11524)>>2)])|0);
    $204=((($203)+($psize_0))|0);
    HEAP32[((11524)>>2)]=$204;
    HEAP32[((11536)>>2)]=$p_0;
    $205=$204|1;
    $206=(($p_0+4)|0);
    HEAP32[(($206)>>2)]=$205;
    $207=((HEAP32[((11532)>>2)])|0);
    $208=($p_0|0)==($207|0);
    if (!($208)) {
     return;
    }
    HEAP32[((11532)>>2)]=0;
    HEAP32[((11520)>>2)]=0;
    return;
   }
   $211=((HEAP32[((11532)>>2)])|0);
   $212=($16|0)==($211|0);
   if ($212) {
    $214=((HEAP32[((11520)>>2)])|0);
    $215=((($214)+($psize_0))|0);
    HEAP32[((11520)>>2)]=$215;
    HEAP32[((11532)>>2)]=$p_0;
    $216=$215|1;
    $217=(($p_0+4)|0);
    HEAP32[(($217)>>2)]=$216;
    $218=(($189+$215)|0);
    $219=$218;
    HEAP32[(($219)>>2)]=$215;
    return;
   }
   $221=$194&-8;
   $222=((($221)+($psize_0))|0);
   $223=$194>>>3;
   $224=($194>>>0)<((256)>>>0);
   L113: do {
    if ($224) {
     $226=(($mem+$14)|0);
     $227=$226;
     $228=((HEAP32[(($227)>>2)])|0);
     $_sum257258=$14|4;
     $229=(($mem+$_sum257258)|0);
     $230=$229;
     $231=((HEAP32[(($230)>>2)])|0);
     $232=$223<<1;
     $233=((11552+($232<<2))|0);
     $234=$233;
     $235=($228|0)==($234|0);
     do {
      if (!($235)) {
       $237=$228;
       $238=((HEAP32[((11528)>>2)])|0);
       $239=($237>>>0)<($238>>>0);
       if ($239) {
        _abort();

       }
       $241=(($228+12)|0);
       $242=((HEAP32[(($241)>>2)])|0);
       $243=($242|0)==($16|0);
       if ($243) {
        break;
       }
       _abort();

      }
     } while(0);
     $244=($231|0)==($228|0);
     if ($244) {
      $246=1<<$223;
      $247=$246^-1;
      $248=((HEAP32[((11512)>>2)])|0);
      $249=$248&$247;
      HEAP32[((11512)>>2)]=$249;
      break;
     }
     $251=($231|0)==($234|0);
     do {
      if ($251) {
       $_pre303=(($231+8)|0);
       $_pre_phi304=$_pre303;
      } else {
       $253=$231;
       $254=((HEAP32[((11528)>>2)])|0);
       $255=($253>>>0)<($254>>>0);
       if ($255) {
        _abort();

       }
       $257=(($231+8)|0);
       $258=((HEAP32[(($257)>>2)])|0);
       $259=($258|0)==($16|0);
       if ($259) {
        $_pre_phi304=$257;
        break;
       }
       _abort();

      }
     } while(0);

     $260=(($228+12)|0);
     HEAP32[(($260)>>2)]=$231;
     HEAP32[(($_pre_phi304)>>2)]=$228;
    } else {
     $262=$15;
     $_sum235=((($14)+(16))|0);
     $263=(($mem+$_sum235)|0);
     $264=$263;
     $265=((HEAP32[(($264)>>2)])|0);
     $_sum236237=$14|4;
     $266=(($mem+$_sum236237)|0);
     $267=$266;
     $268=((HEAP32[(($267)>>2)])|0);
     $269=($268|0)==($262|0);
     do {
      if ($269) {
       $_sum239=((($14)+(12))|0);
       $287=(($mem+$_sum239)|0);
       $288=$287;
       $289=((HEAP32[(($288)>>2)])|0);
       $290=($289|0)==0;
       if ($290) {
        $_sum238=((($14)+(8))|0);
        $292=(($mem+$_sum238)|0);
        $293=$292;
        $294=((HEAP32[(($293)>>2)])|0);
        $295=($294|0)==0;
        if ($295) {
         $R7_1=0;
         break;
        } else {
         $R7_0=$294;$RP9_0=$293;
        }
       } else {
        $R7_0=$289;$RP9_0=$288;
       }
       while(1) {


        $296=(($R7_0+20)|0);
        $297=((HEAP32[(($296)>>2)])|0);
        $298=($297|0)==0;
        if (!($298)) {
         $R7_0=$297;$RP9_0=$296;
         continue;
        }
        $300=(($R7_0+16)|0);
        $301=((HEAP32[(($300)>>2)])|0);
        $302=($301|0)==0;
        if ($302) {
         break;
        } else {
         $R7_0=$301;$RP9_0=$300;
        }
       }
       $304=$RP9_0;
       $305=((HEAP32[((11528)>>2)])|0);
       $306=($304>>>0)<($305>>>0);
       if ($306) {
        _abort();

       } else {
        HEAP32[(($RP9_0)>>2)]=0;
        $R7_1=$R7_0;
        break;
       }
      } else {
       $271=(($mem+$14)|0);
       $272=$271;
       $273=((HEAP32[(($272)>>2)])|0);
       $274=$273;
       $275=((HEAP32[((11528)>>2)])|0);
       $276=($274>>>0)<($275>>>0);
       if ($276) {
        _abort();

       }
       $278=(($273+12)|0);
       $279=((HEAP32[(($278)>>2)])|0);
       $280=($279|0)==($262|0);
       if (!($280)) {
        _abort();

       }
       $282=(($268+8)|0);
       $283=((HEAP32[(($282)>>2)])|0);
       $284=($283|0)==($262|0);
       if ($284) {
        HEAP32[(($278)>>2)]=$268;
        HEAP32[(($282)>>2)]=$273;
        $R7_1=$268;
        break;
       } else {
        _abort();

       }
      }
     } while(0);

     $310=($265|0)==0;
     if ($310) {
      break;
     }
     $_sum250=((($14)+(20))|0);
     $312=(($mem+$_sum250)|0);
     $313=$312;
     $314=((HEAP32[(($313)>>2)])|0);
     $315=((11816+($314<<2))|0);
     $316=((HEAP32[(($315)>>2)])|0);
     $317=($262|0)==($316|0);
     do {
      if ($317) {
       HEAP32[(($315)>>2)]=$R7_1;
       $cond298=($R7_1|0)==0;
       if (!($cond298)) {
        break;
       }
       $319=((HEAP32[(($313)>>2)])|0);
       $320=1<<$319;
       $321=$320^-1;
       $322=((HEAP32[((11516)>>2)])|0);
       $323=$322&$321;
       HEAP32[((11516)>>2)]=$323;
       break L113;
      } else {
       $325=$265;
       $326=((HEAP32[((11528)>>2)])|0);
       $327=($325>>>0)<($326>>>0);
       if ($327) {
        _abort();

       }
       $329=(($265+16)|0);
       $330=((HEAP32[(($329)>>2)])|0);
       $331=($330|0)==($262|0);
       if ($331) {
        HEAP32[(($329)>>2)]=$R7_1;
       } else {
        $334=(($265+20)|0);
        HEAP32[(($334)>>2)]=$R7_1;
       }
       $337=($R7_1|0)==0;
       if ($337) {
        break L113;
       }
      }
     } while(0);
     $339=$R7_1;
     $340=((HEAP32[((11528)>>2)])|0);
     $341=($339>>>0)<($340>>>0);
     if ($341) {
      _abort();

     }
     $343=(($R7_1+24)|0);
     HEAP32[(($343)>>2)]=$265;
     $_sum251=((($14)+(8))|0);
     $344=(($mem+$_sum251)|0);
     $345=$344;
     $346=((HEAP32[(($345)>>2)])|0);
     $347=($346|0)==0;
     do {
      if (!($347)) {
       $349=$346;
       $350=((HEAP32[((11528)>>2)])|0);
       $351=($349>>>0)<($350>>>0);
       if ($351) {
        _abort();

       } else {
        $353=(($R7_1+16)|0);
        HEAP32[(($353)>>2)]=$346;
        $354=(($346+24)|0);
        HEAP32[(($354)>>2)]=$R7_1;
        break;
       }
      }
     } while(0);
     $_sum252=((($14)+(12))|0);
     $357=(($mem+$_sum252)|0);
     $358=$357;
     $359=((HEAP32[(($358)>>2)])|0);
     $360=($359|0)==0;
     if ($360) {
      break;
     }
     $362=$359;
     $363=((HEAP32[((11528)>>2)])|0);
     $364=($362>>>0)<($363>>>0);
     if ($364) {
      _abort();

     } else {
      $366=(($R7_1+20)|0);
      HEAP32[(($366)>>2)]=$359;
      $367=(($359+24)|0);
      HEAP32[(($367)>>2)]=$R7_1;
      break;
     }
    }
   } while(0);
   $371=$222|1;
   $372=(($p_0+4)|0);
   HEAP32[(($372)>>2)]=$371;
   $373=(($189+$222)|0);
   $374=$373;
   HEAP32[(($374)>>2)]=$222;
   $375=((HEAP32[((11532)>>2)])|0);
   $376=($p_0|0)==($375|0);
   if (!($376)) {
    $psize_1=$222;
    break;
   }
   HEAP32[((11520)>>2)]=$222;
   return;
  } else {
   $379=$194&-2;
   HEAP32[(($193)>>2)]=$379;
   $380=$psize_0|1;
   $381=(($p_0+4)|0);
   HEAP32[(($381)>>2)]=$380;
   $382=(($189+$psize_0)|0);
   $383=$382;
   HEAP32[(($383)>>2)]=$psize_0;
   $psize_1=$psize_0;
  }
 } while(0);

 $385=$psize_1>>>3;
 $386=($psize_1>>>0)<((256)>>>0);
 if ($386) {
  $388=$385<<1;
  $389=((11552+($388<<2))|0);
  $390=$389;
  $391=((HEAP32[((11512)>>2)])|0);
  $392=1<<$385;
  $393=$391&$392;
  $394=($393|0)==0;
  do {
   if ($394) {
    $396=$391|$392;
    HEAP32[((11512)>>2)]=$396;
    $_sum248_pre=((($388)+(2))|0);
    $_pre=((11552+($_sum248_pre<<2))|0);
    $F16_0=$390;$_pre_phi=$_pre;
   } else {
    $_sum249=((($388)+(2))|0);
    $398=((11552+($_sum249<<2))|0);
    $399=((HEAP32[(($398)>>2)])|0);
    $400=$399;
    $401=((HEAP32[((11528)>>2)])|0);
    $402=($400>>>0)<($401>>>0);
    if (!($402)) {
     $F16_0=$399;$_pre_phi=$398;
     break;
    }
    _abort();

   }
  } while(0);


  HEAP32[(($_pre_phi)>>2)]=$p_0;
  $405=(($F16_0+12)|0);
  HEAP32[(($405)>>2)]=$p_0;
  $406=(($p_0+8)|0);
  HEAP32[(($406)>>2)]=$F16_0;
  $407=(($p_0+12)|0);
  HEAP32[(($407)>>2)]=$390;
  return;
 }
 $409=$p_0;
 $410=$psize_1>>>8;
 $411=($410|0)==0;
 do {
  if ($411) {
   $I18_0=0;
  } else {
   $413=($psize_1>>>0)>((16777215)>>>0);
   if ($413) {
    $I18_0=31;
    break;
   }
   $415=((($410)+(1048320))|0);
   $416=$415>>>16;
   $417=$416&8;
   $418=$410<<$417;
   $419=((($418)+(520192))|0);
   $420=$419>>>16;
   $421=$420&4;
   $422=$421|$417;
   $423=$418<<$421;
   $424=((($423)+(245760))|0);
   $425=$424>>>16;
   $426=$425&2;
   $427=$422|$426;
   $428=(((14)-($427))|0);
   $429=$423<<$426;
   $430=$429>>>15;
   $431=((($428)+($430))|0);
   $432=$431<<1;
   $433=((($431)+(7))|0);
   $434=$psize_1>>>($433>>>0);
   $435=$434&1;
   $436=$435|$432;
   $I18_0=$436;
  }
 } while(0);

 $438=((11816+($I18_0<<2))|0);
 $439=(($p_0+28)|0);
 $I18_0_c=$I18_0;
 HEAP32[(($439)>>2)]=$I18_0_c;
 $440=(($p_0+20)|0);
 HEAP32[(($440)>>2)]=0;
 $441=(($p_0+16)|0);
 HEAP32[(($441)>>2)]=0;
 $442=((HEAP32[((11516)>>2)])|0);
 $443=1<<$I18_0;
 $444=$442&$443;
 $445=($444|0)==0;
 do {
  if ($445) {
   $447=$442|$443;
   HEAP32[((11516)>>2)]=$447;
   HEAP32[(($438)>>2)]=$409;
   $448=(($p_0+24)|0);
   $_c=$438;
   HEAP32[(($448)>>2)]=$_c;
   $449=(($p_0+12)|0);
   HEAP32[(($449)>>2)]=$p_0;
   $450=(($p_0+8)|0);
   HEAP32[(($450)>>2)]=$p_0;
  } else {
   $452=((HEAP32[(($438)>>2)])|0);
   $453=($I18_0|0)==31;
   if ($453) {
    $458=0;
   } else {
    $455=$I18_0>>>1;
    $456=(((25)-($455))|0);
    $458=$456;
   }

   $459=$psize_1<<$458;
   $K19_0=$459;$T_0=$452;
   while(1) {


    $461=(($T_0+4)|0);
    $462=((HEAP32[(($461)>>2)])|0);
    $463=$462&-8;
    $464=($463|0)==($psize_1|0);
    if ($464) {
     break;
    }
    $466=$K19_0>>>31;
    $467=(($T_0+16+($466<<2))|0);
    $468=((HEAP32[(($467)>>2)])|0);
    $469=($468|0)==0;
    $470=$K19_0<<1;
    if ($469) {
     label = 129;
     break;
    } else {
     $K19_0=$470;$T_0=$468;
    }
   }
   if ((label|0) == 129) {
    $472=$467;
    $473=((HEAP32[((11528)>>2)])|0);
    $474=($472>>>0)<($473>>>0);
    if ($474) {
     _abort();

    } else {
     HEAP32[(($467)>>2)]=$409;
     $476=(($p_0+24)|0);
     $T_0_c245=$T_0;
     HEAP32[(($476)>>2)]=$T_0_c245;
     $477=(($p_0+12)|0);
     HEAP32[(($477)>>2)]=$p_0;
     $478=(($p_0+8)|0);
     HEAP32[(($478)>>2)]=$p_0;
     break;
    }
   }
   $481=(($T_0+8)|0);
   $482=((HEAP32[(($481)>>2)])|0);
   $483=$T_0;
   $484=((HEAP32[((11528)>>2)])|0);
   $485=($483>>>0)<($484>>>0);
   if ($485) {
    _abort();

   }
   $487=$482;
   $488=($487>>>0)<($484>>>0);
   if ($488) {
    _abort();

   } else {
    $490=(($482+12)|0);
    HEAP32[(($490)>>2)]=$409;
    HEAP32[(($481)>>2)]=$409;
    $491=(($p_0+8)|0);
    $_c244=$482;
    HEAP32[(($491)>>2)]=$_c244;
    $492=(($p_0+12)|0);
    $T_0_c=$T_0;
    HEAP32[(($492)>>2)]=$T_0_c;
    $493=(($p_0+24)|0);
    HEAP32[(($493)>>2)]=0;
    break;
   }
  }
 } while(0);
 $495=((HEAP32[((11544)>>2)])|0);
 $496=((($495)-(1))|0);
 HEAP32[((11544)>>2)]=$496;
 $497=($496|0)==0;
 if ($497) {
  $sp_0_in_i=11968;
 } else {
  return;
 }
 while(1) {

  $sp_0_i=((HEAP32[(($sp_0_in_i)>>2)])|0);
  $498=($sp_0_i|0)==0;
  $499=(($sp_0_i+8)|0);
  if ($498) {
   break;
  } else {
   $sp_0_in_i=$499;
  }
 }
 HEAP32[((11544)>>2)]=-1;
 return;
}


function _calloc($n_elements,$elem_size){
 $n_elements=($n_elements)|0;
 $elem_size=($elem_size)|0;
 var $1=0,$3=0,$4=0,$5=0,$7=0,$8=0,$_=0,$req_0=0,$10=0,$11=0,$13=0,$14=0,$15=0,$16=0,$17=0,label=0;

 $1=($n_elements|0)==0;
 do {
  if ($1) {
   $req_0=0;
  } else {
   $3=(Math_imul($elem_size,$n_elements)|0);
   $4=$elem_size|$n_elements;
   $5=($4>>>0)>((65535)>>>0);
   if (!($5)) {
    $req_0=$3;
    break;
   }
   $7=(((($3>>>0))/(($n_elements>>>0)))&-1);
   $8=($7|0)==($elem_size|0);
   $_=($8?$3:-1);
   $req_0=$_;
  }
 } while(0);

 $10=((_malloc($req_0))|0);
 $11=($10|0)==0;
 if ($11) {
  return (($10)|0);
 }
 $13=((($10)-(4))|0);
 $14=$13;
 $15=((HEAP32[(($14)>>2)])|0);
 $16=$15&3;
 $17=($16|0)==0;
 if ($17) {
  return (($10)|0);
 }
 _memset((((($10)|0))|0), ((((0)|0))|0), (((($req_0)|0))|0))|0;
 return (($10)|0);
}


function ___floatscan($f,$prec,$pok){
 $f=($f)|0;
 $prec=($prec)|0;
 $pok=($pok)|0;
 var $x_i=0,$bits_0_ph=0,$emin_0_ph=0,$3=0,$4=0,$6=0,$7=0,$8=0,$10=0,$11=0,$12=0,$14=0,$16=0,$17=0,$18=0,$20=0,$22=0,$23=0,$24=0,$25=0;
 var $26=0,$27=0,$29=0,$30=0,$31=0,$33=0,$sign_0=0,$c_0=0,$c_1149=0,$i_0148=0,$36=0,$37=0,$38=0,$39=0,$40=0,$42=0,$44=0,$45=0,$46=0,$48=0;
 var $49=0,$50=0,$52=0,$c_2=0,$54=0,$55=0,$c_1_lcssa=0,$i_0_lcssa=0,$57=0,$58=0,$or_cond=0,$60=0,$61=0,$62=0,$64=0,$65=0,$notlhs=0,$notrhs=0,$or_cond189_not=0,$brmerge=0;
 var $i_1146=0,$68=0,$69=0,$70=0,$71=0,$72=.0,$73=.0,$74=.0,$76=0,$77=0,$78=0,$80=0,$81=0,$82=0,$84=0,$85=0,$86=0,$88=0,$c_4=0,$90=0;
 var $91=0,$92=0,$93=0,$94=0,$96=0,$97=0,$98=0,$100=0,$102=0,$103=0,$105=0,$106=0,$108=0,$109=0,$i_4=0,$110=0,$111=0,$112=0,$114=0,$115=0;
 var $116=0,$118=0,$120=0,$121=0,$122=0,$123=0,$124=0,$or_cond89=0,$126=0,$127=0,$128=0,$or_cond5=0,$130=0,$132=0,$133=0,$135=0,$136=0,$138=0,$brmerge190=0,$140=0;
 var $_in=0,$141=0,$142=0,$143=0,$144=0,$146=0,$147=0,$148=0,$150=0,$151=0,$153=0,$154=0,$156=0,$157=0,$158=0,$160=0,$161=0,$162=0,$164=0,$166=0;
 var $167=0,$168=0,$170=0,$171=0,$172=0,$174=0,$175=0,$176=0,$178=0,$gotdig_0_i=0,$c_0_i=0,$180=0,$181=0,$182=0,$184=0,$185=0,$186=0,$188=0,$190=0,$191=0;
 var $192=0,$194=0,$195=0,$196=0,$198=0,$c_1_ph_i=0,$199=0,$rp_0113_i$0=0,$rp_0113_i$1=0,$200=0,$201=0,$202=0,$204=0,$205=0,$206=0,$208=0,$210=0,$211=0,$$etemp$0$0=0,$$etemp$0$1=0;
 var $x_0_i=0,$y_0_i=.0,$scale_0_i=.0,$gottail_0_i=0,$gotrad_0_i=0,$gotdig_2_i=0,$rp_1_i$0=0,$rp_1_i$1=0,$dc_0_i$0=0,$dc_0_i$1=0,$c_2_i=0,$212=0,$213=0,$215=0,$216=0,$217=0,$218=0,$or_cond_i=0,$220=0,$222=0;
 var $223=0,$_130_i=0,$d_0_i=0,$$etemp$1$0=0,$$etemp$1$1=0,$224=0,$226=0,$227=0,$$etemp$2$0=0,$$etemp$2$1=0,$229=0,$231=.0,$232=.0,$233=.0,$234=.0,$236=0,$237=0,$or_cond95_i=0,$239=.0,$240=.0;
 var $x_1_i=0,$y_1_i=.0,$scale_1_i=.0,$gottail_1_i=0,$$etemp$3$0=0,$$etemp$3$1=0,$x_2_i=0,$y_2_i=.0,$scale_2_i=.0,$gottail_2_i=0,$gotrad_1_i=0,$gotdig_3_i=0,$rp_2_i$0=0,$rp_2_i$1=0,$dc_1_i$0=0,$dc_1_i$1=0,$243=0,$244=0,$245=0,$247=0;
 var $248=0,$249=0,$251=0,$c_2_lcssa_i=0,$253=0,$255=0,$256=0,$258=0,$259=0,$263=0,$264=0,$265=0,$267=0,$269=.0,$270=.0,$272=0,$dc_0_rp_1_i$0=0,$dc_0_rp_1_i$1=0,$$etemp$4$0=0,$$etemp$4$1=0;
 var $273=0,$dc_2106_i$0=0,$dc_2106_i$1=0,$x_3105_i=0,$274=0,$$etemp$5$0=0,$$etemp$5$1=0,$$etemp$6$0=0,$$etemp$6$1=0,$276=0,$x_3_lcssa_i=0,$277=0,$278=0,$280$0=0,$280$1=0,$$etemp$7$0=0,$$etemp$7$1=0,$281=0,$284=0,$285=0;
 var $287=0,$288=0,$291=0,$292=0,$294=0,$295=0,$e2_0_i$0=0,$e2_0_i$1=0,$297$0=0,$297$1=0,$$etemp$8$0=0,$$etemp$8$1=0,$300=0,$302=.0,$303=.0,$305=0,$306$0=0,$306$1=0,$307=0,$309=0;
 var $310=.0,$311=.0,$312=.0,$314=0,$315$0=0,$315$1=0,$316=0,$317=0,$319=0,$320=.0,$321=.0,$322=.0,$e2_1102_i$0=0,$e2_1102_i$1=0,$y_3101_i=.0,$x_4100_i=0,$323=0,$324=0,$326=0,$327=.0;
 var $x_5_i=0,$_pn_i=.0,$y_4_i=.0,$$etemp$9$0=0,$$etemp$9$1=0,$330=0,$e2_1_lcssa_i$0=0,$e2_1_lcssa_i$1=0,$y_3_lcssa_i=.0,$x_4_lcssa_i=0,$331$0=0,$331$1=0,$332$0=0,$332$1=0,$$etemp$10$0=0,$$etemp$10$1=0,$335=0,$337$0=0,$337=0,$338=0;
 var $__i=0,$_094_i=0,$340=0,$_pre_i=.0,$342=0,$343=.0,$344=.0,$345=.0,$346=0,$347=0,$or_cond96_i=0,$349=0,$350=0,$351=0,$_x_4_i=0,$_y_3_i=.0,$_pre_phi_i=.0,$bias_099_i=.0,$x_6_i=0,$y_5_i=.0;
 var $352=.0,$353=.0,$354=.0,$355=.0,$356=.0,$357=.0,$358=0,$360=0,$362$0=0,$362=0,$363=.0,$365=0,$366=0,$368=0,$369=0,$c_6=0,$371=0,$sum_i=0,$372=0,$gotdig_0_i90=0;
 var $_0234_i=0,$374=0,$375=0,$376=0,$378=0,$379=0,$380=0,$382=0,$384=0,$385=0,$386=0,$388=0,$389=0,$390=0,$392=0,$_1_ph_i=0,$393=0,$lrp_0336_i$0=0,$lrp_0336_i$1=0,$394=0;
 var $395=0,$396=0,$398=0,$399=0,$400=0,$402=0,$_1_be_i=0,$403=0,$$etemp$11$0=0,$$etemp$11$1=0,$lrp_1_i$0=0,$lrp_1_i$1=0,$gotdig_2_i92=0,$gotrad_0_i93=0,$_2_i=0,$404=0,$405=0,$406=0,$407=0,$or_cond7315_i=0;
 var $408=0,$409=0,$410=0,$_3323_i=0,$j_0322_i=0,$k_0321_i=0,$gotrad_1320_i=0,$gotdig_3319_i=0,$lnz_0318_i=0,$dc_0317_i$0=0,$dc_0317_i$1=0,$lrp_2316_i$0=0,$lrp_2316_i$1=0,$cond_i=0,$413=0,$$etemp$12$0=0,$$etemp$12$1=0,$415=0,$417$0=0,$417=0;
 var $_lnz_0_i=0,$418=0,$419=0,$421=0,$422=0,$423=0,$424=0,$storemerge_i=0,$426=0,$427=0,$428=0,$_k_0_i=0,$__i95=0,$431=0,$432=0,$lrp_3_i$0=0,$lrp_3_i$1=0,$dc_1_i96$0=0,$dc_1_i96$1=0,$lnz_2_i=0;
 var $gotdig_4_i=0,$gotrad_2_i=0,$k_2_i=0,$j_2_i=0,$433=0,$434=0,$435=0,$437=0,$438=0,$439=0,$441=0,$_3_be_i=0,$442=0,$443=0,$444=0,$or_cond7_i=0,$_3_lcssa_i=0,$j_0_lcssa_i=0,$k_0_lcssa_i=0,$gotrad_1_lcssa_i=0;
 var $gotdig_3_lcssa_i=0,$lnz_0_lcssa_i=0,$dc_0_lcssa_i$0=0,$dc_0_lcssa_i$1=0,$lrp_2_lcssa_i$0=0,$lrp_2_lcssa_i$1=0,$445=0,$dc_0_lrp_2_i$0=0,$dc_0_lrp_2_i$1=0,$_3314_i=0,$j_0312_i=0,$k_0310_i=0,$gotdig_3307_i=0,$lnz_0305_i=0,$dc_0303_i$0=0,$dc_0303_i$1=0,$lrp_4_i$0=0,$lrp_4_i$1=0,$446=0,$448=0;
 var $449=0,$451$0=0,$451$1=0,$$etemp$13$0=0,$$etemp$13$1=0,$452=0,$455=0,$456=0,$458=0,$459=0,$e10_0_i$0=0,$e10_0_i$1=0,$464=0,$466=0,$467=0,$469=0,$470=0,$lrp_5_i$0=0,$lrp_5_i$1=0,$473=0;
 var $475=0,$476=0,$478=.0,$479=.0,$481=0,$$etemp$14$0=0,$$etemp$14$1=0,$482=0,$or_cond_i97=0,$484=0,$486=0,$487=0,$489=.0,$490=.0,$491=.0,$493=0,$494$0=0,$494$1=0,$495=0,$497=0;
 var $498=.0,$499=.0,$500=.0,$502=0,$503$0=0,$503$1=0,$504=0,$506=0,$507=.0,$508=.0,$509=.0,$511=0,$512=0,$513=0,$_promoted_i=0,$515=0,$j_3297_i=0,$516=0,$517=0,$518=0;
 var $520=0,$k_3_i=0,$522$0=0,$522=0,$523=0,$525=0,$526=0,$or_cond3_i=0,$528=0,$530=.0,$531=0,$532=.0,$533=.0,$535=0,$537=.0,$538=0,$539=.0,$540=.0,$541=0,$542=0;
 var $543=0,$544=.0,$545=.0,$547=0,$_neg247_i=0,$548=0,$549=0,$_pre_i98=0,$551=0,$552=0,$553=.0,$554=.0,$555=.0,$556=0,$557=0,$558=0,$559=.0,$560=.0,$562=0,$563=0;
 var $565=0,$566=0,$567=0,$568=0,$569=0,$570=0,$571=0,$572=0,$carry_0289_i=0,$k_4288_i=0,$a_0287_i=0,$rp_0286_i=0,$573=0,$574=0,$575=0,$576=0,$577=0,$578=0,$579=0,$580=0;
 var $or_cond237_i=0,$581=0,$583=0,$584=0,$rp_1_i99=0,$a_1_i=0,$585=0,$586=0,$588=0,$589=0,$rp_0_lcssa388_i=0,$a_0_lcssa387_i=0,$z_0_i=0,$590=0,$591=0,$rp_2_ph264_i=0,$e2_0_ph_i=0,$z_1_ph265_i=0,$a_2_ph266_i=0,$592=0;
 var $593=0,$594=0,$e2_0_us_i=0,$z_1_us_i=0,$595=0,$z_2_us_i=0,$k_5_in_us_i=0,$carry1_0_us_i=0,$k_5_us_i=0,$597=0,$598=0,$599$0=0,$599$1=0,$600$0=0,$600$1=0,$601$0=0,$601$1=0,$$etemp$15$0=0,$$etemp$15$1=0,$603=0;
 var $extract_t246_us_i$0=0,$extract_t246_us_i=0,$$etemp$16$0=0,$$etemp$16$1=0,$606$0=0,$606=0,$$etemp$17$0=0,$$etemp$17$1=0,$extract_t_us_i$0=0,$extract_t_us_i=0,$_sink_off0_us_i=0,$carry1_1_us_i=0,$609=0,$610=0,$611=0,$612=0,$or_cond238_us_i=0,$614=0,$k_5_z_2_us_i=0,$z_3_us_i=0;
 var $616=0,$618=0,$619=0,$e2_0_us270_i=0,$z_1_us271_i=0,$620=0,$621=0,$622=0,$z_2_us273_i=0,$k_5_in_us274_i=0,$carry1_0_us275_i=0,$k_5_us276_i=0,$624=0,$625=0,$626$0=0,$626$1=0,$627$0=0,$627$1=0,$628$0=0,$628$1=0;
 var $$etemp$18$0=0,$$etemp$18$1=0,$630=0,$extract_t246_us277_i$0=0,$extract_t246_us277_i=0,$$etemp$19$0=0,$$etemp$19$1=0,$633$0=0,$633=0,$$etemp$20$0=0,$$etemp$20$1=0,$extract_t_us278_i$0=0,$extract_t_us278_i=0,$_sink_off0_us279_i=0,$carry1_1_us280_i=0,$636=0,$637=0,$638=0,$639=0,$or_cond238_us281_i=0;
 var $641=0,$k_5_z_2_us282_i=0,$z_3_us283_i=0,$643=0,$645=0,$646=0,$carry1_1_lcssa_lcssa_i=0,$z_3_lcssa_lcssa_i=0,$_lcssa269_i=0,$647=0,$648=0,$649=0,$650=0,$652=0,$653=0,$654=0,$655=0,$656=0,$657=0,$658=0;
 var $659=0,$660=0,$z_4_i=0,$662=0,$e2_1_i=0,$a_3_i=0,$i_0_i=0,$664=0,$666=0,$667=0,$668=0,$670=0,$671=0,$672=0,$673=0,$674=0,$676=0,$677=0,$i_1_i=0,$679=0;
 var $or_cond239_i=0,$680=0,$681=0,$683=0,$684=0,$685=0,$686=0,$687=0,$carry3_0256_i=0,$k_6254_i=0,$a_4253_i=0,$rp_4252_i=0,$688=0,$689=0,$690=0,$691=0,$692=0,$693=0,$694=0,$695=0;
 var $or_cond241_i=0,$696=0,$697=0,$698=0,$rp_5_i=0,$a_5_i=0,$699=0,$700=0,$702=0,$704=0,$rp_3_ph259_i=0,$e2_1_ph_i=0,$z_5_ph_i=0,$a_3_ph_i=0,$705=0,$706=0,$707=0,$708=0,$709=0,$rp_3_i_ph=0;
 var $e2_1_i_ph=0,$a_3_i_ph=0,$710=0,$711=0,$_240_i=0,$713=0,$714=0,$716=0,$717=0,$z_7_i=0,$719=0,$720=0,$721=.0,$722=0,$723=0,$724=0,$726=0,$_242_i=0,$denormal_0_i=0,$_1236_i=0;
 var $728=0,$730=0,$731=.0,$732=.0,$733=0,$734=.0,$735=.0,$736=.0,$737=.0,$y_1_i103=.0,$frac_0_i=.0,$bias_0_i=.0,$739=0,$740=0,$741=0,$743=0,$744=0,$745=0,$747=0,$749=0;
 var $750=0,$751=0,$753=.0,$754=.0,$756=0,$758=.0,$759=.0,$761=0,$762=0,$763=0,$765=.0,$766=.0,$768=.0,$769=.0,$frac_1_i=.0,$771=0,$772=0,$774=.0,$775=0,$777=.0;
 var $frac_2_i=.0,$779=.0,$780=.0,$781=0,$782=0,$783=0,$785=.0,$786=0,$788=0,$789=0,$or_cond243_i=0,$denormal_1_i=0,$790=.0,$791=0,$e2_2_i=0,$denormal_2_i=0,$y_2_i104=.0,$793=0,$794=0,$796=0;
 var $797=0,$or_cond244_i=0,$799=0,$e2_3_i=0,$y_3_i=.0,$801=.0,$803=0,$804=0,$805=0,$806=0,$z_7_1_i=0,$808=.0,$809=0,$810=0,$811=.0,$812=.0,$813=.0,$814=.0,$815=0,$816=0;
 var $817=0,$_0=.0,$819=0,$820=0,$821=0,$823=0,$825=0,$826=0,$827=0,$c_4_1=0,$829=0,$830=0,$phitmp_i$0=0,$phitmp_i$1=0,$242$0=0,$242$1=0,$275$0=0,$275$1=0,$298$0=0,$298$1=0;
 var $299$0=0,$299$1=0,$329$0=0,$329$1=0,$333$0=0,$333$1=0,$334$0=0,$334$1=0,$phitmp_i91$0=0,$phitmp_i91$1=0,$414$0=0,$414$1=0,$462$0=0,$462$1=0,$602$0=0,$602$1=0,$605$0=0,$605$1=0,$607$0=0,$607$1=0;
 var $629$0=0,$629$1=0,$632$0=0,$632$1=0,$634$0=0,$634$1=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+512)|0;
 $x_i=((sp)|0);
 if (((($prec|0))|0)==((1)|0)) {
  $emin_0_ph=-1074;$bits_0_ph=53;
 } else if (((($prec|0))|0)==((2)|0)) {
  $emin_0_ph=-1074;$bits_0_ph=53;
 } else if (((($prec|0))|0)==((0)|0)) {
  $emin_0_ph=-149;$bits_0_ph=24;
 } else {
  $_0=0.0;

  STACKTOP=sp;return (+($_0));
 }


 $3=(($f+4)|0);
 $4=(($f+100)|0);
 while(1) {
  $6=((HEAP32[(($3)>>2)])|0);
  $7=((HEAP32[(($4)>>2)])|0);
  $8=($6>>>0)<($7>>>0);
  if ($8) {
   $10=(($6+1)|0);
   HEAP32[(($3)>>2)]=$10;
   $11=((HEAP8[($6)])|0);
   $12=($11&255);
   $16=$12;
  } else {
   $14=((___shgetc($f))|0);
   $16=$14;
  }

  $17=((_isspace((($16)|0)))|0);
  $18=($17|0)==0;
  if ($18) {
   break;
  }
 }
 $20=($16|0)==45;
 do {
  if (((($16|0))|0)==((45)|0)|((($16|0))|0)==((43)|0)) {
   $22=($20&1);
   $23=$22<<1;
   $24=(((1)-($23))|0);
   $25=((HEAP32[(($3)>>2)])|0);
   $26=((HEAP32[(($4)>>2)])|0);
   $27=($25>>>0)<($26>>>0);
   if ($27) {
    $29=(($25+1)|0);
    HEAP32[(($3)>>2)]=$29;
    $30=((HEAP8[($25)])|0);
    $31=($30&255);
    $c_0=$31;$sign_0=$24;
    break;
   } else {
    $33=((___shgetc($f))|0);
    $c_0=$33;$sign_0=$24;
    break;
   }
  } else {
   $c_0=$16;$sign_0=1;
  }
 } while(0);


 $i_0148=0;$c_1149=$c_0;
 while(1) {


  $36=$c_1149|32;
  $37=((1680+$i_0148)|0);
  $38=((HEAP8[($37)])|0);
  $39=(($38<<24)>>24);
  $40=($36|0)==($39|0);
  if (!($40)) {
   $i_0_lcssa=$i_0148;$c_1_lcssa=$c_1149;
   break;
  }
  $42=($i_0148>>>0)<((7)>>>0);
  do {
   if ($42) {
    $44=((HEAP32[(($3)>>2)])|0);
    $45=((HEAP32[(($4)>>2)])|0);
    $46=($44>>>0)<($45>>>0);
    if ($46) {
     $48=(($44+1)|0);
     HEAP32[(($3)>>2)]=$48;
     $49=((HEAP8[($44)])|0);
     $50=($49&255);
     $c_2=$50;
     break;
    } else {
     $52=((___shgetc($f))|0);
     $c_2=$52;
     break;
    }
   } else {
    $c_2=$c_1149;
   }
  } while(0);

  $54=((($i_0148)+(1))|0);
  $55=($54>>>0)<((8)>>>0);
  if ($55) {
   $i_0148=$54;$c_1149=$c_2;
  } else {
   $i_0_lcssa=$54;$c_1_lcssa=$c_2;
   break;
  }
 }


 do {
  if (((($i_0_lcssa|0))|0)==((3)|0)) {
   label = 23;
  } else if (!(((($i_0_lcssa|0))|0)==((8)|0))) {
   $57=($i_0_lcssa>>>0)<((4)>>>0);
   $58=($pok|0)==0;
   $or_cond=$57|$58;
   if (!($or_cond)) {
    $60=($i_0_lcssa|0)==8;
    if ($60) {
     break;
    } else {
     label = 23;
     break;
    }
   }
   $76=($i_0_lcssa|0)==0;
   do {
    if ($76) {
     $77=$c_1_lcssa|32;
     $78=($77|0)==110;
     if ($78) {
      $80=((HEAP32[(($3)>>2)])|0);
      $81=((HEAP32[(($4)>>2)])|0);
      $82=($80>>>0)<($81>>>0);
      if ($82) {
       $84=(($80+1)|0);
       HEAP32[(($3)>>2)]=$84;
       $85=((HEAP8[($80)])|0);
       $86=($85&255);
       $c_4=$86;
      } else {
       $88=((___shgetc($f))|0);
       $c_4=$88;
      }

      $90=$c_4|32;
      $91=($90|0)==97;
      if (!($91)) {
       break;
      }
      $819=((HEAP32[(($3)>>2)])|0);
      $820=((HEAP32[(($4)>>2)])|0);
      $821=($819>>>0)<($820>>>0);
      if ($821) {
       $825=(($819+1)|0);
       HEAP32[(($3)>>2)]=$825;
       $826=((HEAP8[($819)])|0);
       $827=($826&255);
       $c_4_1=$827;
      } else {
       $823=((___shgetc($f))|0);
       $c_4_1=$823;
      }

      $829=$c_4_1|32;
      $830=($829|0)==110;
      if (!($830)) {
       break;
      }
      $92=((HEAP32[(($3)>>2)])|0);
      $93=((HEAP32[(($4)>>2)])|0);
      $94=($92>>>0)<($93>>>0);
      if ($94) {
       $96=(($92+1)|0);
       HEAP32[(($3)>>2)]=$96;
       $97=((HEAP8[($92)])|0);
       $98=($97&255);
       $102=$98;
      } else {
       $100=((___shgetc($f))|0);
       $102=$100;
      }

      $103=($102|0)==40;
      if ($103) {
       $i_4=1;
      } else {
       $105=((HEAP32[(($4)>>2)])|0);
       $106=($105|0)==0;
       if ($106) {
        $_0=NaN;

        STACKTOP=sp;return (+($_0));
       }
       $108=((HEAP32[(($3)>>2)])|0);
       $109=((($108)-(1))|0);
       HEAP32[(($3)>>2)]=$109;
       $_0=NaN;

       STACKTOP=sp;return (+($_0));
      }
      while(1) {

       $110=((HEAP32[(($3)>>2)])|0);
       $111=((HEAP32[(($4)>>2)])|0);
       $112=($110>>>0)<($111>>>0);
       if ($112) {
        $114=(($110+1)|0);
        HEAP32[(($3)>>2)]=$114;
        $115=((HEAP8[($110)])|0);
        $116=($115&255);
        $120=$116;
       } else {
        $118=((___shgetc($f))|0);
        $120=$118;
       }

       $121=((($120)-(48))|0);
       $122=($121>>>0)<((10)>>>0);
       $123=((($120)-(65))|0);
       $124=($123>>>0)<((26)>>>0);
       $or_cond89=$122|$124;
       if (!($or_cond89)) {
        $126=((($120)-(97))|0);
        $127=($126>>>0)<((26)>>>0);
        $128=($120|0)==95;
        $or_cond5=$127|$128;
        if (!($or_cond5)) {
         break;
        }
       }
       $146=((($i_4)+(1))|0);
       $i_4=$146;
      }
      $130=($120|0)==41;
      if ($130) {
       $_0=NaN;

       STACKTOP=sp;return (+($_0));
      }
      $132=((HEAP32[(($4)>>2)])|0);
      $133=($132|0)==0;
      if (!($133)) {
       $135=((HEAP32[(($3)>>2)])|0);
       $136=((($135)-(1))|0);
       HEAP32[(($3)>>2)]=$136;
      }
      if ($58) {
       $140=((___errno_location())|0);
       HEAP32[(($140)>>2)]=22;
       ___shlim($f,0);
       $_0=0.0;

       STACKTOP=sp;return (+($_0));
      }
      $138=($i_4|0)==0;
      $brmerge190=$138|$133;
      if ($brmerge190) {
       $_0=NaN;

       STACKTOP=sp;return (+($_0));
      } else {
       $_in=$i_4;
      }
      while(1) {

       $141=((($_in)-(1))|0);
       $142=((HEAP32[(($3)>>2)])|0);
       $143=((($142)-(1))|0);
       HEAP32[(($3)>>2)]=$143;
       $144=($141|0)==0;
       if ($144) {
        $_0=NaN;
        break;
       } else {
        $_in=$141;
       }
      }

      STACKTOP=sp;return (+($_0));
     }
     $154=($c_1_lcssa|0)==48;
     do {
      if ($154) {
       $156=((HEAP32[(($3)>>2)])|0);
       $157=((HEAP32[(($4)>>2)])|0);
       $158=($156>>>0)<($157>>>0);
       if ($158) {
        $160=(($156+1)|0);
        HEAP32[(($3)>>2)]=$160;
        $161=((HEAP8[($156)])|0);
        $162=($161&255);
        $166=$162;
       } else {
        $164=((___shgetc($f))|0);
        $166=$164;
       }

       $167=$166|32;
       $168=($167|0)==120;
       if (!($168)) {
        $365=((HEAP32[(($4)>>2)])|0);
        $366=($365|0)==0;
        if ($366) {
         $c_6=48;
         break;
        }
        $368=((HEAP32[(($3)>>2)])|0);
        $369=((($368)-(1))|0);
        HEAP32[(($3)>>2)]=$369;
        $c_6=48;
        break;
       }
       $170=((HEAP32[(($3)>>2)])|0);
       $171=((HEAP32[(($4)>>2)])|0);
       $172=($170>>>0)<($171>>>0);
       if ($172) {
        $174=(($170+1)|0);
        HEAP32[(($3)>>2)]=$174;
        $175=((HEAP8[($170)])|0);
        $176=($175&255);
        $c_0_i=$176;$gotdig_0_i=0;
       } else {
        $178=((___shgetc($f))|0);
        $c_0_i=$178;$gotdig_0_i=0;
       }
       while(1) {


        if (((($c_0_i|0))|0)==((46)|0)) {
         label = 68;
         break;
        } else if (!(((($c_0_i|0))|0)==((48)|0))) {
         $c_2_i=$c_0_i;$dc_0_i$1=0;$dc_0_i$0=0;$rp_1_i$1=0;$rp_1_i$0=0;$gotdig_2_i=$gotdig_0_i;$gotrad_0_i=0;$gottail_0_i=0;$scale_0_i=1.0;$y_0_i=0.0;$x_0_i=0;
         break;
        }
        $180=((HEAP32[(($3)>>2)])|0);
        $181=((HEAP32[(($4)>>2)])|0);
        $182=($180>>>0)<($181>>>0);
        if ($182) {
         $184=(($180+1)|0);
         HEAP32[(($3)>>2)]=$184;
         $185=((HEAP8[($180)])|0);
         $186=($185&255);
         $c_0_i=$186;$gotdig_0_i=1;
         continue;
        } else {
         $188=((___shgetc($f))|0);
         $c_0_i=$188;$gotdig_0_i=1;
         continue;
        }
       }
       L103: do {
        if ((label|0) == 68) {
         $190=((HEAP32[(($3)>>2)])|0);
         $191=((HEAP32[(($4)>>2)])|0);
         $192=($190>>>0)<($191>>>0);
         if ($192) {
          $194=(($190+1)|0);
          HEAP32[(($3)>>2)]=$194;
          $195=((HEAP8[($190)])|0);
          $196=($195&255);
          $c_1_ph_i=$196;
         } else {
          $198=((___shgetc($f))|0);
          $c_1_ph_i=$198;
         }

         $199=($c_1_ph_i|0)==48;
         if ($199) {
          $rp_0113_i$1=-1;$rp_0113_i$0=-1;
         } else {
          $c_2_i=$c_1_ph_i;$dc_0_i$1=0;$dc_0_i$0=0;$rp_1_i$1=0;$rp_1_i$0=0;$gotdig_2_i=$gotdig_0_i;$gotrad_0_i=1;$gottail_0_i=0;$scale_0_i=1.0;$y_0_i=0.0;$x_0_i=0;
          break;
         }
         while(1) {


          $200=((HEAP32[(($3)>>2)])|0);
          $201=((HEAP32[(($4)>>2)])|0);
          $202=($200>>>0)<($201>>>0);
          if ($202) {
           $204=(($200+1)|0);
           HEAP32[(($3)>>2)]=$204;
           $205=((HEAP8[($200)])|0);
           $206=($205&255);
           $210=$206;
          } else {
           $208=((___shgetc($f))|0);
           $210=$208;
          }

          $211=($210|0)==48;
          if (!($211)) {
           $c_2_i=$210;$dc_0_i$1=0;$dc_0_i$0=0;$rp_1_i$1=$rp_0113_i$1;$rp_1_i$0=$rp_0113_i$0;$gotdig_2_i=1;$gotrad_0_i=1;$gottail_0_i=0;$scale_0_i=1.0;$y_0_i=0.0;$x_0_i=0;
           break L103;
          }
          $$etemp$0$0=-1;
          $$etemp$0$1=-1;
          $phitmp_i$0=((_i64Add($rp_0113_i$0,$rp_0113_i$1,$$etemp$0$0,$$etemp$0$1))|0);$phitmp_i$1=tempRet0;
          $rp_0113_i$1=$phitmp_i$1;$rp_0113_i$0=$phitmp_i$0;
         }
        }
       } while(0);
       L116: while(1) {











        $212=((($c_2_i)-(48))|0);
        $213=($212>>>0)<((10)>>>0);
        do {
         if ($213) {
          $d_0_i=$212;
          label = 82;
         } else {
          $215=$c_2_i|32;
          $216=((($215)-(97))|0);
          $217=($216>>>0)<((6)>>>0);
          $218=($c_2_i|0)==46;
          $or_cond_i=$217|$218;
          if (!($or_cond_i)) {
           $c_2_lcssa_i=$c_2_i;
           break L116;
          }
          if ($218) {
           $220=($gotrad_0_i|0)==0;
           if ($220) {
            $dc_1_i$1=$dc_0_i$1;$dc_1_i$0=$dc_0_i$0;$rp_2_i$1=$dc_0_i$1;$rp_2_i$0=$dc_0_i$0;$gotdig_3_i=$gotdig_2_i;$gotrad_1_i=1;$gottail_2_i=$gottail_0_i;$scale_2_i=$scale_0_i;$y_2_i=$y_0_i;$x_2_i=$x_0_i;
            break;
           } else {
            $c_2_lcssa_i=46;
            break L116;
           }
          } else {
           $222=($c_2_i|0)>57;
           $223=((($215)-(87))|0);
           $_130_i=($222?$223:$212);
           $d_0_i=$_130_i;
           label = 82;
           break;
          }
         }
        } while(0);
        if ((label|0) == 82) {
         label = 0;

         $$etemp$1$0=8;
         $$etemp$1$1=0;
         $224=(($dc_0_i$1|0) < ($$etemp$1$1|0)) | (((($dc_0_i$1|0) == ($$etemp$1$1|0) & ($dc_0_i$0>>>0) <  ($$etemp$1$0>>>0))));
         do {
          if ($224) {
           $226=$x_0_i<<4;
           $227=((($d_0_i)+($226))|0);
           $gottail_1_i=$gottail_0_i;$scale_1_i=$scale_0_i;$y_1_i=$y_0_i;$x_1_i=$227;
          } else {
           $$etemp$2$0=14;
           $$etemp$2$1=0;
           $229=(($dc_0_i$1|0) < ($$etemp$2$1|0)) | (((($dc_0_i$1|0) == ($$etemp$2$1|0) & ($dc_0_i$0>>>0) <  ($$etemp$2$0>>>0))));
           if ($229) {
            $231=(+((($d_0_i|0))|0));
            $232=($scale_0_i)*((0.0625));
            $233=($232)*($231);
            $234=($y_0_i)+($233);
            $gottail_1_i=$gottail_0_i;$scale_1_i=$232;$y_1_i=$234;$x_1_i=$x_0_i;
            break;
           }
           $236=($d_0_i|0)!=0;
           $237=($gottail_0_i|0)==0;
           $or_cond95_i=$236&$237;
           if (!($or_cond95_i)) {
            $gottail_1_i=$gottail_0_i;$scale_1_i=$scale_0_i;$y_1_i=$y_0_i;$x_1_i=$x_0_i;
            break;
           }
           $239=($scale_0_i)*((0.5));
           $240=($y_0_i)+($239);
           $gottail_1_i=1;$scale_1_i=$scale_0_i;$y_1_i=$240;$x_1_i=$x_0_i;
          }
         } while(0);




         $$etemp$3$0=1;
         $$etemp$3$1=0;
         $242$0=((_i64Add($dc_0_i$0,$dc_0_i$1,$$etemp$3$0,$$etemp$3$1))|0);$242$1=tempRet0;
         $dc_1_i$1=$242$1;$dc_1_i$0=$242$0;$rp_2_i$1=$rp_1_i$1;$rp_2_i$0=$rp_1_i$0;$gotdig_3_i=1;$gotrad_1_i=$gotrad_0_i;$gottail_2_i=$gottail_1_i;$scale_2_i=$scale_1_i;$y_2_i=$y_1_i;$x_2_i=$x_1_i;
        }










        $243=((HEAP32[(($3)>>2)])|0);
        $244=((HEAP32[(($4)>>2)])|0);
        $245=($243>>>0)<($244>>>0);
        if ($245) {
         $247=(($243+1)|0);
         HEAP32[(($3)>>2)]=$247;
         $248=((HEAP8[($243)])|0);
         $249=($248&255);
         $c_2_i=$249;$dc_0_i$1=$dc_1_i$1;$dc_0_i$0=$dc_1_i$0;$rp_1_i$1=$rp_2_i$1;$rp_1_i$0=$rp_2_i$0;$gotdig_2_i=$gotdig_3_i;$gotrad_0_i=$gotrad_1_i;$gottail_0_i=$gottail_2_i;$scale_0_i=$scale_2_i;$y_0_i=$y_2_i;$x_0_i=$x_2_i;
         continue;
        } else {
         $251=((___shgetc($f))|0);
         $c_2_i=$251;$dc_0_i$1=$dc_1_i$1;$dc_0_i$0=$dc_1_i$0;$rp_1_i$1=$rp_2_i$1;$rp_1_i$0=$rp_2_i$0;$gotdig_2_i=$gotdig_3_i;$gotrad_0_i=$gotrad_1_i;$gottail_0_i=$gottail_2_i;$scale_0_i=$scale_2_i;$y_0_i=$y_2_i;$x_0_i=$x_2_i;
         continue;
        }
       }

       $253=($gotdig_2_i|0)==0;
       if ($253) {
        $255=((HEAP32[(($4)>>2)])|0);
        $256=($255|0)==0;
        if (!($256)) {
         $258=((HEAP32[(($3)>>2)])|0);
         $259=((($258)-(1))|0);
         HEAP32[(($3)>>2)]=$259;
        }
        do {
         if ($58) {
          ___shlim($f,0);
         } else {
          if ($256) {
           break;
          }
          $263=((HEAP32[(($3)>>2)])|0);
          $264=((($263)-(1))|0);
          HEAP32[(($3)>>2)]=$264;
          $265=($gotrad_0_i|0)==0;
          if ($265) {
           break;
          }
          $267=((($263)-(2))|0);
          HEAP32[(($3)>>2)]=$267;
         }
        } while(0);
        $269=(+((($sign_0|0))|0));
        $270=($269)*((0.0));
        $_0=$270;

        STACKTOP=sp;return (+($_0));
       }
       $272=($gotrad_0_i|0)==0;
       $dc_0_rp_1_i$0=($272?$dc_0_i$0:$rp_1_i$0);
       $dc_0_rp_1_i$1=($272?$dc_0_i$1:$rp_1_i$1);
       $$etemp$4$0=8;
       $$etemp$4$1=0;
       $273=(($dc_0_i$1|0) < ($$etemp$4$1|0)) | (((($dc_0_i$1|0) == ($$etemp$4$1|0) & ($dc_0_i$0>>>0) <  ($$etemp$4$0>>>0))));
       if ($273) {
        $x_3105_i=$x_0_i;$dc_2106_i$1=$dc_0_i$1;$dc_2106_i$0=$dc_0_i$0;
        while(1) {



         $274=$x_3105_i<<4;
         $$etemp$5$0=1;
         $$etemp$5$1=0;
         $275$0=((_i64Add($dc_2106_i$0,$dc_2106_i$1,$$etemp$5$0,$$etemp$5$1))|0);$275$1=tempRet0;
         $$etemp$6$0=8;
         $$etemp$6$1=0;
         $276=(($275$1|0) < ($$etemp$6$1|0)) | (((($275$1|0) == ($$etemp$6$1|0) & ($275$0>>>0) <  ($$etemp$6$0>>>0))));
         if ($276) {
          $x_3105_i=$274;$dc_2106_i$1=$275$1;$dc_2106_i$0=$275$0;
         } else {
          $x_3_lcssa_i=$274;
          break;
         }
        }
       } else {
        $x_3_lcssa_i=$x_0_i;
       }

       $277=$c_2_lcssa_i|32;
       $278=($277|0)==112;
       do {
        if ($278) {
         $280$0=((_scanexp($f,$pok))|0);
         $280$1=tempRet0;
         $$etemp$7$0=0;
         $$etemp$7$1=-2147483648;
         $281=(($280$0|0) == ($$etemp$7$0|0)) & (($280$1|0) == ($$etemp$7$1|0));
         if (!($281)) {
          $e2_0_i$1=$280$1;$e2_0_i$0=$280$0;
          break;
         }
         if ($58) {
          ___shlim($f,0);
          $_0=0.0;

          STACKTOP=sp;return (+($_0));
         } else {
          $284=((HEAP32[(($4)>>2)])|0);
          $285=($284|0)==0;
          if ($285) {
           $e2_0_i$1=0;$e2_0_i$0=0;
           break;
          }
          $287=((HEAP32[(($3)>>2)])|0);
          $288=((($287)-(1))|0);
          HEAP32[(($3)>>2)]=$288;
          $e2_0_i$1=0;$e2_0_i$0=0;
          break;
         }
        } else {
         $291=((HEAP32[(($4)>>2)])|0);
         $292=($291|0)==0;
         if ($292) {
          $e2_0_i$1=0;$e2_0_i$0=0;
          break;
         }
         $294=((HEAP32[(($3)>>2)])|0);
         $295=((($294)-(1))|0);
         HEAP32[(($3)>>2)]=$295;
         $e2_0_i$1=0;$e2_0_i$0=0;
        }
       } while(0);


       $297$0=($dc_0_rp_1_i$0<<2)|(0>>>30);
       $297$1=($dc_0_rp_1_i$1<<2)|($dc_0_rp_1_i$0>>>30);
       $$etemp$8$0=-32;
       $$etemp$8$1=-1;
       $298$0=((_i64Add($297$0,$297$1,$$etemp$8$0,$$etemp$8$1))|0);$298$1=tempRet0;
       $299$0=((_i64Add($298$0,$298$1,$e2_0_i$0,$e2_0_i$1))|0);$299$1=tempRet0;
       $300=($x_3_lcssa_i|0)==0;
       if ($300) {
        $302=(+((($sign_0|0))|0));
        $303=($302)*((0.0));
        $_0=$303;

        STACKTOP=sp;return (+($_0));
       }
       $305=(((-$emin_0_ph))|0);
       $306$0=$305;
       $306$1=0;
       $307=(($299$1|0) > ($306$1|0)) | (((($299$1|0) == ($306$1|0) & ($299$0>>>0) >  ($306$0>>>0))));
       if ($307) {
        $309=((___errno_location())|0);
        HEAP32[(($309)>>2)]=34;
        $310=(+((($sign_0|0))|0));
        $311=($310)*((1.7976931348623157e+308));
        $312=($311)*((1.7976931348623157e+308));
        $_0=$312;

        STACKTOP=sp;return (+($_0));
       }
       $314=((($emin_0_ph)-(106))|0);
       $315$0=$314;
       $315$1=((((($314|0)<0))|0)?-1:0);
       $316=(($299$1|0) < ($315$1|0)) | (((($299$1|0) == ($315$1|0) & ($299$0>>>0) <  ($315$0>>>0))));
       if ($316) {
        $319=((___errno_location())|0);
        HEAP32[(($319)>>2)]=34;
        $320=(+((($sign_0|0))|0));
        $321=($320)*((2.2250738585072014e-308));
        $322=($321)*((2.2250738585072014e-308));
        $_0=$322;

        STACKTOP=sp;return (+($_0));
       }
       $317=($x_3_lcssa_i|0)>-1;
       if ($317) {
        $x_4100_i=$x_3_lcssa_i;$y_3101_i=$y_0_i;$e2_1102_i$1=$299$1;$e2_1102_i$0=$299$0;
        while(1) {




         $323=$y_3101_i<(0.5);
         $324=$x_4100_i<<1;
         if ($323) {
          $_pn_i=$y_3101_i;$x_5_i=$324;
         } else {
          $326=$324|1;
          $327=($y_3101_i)+((-1.0));
          $_pn_i=$327;$x_5_i=$326;
         }


         $y_4_i=($y_3101_i)+($_pn_i);
         $$etemp$9$0=-1;
         $$etemp$9$1=-1;
         $329$0=((_i64Add($e2_1102_i$0,$e2_1102_i$1,$$etemp$9$0,$$etemp$9$1))|0);$329$1=tempRet0;
         $330=($x_5_i|0)>-1;
         if ($330) {
          $x_4100_i=$x_5_i;$y_3101_i=$y_4_i;$e2_1102_i$1=$329$1;$e2_1102_i$0=$329$0;
         } else {
          $x_4_lcssa_i=$x_5_i;$y_3_lcssa_i=$y_4_i;$e2_1_lcssa_i$1=$329$1;$e2_1_lcssa_i$0=$329$0;
          break;
         }
        }
       } else {
        $x_4_lcssa_i=$x_3_lcssa_i;$y_3_lcssa_i=$y_0_i;$e2_1_lcssa_i$1=$299$1;$e2_1_lcssa_i$0=$299$0;
       }




       $331$0=$bits_0_ph;
       $331$1=0;
       $332$0=$emin_0_ph;
       $332$1=((((($emin_0_ph|0)<0))|0)?-1:0);
       $$etemp$10$0=32;
       $$etemp$10$1=0;
       $333$0=((_i64Subtract($$etemp$10$0,$$etemp$10$1,$332$0,$332$1))|0);$333$1=tempRet0;
       $334$0=((_i64Add($e2_1_lcssa_i$0,$e2_1_lcssa_i$1,$333$0,$333$1))|0);$334$1=tempRet0;
       $335=(($331$1|0) > ($334$1|0)) | (((($331$1|0) == ($334$1|0) & ($331$0>>>0) >  ($334$0>>>0))));
       if ($335) {
        $337$0=$334$0;
        $337=$337$0;
        $338=($337|0)<0;
        $__i=($338?0:$337);
        $_094_i=$__i;
       } else {
        $_094_i=$bits_0_ph;
       }

       $340=($_094_i|0)<53;
       do {
        if ($340) {
         $342=(((84)-($_094_i))|0);
         $343=(+(_scalbn(1.0,$342)));
         $344=(+((($sign_0|0))|0));
         $345=(+(_copysign((+($343)),(+($344)))));
         $346=($_094_i|0)<32;
         $347=$y_3_lcssa_i!=(0.0);
         $or_cond96_i=$346&$347;
         if (!($or_cond96_i)) {
          $y_5_i=$y_3_lcssa_i;$x_6_i=$x_4_lcssa_i;$bias_099_i=$345;$_pre_phi_i=$344;
          break;
         }
         $349=$x_4_lcssa_i&1;
         $350=($349|0)==0;
         $351=$349^1;
         $_x_4_i=((($351)+($x_4_lcssa_i))|0);
         $_y_3_i=($350?(0.0):$y_3_lcssa_i);
         $y_5_i=$_y_3_i;$x_6_i=$_x_4_i;$bias_099_i=$345;$_pre_phi_i=$344;
        } else {
         $_pre_i=(+((($sign_0|0))|0));
         $y_5_i=$y_3_lcssa_i;$x_6_i=$x_4_lcssa_i;$bias_099_i=0.0;$_pre_phi_i=$_pre_i;
        }
       } while(0);




       $352=(+((($x_6_i>>>0))>>>0));
       $353=($_pre_phi_i)*($352);
       $354=($bias_099_i)+($353);
       $355=($_pre_phi_i)*($y_5_i);
       $356=($355)+($354);
       $357=($356)-($bias_099_i);
       $358=$357!=(0.0);
       if (!($358)) {
        $360=((___errno_location())|0);
        HEAP32[(($360)>>2)]=34;
       }
       $362$0=$e2_1_lcssa_i$0;
       $362=$362$0;
       $363=(+(_scalbnl($357,$362)));
       $_0=$363;

       STACKTOP=sp;return (+($_0));
      } else {
       $c_6=$c_1_lcssa;
      }
     } while(0);

     $371=$x_i;
     $sum_i=((($emin_0_ph)+($bits_0_ph))|0);
     $372=(((3)-($sum_i))|0);
     $_0234_i=$c_6;$gotdig_0_i90=0;
     while(1) {


      if (((($_0234_i|0))|0)==((46)|0)) {
       label = 137;
       break;
      } else if (!(((($_0234_i|0))|0)==((48)|0))) {
       $_2_i=$_0234_i;$gotrad_0_i93=0;$gotdig_2_i92=$gotdig_0_i90;$lrp_1_i$1=0;$lrp_1_i$0=0;
       break;
      }
      $374=((HEAP32[(($3)>>2)])|0);
      $375=((HEAP32[(($4)>>2)])|0);
      $376=($374>>>0)<($375>>>0);
      if ($376) {
       $378=(($374+1)|0);
       HEAP32[(($3)>>2)]=$378;
       $379=((HEAP8[($374)])|0);
       $380=($379&255);
       $_0234_i=$380;$gotdig_0_i90=1;
       continue;
      } else {
       $382=((___shgetc($f))|0);
       $_0234_i=$382;$gotdig_0_i90=1;
       continue;
      }
     }
     L205: do {
      if ((label|0) == 137) {
       $384=((HEAP32[(($3)>>2)])|0);
       $385=((HEAP32[(($4)>>2)])|0);
       $386=($384>>>0)<($385>>>0);
       if ($386) {
        $388=(($384+1)|0);
        HEAP32[(($3)>>2)]=$388;
        $389=((HEAP8[($384)])|0);
        $390=($389&255);
        $_1_ph_i=$390;
       } else {
        $392=((___shgetc($f))|0);
        $_1_ph_i=$392;
       }

       $393=($_1_ph_i|0)==48;
       if ($393) {
        $lrp_0336_i$1=-1;$lrp_0336_i$0=-1;
       } else {
        $_2_i=$_1_ph_i;$gotrad_0_i93=1;$gotdig_2_i92=$gotdig_0_i90;$lrp_1_i$1=0;$lrp_1_i$0=0;
        break;
       }
       while(1) {


        $394=((HEAP32[(($3)>>2)])|0);
        $395=((HEAP32[(($4)>>2)])|0);
        $396=($394>>>0)<($395>>>0);
        if ($396) {
         $398=(($394+1)|0);
         HEAP32[(($3)>>2)]=$398;
         $399=((HEAP8[($394)])|0);
         $400=($399&255);
         $_1_be_i=$400;
        } else {
         $402=((___shgetc($f))|0);
         $_1_be_i=$402;
        }

        $403=($_1_be_i|0)==48;
        if (!($403)) {
         $_2_i=$_1_be_i;$gotrad_0_i93=1;$gotdig_2_i92=1;$lrp_1_i$1=$lrp_0336_i$1;$lrp_1_i$0=$lrp_0336_i$0;
         break L205;
        }
        $$etemp$11$0=-1;
        $$etemp$11$1=-1;
        $phitmp_i91$0=((_i64Add($lrp_0336_i$0,$lrp_0336_i$1,$$etemp$11$0,$$etemp$11$1))|0);$phitmp_i91$1=tempRet0;
        $lrp_0336_i$1=$phitmp_i91$1;$lrp_0336_i$0=$phitmp_i91$0;
       }
      }
     } while(0);





     $404=(($x_i)|0);
     HEAP32[(($404)>>2)]=0;
     $405=((($_2_i)-(48))|0);
     $406=($405>>>0)<((10)>>>0);
     $407=($_2_i|0)==46;
     $or_cond7315_i=$406|$407;
     L219: do {
      if ($or_cond7315_i) {
       $408=(($x_i+496)|0);
       $lrp_2316_i$1=$lrp_1_i$1;$lrp_2316_i$0=$lrp_1_i$0;$dc_0317_i$1=0;$dc_0317_i$0=0;$lnz_0318_i=0;$gotdig_3319_i=$gotdig_2_i92;$gotrad_1320_i=$gotrad_0_i93;$k_0321_i=0;$j_0322_i=0;$_3323_i=$_2_i;$410=$405;$409=$407;
       while(1) {












        do {
         if ($409) {
          $cond_i=($gotrad_1320_i|0)==0;
          if ($cond_i) {
           $j_2_i=$j_0322_i;$k_2_i=$k_0321_i;$gotrad_2_i=1;$gotdig_4_i=$gotdig_3319_i;$lnz_2_i=$lnz_0318_i;$dc_1_i96$1=$dc_0317_i$1;$dc_1_i96$0=$dc_0317_i$0;$lrp_3_i$1=$dc_0317_i$1;$lrp_3_i$0=$dc_0317_i$0;
          } else {
           $lrp_4_i$1=$lrp_2316_i$1;$lrp_4_i$0=$lrp_2316_i$0;$dc_0303_i$1=$dc_0317_i$1;$dc_0303_i$0=$dc_0317_i$0;$lnz_0305_i=$lnz_0318_i;$gotdig_3307_i=$gotdig_3319_i;$k_0310_i=$k_0321_i;$j_0312_i=$j_0322_i;$_3314_i=$_3323_i;
           break L219;
          }
         } else {
          $413=($k_0321_i|0)<125;
          $$etemp$12$0=1;
          $$etemp$12$1=0;
          $414$0=((_i64Add($dc_0317_i$0,$dc_0317_i$1,$$etemp$12$0,$$etemp$12$1))|0);$414$1=tempRet0;
          $415=($_3323_i|0)!=48;
          if (!($413)) {
           if (!($415)) {
            $j_2_i=$j_0322_i;$k_2_i=$k_0321_i;$gotrad_2_i=$gotrad_1320_i;$gotdig_4_i=$gotdig_3319_i;$lnz_2_i=$lnz_0318_i;$dc_1_i96$1=$414$1;$dc_1_i96$0=$414$0;$lrp_3_i$1=$lrp_2316_i$1;$lrp_3_i$0=$lrp_2316_i$0;
            break;
           }
           $431=((HEAP32[(($408)>>2)])|0);
           $432=$431|1;
           HEAP32[(($408)>>2)]=$432;
           $j_2_i=$j_0322_i;$k_2_i=$k_0321_i;$gotrad_2_i=$gotrad_1320_i;$gotdig_4_i=$gotdig_3319_i;$lnz_2_i=$lnz_0318_i;$dc_1_i96$1=$414$1;$dc_1_i96$0=$414$0;$lrp_3_i$1=$lrp_2316_i$1;$lrp_3_i$0=$lrp_2316_i$0;
           break;
          }
          $417$0=$414$0;
          $417=$417$0;
          $_lnz_0_i=($415?$417:$lnz_0318_i);
          $418=($j_0322_i|0)==0;
          $419=(($x_i+($k_0321_i<<2))|0);
          if ($418) {
           $storemerge_i=$410;
          } else {
           $421=((HEAP32[(($419)>>2)])|0);
           $422=((($421)*(10))&-1);
           $423=((($_3323_i)-(48))|0);
           $424=((($423)+($422))|0);
           $storemerge_i=$424;
          }

          HEAP32[(($419)>>2)]=$storemerge_i;
          $426=((($j_0322_i)+(1))|0);
          $427=($426|0)==9;
          $428=($427&1);
          $_k_0_i=((($428)+($k_0321_i))|0);
          $__i95=($427?0:$426);
          $j_2_i=$__i95;$k_2_i=$_k_0_i;$gotrad_2_i=$gotrad_1320_i;$gotdig_4_i=1;$lnz_2_i=$_lnz_0_i;$dc_1_i96$1=$414$1;$dc_1_i96$0=$414$0;$lrp_3_i$1=$lrp_2316_i$1;$lrp_3_i$0=$lrp_2316_i$0;
         }
        } while(0);









        $433=((HEAP32[(($3)>>2)])|0);
        $434=((HEAP32[(($4)>>2)])|0);
        $435=($433>>>0)<($434>>>0);
        if ($435) {
         $437=(($433+1)|0);
         HEAP32[(($3)>>2)]=$437;
         $438=((HEAP8[($433)])|0);
         $439=($438&255);
         $_3_be_i=$439;
        } else {
         $441=((___shgetc($f))|0);
         $_3_be_i=$441;
        }

        $442=((($_3_be_i)-(48))|0);
        $443=($442>>>0)<((10)>>>0);
        $444=($_3_be_i|0)==46;
        $or_cond7_i=$443|$444;
        if ($or_cond7_i) {
         $lrp_2316_i$1=$lrp_3_i$1;$lrp_2316_i$0=$lrp_3_i$0;$dc_0317_i$1=$dc_1_i96$1;$dc_0317_i$0=$dc_1_i96$0;$lnz_0318_i=$lnz_2_i;$gotdig_3319_i=$gotdig_4_i;$gotrad_1320_i=$gotrad_2_i;$k_0321_i=$k_2_i;$j_0322_i=$j_2_i;$_3323_i=$_3_be_i;$410=$442;$409=$444;
        } else {
         $lrp_2_lcssa_i$1=$lrp_3_i$1;$lrp_2_lcssa_i$0=$lrp_3_i$0;$dc_0_lcssa_i$1=$dc_1_i96$1;$dc_0_lcssa_i$0=$dc_1_i96$0;$lnz_0_lcssa_i=$lnz_2_i;$gotdig_3_lcssa_i=$gotdig_4_i;$gotrad_1_lcssa_i=$gotrad_2_i;$k_0_lcssa_i=$k_2_i;$j_0_lcssa_i=$j_2_i;$_3_lcssa_i=$_3_be_i;
         label = 160;
         break;
        }
       }
      } else {
       $lrp_2_lcssa_i$1=$lrp_1_i$1;$lrp_2_lcssa_i$0=$lrp_1_i$0;$dc_0_lcssa_i$1=0;$dc_0_lcssa_i$0=0;$lnz_0_lcssa_i=0;$gotdig_3_lcssa_i=$gotdig_2_i92;$gotrad_1_lcssa_i=$gotrad_0_i93;$k_0_lcssa_i=0;$j_0_lcssa_i=0;$_3_lcssa_i=$_2_i;
       label = 160;
      }
     } while(0);
     if ((label|0) == 160) {










      $445=($gotrad_1_lcssa_i|0)==0;
      $dc_0_lrp_2_i$0=($445?$dc_0_lcssa_i$0:$lrp_2_lcssa_i$0);
      $dc_0_lrp_2_i$1=($445?$dc_0_lcssa_i$1:$lrp_2_lcssa_i$1);
      $lrp_4_i$1=$dc_0_lrp_2_i$1;$lrp_4_i$0=$dc_0_lrp_2_i$0;$dc_0303_i$1=$dc_0_lcssa_i$1;$dc_0303_i$0=$dc_0_lcssa_i$0;$lnz_0305_i=$lnz_0_lcssa_i;$gotdig_3307_i=$gotdig_3_lcssa_i;$k_0310_i=$k_0_lcssa_i;$j_0312_i=$j_0_lcssa_i;$_3314_i=$_3_lcssa_i;
     }









     $446=($gotdig_3307_i|0)!=0;
     do {
      if ($446) {
       $448=$_3314_i|32;
       $449=($448|0)==101;
       if (!($449)) {
        label = 169;
        break;
       }
       $451$0=((_scanexp($f,$pok))|0);
       $451$1=tempRet0;
       $$etemp$13$0=0;
       $$etemp$13$1=-2147483648;
       $452=(($451$0|0) == ($$etemp$13$0|0)) & (($451$1|0) == ($$etemp$13$1|0));
       do {
        if ($452) {
         if ($58) {
          ___shlim($f,0);
          $_0=0.0;

          STACKTOP=sp;return (+($_0));
         } else {
          $455=((HEAP32[(($4)>>2)])|0);
          $456=($455|0)==0;
          if ($456) {
           $e10_0_i$1=0;$e10_0_i$0=0;
           break;
          }
          $458=((HEAP32[(($3)>>2)])|0);
          $459=((($458)-(1))|0);
          HEAP32[(($3)>>2)]=$459;
          $e10_0_i$1=0;$e10_0_i$0=0;
          break;
         }
        } else {
         $e10_0_i$1=$451$1;$e10_0_i$0=$451$0;
        }
       } while(0);


       $462$0=((_i64Add($e10_0_i$0,$e10_0_i$1,$lrp_4_i$0,$lrp_4_i$1))|0);$462$1=tempRet0;
       $lrp_5_i$1=$462$1;$lrp_5_i$0=$462$0;
      } else {
       label = 169;
      }
     } while(0);
     do {
      if ((label|0) == 169) {
       $464=($_3314_i|0)>-1;
       if (!($464)) {
        $lrp_5_i$1=$lrp_4_i$1;$lrp_5_i$0=$lrp_4_i$0;
        break;
       }
       $466=((HEAP32[(($4)>>2)])|0);
       $467=($466|0)==0;
       if ($467) {
        $lrp_5_i$1=$lrp_4_i$1;$lrp_5_i$0=$lrp_4_i$0;
        break;
       }
       $469=((HEAP32[(($3)>>2)])|0);
       $470=((($469)-(1))|0);
       HEAP32[(($3)>>2)]=$470;
       $lrp_5_i$1=$lrp_4_i$1;$lrp_5_i$0=$lrp_4_i$0;
      }
     } while(0);


     if (!($446)) {
      $473=((___errno_location())|0);
      HEAP32[(($473)>>2)]=22;
      ___shlim($f,0);
      $_0=0.0;

      STACKTOP=sp;return (+($_0));
     }
     $475=((HEAP32[(($404)>>2)])|0);
     $476=($475|0)==0;
     if ($476) {
      $478=(+((($sign_0|0))|0));
      $479=($478)*((0.0));
      $_0=$479;

      STACKTOP=sp;return (+($_0));
     }
     $481=(($lrp_5_i$0|0) == ($dc_0303_i$0|0)) & (($lrp_5_i$1|0) == ($dc_0303_i$1|0));
     $$etemp$14$0=10;
     $$etemp$14$1=0;
     $482=(($dc_0303_i$1|0) < ($$etemp$14$1|0)) | (((($dc_0303_i$1|0) == ($$etemp$14$1|0) & ($dc_0303_i$0>>>0) <  ($$etemp$14$0>>>0))));
     $or_cond_i97=$481&$482;
     do {
      if ($or_cond_i97) {
       $484=($bits_0_ph>>>0)>((30)>>>0);
       if (!($484)) {
        $486=$475>>>($bits_0_ph>>>0);
        $487=($486|0)==0;
        if (!($487)) {
         break;
        }
       }
       $489=(+((($sign_0|0))|0));
       $490=(+((($475>>>0))>>>0));
       $491=($489)*($490);
       $_0=$491;

       STACKTOP=sp;return (+($_0));
      }
     } while(0);
     $493=(((($emin_0_ph|0))/(-2))&-1);
     $494$0=$493;
     $494$1=((((($493|0)<0))|0)?-1:0);
     $495=(($lrp_5_i$1|0) > ($494$1|0)) | (((($lrp_5_i$1|0) == ($494$1|0) & ($lrp_5_i$0>>>0) >  ($494$0>>>0))));
     if ($495) {
      $497=((___errno_location())|0);
      HEAP32[(($497)>>2)]=34;
      $498=(+((($sign_0|0))|0));
      $499=($498)*((1.7976931348623157e+308));
      $500=($499)*((1.7976931348623157e+308));
      $_0=$500;

      STACKTOP=sp;return (+($_0));
     }
     $502=((($emin_0_ph)-(106))|0);
     $503$0=$502;
     $503$1=((((($502|0)<0))|0)?-1:0);
     $504=(($lrp_5_i$1|0) < ($503$1|0)) | (((($lrp_5_i$1|0) == ($503$1|0) & ($lrp_5_i$0>>>0) <  ($503$0>>>0))));
     if ($504) {
      $506=((___errno_location())|0);
      HEAP32[(($506)>>2)]=34;
      $507=(+((($sign_0|0))|0));
      $508=($507)*((2.2250738585072014e-308));
      $509=($508)*((2.2250738585072014e-308));
      $_0=$509;

      STACKTOP=sp;return (+($_0));
     }
     $511=($j_0312_i|0)==0;
     if ($511) {
      $k_3_i=$k_0310_i;
     } else {
      $512=($j_0312_i|0)<9;
      if ($512) {
       $513=(($x_i+($k_0310_i<<2))|0);
       $_promoted_i=((HEAP32[(($513)>>2)])|0);
       $j_3297_i=$j_0312_i;$515=$_promoted_i;
       while(1) {


        $516=((($515)*(10))&-1);
        $517=((($j_3297_i)+(1))|0);
        $518=($517|0)<9;
        if ($518) {
         $j_3297_i=$517;$515=$516;
        } else {
         break;
        }
       }
       HEAP32[(($513)>>2)]=$516;
      }
      $520=((($k_0310_i)+(1))|0);
      $k_3_i=$520;
     }

     $522$0=$lrp_5_i$0;
     $522=$522$0;
     $523=($lnz_0305_i|0)<9;
     do {
      if ($523) {
       $525=($lnz_0305_i|0)<=($522|0);
       $526=($522|0)<18;
       $or_cond3_i=$525&$526;
       if (!($or_cond3_i)) {
        break;
       }
       $528=($522|0)==9;
       if ($528) {
        $530=(+((($sign_0|0))|0));
        $531=((HEAP32[(($404)>>2)])|0);
        $532=(+((($531>>>0))>>>0));
        $533=($530)*($532);
        $_0=$533;

        STACKTOP=sp;return (+($_0));
       }
       $535=($522|0)<9;
       if ($535) {
        $537=(+((($sign_0|0))|0));
        $538=((HEAP32[(($404)>>2)])|0);
        $539=(+((($538>>>0))>>>0));
        $540=($537)*($539);
        $541=(((8)-($522))|0);
        $542=((16+($541<<2))|0);
        $543=((HEAP32[(($542)>>2)])|0);
        $544=(+((($543|0))|0));
        $545=($540)/($544);
        $_0=$545;

        STACKTOP=sp;return (+($_0));
       }
       $547=((($522)*(-3))&-1);
       $_neg247_i=((($bits_0_ph)+(27))|0);
       $548=((($_neg247_i)+($547))|0);
       $549=($548|0)>30;
       $_pre_i98=((HEAP32[(($404)>>2)])|0);
       if (!($549)) {
        $551=$_pre_i98>>>($548>>>0);
        $552=($551|0)==0;
        if (!($552)) {
         break;
        }
       }
       $553=(+((($sign_0|0))|0));
       $554=(+((($_pre_i98>>>0))>>>0));
       $555=($553)*($554);
       $556=((($522)-(10))|0);
       $557=((16+($556<<2))|0);
       $558=((HEAP32[(($557)>>2)])|0);
       $559=(+((($558|0))|0));
       $560=($555)*($559);
       $_0=$560;

       STACKTOP=sp;return (+($_0));
      }
     } while(0);
     $562=(((($522|0))%(9))&-1);
     $563=($562|0)==0;
     if ($563) {
      $a_2_ph266_i=0;$z_1_ph265_i=$k_3_i;$e2_0_ph_i=0;$rp_2_ph264_i=$522;
     } else {
      $565=($522|0)>-1;
      $566=((($562)+(9))|0);
      $567=($565?$562:$566);
      $568=(((8)-($567))|0);
      $569=((16+($568<<2))|0);
      $570=((HEAP32[(($569)>>2)])|0);
      $571=($k_3_i|0)==0;
      do {
       if ($571) {
        $z_0_i=0;$a_0_lcssa387_i=0;$rp_0_lcssa388_i=$522;
       } else {
        $572=(((1000000000)/(($570|0)))&-1);
        $rp_0286_i=$522;$a_0287_i=0;$k_4288_i=0;$carry_0289_i=0;
        while(1) {




         $573=(($x_i+($k_4288_i<<2))|0);
         $574=((HEAP32[(($573)>>2)])|0);
         $575=(((($574>>>0))%(($570>>>0)))&-1);
         $576=(((($574>>>0))/(($570>>>0)))&-1);
         $577=((($576)+($carry_0289_i))|0);
         HEAP32[(($573)>>2)]=$577;
         $578=(Math_imul($575,$572)|0);
         $579=($k_4288_i|0)==($a_0287_i|0);
         $580=($577|0)==0;
         $or_cond237_i=$579&$580;
         $581=((($k_4288_i)+(1))|0);
         if ($or_cond237_i) {
          $583=$581&127;
          $584=((($rp_0286_i)-(9))|0);
          $a_1_i=$583;$rp_1_i99=$584;
         } else {
          $a_1_i=$a_0287_i;$rp_1_i99=$rp_0286_i;
         }


         $585=($581|0)==($k_3_i|0);
         if ($585) {
          break;
         } else {
          $rp_0286_i=$rp_1_i99;$a_0287_i=$a_1_i;$k_4288_i=$581;$carry_0289_i=$578;
         }
        }
        $586=($578|0)==0;
        if ($586) {
         $z_0_i=$k_3_i;$a_0_lcssa387_i=$a_1_i;$rp_0_lcssa388_i=$rp_1_i99;
         break;
        }
        $588=((($k_3_i)+(1))|0);
        $589=(($x_i+($k_3_i<<2))|0);
        HEAP32[(($589)>>2)]=$578;
        $z_0_i=$588;$a_0_lcssa387_i=$a_1_i;$rp_0_lcssa388_i=$rp_1_i99;
       }
      } while(0);



      $590=(((9)-($567))|0);
      $591=((($590)+($rp_0_lcssa388_i))|0);
      $a_2_ph266_i=$a_0_lcssa387_i;$z_1_ph265_i=$z_0_i;$e2_0_ph_i=0;$rp_2_ph264_i=$591;
     }
     L317: while(1) {




      $592=($rp_2_ph264_i|0)<18;
      $593=(($x_i+($a_2_ph266_i<<2))|0);
      if ($592) {
       $z_1_us_i=$z_1_ph265_i;$e2_0_us_i=$e2_0_ph_i;
       while(1) {


        $595=((($z_1_us_i)+(127))|0);
        $carry1_0_us_i=0;$k_5_in_us_i=$595;$z_2_us_i=$z_1_us_i;
        while(1) {



         $k_5_us_i=$k_5_in_us_i&127;
         $597=(($x_i+($k_5_us_i<<2))|0);
         $598=((HEAP32[(($597)>>2)])|0);
         $599$0=$598;
         $599$1=0;
         $600$0=($599$0<<29)|(0>>>3);
         $600$1=($599$1<<29)|($599$0>>>3);
         $601$0=$carry1_0_us_i;
         $601$1=0;
         $602$0=((_i64Add($600$0,$600$1,$601$0,$601$1))|0);$602$1=tempRet0;
         $$etemp$15$0=1000000000;
         $$etemp$15$1=0;
         $603=(($602$1>>>0) > ($$etemp$15$1>>>0)) | (((($602$1>>>0) == ($$etemp$15$1>>>0) & ($602$0>>>0) >  ($$etemp$15$0>>>0))));
         $extract_t246_us_i$0=$602$0;
         $extract_t246_us_i=$extract_t246_us_i$0;
         if ($603) {
          $$etemp$16$0=1000000000;
          $$etemp$16$1=0;
          $605$0=((___udivdi3($602$0,$602$1,$$etemp$16$0,$$etemp$16$1))|0);$605$1=tempRet0;
          $606$0=$605$0;
          $606=$606$0;
          $$etemp$17$0=1000000000;
          $$etemp$17$1=0;
          $607$0=((___uremdi3($602$0,$602$1,$$etemp$17$0,$$etemp$17$1))|0);$607$1=tempRet0;
          $extract_t_us_i$0=$607$0;
          $extract_t_us_i=$extract_t_us_i$0;
          $carry1_1_us_i=$606;$_sink_off0_us_i=$extract_t_us_i;
         } else {
          $carry1_1_us_i=0;$_sink_off0_us_i=$extract_t246_us_i;
         }


         HEAP32[(($597)>>2)]=$_sink_off0_us_i;
         $609=((($z_2_us_i)+(127))|0);
         $610=$609&127;
         $611=($k_5_us_i|0)!=($610|0);
         $612=($k_5_us_i|0)==($a_2_ph266_i|0);
         $or_cond238_us_i=$611|$612;
         if ($or_cond238_us_i) {
          $z_3_us_i=$z_2_us_i;
         } else {
          $614=($_sink_off0_us_i|0)==0;
          $k_5_z_2_us_i=($614?$k_5_us_i:$z_2_us_i);
          $z_3_us_i=$k_5_z_2_us_i;
         }

         $616=((($k_5_us_i)-(1))|0);
         if ($612) {
          break;
         } else {
          $carry1_0_us_i=$carry1_1_us_i;$k_5_in_us_i=$616;$z_2_us_i=$z_3_us_i;
         }
        }
        $618=((($e2_0_us_i)-(29))|0);
        $619=($carry1_1_us_i|0)==0;
        if ($619) {
         $z_1_us_i=$z_3_us_i;$e2_0_us_i=$618;
        } else {
         $_lcssa269_i=$618;$z_3_lcssa_lcssa_i=$z_3_us_i;$carry1_1_lcssa_lcssa_i=$carry1_1_us_i;
         break;
        }
       }
      } else {
       $594=($rp_2_ph264_i|0)==18;
       if ($594) {
        $z_1_us271_i=$z_1_ph265_i;$e2_0_us270_i=$e2_0_ph_i;
       } else {
        $a_3_ph_i=$a_2_ph266_i;$z_5_ph_i=$z_1_ph265_i;$e2_1_ph_i=$e2_0_ph_i;$rp_3_ph259_i=$rp_2_ph264_i;
        break;
       }
       while(1) {


        $620=((HEAP32[(($593)>>2)])|0);
        $621=($620>>>0)<((9007199)>>>0);
        if (!($621)) {
         $a_3_ph_i=$a_2_ph266_i;$z_5_ph_i=$z_1_us271_i;$e2_1_ph_i=$e2_0_us270_i;$rp_3_ph259_i=18;
         break L317;
        }
        $622=((($z_1_us271_i)+(127))|0);
        $carry1_0_us275_i=0;$k_5_in_us274_i=$622;$z_2_us273_i=$z_1_us271_i;
        while(1) {



         $k_5_us276_i=$k_5_in_us274_i&127;
         $624=(($x_i+($k_5_us276_i<<2))|0);
         $625=((HEAP32[(($624)>>2)])|0);
         $626$0=$625;
         $626$1=0;
         $627$0=($626$0<<29)|(0>>>3);
         $627$1=($626$1<<29)|($626$0>>>3);
         $628$0=$carry1_0_us275_i;
         $628$1=0;
         $629$0=((_i64Add($627$0,$627$1,$628$0,$628$1))|0);$629$1=tempRet0;
         $$etemp$18$0=1000000000;
         $$etemp$18$1=0;
         $630=(($629$1>>>0) > ($$etemp$18$1>>>0)) | (((($629$1>>>0) == ($$etemp$18$1>>>0) & ($629$0>>>0) >  ($$etemp$18$0>>>0))));
         $extract_t246_us277_i$0=$629$0;
         $extract_t246_us277_i=$extract_t246_us277_i$0;
         if ($630) {
          $$etemp$19$0=1000000000;
          $$etemp$19$1=0;
          $632$0=((___udivdi3($629$0,$629$1,$$etemp$19$0,$$etemp$19$1))|0);$632$1=tempRet0;
          $633$0=$632$0;
          $633=$633$0;
          $$etemp$20$0=1000000000;
          $$etemp$20$1=0;
          $634$0=((___uremdi3($629$0,$629$1,$$etemp$20$0,$$etemp$20$1))|0);$634$1=tempRet0;
          $extract_t_us278_i$0=$634$0;
          $extract_t_us278_i=$extract_t_us278_i$0;
          $carry1_1_us280_i=$633;$_sink_off0_us279_i=$extract_t_us278_i;
         } else {
          $carry1_1_us280_i=0;$_sink_off0_us279_i=$extract_t246_us277_i;
         }


         HEAP32[(($624)>>2)]=$_sink_off0_us279_i;
         $636=((($z_2_us273_i)+(127))|0);
         $637=$636&127;
         $638=($k_5_us276_i|0)!=($637|0);
         $639=($k_5_us276_i|0)==($a_2_ph266_i|0);
         $or_cond238_us281_i=$638|$639;
         if ($or_cond238_us281_i) {
          $z_3_us283_i=$z_2_us273_i;
         } else {
          $641=($_sink_off0_us279_i|0)==0;
          $k_5_z_2_us282_i=($641?$k_5_us276_i:$z_2_us273_i);
          $z_3_us283_i=$k_5_z_2_us282_i;
         }

         $643=((($k_5_us276_i)-(1))|0);
         if ($639) {
          break;
         } else {
          $carry1_0_us275_i=$carry1_1_us280_i;$k_5_in_us274_i=$643;$z_2_us273_i=$z_3_us283_i;
         }
        }
        $645=((($e2_0_us270_i)-(29))|0);
        $646=($carry1_1_us280_i|0)==0;
        if ($646) {
         $z_1_us271_i=$z_3_us283_i;$e2_0_us270_i=$645;
        } else {
         $_lcssa269_i=$645;$z_3_lcssa_lcssa_i=$z_3_us283_i;$carry1_1_lcssa_lcssa_i=$carry1_1_us280_i;
         break;
        }
       }
      }



      $647=((($rp_2_ph264_i)+(9))|0);
      $648=((($a_2_ph266_i)+(127))|0);
      $649=$648&127;
      $650=($649|0)==($z_3_lcssa_lcssa_i|0);
      if ($650) {
       $652=((($z_3_lcssa_lcssa_i)+(127))|0);
       $653=$652&127;
       $654=(($x_i+($653<<2))|0);
       $655=((HEAP32[(($654)>>2)])|0);
       $656=((($z_3_lcssa_lcssa_i)+(126))|0);
       $657=$656&127;
       $658=(($x_i+($657<<2))|0);
       $659=((HEAP32[(($658)>>2)])|0);
       $660=$659|$655;
       HEAP32[(($658)>>2)]=$660;
       $z_4_i=$653;
      } else {
       $z_4_i=$z_3_lcssa_lcssa_i;
      }

      $662=(($x_i+($649<<2))|0);
      HEAP32[(($662)>>2)]=$carry1_1_lcssa_lcssa_i;
      $a_2_ph266_i=$649;$z_1_ph265_i=$z_4_i;$e2_0_ph_i=$_lcssa269_i;$rp_2_ph264_i=$647;
     }
     L348: while(1) {




      $705=((($z_5_ph_i)+(1))|0);
      $706=$705&127;
      $707=((($z_5_ph_i)+(127))|0);
      $708=$707&127;
      $709=(($x_i+($708<<2))|0);
      $a_3_i_ph=$a_3_ph_i;$e2_1_i_ph=$e2_1_ph_i;$rp_3_i_ph=$rp_3_ph259_i;
      while(1) {



       $710=($rp_3_i_ph|0)==18;
       $711=($rp_3_i_ph|0)>27;
       $_240_i=($711?9:1);
       $a_3_i=$a_3_i_ph;$e2_1_i=$e2_1_i_ph;
       while(1) {


        $i_0_i=0;
        while(1) {

         $664=($i_0_i|0)<2;
         if (!($664)) {
          $i_1_i=$i_0_i;
          break;
         }
         $666=((($i_0_i)+($a_3_i))|0);
         $667=$666&127;
         $668=($667|0)==($z_5_ph_i|0);
         if ($668) {
          $i_1_i=2;
          break;
         }
         $670=(($x_i+($667<<2))|0);
         $671=((HEAP32[(($670)>>2)])|0);
         $672=((8+($i_0_i<<2))|0);
         $673=((HEAP32[(($672)>>2)])|0);
         $674=($671>>>0)<($673>>>0);
         if ($674) {
          $i_1_i=2;
          break;
         }
         $676=($671>>>0)>($673>>>0);
         $677=((($i_0_i)+(1))|0);
         if ($676) {
          $i_1_i=$i_0_i;
          break;
         } else {
          $i_0_i=$677;
         }
        }

        $679=($i_1_i|0)==2;
        $or_cond239_i=$679&$710;
        if ($or_cond239_i) {
         break L348;
        }
        $683=((($_240_i)+($e2_1_i))|0);
        $684=($a_3_i|0)==($z_5_ph_i|0);
        if ($684) {
         $a_3_i=$z_5_ph_i;$e2_1_i=$683;
        } else {
         break;
        }
       }
       $685=1<<$_240_i;
       $686=((($685)-(1))|0);
       $687=1000000000>>>($_240_i>>>0);
       $rp_4252_i=$rp_3_i_ph;$a_4253_i=$a_3_i;$k_6254_i=$a_3_i;$carry3_0256_i=0;
       while(1) {




        $688=(($x_i+($k_6254_i<<2))|0);
        $689=((HEAP32[(($688)>>2)])|0);
        $690=$689&$686;
        $691=$689>>>($_240_i>>>0);
        $692=((($691)+($carry3_0256_i))|0);
        HEAP32[(($688)>>2)]=$692;
        $693=(Math_imul($690,$687)|0);
        $694=($k_6254_i|0)==($a_4253_i|0);
        $695=($692|0)==0;
        $or_cond241_i=$694&$695;
        $696=((($k_6254_i)+(1))|0);
        $697=$696&127;
        $698=((($rp_4252_i)-(9))|0);
        $rp_5_i=($or_cond241_i?$698:$rp_4252_i);
        $a_5_i=($or_cond241_i?$697:$a_4253_i);
        $699=($697|0)==($z_5_ph_i|0);
        if ($699) {
         break;
        } else {
         $rp_4252_i=$rp_5_i;$a_4253_i=$a_5_i;$k_6254_i=$697;$carry3_0256_i=$693;
        }
       }
       $700=($693|0)==0;
       if ($700) {
        $a_3_i_ph=$a_5_i;$e2_1_i_ph=$683;$rp_3_i_ph=$rp_5_i;
        continue;
       }
       $702=($706|0)==($a_5_i|0);
       if (!($702)) {
        break;
       }
       $713=((HEAP32[(($709)>>2)])|0);
       $714=$713|1;
       HEAP32[(($709)>>2)]=$714;
       $a_3_i_ph=$a_5_i;$e2_1_i_ph=$683;$rp_3_i_ph=$rp_5_i;
      }
      $704=(($x_i+($z_5_ph_i<<2))|0);
      HEAP32[(($704)>>2)]=$693;
      $a_3_ph_i=$a_5_i;$z_5_ph_i=$706;$e2_1_ph_i=$683;$rp_3_ph259_i=$rp_5_i;
     }
     $680=$a_3_i&127;
     $681=($680|0)==($z_5_ph_i|0);
     if ($681) {
      $716=((($706)-(1))|0);
      $717=(($x_i+($716<<2))|0);
      HEAP32[(($717)>>2)]=0;
      $z_7_i=$706;
     } else {
      $z_7_i=$z_5_ph_i;
     }

     $719=(($x_i+($680<<2))|0);
     $720=((HEAP32[(($719)>>2)])|0);
     $721=(+((($720>>>0))>>>0));
     $722=((($a_3_i)+(1))|0);
     $723=$722&127;
     $724=($723|0)==($z_7_i|0);
     if ($724) {
      $803=((($z_7_i)+(1))|0);
      $804=$803&127;
      $805=((($804)-(1))|0);
      $806=(($x_i+($805<<2))|0);
      HEAP32[(($806)>>2)]=0;
      $z_7_1_i=$804;
     } else {
      $z_7_1_i=$z_7_i;
     }

     $808=($721)*((1000000000.0));
     $809=(($x_i+($723<<2))|0);
     $810=((HEAP32[(($809)>>2)])|0);
     $811=(+((($810>>>0))>>>0));
     $812=($808)+($811);
     $813=(+((($sign_0|0))|0));
     $814=($813)*($812);
     $815=((($e2_1_i)+(53))|0);
     $816=((($815)-($emin_0_ph))|0);
     $817=($816|0)<($bits_0_ph|0);
     if ($817) {
      $726=($816|0)<0;
      $_242_i=($726?0:$816);
      $_1236_i=$_242_i;$denormal_0_i=1;
     } else {
      $_1236_i=$bits_0_ph;$denormal_0_i=0;
     }


     $728=($_1236_i|0)<53;
     if ($728) {
      $730=(((105)-($_1236_i))|0);
      $731=(+(_scalbn(1.0,$730)));
      $732=(+(_copysign((+($731)),(+($814)))));
      $733=(((53)-($_1236_i))|0);
      $734=(+(_scalbn(1.0,$733)));
      $735=(+(_fmod((+($814)),(+($734)))));
      $736=($814)-($735);
      $737=($732)+($736);
      $bias_0_i=$732;$frac_0_i=$735;$y_1_i103=$737;
     } else {
      $bias_0_i=0.0;$frac_0_i=0.0;$y_1_i103=$814;
     }



     $739=((($a_3_i)+(2))|0);
     $740=$739&127;
     $741=($740|0)==($z_7_1_i|0);
     do {
      if ($741) {
       $frac_2_i=$frac_0_i;
      } else {
       $743=(($x_i+($740<<2))|0);
       $744=((HEAP32[(($743)>>2)])|0);
       $745=($744>>>0)<((500000000)>>>0);
       do {
        if ($745) {
         $747=($744|0)==0;
         if ($747) {
          $749=((($a_3_i)+(3))|0);
          $750=$749&127;
          $751=($750|0)==($z_7_1_i|0);
          if ($751) {
           $frac_1_i=$frac_0_i;
           break;
          }
         }
         $753=($813)*((0.25));
         $754=($753)+($frac_0_i);
         $frac_1_i=$754;
        } else {
         $756=($744>>>0)>((500000000)>>>0);
         if ($756) {
          $758=($813)*((0.75));
          $759=($758)+($frac_0_i);
          $frac_1_i=$759;
          break;
         }
         $761=((($a_3_i)+(3))|0);
         $762=$761&127;
         $763=($762|0)==($z_7_1_i|0);
         if ($763) {
          $765=($813)*((0.5));
          $766=($765)+($frac_0_i);
          $frac_1_i=$766;
          break;
         } else {
          $768=($813)*((0.75));
          $769=($768)+($frac_0_i);
          $frac_1_i=$769;
          break;
         }
        }
       } while(0);

       $771=(((53)-($_1236_i))|0);
       $772=($771|0)>1;
       if (!($772)) {
        $frac_2_i=$frac_1_i;
        break;
       }
       $774=(+(_fmod((+($frac_1_i)),1.0)));
       $775=$774!=(0.0);
       if ($775) {
        $frac_2_i=$frac_1_i;
        break;
       }
       $777=($frac_1_i)+((1.0));
       $frac_2_i=$777;
      }
     } while(0);

     $779=($y_1_i103)+($frac_2_i);
     $780=($779)-($bias_0_i);
     $781=$815&2147483647;
     $782=(((-2)-($sum_i))|0);
     $783=($781|0)>($782|0);
     do {
      if ($783) {
       $785=(+(Math_abs((+($780)))));
       $786=$785<(9007199254740992.0);
       if ($786) {
        $y_2_i104=$780;$denormal_2_i=$denormal_0_i;$e2_2_i=$e2_1_i;
       } else {
        $788=($denormal_0_i|0)!=0;
        $789=($_1236_i|0)==($816|0);
        $or_cond243_i=$788&$789;
        $denormal_1_i=($or_cond243_i?0:$denormal_0_i);
        $790=($780)*((0.5));
        $791=((($e2_1_i)+(1))|0);
        $y_2_i104=$790;$denormal_2_i=$denormal_1_i;$e2_2_i=$791;
       }



       $793=((($e2_2_i)+(53))|0);
       $794=($793|0)>($372|0);
       if (!($794)) {
        $796=($denormal_2_i|0)!=0;
        $797=$frac_2_i!=(0.0);
        $or_cond244_i=$796&$797;
        if (!($or_cond244_i)) {
         $y_3_i=$y_2_i104;$e2_3_i=$e2_2_i;
         break;
        }
       }
       $799=((___errno_location())|0);
       HEAP32[(($799)>>2)]=34;
       $y_3_i=$y_2_i104;$e2_3_i=$e2_2_i;
      } else {
       $y_3_i=$780;$e2_3_i=$e2_1_i;
      }
     } while(0);


     $801=(+(_scalbnl($y_3_i,$e2_3_i)));
     $_0=$801;

     STACKTOP=sp;return (+($_0));
    }
   } while(0);
   $147=((HEAP32[(($4)>>2)])|0);
   $148=($147|0)==0;
   if (!($148)) {
    $150=((HEAP32[(($3)>>2)])|0);
    $151=((($150)-(1))|0);
    HEAP32[(($3)>>2)]=$151;
   }
   $153=((___errno_location())|0);
   HEAP32[(($153)>>2)]=22;
   ___shlim($f,0);
   $_0=0.0;

   STACKTOP=sp;return (+($_0));
  }
 } while(0);
 do {
  if ((label|0) == 23) {
   $61=((HEAP32[(($4)>>2)])|0);
   $62=($61|0)==0;
   if (!($62)) {
    $64=((HEAP32[(($3)>>2)])|0);
    $65=((($64)-(1))|0);
    HEAP32[(($3)>>2)]=$65;
   }
   $notlhs=($pok|0)==0;
   $notrhs=($i_0_lcssa>>>0)<((4)>>>0);
   $or_cond189_not=$notrhs|$notlhs;
   $brmerge=$or_cond189_not|$62;
   if ($brmerge) {
    break;
   } else {
    $i_1146=$i_0_lcssa;
   }
   while(1) {

    $68=((HEAP32[(($3)>>2)])|0);
    $69=((($68)-(1))|0);
    HEAP32[(($3)>>2)]=$69;
    $70=((($i_1146)-(1))|0);
    $71=($70>>>0)>((3)>>>0);
    if ($71) {
     $i_1146=$70;
    } else {
     break;
    }
   }
  }
 } while(0);
 $72=(+((($sign_0|0))|0));
 $73=($72)*(Infinity);
 $74=$73;
 $_0=$74;

 STACKTOP=sp;return (+($_0));
}


function _scanexp($f,$pok){
 $f=($f)|0;
 $pok=($pok)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$7=0,$8=0,$9=0,$11=0,$13=0,$14=0,$15=0,$16=0,$17=0,$18=0,$20=0,$21=0,$22=0,$24=0,$26=0;
 var $27=0,$28=0,$29=0,$or_cond=0,$31=0,$32=0,$34=0,$35=0,$c_0=0,$neg_0=0,$37=0,$38=0,$40=0,$41=0,$43=0,$44=0,$x_042=0,$c_141=0,$45=0,$46=0;
 var $47=0,$48=0,$49=0,$51=0,$52=0,$53=0,$55=0,$c_1_be=0,$56=0,$57=0,$58=0,$59=0,$phitmp49=0,$phitmp$0=0,$phitmp$1=0,$61=0,$62=0,$y_0_lcssa$0=0,$y_0_lcssa$1=0,$c_2_lcssa=0;
 var $63=0,$64=0,$y_037$0=0,$y_037$1=0,$c_236=0,$$etemp$0$0=0,$$etemp$0$1=0,$66$0=0,$66$1=0,$$etemp$1$0=0,$$etemp$1$1=0,$69=0,$70=0,$71=0,$73=0,$74=0,$75=0,$77=0,$c_2_be=0,$78=0;
 var $79=0,$$etemp$2$0=0,$$etemp$2$1=0,$80=0,$or_cond35=0,$81=0,$82=0,$83=0,$85=0,$86=0,$87=0,$89=0,$c_3_be=0,$90=0,$91=0,$92=0,$93=0,$95=0,$96=0,$98=0;
 var $$etemp$3$0=0,$$etemp$3$1=0,$100$0=0,$100$1=0,$_0$0=0,$_0$1=0,$65$0=0,$65$1=0,$67$0=0,$67$1=0,$68$0=0,$68$1=0,$99$0=0,$99$1=0,label=0;

 $1=(($f+4)|0);
 $2=((HEAP32[(($1)>>2)])|0);
 $3=(($f+100)|0);
 $4=((HEAP32[(($3)>>2)])|0);
 $5=($2>>>0)<($4>>>0);
 if ($5) {
  $7=(($2+1)|0);
  HEAP32[(($1)>>2)]=$7;
  $8=((HEAP8[($2)])|0);
  $9=($8&255);
  $13=$9;
 } else {
  $11=((___shgetc($f))|0);
  $13=$11;
 }

 $14=($13|0)==45;
 do {
  if (((($13|0))|0)==((45)|0)|((($13|0))|0)==((43)|0)) {
   $15=($14&1);
   $16=((HEAP32[(($1)>>2)])|0);
   $17=((HEAP32[(($3)>>2)])|0);
   $18=($16>>>0)<($17>>>0);
   if ($18) {
    $20=(($16+1)|0);
    HEAP32[(($1)>>2)]=$20;
    $21=((HEAP8[($16)])|0);
    $22=($21&255);
    $26=$22;
   } else {
    $24=((___shgetc($f))|0);
    $26=$24;
   }

   $27=((($26)-(48))|0);
   $28=($27>>>0)<((10)>>>0);
   $29=($pok|0)==0;
   $or_cond=$28|$29;
   if ($or_cond) {
    $neg_0=$15;$c_0=$26;
    break;
   }
   $31=((HEAP32[(($3)>>2)])|0);
   $32=($31|0)==0;
   if ($32) {
    $neg_0=$15;$c_0=$26;
    break;
   }
   $34=((HEAP32[(($1)>>2)])|0);
   $35=((($34)-(1))|0);
   HEAP32[(($1)>>2)]=$35;
   $neg_0=$15;$c_0=$26;
  } else {
   $neg_0=0;$c_0=$13;
  }
 } while(0);


 $37=((($c_0)-(48))|0);
 $38=($37>>>0)>((9)>>>0);
 if ($38) {
  $40=((HEAP32[(($3)>>2)])|0);
  $41=($40|0)==0;
  if ($41) {
   $_0$1=-2147483648;$_0$0=0;


   return (((tempRet0=$_0$1,$_0$0))|0);
  }
  $43=((HEAP32[(($1)>>2)])|0);
  $44=((($43)-(1))|0);
  HEAP32[(($1)>>2)]=$44;
  $_0$1=-2147483648;$_0$0=0;


  return (((tempRet0=$_0$1,$_0$0))|0);
 } else {
  $c_141=$c_0;$x_042=0;
 }
 while(1) {


  $45=((($c_141)-(48))|0);
  $46=((($45)+($x_042))|0);
  $47=((HEAP32[(($1)>>2)])|0);
  $48=((HEAP32[(($3)>>2)])|0);
  $49=($47>>>0)<($48>>>0);
  if ($49) {
   $51=(($47+1)|0);
   HEAP32[(($1)>>2)]=$51;
   $52=((HEAP8[($47)])|0);
   $53=($52&255);
   $c_1_be=$53;
  } else {
   $55=((___shgetc($f))|0);
   $c_1_be=$55;
  }

  $56=((($c_1_be)-(48))|0);
  $57=($56>>>0)<((10)>>>0);
  $58=($46|0)<214748364;
  $59=$57&$58;
  if (!($59)) {
   break;
  }
  $phitmp49=((($46)*(10))&-1);
  $c_141=$c_1_be;$x_042=$phitmp49;
 }
 $phitmp$0=$46;
 $phitmp$1=((((($46|0)<0))|0)?-1:0);
 $61=((($c_1_be)-(48))|0);
 $62=($61>>>0)<((10)>>>0);
 if ($62) {
  $c_236=$c_1_be;$y_037$1=$phitmp$1;$y_037$0=$phitmp$0;
  while(1) {



   $$etemp$0$0=10;
   $$etemp$0$1=0;
   $65$0=((___muldi3($y_037$0,$y_037$1,$$etemp$0$0,$$etemp$0$1))|0);$65$1=tempRet0;
   $66$0=$c_236;
   $66$1=((((($c_236|0)<0))|0)?-1:0);
   $$etemp$1$0=-48;
   $$etemp$1$1=-1;
   $67$0=((_i64Add($66$0,$66$1,$$etemp$1$0,$$etemp$1$1))|0);$67$1=tempRet0;
   $68$0=((_i64Add($67$0,$67$1,$65$0,$65$1))|0);$68$1=tempRet0;
   $69=((HEAP32[(($1)>>2)])|0);
   $70=((HEAP32[(($3)>>2)])|0);
   $71=($69>>>0)<($70>>>0);
   if ($71) {
    $73=(($69+1)|0);
    HEAP32[(($1)>>2)]=$73;
    $74=((HEAP8[($69)])|0);
    $75=($74&255);
    $c_2_be=$75;
   } else {
    $77=((___shgetc($f))|0);
    $c_2_be=$77;
   }

   $78=((($c_2_be)-(48))|0);
   $79=($78>>>0)<((10)>>>0);
   $$etemp$2$0=2061584302;
   $$etemp$2$1=21474836;
   $80=(($68$1|0) < ($$etemp$2$1|0)) | (((($68$1|0) == ($$etemp$2$1|0) & ($68$0>>>0) <  ($$etemp$2$0>>>0))));
   $or_cond35=$79&$80;
   if ($or_cond35) {
    $c_236=$c_2_be;$y_037$1=$68$1;$y_037$0=$68$0;
   } else {
    $c_2_lcssa=$c_2_be;$y_0_lcssa$1=$68$1;$y_0_lcssa$0=$68$0;
    break;
   }
  }
 } else {
  $c_2_lcssa=$c_1_be;$y_0_lcssa$1=$phitmp$1;$y_0_lcssa$0=$phitmp$0;
 }



 $63=((($c_2_lcssa)-(48))|0);
 $64=($63>>>0)<((10)>>>0);
 if ($64) {
  while(1) {
   $81=((HEAP32[(($1)>>2)])|0);
   $82=((HEAP32[(($3)>>2)])|0);
   $83=($81>>>0)<($82>>>0);
   if ($83) {
    $85=(($81+1)|0);
    HEAP32[(($1)>>2)]=$85;
    $86=((HEAP8[($81)])|0);
    $87=($86&255);
    $c_3_be=$87;
   } else {
    $89=((___shgetc($f))|0);
    $c_3_be=$89;
   }

   $90=((($c_3_be)-(48))|0);
   $91=($90>>>0)<((10)>>>0);
   if (!($91)) {
    break;
   }
  }
 }
 $92=((HEAP32[(($3)>>2)])|0);
 $93=($92|0)==0;
 if (!($93)) {
  $95=((HEAP32[(($1)>>2)])|0);
  $96=((($95)-(1))|0);
  HEAP32[(($1)>>2)]=$96;
 }
 $98=($neg_0|0)!=0;
 $$etemp$3$0=0;
 $$etemp$3$1=0;
 $99$0=((_i64Subtract($$etemp$3$0,$$etemp$3$1,$y_0_lcssa$0,$y_0_lcssa$1))|0);$99$1=tempRet0;
 $100$0=($98?$99$0:$y_0_lcssa$0);
 $100$1=($98?$99$1:$y_0_lcssa$1);
 $_0$1=$100$1;$_0$0=$100$0;


 return (((tempRet0=$_0$1,$_0$0))|0);
}


function ___shlim($f,$lim){
 $f=($f)|0;
 $lim=($lim)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$10=0,$11=0,$or_cond=0,$13=0,$14=0,$16=0,label=0;

 $1=(($f+104)|0);
 HEAP32[(($1)>>2)]=$lim;
 $2=(($f+8)|0);
 $3=((HEAP32[(($2)>>2)])|0);
 $4=(($f+4)|0);
 $5=((HEAP32[(($4)>>2)])|0);
 $6=$3;
 $7=$5;
 $8=((($6)-($7))|0);
 $9=(($f+108)|0);
 HEAP32[(($9)>>2)]=$8;
 $10=($lim|0)!=0;
 $11=($8|0)>($lim|0);
 $or_cond=$10&$11;
 if ($or_cond) {
  $13=(($5+$lim)|0);
  $14=(($f+100)|0);
  HEAP32[(($14)>>2)]=$13;
  return;
 } else {
  $16=(($f+100)|0);
  HEAP32[(($16)>>2)]=$3;
  return;
 }
}


function ___shgetc($f){
 $f=($f)|0;
 var $1=0,$2=0,$3=0,$5=0,$6=0,$7=0,$9=0,$10=0,$12=0,$14=0,$15=0,$_phi_trans_insert=0,$_pre=0,$17=0,$18=0,$19=0,$20=0,$21=0,$22=0,$23=0;
 var $24=0,$25=0,$26=0,$28=0,$29=0,$30=0,$32=0,$_phi_trans_insert26=0,$_pre27=0,$34=0,$35=0,$36=0,$37=0,$38=0,$39=0,$40=0,$41=0,$42=0,$43=0,$44=0;
 var $46=0,$_0=0,label=0;

 $1=(($f+104)|0);
 $2=((HEAP32[(($1)>>2)])|0);
 $3=($2|0)==0;
 if ($3) {
  label = 3;
 } else {
  $5=(($f+108)|0);
  $6=((HEAP32[(($5)>>2)])|0);
  $7=($6|0)<($2|0);
  if ($7) {
   label = 3;
  }
 }
 do {
  if ((label|0) == 3) {
   $9=((___uflow($f))|0);
   $10=($9|0)<0;
   if ($10) {
    break;
   }
   $14=((HEAP32[(($1)>>2)])|0);
   $15=($14|0)==0;
   $_phi_trans_insert=(($f+8)|0);
   $_pre=((HEAP32[(($_phi_trans_insert)>>2)])|0);
   do {
    if ($15) {
     label = 8;
    } else {
     $17=(($f+4)|0);
     $18=((HEAP32[(($17)>>2)])|0);
     $19=$_pre;
     $20=$18;
     $21=((($19)-($20))|0);
     $22=(($f+108)|0);
     $23=((HEAP32[(($22)>>2)])|0);
     $24=((($14)-($23))|0);
     $25=((($24)-(1))|0);
     $26=($21|0)>($25|0);
     if (!($26)) {
      label = 8;
      break;
     }
     $28=(($18+$25)|0);
     $29=(($f+100)|0);
     HEAP32[(($29)>>2)]=$28;
    }
   } while(0);
   if ((label|0) == 8) {
    $30=(($f+100)|0);
    HEAP32[(($30)>>2)]=$_pre;
   }
   $32=($_pre|0)==0;
   $_phi_trans_insert26=(($f+4)|0);
   $_pre27=((HEAP32[(($_phi_trans_insert26)>>2)])|0);
   if (!($32)) {
    $34=$_pre;
    $35=$_pre27;
    $36=(($f+108)|0);
    $37=((HEAP32[(($36)>>2)])|0);
    $38=((($34)+(1))|0);
    $39=((($38)-($35))|0);
    $40=((($39)+($37))|0);
    HEAP32[(($36)>>2)]=$40;
   }
   $41=((($_pre27)-(1))|0);
   $42=((HEAP8[($41)])|0);
   $43=($42&255);
   $44=($43|0)==($9|0);
   if ($44) {
    $_0=$9;

    return (($_0)|0);
   }
   $46=(($9)&255);
   HEAP8[($41)]=$46;
   $_0=$9;

   return (($_0)|0);
  }
 } while(0);
 $12=(($f+100)|0);
 HEAP32[(($12)>>2)]=0;
 $_0=-1;

 return (($_0)|0);
}


function _scalbn($x,$n){
 $x=+($x);
 $n=($n)|0;
 var $1=0,$3=.0,$4=0,$5=0,$7=.0,$8=0,$9=0,$_=0,$11=0,$13=.0,$14=0,$15=0,$17=.0,$18=0,$19=0,$_17=0,$_0=0,$y_0=.0,$21=0,$22$0=0;
 var $22$1=0,$23$0=0,$23$1=0,$24=.0,$25=.0,label=0;

 $1=($n|0)>1023;
 do {
  if ($1) {
   $3=($x)*((8.98846567431158e+307));
   $4=((($n)-(1023))|0);
   $5=($4|0)>1023;
   if (!($5)) {
    $y_0=$3;$_0=$4;
    break;
   }
   $7=($3)*((8.98846567431158e+307));
   $8=((($n)-(2046))|0);
   $9=($8|0)>1023;
   $_=($9?1023:$8);
   $y_0=$7;$_0=$_;
  } else {
   $11=($n|0)<-1022;
   if (!($11)) {
    $y_0=$x;$_0=$n;
    break;
   }
   $13=($x)*((2.2250738585072014e-308));
   $14=((($n)+(1022))|0);
   $15=($14|0)<-1022;
   if (!($15)) {
    $y_0=$13;$_0=$14;
    break;
   }
   $17=($13)*((2.2250738585072014e-308));
   $18=((($n)+(2044))|0);
   $19=($18|0)<-1022;
   $_17=($19?-1022:$18);
   $y_0=$17;$_0=$_17;
  }
 } while(0);


 $21=((($_0)+(1023))|0);
 $22$0=$21;
 $22$1=0;
 $23$0=(0<<20)|(0>>>12);
 $23$1=($22$0<<20)|(0>>>12);
 $24=(HEAP32[((tempDoublePtr)>>2)]=$23$0, HEAP32[(((tempDoublePtr)+(4))>>2)]=$23$1, (+(HEAPF64[(tempDoublePtr)>>3])));
 $25=($y_0)*($24);
 return (+($25));
}


function _scalbnl($x,$n){
 $x=+($x);
 $n=($n)|0;
 var $1=.0,label=0;

 $1=(+(_scalbn($x,$n)));
 return (+($1));
}


function ___toread($f){
 $f=($f)|0;
 var $1=0,$2=0,$3=0,$4=0,$5=0,$6=0,$7=0,$8=0,$9=0,$11=0,$12=0,$13=0,$15=0,$16=0,$17=0,$18=0,$19=0,$20=0,$22=0,$23=0;
 var $25=0,$27=0,$28=0,$29=0,$_0=0,label=0;

 $1=(($f+74)|0);
 $2=((HEAP8[($1)])|0);
 $3=((($2)-(1))&255);
 $4=$3|$2;
 HEAP8[($1)]=$4;
 $5=(($f+20)|0);
 $6=((HEAP32[(($5)>>2)])|0);
 $7=(($f+44)|0);
 $8=((HEAP32[(($7)>>2)])|0);
 $9=($6>>>0)>($8>>>0);
 if ($9) {
  $11=(($f+36)|0);
  $12=((HEAP32[(($11)>>2)])|0);
  $13=((FUNCTION_TABLE_iiii[($12)&1]($f,0,0))|0);
 }
 $15=(($f+16)|0);
 HEAP32[(($15)>>2)]=0;
 $16=(($f+28)|0);
 HEAP32[(($16)>>2)]=0;
 HEAP32[(($5)>>2)]=0;
 $17=(($f)|0);
 $18=((HEAP32[(($17)>>2)])|0);
 $19=$18&20;
 $20=($19|0)==0;
 if ($20) {
  $27=((HEAP32[(($7)>>2)])|0);
  $28=(($f+8)|0);
  HEAP32[(($28)>>2)]=$27;
  $29=(($f+4)|0);
  HEAP32[(($29)>>2)]=$27;
  $_0=0;

  return (($_0)|0);
 }
 $22=$18&4;
 $23=($22|0)==0;
 if ($23) {
  $_0=-1;

  return (($_0)|0);
 }
 $25=$18|32;
 HEAP32[(($17)>>2)]=$25;
 $_0=-1;

 return (($_0)|0);
}


function ___uflow($f){
 $f=($f)|0;
 var $c=0,$1=0,$2=0,$3=0,$5=0,$6=0,$8=0,$9=0,$10=0,$11=0,$13=0,$14=0,$_0=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+8)|0;
 $c=((sp)|0);
 $1=(($f+8)|0);
 $2=((HEAP32[(($1)>>2)])|0);
 $3=($2|0)==0;
 if ($3) {
  $5=((___toread($f))|0);
  $6=($5|0)==0;
  if ($6) {
   label = 3;
  } else {
   $_0=-1;
  }
 } else {
  label = 3;
 }
 do {
  if ((label|0) == 3) {
   $8=(($f+32)|0);
   $9=((HEAP32[(($8)>>2)])|0);
   $10=((FUNCTION_TABLE_iiii[($9)&1]($f,$c,1))|0);
   $11=($10|0)==1;
   if (!($11)) {
    $_0=-1;
    break;
   }
   $13=((HEAP8[($c)])|0);
   $14=($13&255);
   $_0=$14;
  }
 } while(0);

 STACKTOP=sp;return (($_0)|0);
}


function _atof($s){
 $s=($s)|0;
 var $1=.0,label=0;

 $1=(+(_strtod($s,0)));
 return (+($1));
}


function _strtod($s,$p){
 $s=($s)|0;
 $p=($p)|0;
 var $f_i=0,$1=0,$2=0,$3=0,$4=0,$5=0,$6=.0,$7=0,$8=0,$9=0,$10=0,$11=0,$12=0,$13=0,$14=0,$15=0,$17=0,$19=0,$21=0,label=0;
 var sp=0;sp=STACKTOP;STACKTOP=(STACKTOP+112)|0;
 $f_i=((sp)|0);
 $1=$f_i;
 _memset((((($1)|0))|0), ((((0)|0))|0), ((((112)|0))|0))|0;
 $2=(($f_i+4)|0);
 HEAP32[(($2)>>2)]=$s;
 $3=(($f_i+8)|0);
 HEAP32[(($3)>>2)]=-1;
 $4=(($f_i+44)|0);
 HEAP32[(($4)>>2)]=$s;
 $5=(($f_i+76)|0);
 HEAP32[(($5)>>2)]=-1;
 ___shlim($f_i,0);
 $6=(+(___floatscan($f_i,1,1)));
 $7=(($f_i+108)|0);
 $8=((HEAP32[(($7)>>2)])|0);
 $9=((HEAP32[(($2)>>2)])|0);
 $10=((HEAP32[(($3)>>2)])|0);
 $11=$9;
 $12=$10;
 $13=((($11)-($12))|0);
 $14=((($13)+($8))|0);
 $15=($p|0)==0;
 if ($15) {
  STACKTOP=sp;return (+($6));
 }
 $17=($14|0)==0;
 if ($17) {
  $21=$s;
 } else {
  $19=(($s+$14)|0);
  $21=$19;
 }

 HEAP32[(($p)>>2)]=$21;
 STACKTOP=sp;return (+($6));
}


function _strlen(ptr) {
    ptr = ptr|0;
    var curr = 0;
    curr = ptr;
    while (((HEAP8[(curr)])|0)) {
      curr = (curr + 1)|0;
    }
    return (curr - ptr)|0;
}
function _strncpy(pdest, psrc, num) {
    pdest = pdest|0; psrc = psrc|0; num = num|0;
    var padding = 0, curr = 0, i = 0;
    while ((i|0) < (num|0)) {
      curr = padding ? 0 : ((HEAP8[(((psrc)+(i))|0)])|0);
      HEAP8[(((pdest)+(i))|0)]=curr;
      padding = padding ? 1 : (((HEAP8[(((psrc)+(i))|0)])|0) == 0);
      i = (i+1)|0;
    }
    return pdest|0;
}
function _strcpy(pdest, psrc) {
    pdest = pdest|0; psrc = psrc|0;
    var i = 0;
    do {
      HEAP8[(((pdest+i)|0)|0)]=HEAP8[(((psrc+i)|0)|0)];
      i = (i+1)|0;
    } while (((HEAP8[(((psrc)+(i-1))|0)])|0));
    return pdest|0;
}
function _memcpy(dest, src, num) {
    dest = dest|0; src = src|0; num = num|0;
    var ret = 0;
    ret = dest|0;
    if ((dest&3) == (src&3)) {
      while (dest & 3) {
        if ((num|0) == 0) return ret|0;
        HEAP8[(dest)]=((HEAP8[(src)])|0);
        dest = (dest+1)|0;
        src = (src+1)|0;
        num = (num-1)|0;
      }
      while ((num|0) >= 4) {
        HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);
        dest = (dest+4)|0;
        src = (src+4)|0;
        num = (num-4)|0;
      }
    }
    while ((num|0) > 0) {
      HEAP8[(dest)]=((HEAP8[(src)])|0);
      dest = (dest+1)|0;
      src = (src+1)|0;
      num = (num-1)|0;
    }
    return ret|0;
}
function _memset(ptr, value, num) {
    ptr = ptr|0; value = value|0; num = num|0;
    var stop = 0, value4 = 0, stop4 = 0, unaligned = 0;
    stop = (ptr + num)|0;
    if ((num|0) >= 20) {
      // This is unaligned, but quite large, so work hard to get to aligned settings
      value = value & 0xff;
      unaligned = ptr & 3;
      value4 = value | (value << 8) | (value << 16) | (value << 24);
      stop4 = stop & ~3;
      if (unaligned) {
        unaligned = (ptr + 4 - unaligned)|0;
        while ((ptr|0) < (unaligned|0)) { // no need to check for stop, since we have large num
          HEAP8[(ptr)]=value;
          ptr = (ptr+1)|0;
        }
      }
      while ((ptr|0) < (stop4|0)) {
        HEAP32[((ptr)>>2)]=value4;
        ptr = (ptr+4)|0;
      }
    }
    while ((ptr|0) < (stop|0)) {
      HEAP8[(ptr)]=value;
      ptr = (ptr+1)|0;
    }
    return (ptr-num)|0;
}
function _strcat(pdest, psrc) {
    pdest = pdest|0; psrc = psrc|0;
    var i = 0;
    var pdestEnd = 0;
    pdestEnd = (pdest + (_strlen(pdest)|0))|0;
    do {
      HEAP8[((pdestEnd+i)|0)]=HEAP8[((psrc+i)|0)];
      i = (i+1)|0;
    } while (((HEAP8[(((psrc)+(i-1))|0)])|0));
    return pdest|0;
}


function _i64Add(a, b, c, d) {
    /*
      x = a + b*2^32
      y = c + d*2^32
      result = l + h*2^32
    */
    a = a|0; b = b|0; c = c|0; d = d|0;
    var l = 0, h = 0;
    l = (a + c)>>>0;
    h = (b + d + (((l>>>0) < (a>>>0))|0))>>>0; // Add carry from low word to high word on overflow.
    return ((tempRet0 = h,l|0)|0);
  }
function _i64Subtract(a, b, c, d) {
    a = a|0; b = b|0; c = c|0; d = d|0;
    var l = 0, h = 0;
    l = (a - c)>>>0;
    h = (b - d)>>>0;
    h = (b - d - (((c>>>0) > (a>>>0))|0))>>>0; // Borrow one from high word to low word on underflow.
    return ((tempRet0 = h,l|0)|0);
  }
function _bitshift64Shl(low, high, bits) {
    low = low|0; high = high|0; bits = bits|0;
    var ander = 0;
    if ((bits|0) < 32) {
      ander = ((1 << bits) - 1)|0;
      tempRet0 = (high << bits) | ((low&(ander << (32 - bits))) >>> (32 - bits));
      return low << bits;
    }
    tempRet0 = low << (bits - 32);
    return 0;
  }
function _bitshift64Lshr(low, high, bits) {
    low = low|0; high = high|0; bits = bits|0;
    var ander = 0;
    if ((bits|0) < 32) {
      ander = ((1 << bits) - 1)|0;
      tempRet0 = high >>> bits;
      return (low >>> bits) | ((high&ander) << (32 - bits));
    }
    tempRet0 = 0;
    return (high >>> (bits - 32))|0;
  }
function _bitshift64Ashr(low, high, bits) {
    low = low|0; high = high|0; bits = bits|0;
    var ander = 0;
    if ((bits|0) < 32) {
      ander = ((1 << bits) - 1)|0;
      tempRet0 = high >> bits;
      return (low >>> bits) | ((high&ander) << (32 - bits));
    }
    tempRet0 = (high|0) < 0 ? -1 : 0;
    return (high >> (bits - 32))|0;
  }
function _llvm_ctlz_i32(x) {
    x = x|0;
    var ret = 0;
    ret = ((HEAP8[(((ctlz_i8)+(x >>> 24))|0)])|0);
    if ((ret|0) < 8) return ret|0;
    ret = ((HEAP8[(((ctlz_i8)+((x >> 16)&0xff))|0)])|0);
    if ((ret|0) < 8) return (ret + 8)|0;
    ret = ((HEAP8[(((ctlz_i8)+((x >> 8)&0xff))|0)])|0);
    if ((ret|0) < 8) return (ret + 16)|0;
    return (((HEAP8[(((ctlz_i8)+(x&0xff))|0)])|0) + 24)|0;
  }

function _llvm_cttz_i32(x) {
    x = x|0;
    var ret = 0;
    ret = ((HEAP8[(((cttz_i8)+(x & 0xff))|0)])|0);
    if ((ret|0) < 8) return ret|0;
    ret = ((HEAP8[(((cttz_i8)+((x >> 8)&0xff))|0)])|0);
    if ((ret|0) < 8) return (ret + 8)|0;
    ret = ((HEAP8[(((cttz_i8)+((x >> 16)&0xff))|0)])|0);
    if ((ret|0) < 8) return (ret + 16)|0;
    return (((HEAP8[(((cttz_i8)+(x >>> 24))|0)])|0) + 24)|0;
  }

// ======== compiled code from system/lib/compiler-rt , see readme therein
function ___muldsi3($a, $b) {
  $a = $a | 0;
  $b = $b | 0;
  var $1 = 0, $2 = 0, $3 = 0, $6 = 0, $8 = 0, $11 = 0, $12 = 0;
  $1 = $a & 65535;
  $2 = $b & 65535;
  $3 = Math_imul($2, $1) | 0;
  $6 = $a >>> 16;
  $8 = ($3 >>> 16) + (Math_imul($2, $6) | 0) | 0;
  $11 = $b >>> 16;
  $12 = Math_imul($11, $1) | 0;
  return (tempRet0 = (($8 >>> 16) + (Math_imul($11, $6) | 0) | 0) + ((($8 & 65535) + $12 | 0) >>> 16) | 0, 0 | ($8 + $12 << 16 | $3 & 65535)) | 0;
}
function ___divdi3($a$0, $a$1, $b$0, $b$1) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  var $1$0 = 0, $1$1 = 0, $2$0 = 0, $2$1 = 0, $4$0 = 0, $4$1 = 0, $6$0 = 0, $7$0 = 0, $7$1 = 0, $8$0 = 0, $10$0 = 0;
  $1$0 = $a$1 >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
  $1$1 = (($a$1 | 0) < 0 ? -1 : 0) >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
  $2$0 = $b$1 >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
  $2$1 = (($b$1 | 0) < 0 ? -1 : 0) >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
  $4$0 = _i64Subtract($1$0 ^ $a$0, $1$1 ^ $a$1, $1$0, $1$1) | 0;
  $4$1 = tempRet0;
  $6$0 = _i64Subtract($2$0 ^ $b$0, $2$1 ^ $b$1, $2$0, $2$1) | 0;
  $7$0 = $2$0 ^ $1$0;
  $7$1 = $2$1 ^ $1$1;
  $8$0 = ___udivmoddi4($4$0, $4$1, $6$0, tempRet0, 0) | 0;
  $10$0 = _i64Subtract($8$0 ^ $7$0, tempRet0 ^ $7$1, $7$0, $7$1) | 0;
  return (tempRet0 = tempRet0, $10$0) | 0;
}
function ___remdi3($a$0, $a$1, $b$0, $b$1) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  var $rem = 0, $1$0 = 0, $1$1 = 0, $2$0 = 0, $2$1 = 0, $4$0 = 0, $4$1 = 0, $6$0 = 0, $10$0 = 0, $10$1 = 0, __stackBase__ = 0;
  __stackBase__ = STACKTOP;
  STACKTOP = STACKTOP + 8 | 0;
  $rem = __stackBase__ | 0;
  $1$0 = $a$1 >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
  $1$1 = (($a$1 | 0) < 0 ? -1 : 0) >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
  $2$0 = $b$1 >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
  $2$1 = (($b$1 | 0) < 0 ? -1 : 0) >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
  $4$0 = _i64Subtract($1$0 ^ $a$0, $1$1 ^ $a$1, $1$0, $1$1) | 0;
  $4$1 = tempRet0;
  $6$0 = _i64Subtract($2$0 ^ $b$0, $2$1 ^ $b$1, $2$0, $2$1) | 0;
  ___udivmoddi4($4$0, $4$1, $6$0, tempRet0, $rem) | 0;
  $10$0 = _i64Subtract(HEAP32[$rem >> 2] ^ $1$0, HEAP32[$rem + 4 >> 2] ^ $1$1, $1$0, $1$1) | 0;
  $10$1 = tempRet0;
  STACKTOP = __stackBase__;
  return (tempRet0 = $10$1, $10$0) | 0;
}
function ___muldi3($a$0, $a$1, $b$0, $b$1) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  var $x_sroa_0_0_extract_trunc = 0, $y_sroa_0_0_extract_trunc = 0, $1$0 = 0, $1$1 = 0, $2 = 0;
  $x_sroa_0_0_extract_trunc = $a$0;
  $y_sroa_0_0_extract_trunc = $b$0;
  $1$0 = ___muldsi3($x_sroa_0_0_extract_trunc, $y_sroa_0_0_extract_trunc) | 0;
  $1$1 = tempRet0;
  $2 = Math_imul($a$1, $y_sroa_0_0_extract_trunc) | 0;
  return (tempRet0 = ((Math_imul($b$1, $x_sroa_0_0_extract_trunc) | 0) + $2 | 0) + $1$1 | $1$1 & 0, 0 | $1$0 & -1) | 0;
}
function ___udivdi3($a$0, $a$1, $b$0, $b$1) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  var $1$0 = 0;
  $1$0 = ___udivmoddi4($a$0, $a$1, $b$0, $b$1, 0) | 0;
  return (tempRet0 = tempRet0, $1$0) | 0;
}
function ___uremdi3($a$0, $a$1, $b$0, $b$1) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  var $rem = 0, __stackBase__ = 0;
  __stackBase__ = STACKTOP;
  STACKTOP = STACKTOP + 8 | 0;
  $rem = __stackBase__ | 0;
  ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) | 0;
  STACKTOP = __stackBase__;
  return (tempRet0 = HEAP32[$rem + 4 >> 2] | 0, HEAP32[$rem >> 2] | 0) | 0;
}
function ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  $rem = $rem | 0;
  var $n_sroa_0_0_extract_trunc = 0, $n_sroa_1_4_extract_shift$0 = 0, $n_sroa_1_4_extract_trunc = 0, $d_sroa_0_0_extract_trunc = 0, $d_sroa_1_4_extract_shift$0 = 0, $d_sroa_1_4_extract_trunc = 0, $4 = 0, $17 = 0, $37 = 0, $49 = 0, $51 = 0, $57 = 0, $58 = 0, $66 = 0, $78 = 0, $86 = 0, $88 = 0, $89 = 0, $91 = 0, $92 = 0, $95 = 0, $105 = 0, $117 = 0, $119 = 0, $125 = 0, $126 = 0, $130 = 0, $q_sroa_1_1_ph = 0, $q_sroa_0_1_ph = 0, $r_sroa_1_1_ph = 0, $r_sroa_0_1_ph = 0, $sr_1_ph = 0, $d_sroa_0_0_insert_insert99$0 = 0, $d_sroa_0_0_insert_insert99$1 = 0, $137$0 = 0, $137$1 = 0, $carry_0203 = 0, $sr_1202 = 0, $r_sroa_0_1201 = 0, $r_sroa_1_1200 = 0, $q_sroa_0_1199 = 0, $q_sroa_1_1198 = 0, $147 = 0, $149 = 0, $r_sroa_0_0_insert_insert42$0 = 0, $r_sroa_0_0_insert_insert42$1 = 0, $150$1 = 0, $151$0 = 0, $152 = 0, $154$0 = 0, $r_sroa_0_0_extract_trunc = 0, $r_sroa_1_4_extract_trunc = 0, $155 = 0, $carry_0_lcssa$0 = 0, $carry_0_lcssa$1 = 0, $r_sroa_0_1_lcssa = 0, $r_sroa_1_1_lcssa = 0, $q_sroa_0_1_lcssa = 0, $q_sroa_1_1_lcssa = 0, $q_sroa_0_0_insert_ext75$0 = 0, $q_sroa_0_0_insert_ext75$1 = 0, $q_sroa_0_0_insert_insert77$1 = 0, $_0$0 = 0, $_0$1 = 0;
  $n_sroa_0_0_extract_trunc = $a$0;
  $n_sroa_1_4_extract_shift$0 = $a$1;
  $n_sroa_1_4_extract_trunc = $n_sroa_1_4_extract_shift$0;
  $d_sroa_0_0_extract_trunc = $b$0;
  $d_sroa_1_4_extract_shift$0 = $b$1;
  $d_sroa_1_4_extract_trunc = $d_sroa_1_4_extract_shift$0;
  if (($n_sroa_1_4_extract_trunc | 0) == 0) {
    $4 = ($rem | 0) != 0;
    if (($d_sroa_1_4_extract_trunc | 0) == 0) {
      if ($4) {
        HEAP32[$rem >> 2] = ($n_sroa_0_0_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);
        HEAP32[$rem + 4 >> 2] = 0;
      }
      $_0$1 = 0;
      $_0$0 = ($n_sroa_0_0_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;
      return (tempRet0 = $_0$1, $_0$0) | 0;
    } else {
      if (!$4) {
        $_0$1 = 0;
        $_0$0 = 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      HEAP32[$rem >> 2] = $a$0 & -1;
      HEAP32[$rem + 4 >> 2] = $a$1 & 0;
      $_0$1 = 0;
      $_0$0 = 0;
      return (tempRet0 = $_0$1, $_0$0) | 0;
    }
  }
  $17 = ($d_sroa_1_4_extract_trunc | 0) == 0;
  do {
    if (($d_sroa_0_0_extract_trunc | 0) == 0) {
      if ($17) {
        if (($rem | 0) != 0) {
          HEAP32[$rem >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);
          HEAP32[$rem + 4 >> 2] = 0;
        }
        $_0$1 = 0;
        $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      if (($n_sroa_0_0_extract_trunc | 0) == 0) {
        if (($rem | 0) != 0) {
          HEAP32[$rem >> 2] = 0;
          HEAP32[$rem + 4 >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_1_4_extract_trunc >>> 0);
        }
        $_0$1 = 0;
        $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_1_4_extract_trunc >>> 0) >>> 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      $37 = $d_sroa_1_4_extract_trunc - 1 | 0;
      if (($37 & $d_sroa_1_4_extract_trunc | 0) == 0) {
        if (($rem | 0) != 0) {
          HEAP32[$rem >> 2] = 0 | $a$0 & -1;
          HEAP32[$rem + 4 >> 2] = $37 & $n_sroa_1_4_extract_trunc | $a$1 & 0;
        }
        $_0$1 = 0;
        $_0$0 = $n_sroa_1_4_extract_trunc >>> ((_llvm_cttz_i32($d_sroa_1_4_extract_trunc | 0) | 0) >>> 0);
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      $49 = _llvm_ctlz_i32($d_sroa_1_4_extract_trunc | 0) | 0;
      $51 = $49 - (_llvm_ctlz_i32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
      if ($51 >>> 0 <= 30) {
        $57 = $51 + 1 | 0;
        $58 = 31 - $51 | 0;
        $sr_1_ph = $57;
        $r_sroa_0_1_ph = $n_sroa_1_4_extract_trunc << $58 | $n_sroa_0_0_extract_trunc >>> ($57 >>> 0);
        $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($57 >>> 0);
        $q_sroa_0_1_ph = 0;
        $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $58;
        break;
      }
      if (($rem | 0) == 0) {
        $_0$1 = 0;
        $_0$0 = 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      HEAP32[$rem >> 2] = 0 | $a$0 & -1;
      HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
      $_0$1 = 0;
      $_0$0 = 0;
      return (tempRet0 = $_0$1, $_0$0) | 0;
    } else {
      if (!$17) {
        $117 = _llvm_ctlz_i32($d_sroa_1_4_extract_trunc | 0) | 0;
        $119 = $117 - (_llvm_ctlz_i32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
        if ($119 >>> 0 <= 31) {
          $125 = $119 + 1 | 0;
          $126 = 31 - $119 | 0;
          $130 = $119 - 31 >> 31;
          $sr_1_ph = $125;
          $r_sroa_0_1_ph = $n_sroa_0_0_extract_trunc >>> ($125 >>> 0) & $130 | $n_sroa_1_4_extract_trunc << $126;
          $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($125 >>> 0) & $130;
          $q_sroa_0_1_ph = 0;
          $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $126;
          break;
        }
        if (($rem | 0) == 0) {
          $_0$1 = 0;
          $_0$0 = 0;
          return (tempRet0 = $_0$1, $_0$0) | 0;
        }
        HEAP32[$rem >> 2] = 0 | $a$0 & -1;
        HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
        $_0$1 = 0;
        $_0$0 = 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      $66 = $d_sroa_0_0_extract_trunc - 1 | 0;
      if (($66 & $d_sroa_0_0_extract_trunc | 0) != 0) {
        $86 = (_llvm_ctlz_i32($d_sroa_0_0_extract_trunc | 0) | 0) + 33 | 0;
        $88 = $86 - (_llvm_ctlz_i32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
        $89 = 64 - $88 | 0;
        $91 = 32 - $88 | 0;
        $92 = $91 >> 31;
        $95 = $88 - 32 | 0;
        $105 = $95 >> 31;
        $sr_1_ph = $88;
        $r_sroa_0_1_ph = $91 - 1 >> 31 & $n_sroa_1_4_extract_trunc >>> ($95 >>> 0) | ($n_sroa_1_4_extract_trunc << $91 | $n_sroa_0_0_extract_trunc >>> ($88 >>> 0)) & $105;
        $r_sroa_1_1_ph = $105 & $n_sroa_1_4_extract_trunc >>> ($88 >>> 0);
        $q_sroa_0_1_ph = $n_sroa_0_0_extract_trunc << $89 & $92;
        $q_sroa_1_1_ph = ($n_sroa_1_4_extract_trunc << $89 | $n_sroa_0_0_extract_trunc >>> ($95 >>> 0)) & $92 | $n_sroa_0_0_extract_trunc << $91 & $88 - 33 >> 31;
        break;
      }
      if (($rem | 0) != 0) {
        HEAP32[$rem >> 2] = $66 & $n_sroa_0_0_extract_trunc;
        HEAP32[$rem + 4 >> 2] = 0;
      }
      if (($d_sroa_0_0_extract_trunc | 0) == 1) {
        $_0$1 = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
        $_0$0 = 0 | $a$0 & -1;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      } else {
        $78 = _llvm_cttz_i32($d_sroa_0_0_extract_trunc | 0) | 0;
        $_0$1 = 0 | $n_sroa_1_4_extract_trunc >>> ($78 >>> 0);
        $_0$0 = $n_sroa_1_4_extract_trunc << 32 - $78 | $n_sroa_0_0_extract_trunc >>> ($78 >>> 0) | 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
    }
  } while (0);
  if (($sr_1_ph | 0) == 0) {
    $q_sroa_1_1_lcssa = $q_sroa_1_1_ph;
    $q_sroa_0_1_lcssa = $q_sroa_0_1_ph;
    $r_sroa_1_1_lcssa = $r_sroa_1_1_ph;
    $r_sroa_0_1_lcssa = $r_sroa_0_1_ph;
    $carry_0_lcssa$1 = 0;
    $carry_0_lcssa$0 = 0;
  } else {
    $d_sroa_0_0_insert_insert99$0 = 0 | $b$0 & -1;
    $d_sroa_0_0_insert_insert99$1 = $d_sroa_1_4_extract_shift$0 | $b$1 & 0;
    $137$0 = _i64Add($d_sroa_0_0_insert_insert99$0, $d_sroa_0_0_insert_insert99$1, -1, -1) | 0;
    $137$1 = tempRet0;
    $q_sroa_1_1198 = $q_sroa_1_1_ph;
    $q_sroa_0_1199 = $q_sroa_0_1_ph;
    $r_sroa_1_1200 = $r_sroa_1_1_ph;
    $r_sroa_0_1201 = $r_sroa_0_1_ph;
    $sr_1202 = $sr_1_ph;
    $carry_0203 = 0;
    while (1) {
      $147 = $q_sroa_0_1199 >>> 31 | $q_sroa_1_1198 << 1;
      $149 = $carry_0203 | $q_sroa_0_1199 << 1;
      $r_sroa_0_0_insert_insert42$0 = 0 | ($r_sroa_0_1201 << 1 | $q_sroa_1_1198 >>> 31);
      $r_sroa_0_0_insert_insert42$1 = $r_sroa_0_1201 >>> 31 | $r_sroa_1_1200 << 1 | 0;
      _i64Subtract($137$0, $137$1, $r_sroa_0_0_insert_insert42$0, $r_sroa_0_0_insert_insert42$1) | 0;
      $150$1 = tempRet0;
      $151$0 = $150$1 >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1;
      $152 = $151$0 & 1;
      $154$0 = _i64Subtract($r_sroa_0_0_insert_insert42$0, $r_sroa_0_0_insert_insert42$1, $151$0 & $d_sroa_0_0_insert_insert99$0, ((($150$1 | 0) < 0 ? -1 : 0) >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1) & $d_sroa_0_0_insert_insert99$1) | 0;
      $r_sroa_0_0_extract_trunc = $154$0;
      $r_sroa_1_4_extract_trunc = tempRet0;
      $155 = $sr_1202 - 1 | 0;
      if (($155 | 0) == 0) {
        break;
      } else {
        $q_sroa_1_1198 = $147;
        $q_sroa_0_1199 = $149;
        $r_sroa_1_1200 = $r_sroa_1_4_extract_trunc;
        $r_sroa_0_1201 = $r_sroa_0_0_extract_trunc;
        $sr_1202 = $155;
        $carry_0203 = $152;
      }
    }
    $q_sroa_1_1_lcssa = $147;
    $q_sroa_0_1_lcssa = $149;
    $r_sroa_1_1_lcssa = $r_sroa_1_4_extract_trunc;
    $r_sroa_0_1_lcssa = $r_sroa_0_0_extract_trunc;
    $carry_0_lcssa$1 = 0;
    $carry_0_lcssa$0 = $152;
  }
  $q_sroa_0_0_insert_ext75$0 = $q_sroa_0_1_lcssa;
  $q_sroa_0_0_insert_ext75$1 = 0;
  $q_sroa_0_0_insert_insert77$1 = $q_sroa_1_1_lcssa | $q_sroa_0_0_insert_ext75$1;
  if (($rem | 0) != 0) {
    HEAP32[$rem >> 2] = 0 | $r_sroa_0_1_lcssa;
    HEAP32[$rem + 4 >> 2] = $r_sroa_1_1_lcssa | 0;
  }
  $_0$1 = (0 | $q_sroa_0_0_insert_ext75$0) >>> 31 | $q_sroa_0_0_insert_insert77$1 << 1 | ($q_sroa_0_0_insert_ext75$1 << 1 | $q_sroa_0_0_insert_ext75$0 >>> 31) & 0 | $carry_0_lcssa$1;
  $_0$0 = ($q_sroa_0_0_insert_ext75$0 << 1 | 0 >>> 31) & -2 | $carry_0_lcssa$0;
  return (tempRet0 = $_0$1, $_0$0) | 0;
}
// =======================================================================


// EMSCRIPTEN_END_FUNCS

  
  function dynCall_iiii(index,a1,a2,a3) {
    index = index|0;
    a1=a1|0; a2=a2|0; a3=a3|0;
    return FUNCTION_TABLE_iiii[index&1](a1|0,a2|0,a3|0)|0;
  }


  function dynCall_vi(index,a1) {
    index = index|0;
    a1=a1|0;
    FUNCTION_TABLE_vi[index&1](a1|0);
  }


  function dynCall_ii(index,a1) {
    index = index|0;
    a1=a1|0;
    return FUNCTION_TABLE_ii[index&1](a1|0)|0;
  }


  function dynCall_v(index) {
    index = index|0;
    
    FUNCTION_TABLE_v[index&1]();
  }


  function dynCall_iii(index,a1,a2) {
    index = index|0;
    a1=a1|0; a2=a2|0;
    return FUNCTION_TABLE_iii[index&1](a1|0,a2|0)|0;
  }

function b0(p0,p1,p2) { p0 = p0|0;p1 = p1|0;p2 = p2|0; abort(0); return 0 }
  function b1(p0) { p0 = p0|0; abort(1);  }
  function b2(p0) { p0 = p0|0; abort(2); return 0 }
  function b3() { ; abort(3);  }
  function b4(p0,p1) { p0 = p0|0;p1 = p1|0; abort(4); return 0 }
  // EMSCRIPTEN_END_FUNCS
  var FUNCTION_TABLE_iiii = [b0,b0];
  
  var FUNCTION_TABLE_vi = [b1,b1];
  
  var FUNCTION_TABLE_ii = [b2,b2];
  
  var FUNCTION_TABLE_v = [b3,b3];
  
  var FUNCTION_TABLE_iii = [b4,b4];
  

  return { _strlen: _strlen, _strcat: _strcat, _free: _free, _main: _main, _strncpy: _strncpy, _memset: _memset, _malloc: _malloc, _memcpy: _memcpy, _hour: _hour, _strcpy: _strcpy, _calloc: _calloc, runPostSets: runPostSets, stackAlloc: stackAlloc, stackSave: stackSave, stackRestore: stackRestore, setThrew: setThrew, setTempRet0: setTempRet0, setTempRet1: setTempRet1, setTempRet2: setTempRet2, setTempRet3: setTempRet3, setTempRet4: setTempRet4, setTempRet5: setTempRet5, setTempRet6: setTempRet6, setTempRet7: setTempRet7, setTempRet8: setTempRet8, setTempRet9: setTempRet9, dynCall_iiii: dynCall_iiii, dynCall_vi: dynCall_vi, dynCall_ii: dynCall_ii, dynCall_v: dynCall_v, dynCall_iii: dynCall_iii };
})
// EMSCRIPTEN_END_ASM
({ "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array }, { "abort": abort, "assert": assert, "asmPrintInt": asmPrintInt, "asmPrintFloat": asmPrintFloat, "min": Math_min, "invoke_iiii": invoke_iiii, "invoke_vi": invoke_vi, "invoke_ii": invoke_ii, "invoke_v": invoke_v, "invoke_iii": invoke_iii, "_strncmp": _strncmp, "_lseek": _lseek, "_tzset": _tzset, "_snprintf": _snprintf, "_fgetc": _fgetc, "_fread": _fread, "_fclose": _fclose, "_strtok_r": _strtok_r, "_ctime": _ctime, "_sbrk": _sbrk, "_abort": _abort, "_fprintf": _fprintf, "_sqrt": _sqrt, "_pread": _pread, "_fgets": _fgets, "_close": _close, "_fflush": _fflush, "_fopen": _fopen, "_open": _open, "_mktemp": _mktemp, "_fputc": _fputc, "_strtol": _strtol, "_creat": _creat, "_fabs": _fabs, "_strtok": _strtok, "___setErrNo": ___setErrNo, "__reallyNegative": __reallyNegative, "_sysconf": _sysconf, "_fseek": _fseek, "_send": _send, "_write": _write, "_fputs": _fputs, "_ftell": _ftell, "_rmdir": _rmdir, "_llvm_lifetime_end": _llvm_lifetime_end, "_writecon": _writecon, "_mkstemp": _mkstemp, "_isspace": _isspace, "_sprintf": _sprintf, "_strchr": _strchr, "_fmod": _fmod, "_mktime": _mktime, "_strcspn": _strcspn, "_read": _read, "_copysign": _copysign, "_rewind": _rewind, "__formatString": __formatString, "_localtime_r": _localtime_r, "_atoi": _atoi, "_asctime_r": _asctime_r, "_unlink": _unlink, "_recv": _recv, "_log": _log, "_pwrite": _pwrite, "_llvm_pow_f64": _llvm_pow_f64, "_fsync": _fsync, "___errno_location": ___errno_location, "_asctime": _asctime, "_remove": _remove, "_llvm_lifetime_start": _llvm_lifetime_start, "_time": _time, "__parseInt": __parseInt, "_fwrite": _fwrite, "_localtime": _localtime, "_strcmp": _strcmp, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "cttz_i8": cttz_i8, "ctlz_i8": ctlz_i8, "NaN": NaN, "Infinity": Infinity, "_stdout": _stdout }, buffer);
var _strlen = Module["_strlen"] = asm["_strlen"];
var _strcat = Module["_strcat"] = asm["_strcat"];
var _free = Module["_free"] = asm["_free"];
var _main = Module["_main"] = asm["_main"];
var _strncpy = Module["_strncpy"] = asm["_strncpy"];
var _memset = Module["_memset"] = asm["_memset"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _hour = Module["_hour"] = asm["_hour"];
var _strcpy = Module["_strcpy"] = asm["_strcpy"];
var _calloc = Module["_calloc"] = asm["_calloc"];
var runPostSets = Module["runPostSets"] = asm["runPostSets"];
var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
var dynCall_vi = Module["dynCall_vi"] = asm["dynCall_vi"];
var dynCall_ii = Module["dynCall_ii"] = asm["dynCall_ii"];
var dynCall_v = Module["dynCall_v"] = asm["dynCall_v"];
var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];

Runtime.stackAlloc = function(size) { return asm['stackAlloc'](size) };
Runtime.stackSave = function() { return asm['stackSave']() };
Runtime.stackRestore = function(top) { asm['stackRestore'](top) };

// TODO: strip out parts of this we do not need

//======= begin closure i64 code =======

// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines a Long class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "long". This
 * implementation is derived from LongLib in GWT.
 *
 */

var i64Math = (function() { // Emscripten wrapper
  var goog = { math: {} };


  /**
   * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
   * values as *signed* integers.  See the from* functions below for more
   * convenient ways of constructing Longs.
   *
   * The internal representation of a long is the two given signed, 32-bit values.
   * We use 32-bit pieces because these are the size of integers on which
   * Javascript performs bit-operations.  For operations like addition and
   * multiplication, we split each number into 16-bit pieces, which can easily be
   * multiplied within Javascript's floating-point representation without overflow
   * or change in sign.
   *
   * In the algorithms below, we frequently reduce the negative case to the
   * positive case by negating the input(s) and then post-processing the result.
   * Note that we must ALWAYS check specially whether those values are MIN_VALUE
   * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
   * a positive number, it overflows back into a negative).  Not handling this
   * case would often result in infinite recursion.
   *
   * @param {number} low  The low (signed) 32 bits of the long.
   * @param {number} high  The high (signed) 32 bits of the long.
   * @constructor
   */
  goog.math.Long = function(low, high) {
    /**
     * @type {number}
     * @private
     */
    this.low_ = low | 0;  // force into 32 signed bits.

    /**
     * @type {number}
     * @private
     */
    this.high_ = high | 0;  // force into 32 signed bits.
  };


  // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
  // from* methods on which they depend.


  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @private
   */
  goog.math.Long.IntCache_ = {};


  /**
   * Returns a Long representing the given (32-bit) integer value.
   * @param {number} value The 32-bit integer in question.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromInt = function(value) {
    if (-128 <= value && value < 128) {
      var cachedObj = goog.math.Long.IntCache_[value];
      if (cachedObj) {
        return cachedObj;
      }
    }

    var obj = new goog.math.Long(value | 0, value < 0 ? -1 : 0);
    if (-128 <= value && value < 128) {
      goog.math.Long.IntCache_[value] = obj;
    }
    return obj;
  };


  /**
   * Returns a Long representing the given value, provided that it is a finite
   * number.  Otherwise, zero is returned.
   * @param {number} value The number in question.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromNumber = function(value) {
    if (isNaN(value) || !isFinite(value)) {
      return goog.math.Long.ZERO;
    } else if (value <= -goog.math.Long.TWO_PWR_63_DBL_) {
      return goog.math.Long.MIN_VALUE;
    } else if (value + 1 >= goog.math.Long.TWO_PWR_63_DBL_) {
      return goog.math.Long.MAX_VALUE;
    } else if (value < 0) {
      return goog.math.Long.fromNumber(-value).negate();
    } else {
      return new goog.math.Long(
          (value % goog.math.Long.TWO_PWR_32_DBL_) | 0,
          (value / goog.math.Long.TWO_PWR_32_DBL_) | 0);
    }
  };


  /**
   * Returns a Long representing the 64-bit integer that comes by concatenating
   * the given high and low bits.  Each is assumed to use 32 bits.
   * @param {number} lowBits The low 32-bits.
   * @param {number} highBits The high 32-bits.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromBits = function(lowBits, highBits) {
    return new goog.math.Long(lowBits, highBits);
  };


  /**
   * Returns a Long representation of the given string, written using the given
   * radix.
   * @param {string} str The textual representation of the Long.
   * @param {number=} opt_radix The radix in which the text is written.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromString = function(str, opt_radix) {
    if (str.length == 0) {
      throw Error('number format error: empty string');
    }

    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error('radix out of range: ' + radix);
    }

    if (str.charAt(0) == '-') {
      return goog.math.Long.fromString(str.substring(1), radix).negate();
    } else if (str.indexOf('-') >= 0) {
      throw Error('number format error: interior "-" character: ' + str);
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 8));

    var result = goog.math.Long.ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i);
      var value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = goog.math.Long.fromNumber(Math.pow(radix, size));
        result = result.multiply(power).add(goog.math.Long.fromNumber(value));
      } else {
        result = result.multiply(radixToPower);
        result = result.add(goog.math.Long.fromNumber(value));
      }
    }
    return result;
  };


  // NOTE: the compiler should inline these constant values below and then remove
  // these variables, so there should be no runtime penalty for these.


  /**
   * Number used repeated below in calculations.  This must appear before the
   * first call to any from* function below.
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_16_DBL_ = 1 << 16;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_24_DBL_ = 1 << 24;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_32_DBL_ =
      goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_31_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ / 2;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_48_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_64_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_63_DBL_ =
      goog.math.Long.TWO_PWR_64_DBL_ / 2;


  /** @type {!goog.math.Long} */
  goog.math.Long.ZERO = goog.math.Long.fromInt(0);


  /** @type {!goog.math.Long} */
  goog.math.Long.ONE = goog.math.Long.fromInt(1);


  /** @type {!goog.math.Long} */
  goog.math.Long.NEG_ONE = goog.math.Long.fromInt(-1);


  /** @type {!goog.math.Long} */
  goog.math.Long.MAX_VALUE =
      goog.math.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);


  /** @type {!goog.math.Long} */
  goog.math.Long.MIN_VALUE = goog.math.Long.fromBits(0, 0x80000000 | 0);


  /**
   * @type {!goog.math.Long}
   * @private
   */
  goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(1 << 24);


  /** @return {number} The value, assuming it is a 32-bit integer. */
  goog.math.Long.prototype.toInt = function() {
    return this.low_;
  };


  /** @return {number} The closest floating-point representation to this value. */
  goog.math.Long.prototype.toNumber = function() {
    return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ +
           this.getLowBitsUnsigned();
  };


  /**
   * @param {number=} opt_radix The radix in which the text should be written.
   * @return {string} The textual representation of this value.
   */
  goog.math.Long.prototype.toString = function(opt_radix) {
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error('radix out of range: ' + radix);
    }

    if (this.isZero()) {
      return '0';
    }

    if (this.isNegative()) {
      if (this.equals(goog.math.Long.MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = goog.math.Long.fromNumber(radix);
        var div = this.div(radixLong);
        var rem = div.multiply(radixLong).subtract(this);
        return div.toString(radix) + rem.toInt().toString(radix);
      } else {
        return '-' + this.negate().toString(radix);
      }
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 6));

    var rem = this;
    var result = '';
    while (true) {
      var remDiv = rem.div(radixToPower);
      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
      var digits = intval.toString(radix);

      rem = remDiv;
      if (rem.isZero()) {
        return digits + result;
      } else {
        while (digits.length < 6) {
          digits = '0' + digits;
        }
        result = '' + digits + result;
      }
    }
  };


  /** @return {number} The high 32-bits as a signed value. */
  goog.math.Long.prototype.getHighBits = function() {
    return this.high_;
  };


  /** @return {number} The low 32-bits as a signed value. */
  goog.math.Long.prototype.getLowBits = function() {
    return this.low_;
  };


  /** @return {number} The low 32-bits as an unsigned value. */
  goog.math.Long.prototype.getLowBitsUnsigned = function() {
    return (this.low_ >= 0) ?
        this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
  };


  /**
   * @return {number} Returns the number of bits needed to represent the absolute
   *     value of this Long.
   */
  goog.math.Long.prototype.getNumBitsAbs = function() {
    if (this.isNegative()) {
      if (this.equals(goog.math.Long.MIN_VALUE)) {
        return 64;
      } else {
        return this.negate().getNumBitsAbs();
      }
    } else {
      var val = this.high_ != 0 ? this.high_ : this.low_;
      for (var bit = 31; bit > 0; bit--) {
        if ((val & (1 << bit)) != 0) {
          break;
        }
      }
      return this.high_ != 0 ? bit + 33 : bit + 1;
    }
  };


  /** @return {boolean} Whether this value is zero. */
  goog.math.Long.prototype.isZero = function() {
    return this.high_ == 0 && this.low_ == 0;
  };


  /** @return {boolean} Whether this value is negative. */
  goog.math.Long.prototype.isNegative = function() {
    return this.high_ < 0;
  };


  /** @return {boolean} Whether this value is odd. */
  goog.math.Long.prototype.isOdd = function() {
    return (this.low_ & 1) == 1;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long equals the other.
   */
  goog.math.Long.prototype.equals = function(other) {
    return (this.high_ == other.high_) && (this.low_ == other.low_);
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long does not equal the other.
   */
  goog.math.Long.prototype.notEquals = function(other) {
    return (this.high_ != other.high_) || (this.low_ != other.low_);
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than the other.
   */
  goog.math.Long.prototype.lessThan = function(other) {
    return this.compare(other) < 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than or equal to the other.
   */
  goog.math.Long.prototype.lessThanOrEqual = function(other) {
    return this.compare(other) <= 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than the other.
   */
  goog.math.Long.prototype.greaterThan = function(other) {
    return this.compare(other) > 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than or equal to the other.
   */
  goog.math.Long.prototype.greaterThanOrEqual = function(other) {
    return this.compare(other) >= 0;
  };


  /**
   * Compares this Long with the given one.
   * @param {goog.math.Long} other Long to compare against.
   * @return {number} 0 if they are the same, 1 if the this is greater, and -1
   *     if the given one is greater.
   */
  goog.math.Long.prototype.compare = function(other) {
    if (this.equals(other)) {
      return 0;
    }

    var thisNeg = this.isNegative();
    var otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) {
      return -1;
    }
    if (!thisNeg && otherNeg) {
      return 1;
    }

    // at this point, the signs are the same, so subtraction will not overflow
    if (this.subtract(other).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };


  /** @return {!goog.math.Long} The negation of this value. */
  goog.math.Long.prototype.negate = function() {
    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.MIN_VALUE;
    } else {
      return this.not().add(goog.math.Long.ONE);
    }
  };


  /**
   * Returns the sum of this and the given Long.
   * @param {goog.math.Long} other Long to add to this one.
   * @return {!goog.math.Long} The sum of this and the given Long.
   */
  goog.math.Long.prototype.add = function(other) {
    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xFFFF;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xFFFF;

    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xFFFF;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
  };


  /**
   * Returns the difference of this and the given Long.
   * @param {goog.math.Long} other Long to subtract from this.
   * @return {!goog.math.Long} The difference of this and the given Long.
   */
  goog.math.Long.prototype.subtract = function(other) {
    return this.add(other.negate());
  };


  /**
   * Returns the product of this and the given long.
   * @param {goog.math.Long} other Long to multiply with this.
   * @return {!goog.math.Long} The product of this and the other.
   */
  goog.math.Long.prototype.multiply = function(other) {
    if (this.isZero()) {
      return goog.math.Long.ZERO;
    } else if (other.isZero()) {
      return goog.math.Long.ZERO;
    }

    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return other.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return this.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().multiply(other.negate());
      } else {
        return this.negate().multiply(other).negate();
      }
    } else if (other.isNegative()) {
      return this.multiply(other.negate()).negate();
    }

    // If both longs are small, use float multiplication
    if (this.lessThan(goog.math.Long.TWO_PWR_24_) &&
        other.lessThan(goog.math.Long.TWO_PWR_24_)) {
      return goog.math.Long.fromNumber(this.toNumber() * other.toNumber());
    }

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xFFFF;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xFFFF;

    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xFFFF;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
  };


  /**
   * Returns this Long divided by the given one.
   * @param {goog.math.Long} other Long by which to divide.
   * @return {!goog.math.Long} This Long divided by the given one.
   */
  goog.math.Long.prototype.div = function(other) {
    if (other.isZero()) {
      throw Error('division by zero');
    } else if (this.isZero()) {
      return goog.math.Long.ZERO;
    }

    if (this.equals(goog.math.Long.MIN_VALUE)) {
      if (other.equals(goog.math.Long.ONE) ||
          other.equals(goog.math.Long.NEG_ONE)) {
        return goog.math.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
      } else if (other.equals(goog.math.Long.MIN_VALUE)) {
        return goog.math.Long.ONE;
      } else {
        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
        var halfThis = this.shiftRight(1);
        var approx = halfThis.div(other).shiftLeft(1);
        if (approx.equals(goog.math.Long.ZERO)) {
          return other.isNegative() ? goog.math.Long.ONE : goog.math.Long.NEG_ONE;
        } else {
          var rem = this.subtract(other.multiply(approx));
          var result = approx.add(rem.div(other));
          return result;
        }
      }
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().div(other.negate());
      } else {
        return this.negate().div(other).negate();
      }
    } else if (other.isNegative()) {
      return this.div(other.negate()).negate();
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    var res = goog.math.Long.ZERO;
    var rem = this;
    while (rem.greaterThanOrEqual(other)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

      // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
      var log2 = Math.ceil(Math.log(approx) / Math.LN2);
      var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

      // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      var approxRes = goog.math.Long.fromNumber(approx);
      var approxRem = approxRes.multiply(other);
      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
        approx -= delta;
        approxRes = goog.math.Long.fromNumber(approx);
        approxRem = approxRes.multiply(other);
      }

      // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
      if (approxRes.isZero()) {
        approxRes = goog.math.Long.ONE;
      }

      res = res.add(approxRes);
      rem = rem.subtract(approxRem);
    }
    return res;
  };


  /**
   * Returns this Long modulo the given one.
   * @param {goog.math.Long} other Long by which to mod.
   * @return {!goog.math.Long} This Long modulo the given one.
   */
  goog.math.Long.prototype.modulo = function(other) {
    return this.subtract(this.div(other).multiply(other));
  };


  /** @return {!goog.math.Long} The bitwise-NOT of this value. */
  goog.math.Long.prototype.not = function() {
    return goog.math.Long.fromBits(~this.low_, ~this.high_);
  };


  /**
   * Returns the bitwise-AND of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to AND.
   * @return {!goog.math.Long} The bitwise-AND of this and the other.
   */
  goog.math.Long.prototype.and = function(other) {
    return goog.math.Long.fromBits(this.low_ & other.low_,
                                   this.high_ & other.high_);
  };


  /**
   * Returns the bitwise-OR of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to OR.
   * @return {!goog.math.Long} The bitwise-OR of this and the other.
   */
  goog.math.Long.prototype.or = function(other) {
    return goog.math.Long.fromBits(this.low_ | other.low_,
                                   this.high_ | other.high_);
  };


  /**
   * Returns the bitwise-XOR of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to XOR.
   * @return {!goog.math.Long} The bitwise-XOR of this and the other.
   */
  goog.math.Long.prototype.xor = function(other) {
    return goog.math.Long.fromBits(this.low_ ^ other.low_,
                                   this.high_ ^ other.high_);
  };


  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the left by the given amount.
   */
  goog.math.Long.prototype.shiftLeft = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var low = this.low_;
      if (numBits < 32) {
        var high = this.high_;
        return goog.math.Long.fromBits(
            low << numBits,
            (high << numBits) | (low >>> (32 - numBits)));
      } else {
        return goog.math.Long.fromBits(0, low << (numBits - 32));
      }
    }
  };


  /**
   * Returns this Long with bits shifted to the right by the given amount.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the right by the given amount.
   */
  goog.math.Long.prototype.shiftRight = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return goog.math.Long.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >> numBits);
      } else {
        return goog.math.Long.fromBits(
            high >> (numBits - 32),
            high >= 0 ? 0 : -1);
      }
    }
  };


  /**
   * Returns this Long with bits shifted to the right by the given amount, with
   * the new top bits matching the current sign bit.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the right by the given amount, with
   *     zeros placed into the new leading bits.
   */
  goog.math.Long.prototype.shiftRightUnsigned = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return goog.math.Long.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >>> numBits);
      } else if (numBits == 32) {
        return goog.math.Long.fromBits(high, 0);
      } else {
        return goog.math.Long.fromBits(high >>> (numBits - 32), 0);
      }
    }
  };

  //======= begin jsbn =======

  var navigator = { appName: 'Modern Browser' }; // polyfill a little

  // Copyright (c) 2005  Tom Wu
  // All Rights Reserved.
  // http://www-cs-students.stanford.edu/~tjw/jsbn/

  /*
   * Copyright (c) 2003-2005  Tom Wu
   * All Rights Reserved.
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
   *
   * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
   * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
   * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
   * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * In addition, the following condition applies:
   *
   * All redistributions must retain an intact copy of this copyright notice
   * and disclaimer.
   */

  // Basic JavaScript BN library - subset useful for RSA encryption.

  // Bits per digit
  var dbits;

  // JavaScript engine analysis
  var canary = 0xdeadbeefcafe;
  var j_lm = ((canary&0xffffff)==0xefcafe);

  // (public) Constructor
  function BigInteger(a,b,c) {
    if(a != null)
      if("number" == typeof a) this.fromNumber(a,b,c);
      else if(b == null && "string" != typeof a) this.fromString(a,256);
      else this.fromString(a,b);
  }

  // return new, unset BigInteger
  function nbi() { return new BigInteger(null); }

  // am: Compute w_j += (x*this_i), propagate carries,
  // c is initial carry, returns final carry.
  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
  // We need to select the fastest one that works in this environment.

  // am1: use a single mult and divide to get the high bits,
  // max digit bits should be 26 because
  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
  function am1(i,x,w,j,c,n) {
    while(--n >= 0) {
      var v = x*this[i++]+w[j]+c;
      c = Math.floor(v/0x4000000);
      w[j++] = v&0x3ffffff;
    }
    return c;
  }
  // am2 avoids a big mult-and-extract completely.
  // Max digit bits should be <= 30 because we do bitwise ops
  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
  function am2(i,x,w,j,c,n) {
    var xl = x&0x7fff, xh = x>>15;
    while(--n >= 0) {
      var l = this[i]&0x7fff;
      var h = this[i++]>>15;
      var m = xh*l+h*xl;
      l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
      c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
      w[j++] = l&0x3fffffff;
    }
    return c;
  }
  // Alternately, set max digit bits to 28 since some
  // browsers slow down when dealing with 32-bit numbers.
  function am3(i,x,w,j,c,n) {
    var xl = x&0x3fff, xh = x>>14;
    while(--n >= 0) {
      var l = this[i]&0x3fff;
      var h = this[i++]>>14;
      var m = xh*l+h*xl;
      l = xl*l+((m&0x3fff)<<14)+w[j]+c;
      c = (l>>28)+(m>>14)+xh*h;
      w[j++] = l&0xfffffff;
    }
    return c;
  }
  if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    BigInteger.prototype.am = am2;
    dbits = 30;
  }
  else if(j_lm && (navigator.appName != "Netscape")) {
    BigInteger.prototype.am = am1;
    dbits = 26;
  }
  else { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
  }

  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = ((1<<dbits)-1);
  BigInteger.prototype.DV = (1<<dbits);

  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2,BI_FP);
  BigInteger.prototype.F1 = BI_FP-dbits;
  BigInteger.prototype.F2 = 2*dbits-BI_FP;

  // Digit conversions
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr,vv;
  rr = "0".charCodeAt(0);
  for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

  function int2char(n) { return BI_RM.charAt(n); }
  function intAt(s,i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c==null)?-1:c;
  }

  // (protected) copy this to r
  function bnpCopyTo(r) {
    for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
  }

  // (protected) set from integer value x, -DV <= x < DV
  function bnpFromInt(x) {
    this.t = 1;
    this.s = (x<0)?-1:0;
    if(x > 0) this[0] = x;
    else if(x < -1) this[0] = x+DV;
    else this.t = 0;
  }

  // return bigint initialized to value
  function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

  // (protected) set from string and radix
  function bnpFromString(s,b) {
    var k;
    if(b == 16) k = 4;
    else if(b == 8) k = 3;
    else if(b == 256) k = 8; // byte array
    else if(b == 2) k = 1;
    else if(b == 32) k = 5;
    else if(b == 4) k = 2;
    else { this.fromRadix(s,b); return; }
    this.t = 0;
    this.s = 0;
    var i = s.length, mi = false, sh = 0;
    while(--i >= 0) {
      var x = (k==8)?s[i]&0xff:intAt(s,i);
      if(x < 0) {
        if(s.charAt(i) == "-") mi = true;
        continue;
      }
      mi = false;
      if(sh == 0)
        this[this.t++] = x;
      else if(sh+k > this.DB) {
        this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
        this[this.t++] = (x>>(this.DB-sh));
      }
      else
        this[this.t-1] |= x<<sh;
      sh += k;
      if(sh >= this.DB) sh -= this.DB;
    }
    if(k == 8 && (s[0]&0x80) != 0) {
      this.s = -1;
      if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
    }
    this.clamp();
    if(mi) BigInteger.ZERO.subTo(this,this);
  }

  // (protected) clamp off excess high words
  function bnpClamp() {
    var c = this.s&this.DM;
    while(this.t > 0 && this[this.t-1] == c) --this.t;
  }

  // (public) return string representation in given radix
  function bnToString(b) {
    if(this.s < 0) return "-"+this.negate().toString(b);
    var k;
    if(b == 16) k = 4;
    else if(b == 8) k = 3;
    else if(b == 2) k = 1;
    else if(b == 32) k = 5;
    else if(b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1<<k)-1, d, m = false, r = "", i = this.t;
    var p = this.DB-(i*this.DB)%k;
    if(i-- > 0) {
      if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
      while(i >= 0) {
        if(p < k) {
          d = (this[i]&((1<<p)-1))<<(k-p);
          d |= this[--i]>>(p+=this.DB-k);
        }
        else {
          d = (this[i]>>(p-=k))&km;
          if(p <= 0) { p += this.DB; --i; }
        }
        if(d > 0) m = true;
        if(m) r += int2char(d);
      }
    }
    return m?r:"0";
  }

  // (public) -this
  function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

  // (public) |this|
  function bnAbs() { return (this.s<0)?this.negate():this; }

  // (public) return + if this > a, - if this < a, 0 if equal
  function bnCompareTo(a) {
    var r = this.s-a.s;
    if(r != 0) return r;
    var i = this.t;
    r = i-a.t;
    if(r != 0) return (this.s<0)?-r:r;
    while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
    return 0;
  }

  // returns bit length of the integer x
  function nbits(x) {
    var r = 1, t;
    if((t=x>>>16) != 0) { x = t; r += 16; }
    if((t=x>>8) != 0) { x = t; r += 8; }
    if((t=x>>4) != 0) { x = t; r += 4; }
    if((t=x>>2) != 0) { x = t; r += 2; }
    if((t=x>>1) != 0) { x = t; r += 1; }
    return r;
  }

  // (public) return the number of bits in "this"
  function bnBitLength() {
    if(this.t <= 0) return 0;
    return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
  }

  // (protected) r = this << n*DB
  function bnpDLShiftTo(n,r) {
    var i;
    for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
    for(i = n-1; i >= 0; --i) r[i] = 0;
    r.t = this.t+n;
    r.s = this.s;
  }

  // (protected) r = this >> n*DB
  function bnpDRShiftTo(n,r) {
    for(var i = n; i < this.t; ++i) r[i-n] = this[i];
    r.t = Math.max(this.t-n,0);
    r.s = this.s;
  }

  // (protected) r = this << n
  function bnpLShiftTo(n,r) {
    var bs = n%this.DB;
    var cbs = this.DB-bs;
    var bm = (1<<cbs)-1;
    var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
    for(i = this.t-1; i >= 0; --i) {
      r[i+ds+1] = (this[i]>>cbs)|c;
      c = (this[i]&bm)<<bs;
    }
    for(i = ds-1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t+ds+1;
    r.s = this.s;
    r.clamp();
  }

  // (protected) r = this >> n
  function bnpRShiftTo(n,r) {
    r.s = this.s;
    var ds = Math.floor(n/this.DB);
    if(ds >= this.t) { r.t = 0; return; }
    var bs = n%this.DB;
    var cbs = this.DB-bs;
    var bm = (1<<bs)-1;
    r[0] = this[ds]>>bs;
    for(var i = ds+1; i < this.t; ++i) {
      r[i-ds-1] |= (this[i]&bm)<<cbs;
      r[i-ds] = this[i]>>bs;
    }
    if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
    r.t = this.t-ds;
    r.clamp();
  }

  // (protected) r = this - a
  function bnpSubTo(a,r) {
    var i = 0, c = 0, m = Math.min(a.t,this.t);
    while(i < m) {
      c += this[i]-a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    if(a.t < this.t) {
      c -= a.s;
      while(i < this.t) {
        c += this[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else {
      c += this.s;
      while(i < a.t) {
        c -= a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = (c<0)?-1:0;
    if(c < -1) r[i++] = this.DV+c;
    else if(c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
  }

  // (protected) r = this * a, r != this,a (HAC 14.12)
  // "this" should be the larger one if appropriate.
  function bnpMultiplyTo(a,r) {
    var x = this.abs(), y = a.abs();
    var i = x.t;
    r.t = i+y.t;
    while(--i >= 0) r[i] = 0;
    for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
    r.s = 0;
    r.clamp();
    if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
  }

  // (protected) r = this^2, r != this (HAC 14.16)
  function bnpSquareTo(r) {
    var x = this.abs();
    var i = r.t = 2*x.t;
    while(--i >= 0) r[i] = 0;
    for(i = 0; i < x.t-1; ++i) {
      var c = x.am(i,x[i],r,2*i,0,1);
      if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
        r[i+x.t] -= x.DV;
        r[i+x.t+1] = 1;
      }
    }
    if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
    r.s = 0;
    r.clamp();
  }

  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
  // r != q, this != m.  q or r may be null.
  function bnpDivRemTo(m,q,r) {
    var pm = m.abs();
    if(pm.t <= 0) return;
    var pt = this.abs();
    if(pt.t < pm.t) {
      if(q != null) q.fromInt(0);
      if(r != null) this.copyTo(r);
      return;
    }
    if(r == null) r = nbi();
    var y = nbi(), ts = this.s, ms = m.s;
    var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
    if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
    else { pm.copyTo(y); pt.copyTo(r); }
    var ys = y.t;
    var y0 = y[ys-1];
    if(y0 == 0) return;
    var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
    var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
    var i = r.t, j = i-ys, t = (q==null)?nbi():q;
    y.dlShiftTo(j,t);
    if(r.compareTo(t) >= 0) {
      r[r.t++] = 1;
      r.subTo(t,r);
    }
    BigInteger.ONE.dlShiftTo(ys,t);
    t.subTo(y,y);	// "negative" y so we can replace sub with am later
    while(y.t < ys) y[y.t++] = 0;
    while(--j >= 0) {
      // Estimate quotient digit
      var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
      if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
        y.dlShiftTo(j,t);
        r.subTo(t,r);
        while(r[i] < --qd) r.subTo(t,r);
      }
    }
    if(q != null) {
      r.drShiftTo(ys,q);
      if(ts != ms) BigInteger.ZERO.subTo(q,q);
    }
    r.t = ys;
    r.clamp();
    if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
    if(ts < 0) BigInteger.ZERO.subTo(r,r);
  }

  // (public) this mod a
  function bnMod(a) {
    var r = nbi();
    this.abs().divRemTo(a,null,r);
    if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
    return r;
  }

  // Modular reduction using "classic" algorithm
  function Classic(m) { this.m = m; }
  function cConvert(x) {
    if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
  }
  function cRevert(x) { return x; }
  function cReduce(x) { x.divRemTo(this.m,null,x); }
  function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
  function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;

  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
  // justification:
  //         xy == 1 (mod m)
  //         xy =  1+km
  //   xy(2-xy) = (1+km)(1-km)
  // x[y(2-xy)] = 1-k^2m^2
  // x[y(2-xy)] == 1 (mod m^2)
  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
  // JS multiply "overflows" differently from C/C++, so care is needed here.
  function bnpInvDigit() {
    if(this.t < 1) return 0;
    var x = this[0];
    if((x&1) == 0) return 0;
    var y = x&3;		// y == 1/x mod 2^2
    y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
    y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
    y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y>0)?this.DV-y:-y;
  }

  // Montgomery reduction
  function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp&0x7fff;
    this.mph = this.mp>>15;
    this.um = (1<<(m.DB-15))-1;
    this.mt2 = 2*m.t;
  }

  // xR mod m
  function montConvert(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t,r);
    r.divRemTo(this.m,null,r);
    if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
    return r;
  }

  // x/R mod m
  function montRevert(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }

  // x = x/R mod m (HAC 14.32)
  function montReduce(x) {
    while(x.t <= this.mt2)	// pad x so am has enough room later
      x[x.t++] = 0;
    for(var i = 0; i < this.m.t; ++i) {
      // faster way of calculating u0 = x[i]*mp mod DV
      var j = x[i]&0x7fff;
      var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
      // use am to combine the multiply-shift-add into one call
      j = i+this.m.t;
      x[j] += this.m.am(0,u0,x,i,0,this.m.t);
      // propagate carry
      while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
    }
    x.clamp();
    x.drShiftTo(this.m.t,x);
    if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
  }

  // r = "x^2/R mod m"; x != r
  function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

  // r = "xy/R mod m"; x,y != r
  function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;

  // (protected) true iff this is even
  function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
  function bnpExp(e,z) {
    if(e > 0xffffffff || e < 1) return BigInteger.ONE;
    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
    g.copyTo(r);
    while(--i >= 0) {
      z.sqrTo(r,r2);
      if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
      else { var t = r; r = r2; r2 = t; }
    }
    return z.revert(r);
  }

  // (public) this^e % m, 0 <= e < 2^32
  function bnModPowInt(e,m) {
    var z;
    if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
    return this.exp(e,z);
  }

  // protected
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;

  // public
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;

  // "constants"
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);

  // jsbn2 stuff

  // (protected) convert from radix string
  function bnpFromRadix(s,b) {
    this.fromInt(0);
    if(b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
    for(var i = 0; i < s.length; ++i) {
      var x = intAt(s,i);
      if(x < 0) {
        if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
        continue;
      }
      w = b*w+x;
      if(++j >= cs) {
        this.dMultiply(d);
        this.dAddOffset(w,0);
        j = 0;
        w = 0;
      }
    }
    if(j > 0) {
      this.dMultiply(Math.pow(b,j));
      this.dAddOffset(w,0);
    }
    if(mi) BigInteger.ZERO.subTo(this,this);
  }

  // (protected) return x s.t. r^x < DV
  function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

  // (public) 0 if this == 0, 1 if this > 0
  function bnSigNum() {
    if(this.s < 0) return -1;
    else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
  }

  // (protected) this *= n, this >= 0, 1 < n < DV
  function bnpDMultiply(n) {
    this[this.t] = this.am(0,n-1,this,0,0,this.t);
    ++this.t;
    this.clamp();
  }

  // (protected) this += n << w words, this >= 0
  function bnpDAddOffset(n,w) {
    if(n == 0) return;
    while(this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while(this[w] >= this.DV) {
      this[w] -= this.DV;
      if(++w >= this.t) this[this.t++] = 0;
      ++this[w];
    }
  }

  // (protected) convert to radix string
  function bnpToRadix(b) {
    if(b == null) b = 10;
    if(this.signum() == 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b,cs);
    var d = nbv(a), y = nbi(), z = nbi(), r = "";
    this.divRemTo(d,y,z);
    while(y.signum() > 0) {
      r = (a+z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d,y,z);
    }
    return z.intValue().toString(b) + r;
  }

  // (public) return value as integer
  function bnIntValue() {
    if(this.s < 0) {
      if(this.t == 1) return this[0]-this.DV;
      else if(this.t == 0) return -1;
    }
    else if(this.t == 1) return this[0];
    else if(this.t == 0) return 0;
    // assumes 16 < DB < 32
    return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
  }

  // (protected) r = this + a
  function bnpAddTo(a,r) {
    var i = 0, c = 0, m = Math.min(a.t,this.t);
    while(i < m) {
      c += this[i]+a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    if(a.t < this.t) {
      c += a.s;
      while(i < this.t) {
        c += this[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else {
      c += this.s;
      while(i < a.t) {
        c += a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = (c<0)?-1:0;
    if(c > 0) r[i++] = c;
    else if(c < -1) r[i++] = this.DV+c;
    r.t = i;
    r.clamp();
  }

  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.addTo = bnpAddTo;

  //======= end jsbn =======

  // Emscripten wrapper
  var Wrapper = {
    abs: function(l, h) {
      var x = new goog.math.Long(l, h);
      var ret;
      if (x.isNegative()) {
        ret = x.negate();
      } else {
        ret = x;
      }
      HEAP32[tempDoublePtr>>2] = ret.low_;
      HEAP32[tempDoublePtr+4>>2] = ret.high_;
    },
    ensureTemps: function() {
      if (Wrapper.ensuredTemps) return;
      Wrapper.ensuredTemps = true;
      Wrapper.two32 = new BigInteger();
      Wrapper.two32.fromString('4294967296', 10);
      Wrapper.two64 = new BigInteger();
      Wrapper.two64.fromString('18446744073709551616', 10);
      Wrapper.temp1 = new BigInteger();
      Wrapper.temp2 = new BigInteger();
    },
    lh2bignum: function(l, h) {
      var a = new BigInteger();
      a.fromString(h.toString(), 10);
      var b = new BigInteger();
      a.multiplyTo(Wrapper.two32, b);
      var c = new BigInteger();
      c.fromString(l.toString(), 10);
      var d = new BigInteger();
      c.addTo(b, d);
      return d;
    },
    stringify: function(l, h, unsigned) {
      var ret = new goog.math.Long(l, h).toString();
      if (unsigned && ret[0] == '-') {
        // unsign slowly using jsbn bignums
        Wrapper.ensureTemps();
        var bignum = new BigInteger();
        bignum.fromString(ret, 10);
        ret = new BigInteger();
        Wrapper.two64.addTo(bignum, ret);
        ret = ret.toString(10);
      }
      return ret;
    },
    fromString: function(str, base, min, max, unsigned) {
      Wrapper.ensureTemps();
      var bignum = new BigInteger();
      bignum.fromString(str, base);
      var bigmin = new BigInteger();
      bigmin.fromString(min, 10);
      var bigmax = new BigInteger();
      bigmax.fromString(max, 10);
      if (unsigned && bignum.compareTo(BigInteger.ZERO) < 0) {
        var temp = new BigInteger();
        bignum.addTo(Wrapper.two64, temp);
        bignum = temp;
      }
      var error = false;
      if (bignum.compareTo(bigmin) < 0) {
        bignum = bigmin;
        error = true;
      } else if (bignum.compareTo(bigmax) > 0) {
        bignum = bigmax;
        error = true;
      }
      var ret = goog.math.Long.fromString(bignum.toString()); // min-max checks should have clamped this to a range goog.math.Long can handle well
      HEAP32[tempDoublePtr>>2] = ret.low_;
      HEAP32[tempDoublePtr+4>>2] = ret.high_;
      if (error) throw 'range error';
    }
  };
  return Wrapper;
})();

//======= end closure i64 code =======



// === Auto-generated postamble setup entry stuff ===

if (memoryInitializer) {
  function applyData(data) {
    HEAPU8.set(data, STATIC_BASE);
  }
  if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
    applyData(Module['readBinary'](memoryInitializer));
  } else {
    addRunDependency('memory initializer');
    Browser.asyncLoad(memoryInitializer, function(data) {
      applyData(data);
      removeRunDependency('memory initializer');
    }, function(data) {
      throw 'could not load memory initializer ' + memoryInitializer;
    });
  }
}

function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var initialStackTop;
var preloadStartTime = null;
var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun'] && shouldRunNow) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}

Module['callMain'] = Module.callMain = function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on __ATMAIN__)');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  args = args || [];

  if (ENVIRONMENT_IS_WEB && preloadStartTime !== null) {
    Module.printErr('preload time: ' + (Date.now() - preloadStartTime) + ' ms');
  }

  ensureInitRuntime();

  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString("/bin/this.program"), 'i8', ALLOC_NORMAL) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_NORMAL));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_NORMAL);

  initialStackTop = STACKTOP;

  try {

    var ret = Module['_main'](argc, argv, 0);


    // if we're not running an evented main loop, it's time to exit
    if (!Module['noExitRuntime']) {
      exit(ret);
    }
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'SimulateInfiniteLoop') {
      // running an evented main loop, don't immediately exit
      Module['noExitRuntime'] = true;
      return;
    } else {
      if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
      throw e;
    }
  } finally {
    calledMain = true;
  }
}




function run(args) {
  args = args || Module['arguments'];

  if (preloadStartTime === null) preloadStartTime = Date.now();

  if (runDependencies > 0) {
    Module.printErr('run() called, but dependencies remain, so not running');
    return;
  }

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    ensureInitRuntime();

    preMain();

    if (Module['_main'] && shouldRunNow) {
      Module['callMain'](args);
    }

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      if (!ABORT) doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = Module.run = run;

function exit(status) {
  ABORT = true;
  EXITSTATUS = status;
  STACKTOP = initialStackTop;

  // exit the runtime
  exitRuntime();

  // TODO We should handle this differently based on environment.
  // In the browser, the best we can do is throw an exception
  // to halt execution, but in node we could process.exit and
  // I'd imagine SM shell would have something equivalent.
  // This would let us set a proper exit status (which
  // would be great for checking test exit statuses).
  // https://github.com/kripken/emscripten/issues/1371

  // throw an exception to halt the current execution
  throw new ExitStatus(status);
}
Module['exit'] = Module.exit = exit;

function abort(text) {
  if (text) {
    Module.print(text);
    Module.printErr(text);
  }

  ABORT = true;
  EXITSTATUS = 1;

  throw 'abort() at ' + stackTrace();
}
Module['abort'] = Module.abort = abort;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}

run();

// {{POST_RUN_ADDITIONS}}






// {{MODULE_ADDITIONS}}



